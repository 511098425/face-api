{
  "version": 3,
  "sources": ["../src/tfjs/tf-node-gpu.js", "../src/env/isNodejs.ts", "../src/index.ts", "../src/draw/index.ts", "../src/draw/drawContour.ts", "../src/utils/index.ts", "../src/classes/Dimensions.ts", "../src/classes/Point.ts", "../src/classes/Box.ts", "../src/classes/BoundingBox.ts", "../src/classes/ObjectDetection.ts", "../src/classes/FaceDetection.ts", "../src/ops/iou.ts", "../src/ops/minBbox.ts", "../src/ops/nonMaxSuppression.ts", "../src/ops/normalize.ts", "../src/ops/padToSquare.ts", "../src/ops/shuffleArray.ts", "../src/ops/index.ts", "../src/classes/Rect.ts", "../src/classes/FaceLandmarks.ts", "../src/classes/FaceLandmarks5.ts", "../src/classes/FaceLandmarks68.ts", "../src/classes/FaceMatch.ts", "../src/classes/LabeledBox.ts", "../src/classes/LabeledFaceDescriptors.ts", "../src/classes/PredictedBox.ts", "../src/factories/WithFaceDetection.ts", "../src/env/createBrowserEnv.ts", "../src/env/createFileSystem.ts", "../src/env/createNodejsEnv.ts", "../src/env/isBrowser.ts", "../src/env/index.ts", "../src/dom/resolveInput.ts", "../src/dom/getContext2dOrThrow.ts", "../src/draw/DrawTextField.ts", "../src/draw/DrawBox.ts", "../src/draw/drawDetections.ts", "../src/faceExpressionNet/FaceExpressionNet.ts", "../src/dom/isMediaLoaded.ts", "../src/dom/awaitMediaLoaded.ts", "../src/dom/bufferToImage.ts", "../src/dom/getMediaDimensions.ts", "../src/dom/createCanvas.ts", "../src/dom/imageTensorToCanvas.ts", "../src/dom/isMediaElement.ts", "../src/dom/NetInput.ts", "../src/dom/imageToSquare.ts", "../src/dom/toNetInput.ts", "../src/dom/extractFaces.ts", "../src/dom/extractFaceTensors.ts", "../src/dom/fetchOrThrow.ts", "../src/dom/fetchImage.ts", "../src/dom/fetchJson.ts", "../src/dom/fetchNetWeights.ts", "../src/dom/loadWeightMap.ts", "../src/common/getModelUris.ts", "../src/dom/matchDimensions.ts", "../src/faceFeatureExtractor/FaceFeatureExtractor.ts", "../src/NeuralNetwork.ts", "../src/faceFeatureExtractor/denseBlock.ts", "../src/common/depthwiseSeparableConv.ts", "../src/common/convLayer.ts", "../src/common/disposeUnusedWeightTensors.ts", "../src/common/extractConvParamsFactory.ts", "../src/common/extractFCParamsFactory.ts", "../src/common/extractSeparableConvParamsFactory.ts", "../src/common/types.ts", "../src/common/extractWeightEntryFactory.ts", "../src/common/extractWeightsFactory.ts", "../src/faceFeatureExtractor/extractorsFactory.ts", "../src/faceFeatureExtractor/extractParams.ts", "../src/common/loadConvParamsFactory.ts", "../src/faceFeatureExtractor/loadParamsFactory.ts", "../src/faceFeatureExtractor/extractParamsFromWeigthMap.ts", "../src/faceProcessor/FaceProcessor.ts", "../src/common/fullyConnectedLayer.ts", "../src/faceProcessor/extractParams.ts", "../src/faceProcessor/extractParamsFromWeigthMap.ts", "../src/faceProcessor/util.ts", "../src/faceExpressionNet/FaceExpressions.ts", "../src/factories/WithFaceExpressions.ts", "../src/draw/drawFaceExpressions.ts", "../src/factories/WithFaceLandmarks.ts", "../src/draw/DrawFaceLandmarks.ts", "../src/ageGenderNet/AgeGenderNet.ts", "../src/xception/TinyXception.ts", "../src/xception/extractParams.ts", "../src/xception/extractParamsFromWeigthMap.ts", "../src/ageGenderNet/extractParams.ts", "../src/ageGenderNet/extractParamsFromWeigthMap.ts", "../src/ageGenderNet/types.ts", "../src/faceLandmarkNet/FaceLandmark68NetBase.ts", "../src/faceLandmarkNet/FaceLandmark68Net.ts", "../src/faceFeatureExtractor/TinyFaceFeatureExtractor.ts", "../src/faceFeatureExtractor/extractParamsFromWeigthMapTiny.ts", "../src/faceFeatureExtractor/extractParamsTiny.ts", "../src/faceLandmarkNet/FaceLandmark68TinyNet.ts", "../src/faceLandmarkNet/index.ts", "../src/faceRecognitionNet/FaceRecognitionNet.ts", "../src/faceRecognitionNet/convLayer.ts", "../src/faceRecognitionNet/scaleLayer.ts", "../src/faceRecognitionNet/extractParams.ts", "../src/faceRecognitionNet/extractParamsFromWeigthMap.ts", "../src/faceRecognitionNet/residualLayer.ts", "../src/faceRecognitionNet/index.ts", "../src/factories/WithFaceDescriptor.ts", "../src/factories/WithAge.ts", "../src/factories/WithGender.ts", "../src/ssdMobilenetv1/SsdMobilenetv1.ts", "../src/ssdMobilenetv1/extractParams.ts", "../src/ssdMobilenetv1/extractParamsFromWeigthMap.ts", "../src/ssdMobilenetv1/mobileNetV1.ts", "../src/ssdMobilenetv1/pointwiseConvLayer.ts", "../src/ssdMobilenetv1/nonMaxSuppression.ts", "../src/ssdMobilenetv1/outputLayer.ts", "../src/ssdMobilenetv1/predictionLayer.ts", "../src/ssdMobilenetv1/boxPredictionLayer.ts", "../src/ssdMobilenetv1/SsdMobilenetv1Options.ts", "../src/ssdMobilenetv1/index.ts", "../src/tinyYolov2/const.ts", "../src/tinyYolov2/TinyYolov2Base.ts", "../src/tinyYolov2/config.ts", "../src/tinyYolov2/convWithBatchNorm.ts", "../src/tinyYolov2/leaky.ts", "../src/tinyYolov2/depthwiseSeparableConv.ts", "../src/tinyYolov2/extractParams.ts", "../src/tinyYolov2/extractParamsFromWeigthMap.ts", "../src/tinyYolov2/TinyYolov2Options.ts", "../src/tinyYolov2/TinyYolov2.ts", "../src/tinyYolov2/index.ts", "../src/tinyFaceDetector/TinyFaceDetectorOptions.ts", "../src/globalApi/ComposableTask.ts", "../src/globalApi/DetectFaceLandmarksTasks.ts", "../src/globalApi/extractFacesAndComputeResults.ts", "../src/tinyFaceDetector/const.ts", "../src/tinyFaceDetector/TinyFaceDetector.ts", "../src/globalApi/nets.ts", "../src/globalApi/PredictFaceExpressionsTask.ts", "../src/globalApi/PredictAgeAndGenderTask.ts", "../src/globalApi/ComputeFaceDescriptorsTasks.ts", "../src/globalApi/DetectFacesTasks.ts", "../src/globalApi/detectFaces.ts", "../src/globalApi/allFaces.ts", "../src/euclideanDistance.ts", "../src/globalApi/FaceMatcher.ts", "../src/tinyFaceDetector/index.ts", "../src/resizeResults.ts"],
  "sourcesContent": ["/* eslint-disable import/no-extraneous-dependencies */\n/* eslint-disable node/no-unpublished-import */\n\nexport * from '@tensorflow/tfjs-node-gpu';\n", "export function isNodejs(): boolean {\n  return typeof global === 'object'\n    && typeof require === 'function'\n    && typeof module !== 'undefined'\n    // issues with gatsby.js: module.exports is undefined\n    // && !!module.exports\n    && typeof process !== 'undefined' && !!process.version;\n}\n", "import * as tf from '../dist/tfjs.esm.js';\nimport * as draw from './draw/index';\nimport * as utils from './utils/index';\nimport * as pkg from '../package.json';\n\nexport { tf, draw, utils };\n\nexport * from './ageGenderNet/index';\nexport * from './classes/index';\nexport * from './dom/index';\nexport * from './env/index';\nexport * from './faceExpressionNet/index';\nexport * from './faceLandmarkNet/index';\nexport * from './faceRecognitionNet/index';\nexport * from './factories/index';\nexport * from './globalApi/index';\nexport * from './ops/index';\nexport * from './ssdMobilenetv1/index';\nexport * from './tinyFaceDetector/index';\nexport * from './tinyYolov2/index';\nexport * from './euclideanDistance';\nexport * from './NeuralNetwork';\nexport * from './resizeResults';\n\nconst node = (typeof process !== 'undefined');\n// eslint-disable-next-line no-undef\nconst browser = (typeof navigator !== 'undefined') && (typeof navigator.userAgent !== 'undefined');\nexport const version = { faceapi: pkg.version as string, node, browser };\n", "export * from './drawContour';\nexport * from './drawDetections';\nexport * from './drawFaceExpressions';\nexport * from './DrawBox';\nexport * from './DrawFaceLandmarks';\nexport * from './DrawTextField';\n", "import { Point } from '../classes/index';\n\nexport function drawContour(\n  ctx: CanvasRenderingContext2D,\n  points: Point[],\n  isClosed: boolean = false,\n) {\n  ctx.beginPath();\n\n  points.slice(1).forEach(({ x, y }, prevIdx) => {\n    const from = points[prevIdx];\n    ctx.moveTo(from.x, from.y);\n    ctx.lineTo(x, y);\n  });\n\n  if (isClosed) {\n    const from = points[points.length - 1];\n    const to = points[0];\n    if (!from || !to) {\n      return;\n    }\n\n    ctx.moveTo(from.x, from.y);\n    ctx.lineTo(to.x, to.y);\n  }\n\n  ctx.stroke();\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { Point } from '../classes/index';\nimport { Dimensions, IDimensions } from '../classes/Dimensions';\n\nexport function isTensor(tensor: any, dim: number) {\n  return tensor instanceof tf.Tensor && tensor.shape.length === dim;\n}\n\nexport function isTensor1D(tensor: any): tensor is tf.Tensor1D {\n  return isTensor(tensor, 1);\n}\n\nexport function isTensor2D(tensor: any): tensor is tf.Tensor2D {\n  return isTensor(tensor, 2);\n}\n\nexport function isTensor3D(tensor: any): tensor is tf.Tensor3D {\n  return isTensor(tensor, 3);\n}\n\nexport function isTensor4D(tensor: any): tensor is tf.Tensor4D {\n  return isTensor(tensor, 4);\n}\n\nexport function isFloat(num: number) {\n  return num % 1 !== 0;\n}\n\nexport function isEven(num: number) {\n  return num % 2 === 0;\n}\n\nexport function round(num: number, prec: number = 2) {\n  const f = 10 ** prec;\n  return Math.floor(num * f) / f;\n}\n\nexport function isDimensions(obj: any): boolean {\n  return obj && obj.width && obj.height;\n}\n\nexport function computeReshapedDimensions({ width, height }: IDimensions, inputSize: number) {\n  const scale = inputSize / Math.max(height, width);\n  return new Dimensions(Math.round(width * scale), Math.round(height * scale));\n}\n\nexport function getCenterPoint(pts: Point[]): Point {\n  return pts.reduce((sum, pt) => sum.add(pt), new Point(0, 0))\n    .div(new Point(pts.length, pts.length));\n}\n\nexport function range(num: number, start: number, step: number): number[] {\n  return Array(num).fill(0).map((_, i) => start + (i * step));\n}\n\nexport function isValidNumber(num: any) {\n  // eslint-disable-next-line no-mixed-operators\n  return !!num && (num !== Infinity) && (num !== -Infinity) && !Number.isNaN(num) || num === 0;\n}\n\nexport function isValidProbablitiy(num: any) {\n  return isValidNumber(num) && num >= 0 && num <= 1.0;\n}\n", "import { isValidNumber } from '../utils/index';\n\nexport interface IDimensions {\n  width: number\n  height: number\n}\n\nexport class Dimensions implements IDimensions {\n  private _width: number\n\n  private _height: number\n\n  constructor(width: number, height: number) {\n    if (!isValidNumber(width) || !isValidNumber(height)) {\n      throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({ width, height })}`);\n    }\n\n    this._width = width;\n    this._height = height;\n  }\n\n  public get width(): number { return this._width; }\n\n  public get height(): number { return this._height; }\n\n  public reverse(): Dimensions {\n    return new Dimensions(1 / this.width, 1 / this.height);\n  }\n}\n", "export interface IPoint {\n  x: number\n  y: number\n}\n\nexport class Point implements IPoint {\n  private _x: number\n\n  private _y: number\n\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  get x(): number { return this._x; }\n\n  get y(): number { return this._y; }\n\n  public add(pt: IPoint): Point {\n    return new Point(this.x + pt.x, this.y + pt.y);\n  }\n\n  public sub(pt: IPoint): Point {\n    return new Point(this.x - pt.x, this.y - pt.y);\n  }\n\n  public mul(pt: IPoint): Point {\n    return new Point(this.x * pt.x, this.y * pt.y);\n  }\n\n  public div(pt: IPoint): Point {\n    return new Point(this.x / pt.x, this.y / pt.y);\n  }\n\n  public abs(): Point {\n    return new Point(Math.abs(this.x), Math.abs(this.y));\n  }\n\n  public magnitude(): number {\n    return Math.sqrt((this.x ** 2) + (this.y ** 2));\n  }\n\n  public floor(): Point {\n    return new Point(Math.floor(this.x), Math.floor(this.y));\n  }\n}\n", "import { isDimensions, isValidNumber } from '../utils/index';\nimport { IBoundingBox } from './BoundingBox';\nimport { IDimensions } from './Dimensions';\nimport { Point } from './Point';\nimport { IRect } from './Rect';\n\nexport class Box<BoxType = any> implements IBoundingBox, IRect {\n  public static isRect(rect: any): boolean {\n    return !!rect && [rect.x, rect.y, rect.width, rect.height].every(isValidNumber);\n  }\n\n  public static assertIsValidBox(box: any, callee: string, allowNegativeDimensions: boolean = false) {\n    if (!Box.isRect(box)) {\n      throw new Error(`${callee} - invalid box: ${JSON.stringify(box)}, expected object with properties x, y, width, height`);\n    }\n\n    if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {\n      throw new Error(`${callee} - width (${box.width}) and height (${box.height}) must be positive numbers`);\n    }\n  }\n\n  private _x: number\n\n  private _y: number\n\n  private _width: number\n\n  private _height: number\n\n  constructor(_box: IBoundingBox | IRect, allowNegativeDimensions: boolean = true) {\n    const box = (_box || {}) as any;\n\n    const isBbox = [box.left, box.top, box.right, box.bottom].every(isValidNumber);\n    const isRect = [box.x, box.y, box.width, box.height].every(isValidNumber);\n\n    if (!isRect && !isBbox) {\n      throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(box)}`);\n    }\n\n    const [x, y, width, height] = isRect\n      ? [box.x, box.y, box.width, box.height]\n      : [box.left, box.top, box.right - box.left, box.bottom - box.top];\n\n    Box.assertIsValidBox({\n      x, y, width, height,\n    }, 'Box.constructor', allowNegativeDimensions);\n\n    this._x = x;\n    this._y = y;\n    this._width = width;\n    this._height = height;\n  }\n\n  public get x(): number { return this._x; }\n\n  public get y(): number { return this._y; }\n\n  public get width(): number { return this._width; }\n\n  public get height(): number { return this._height; }\n\n  public get left(): number { return this.x; }\n\n  public get top(): number { return this.y; }\n\n  public get right(): number { return this.x + this.width; }\n\n  public get bottom(): number { return this.y + this.height; }\n\n  public get area(): number { return this.width * this.height; }\n\n  public get topLeft(): Point { return new Point(this.left, this.top); }\n\n  public get topRight(): Point { return new Point(this.right, this.top); }\n\n  public get bottomLeft(): Point { return new Point(this.left, this.bottom); }\n\n  public get bottomRight(): Point { return new Point(this.right, this.bottom); }\n\n  public round(): Box<BoxType> {\n    const [x, y, width, height] = [this.x, this.y, this.width, this.height]\n      .map((val) => Math.round(val));\n    return new Box({\n      x, y, width, height,\n    });\n  }\n\n  public floor(): Box<BoxType> {\n    const [x, y, width, height] = [this.x, this.y, this.width, this.height]\n      .map((val) => Math.floor(val));\n    return new Box({\n      x, y, width, height,\n    });\n  }\n\n  public toSquare(): Box<BoxType> {\n    let {\n      x, y, width, height,\n    } = this;\n    const diff = Math.abs(width - height);\n    if (width < height) {\n      x -= (diff / 2);\n      width += diff;\n    }\n    if (height < width) {\n      y -= (diff / 2);\n      height += diff;\n    }\n\n    return new Box({\n      x, y, width, height,\n    });\n  }\n\n  public rescale(s: IDimensions | number): Box<BoxType> {\n    const scaleX = isDimensions(s) ? (s as IDimensions).width : s as number;\n    const scaleY = isDimensions(s) ? (s as IDimensions).height : s as number;\n    return new Box({\n      x: this.x * scaleX,\n      y: this.y * scaleY,\n      width: this.width * scaleX,\n      height: this.height * scaleY,\n    });\n  }\n\n  public pad(padX: number, padY: number): Box<BoxType> {\n    const [x, y, width, height] = [\n      this.x - (padX / 2),\n      this.y - (padY / 2),\n      this.width + padX,\n      this.height + padY,\n    ];\n    return new Box({\n      x, y, width, height,\n    });\n  }\n\n  public clipAtImageBorders(imgWidth: number, imgHeight: number): Box<BoxType> {\n    const {\n      x, y, right, bottom,\n    } = this;\n    const clippedX = Math.max(x, 0);\n    const clippedY = Math.max(y, 0);\n\n    const newWidth = right - clippedX;\n    const newHeight = bottom - clippedY;\n    const clippedWidth = Math.min(newWidth, imgWidth - clippedX);\n    const clippedHeight = Math.min(newHeight, imgHeight - clippedY);\n\n    return (new Box({\n      x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight,\n    })).floor();\n  }\n\n  public shift(sx: number, sy: number): Box<BoxType> {\n    const { width, height } = this;\n    const x = this.x + sx;\n    const y = this.y + sy;\n\n    return new Box({\n      x, y, width, height,\n    });\n  }\n\n  public padAtBorders(imageHeight: number, imageWidth: number) {\n    const w = this.width + 1;\n    const h = this.height + 1;\n\n    const dx = 1;\n    const dy = 1;\n    let edx = w;\n    let edy = h;\n\n    let x = this.left;\n    let y = this.top;\n    let ex = this.right;\n    let ey = this.bottom;\n\n    if (ex > imageWidth) {\n      edx = -ex + imageWidth + w;\n      ex = imageWidth;\n    }\n    if (ey > imageHeight) {\n      edy = -ey + imageHeight + h;\n      ey = imageHeight;\n    }\n    if (x < 1) {\n      edy = 2 - x;\n      x = 1;\n    }\n    if (y < 1) {\n      edy = 2 - y;\n      y = 1;\n    }\n\n    return {\n      dy, edy, dx, edx, y, ey, x, ex, w, h,\n    };\n  }\n\n  public calibrate(region: Box) {\n    return new Box({\n      left: this.left + (region.left * this.width),\n      top: this.top + (region.top * this.height),\n      right: this.right + (region.right * this.width),\n      bottom: this.bottom + (region.bottom * this.height),\n    }).toSquare().round();\n  }\n}\n", "import { Box } from './Box';\n\nexport interface IBoundingBox {\n  left: number\n  top: number\n  right: number\n  bottom: number\n}\n\nexport class BoundingBox extends Box<BoundingBox> implements IBoundingBox {\n  constructor(left: number, top: number, right: number, bottom: number, allowNegativeDimensions: boolean = false) {\n    super({\n      left, top, right, bottom,\n    }, allowNegativeDimensions);\n  }\n}\n", "import { Box } from './Box';\nimport { Dimensions, IDimensions } from './Dimensions';\nimport { IRect, Rect } from './Rect';\n\nexport class ObjectDetection {\n  private _score: number\n\n  private _classScore: number\n\n  private _className: string\n\n  private _box: Rect\n\n  private _imageDims: Dimensions\n\n  constructor(\n    score: number,\n    classScore: number,\n    className: string,\n    relativeBox: IRect,\n    imageDims: IDimensions,\n  ) {\n    this._imageDims = new Dimensions(imageDims.width, imageDims.height);\n    this._score = score;\n    this._classScore = classScore;\n    this._className = className;\n    this._box = new Box(relativeBox).rescale(this._imageDims);\n  }\n\n  public get score(): number { return this._score; }\n\n  public get classScore(): number { return this._classScore; }\n\n  public get className(): string { return this._className; }\n\n  public get box(): Box { return this._box; }\n\n  public get imageDims(): Dimensions { return this._imageDims; }\n\n  public get imageWidth(): number { return this.imageDims.width; }\n\n  public get imageHeight(): number { return this.imageDims.height; }\n\n  public get relativeBox(): Box { return new Box(this._box).rescale(this.imageDims.reverse()); }\n\n  public forSize(width: number, height: number): ObjectDetection {\n    return new ObjectDetection(\n      this.score,\n      this.classScore,\n      this.className,\n      this.relativeBox,\n      { width, height },\n    );\n  }\n}\n", "import { Box } from './Box';\nimport { IDimensions } from './Dimensions';\nimport { ObjectDetection } from './ObjectDetection';\nimport { Rect } from './Rect';\n\nexport interface IFaceDetecion {\n  score: number\n  box: Box\n}\n\nexport class FaceDetection extends ObjectDetection implements IFaceDetecion {\n  constructor(\n    score: number,\n    relativeBox: Rect,\n    imageDims: IDimensions,\n  ) {\n    super(score, score, '', relativeBox, imageDims);\n  }\n\n  public forSize(width: number, height: number): FaceDetection {\n    const { score, relativeBox, imageDims } = super.forSize(width, height);\n    return new FaceDetection(score, relativeBox, imageDims);\n  }\n}\n", "import { Box } from '../classes/Box';\n\nexport function iou(box1: Box, box2: Box, isIOU: boolean = true) {\n  const width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));\n  const height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));\n  const interSection = width * height;\n\n  return isIOU\n    ? interSection / (box1.area + box2.area - interSection)\n    : interSection / Math.min(box1.area, box2.area);\n}\n", "import { BoundingBox, IPoint } from '../classes/index';\n\nexport function minBbox(pts: IPoint[]): BoundingBox {\n  const xs = pts.map((pt) => pt.x);\n  const ys = pts.map((pt) => pt.y);\n  const minX = xs.reduce((min, x) => (x < min ? x : min), Infinity);\n  const minY = ys.reduce((min, y) => (y < min ? y : min), Infinity);\n  const maxX = xs.reduce((max, x) => (max < x ? x : max), 0);\n  const maxY = ys.reduce((max, y) => (max < y ? y : max), 0);\n\n  return new BoundingBox(minX, minY, maxX, maxY);\n}\n", "import { Box } from '../classes/Box';\nimport { iou } from './iou';\n\nexport function nonMaxSuppression(\n  boxes: Box[],\n  scores: number[],\n  iouThreshold: number,\n  isIOU: boolean = true,\n): number[] {\n  let indicesSortedByScore = scores\n    .map((score, boxIndex) => ({ score, boxIndex }))\n    .sort((c1, c2) => c1.score - c2.score)\n    .map((c) => c.boxIndex);\n\n  const pick: number[] = [];\n\n  while (indicesSortedByScore.length > 0) {\n    const curr = indicesSortedByScore.pop() as number;\n    pick.push(curr);\n\n    const indices = indicesSortedByScore;\n\n    const outputs: number[] = [];\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n\n      const currBox = boxes[curr];\n      const idxBox = boxes[idx];\n\n      outputs.push(iou(currBox, idxBox, isIOU));\n    }\n\n    indicesSortedByScore = indicesSortedByScore.filter(\n      (_, j) => outputs[j] <= iouThreshold,\n    );\n  }\n\n  return pick;\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nexport function normalize(x: tf.Tensor4D, meanRgb: number[]): tf.Tensor4D {\n  return tf.tidy(() => {\n    const [r, g, b] = meanRgb;\n    const avg_r = tf.fill([...x.shape.slice(0, 3), 1], r, 'float32');\n    const avg_g = tf.fill([...x.shape.slice(0, 3), 1], g, 'float32');\n    const avg_b = tf.fill([...x.shape.slice(0, 3), 1], b, 'float32');\n    const avg_rgb = tf.concat([avg_r, avg_g, avg_b], 3);\n\n    return tf.sub(x, avg_rgb);\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\n/**\n * Pads the smaller dimension of an image tensor with zeros, such that width === height.\n *\n * @param imgTensor The image tensor.\n * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\n * both sides of the minor dimension oof the image.\n * @returns The padded tensor with width === height.\n */\nexport function padToSquare(\n  imgTensor: tf.Tensor4D,\n  isCenterImage: boolean = false,\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const [height, width] = imgTensor.shape.slice(1);\n    if (height === width) {\n      return imgTensor;\n    }\n\n    const dimDiff = Math.abs(height - width);\n    const paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));\n    const paddingAxis = height > width ? 2 : 1;\n\n    const createPaddingTensor = (paddingAmountLocal: number): tf.Tensor => {\n      const paddingTensorShape = imgTensor.shape.slice();\n      paddingTensorShape[paddingAxis] = paddingAmountLocal;\n      return tf.fill(paddingTensorShape, 0, 'float32');\n    };\n\n    const paddingTensorAppend = createPaddingTensor(paddingAmount);\n    const remainingPaddingAmount = dimDiff - (paddingTensorAppend.shape[paddingAxis] as number);\n\n    const paddingTensorPrepend = isCenterImage && remainingPaddingAmount\n      ? createPaddingTensor(remainingPaddingAmount)\n      : null;\n\n    const tensorsToStack = [\n      paddingTensorPrepend,\n      imgTensor,\n      paddingTensorAppend,\n    ]\n      .filter((t) => !!t)\n      // .map((t: tf.Tensor) => t.toFloat()) as tf.Tensor4D[]\n      .map((t: tf.Tensor) => tf.cast(t, 'float32')) as tf.Tensor4D[];\n    return tf.concat(tensorsToStack, paddingAxis);\n  });\n}\n", "export function shuffleArray(inputArray: any[]) {\n  const array = inputArray.slice();\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const x = array[i];\n    array[i] = array[j];\n    array[j] = x;\n  }\n  return array;\n}\n", "export * from './iou';\nexport * from './minBbox';\nexport * from './nonMaxSuppression';\nexport * from './normalize';\nexport * from './padToSquare';\nexport * from './shuffleArray';\n\nexport function sigmoid(x: number) {\n  return 1 / (1 + Math.exp(-x));\n}\n\nexport function inverseSigmoid(x: number) {\n  return Math.log(x / (1 - x));\n}\n", "import { Box } from './Box';\n\nexport interface IRect {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\nexport class Rect extends Box<Rect> implements IRect {\n  constructor(x: number, y: number, width: number, height: number, allowNegativeDimensions: boolean = false) {\n    super({\n      x, y, width, height,\n    }, allowNegativeDimensions);\n  }\n}\n", "import { minBbox } from '../ops/index';\nimport { getCenterPoint } from '../utils/index';\nimport { IBoundingBox } from './BoundingBox';\nimport { Box } from './Box';\nimport { Dimensions, IDimensions } from './Dimensions';\nimport { FaceDetection } from './FaceDetection';\nimport { Point } from './Point';\nimport { IRect, Rect } from './Rect';\n\n// face alignment constants\nconst relX = 0.5;\nconst relY = 0.43;\nconst relScale = 0.45;\n\nexport interface IFaceLandmarks {\n  positions: Point[]\n  shift: Point\n}\n\nexport class FaceLandmarks implements IFaceLandmarks {\n  protected _shift: Point\n\n  protected _positions: Point[]\n\n  protected _imgDims: Dimensions\n\n  constructor(\n    relativeFaceLandmarkPositions: Point[],\n    imgDims: IDimensions,\n    shift: Point = new Point(0, 0),\n  ) {\n    const { width, height } = imgDims;\n    this._imgDims = new Dimensions(width, height);\n    this._shift = shift;\n    this._positions = relativeFaceLandmarkPositions.map(\n      (pt) => pt.mul(new Point(width, height)).add(shift),\n    );\n  }\n\n  public get shift(): Point { return new Point(this._shift.x, this._shift.y); }\n\n  public get imageWidth(): number { return this._imgDims.width; }\n\n  public get imageHeight(): number { return this._imgDims.height; }\n\n  public get positions(): Point[] { return this._positions; }\n\n  public get relativePositions(): Point[] {\n    return this._positions.map(\n      (pt) => pt.sub(this._shift).div(new Point(this.imageWidth, this.imageHeight)),\n    );\n  }\n\n  public forSize<T extends FaceLandmarks>(width: number, height: number): T {\n    return new (this.constructor as any)(\n      this.relativePositions,\n      { width, height },\n    );\n  }\n\n  public shiftBy<T extends FaceLandmarks>(x: number, y: number): T {\n    return new (this.constructor as any)(\n      this.relativePositions,\n      this._imgDims,\n      new Point(x, y),\n    );\n  }\n\n  public shiftByPoint<T extends FaceLandmarks>(pt: Point): T {\n    return this.shiftBy(pt.x, pt.y);\n  }\n\n  /**\n   * Aligns the face landmarks after face detection from the relative positions of the faces\n   * bounding box, or it's current shift. This function should be used to align the face images\n   * after face detection has been performed, before they are passed to the face recognition net.\n   * This will make the computed face descriptor more accurate.\n   *\n   * @param detection (optional) The bounding box of the face or the face detection result. If\n   * no argument was passed the position of the face landmarks are assumed to be relative to\n   * it's current shift.\n   * @returns The bounding box of the aligned face.\n   */\n  public align(\n    detection?: FaceDetection | IRect | IBoundingBox | null,\n    options: { useDlibAlignment?: boolean, minBoxPadding?: number } = { },\n  ): Box {\n    if (detection) {\n      const box = detection instanceof FaceDetection\n        ? detection.box.floor()\n        : new Box(detection);\n\n      return this.shiftBy(box.x, box.y).align(null, options);\n    }\n\n    const { useDlibAlignment, minBoxPadding } = { useDlibAlignment: false, minBoxPadding: 0.2, ...options };\n\n    if (useDlibAlignment) {\n      return this.alignDlib();\n    }\n\n    return this.alignMinBbox(minBoxPadding);\n  }\n\n  private alignDlib(): Box {\n    const centers = this.getRefPointsForAlignment();\n\n    const [leftEyeCenter, rightEyeCenter, mouthCenter] = centers;\n    const distToMouth = (pt: Point) => mouthCenter.sub(pt).magnitude();\n    const eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\n\n    const size = Math.floor(eyeToMouthDist / relScale);\n\n    const refPoint = getCenterPoint(centers);\n    // TODO: pad in case rectangle is out of image bounds\n    const x = Math.floor(Math.max(0, refPoint.x - (relX * size)));\n    const y = Math.floor(Math.max(0, refPoint.y - (relY * size)));\n\n    return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\n  }\n\n  private alignMinBbox(padding: number): Box {\n    const box = minBbox(this.positions);\n    return box.pad(box.width * padding, box.height * padding);\n  }\n\n  protected getRefPointsForAlignment(): Point[] {\n    throw new Error('getRefPointsForAlignment not implemented by base class');\n  }\n}\n", "import { getCenterPoint } from '../utils/index';\nimport { FaceLandmarks } from './FaceLandmarks';\nimport { Point } from './Point';\n\nexport class FaceLandmarks5 extends FaceLandmarks {\n  protected getRefPointsForAlignment(): Point[] {\n    const pts = this.positions;\n    return [\n      pts[0],\n      pts[1],\n      getCenterPoint([pts[3], pts[4]]),\n    ];\n  }\n}\n", "import { getCenterPoint } from '../utils/index';\nimport { FaceLandmarks } from './FaceLandmarks';\nimport { Point } from './Point';\n\nexport class FaceLandmarks68 extends FaceLandmarks {\n  public getJawOutline(): Point[] {\n    return this.positions.slice(0, 17);\n  }\n\n  public getLeftEyeBrow(): Point[] {\n    return this.positions.slice(17, 22);\n  }\n\n  public getRightEyeBrow(): Point[] {\n    return this.positions.slice(22, 27);\n  }\n\n  public getNose(): Point[] {\n    return this.positions.slice(27, 36);\n  }\n\n  public getLeftEye(): Point[] {\n    return this.positions.slice(36, 42);\n  }\n\n  public getRightEye(): Point[] {\n    return this.positions.slice(42, 48);\n  }\n\n  public getMouth(): Point[] {\n    return this.positions.slice(48, 68);\n  }\n\n  protected getRefPointsForAlignment(): Point[] {\n    return [\n      this.getLeftEye(),\n      this.getRightEye(),\n      this.getMouth(),\n    ].map(getCenterPoint);\n  }\n}\n", "import { round } from '../utils/index';\n\nexport interface IFaceMatch {\n  label: string\n  distance: number\n}\n\nexport class FaceMatch implements IFaceMatch {\n  private _label: string\n\n  private _distance: number\n\n  constructor(label: string, distance: number) {\n    this._label = label;\n    this._distance = distance;\n  }\n\n  public get label(): string { return this._label; }\n\n  public get distance(): number { return this._distance; }\n\n  public toString(withDistance: boolean = true): string {\n    return `${this.label}${withDistance ? ` (${round(this.distance)})` : ''}`;\n  }\n}\n", "import { isValidNumber } from '../utils/index';\nimport { IBoundingBox } from './BoundingBox';\nimport { Box } from './Box';\nimport { IRect } from './Rect';\n\nexport class LabeledBox extends Box<LabeledBox> {\n  public static assertIsValidLabeledBox(box: any, callee: string) {\n    Box.assertIsValidBox(box, callee);\n\n    if (!isValidNumber(box.label)) {\n      throw new Error(`${callee} - expected property label (${box.label}) to be a number`);\n    }\n  }\n\n  private _label: number\n\n  constructor(box: IBoundingBox | IRect | any, label: number) {\n    super(box);\n    this._label = label;\n  }\n\n  public get label(): number { return this._label; }\n}\n", "export class LabeledFaceDescriptors {\n  private _label: string\n\n  private _descriptors: Float32Array[]\n\n  constructor(label: string, descriptors: Float32Array[]) {\n    if (!(typeof label === 'string')) {\n      throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');\n    }\n\n    if (!Array.isArray(descriptors) || descriptors.some((desc) => !(desc instanceof Float32Array))) {\n      throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');\n    }\n\n    this._label = label;\n    this._descriptors = descriptors;\n  }\n\n  public get label(): string { return this._label; }\n\n  public get descriptors(): Float32Array[] { return this._descriptors; }\n\n  public toJSON(): any {\n    return {\n      label: this.label,\n      descriptors: this.descriptors.map((d) => Array.from(d)),\n    };\n  }\n\n  public static fromJSON(json: any): LabeledFaceDescriptors {\n    const descriptors = json.descriptors.map((d: any) => new Float32Array(d));\n    return new LabeledFaceDescriptors(json.label, descriptors);\n  }\n}\n", "import { isValidProbablitiy } from '../utils/index';\nimport { IBoundingBox } from './BoundingBox';\nimport { LabeledBox } from './LabeledBox';\nimport { IRect } from './Rect';\n\nexport class PredictedBox extends LabeledBox {\n  public static assertIsValidPredictedBox(box: any, callee: string) {\n    LabeledBox.assertIsValidLabeledBox(box, callee);\n\n    if (\n      !isValidProbablitiy(box.score)\n      || !isValidProbablitiy(box.classScore)\n    ) {\n      throw new Error(`${callee} - expected properties score (${box.score}) and (${box.classScore}) to be a number between [0, 1]`);\n    }\n  }\n\n  private _score: number\n\n  private _classScore: number\n\n  constructor(box: IBoundingBox | IRect | any, label: number, score: number, classScore: number) {\n    super(box, label);\n    this._score = score;\n    this._classScore = classScore;\n  }\n\n  public get score(): number { return this._score; }\n\n  public get classScore(): number { return this._classScore; }\n}\n", "import { FaceDetection } from '../classes/FaceDetection';\n\nexport type WithFaceDetection<TSource> = TSource & {\n  detection: FaceDetection\n}\n\nexport function isWithFaceDetection(obj: any): obj is WithFaceDetection<{}> {\n  return obj.detection instanceof FaceDetection;\n}\n\nexport function extendWithFaceDetection<\n  TSource\n>(\n  sourceObj: TSource,\n  detection: FaceDetection,\n): WithFaceDetection<TSource> {\n  const extension = { detection };\n  return { ...sourceObj, ...extension };\n}\n", "import { Environment } from './types';\n\nexport function createBrowserEnv(): Environment {\n  const fetch = window.fetch;\n  if (!fetch) throw new Error('fetch - missing fetch implementation for browser environment');\n\n  const readFile = () => {\n    throw new Error('readFile - filesystem not available for browser environment');\n  };\n\n  return {\n    Canvas: HTMLCanvasElement,\n    CanvasRenderingContext2D,\n    Image: HTMLImageElement,\n    ImageData,\n    Video: HTMLVideoElement,\n    createCanvasElement: () => document.createElement('canvas'),\n    createImageElement: () => document.createElement('img'),\n    fetch,\n    readFile,\n  };\n}\n", "import { FileSystem } from './types';\n\nexport function createFileSystem(fs?: any): FileSystem {\n  let requireFsError = '';\n\n  if (!fs) {\n    try {\n      // eslint-disable-next-line global-require\n      fs = require('fs');\n    } catch (err) {\n      requireFsError = err.toString();\n    }\n  }\n\n  const readFile = fs\n    ? (filePath: string) => new Promise<Buffer>((resolve, reject) => {\n      fs.readFile(filePath, (err: any, buffer: Buffer) => (err ? reject(err) : resolve(buffer)));\n    })\n    : () => {\n      throw new Error(`readFile - failed to require fs in nodejs environment with error: ${requireFsError}`);\n    };\n\n  return {\n    readFile,\n  };\n}\n", "/* eslint-disable max-classes-per-file */\nimport { createFileSystem } from './createFileSystem';\nimport { Environment } from './types';\n\nexport function createNodejsEnv(): Environment {\n  // eslint-disable-next-line dot-notation\n  const Canvas = global['Canvas'] || global.HTMLCanvasElement;\n  const Image = global.Image || global.HTMLImageElement;\n\n  const createCanvasElement = () => {\n    if (Canvas) return new Canvas();\n    throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');\n  };\n\n  const createImageElement = () => {\n    if (Image) return new Image();\n    throw new Error('createImageElement - missing Image implementation for nodejs environment');\n  };\n\n  const fetch = global.fetch;\n  // if (!fetch) throw new Error('fetch - missing fetch implementation for nodejs environment');\n\n  const fileSystem = createFileSystem();\n\n  return {\n    Canvas: Canvas || class {},\n    CanvasRenderingContext2D: global.CanvasRenderingContext2D || class {},\n    Image: Image || class {},\n    ImageData: global.ImageData || class {},\n    Video: global.HTMLVideoElement || class {},\n    createCanvasElement,\n    createImageElement,\n    fetch,\n    ...fileSystem,\n  };\n}\n", "export function isBrowser(): boolean {\n  return typeof window === 'object'\n    && typeof document !== 'undefined'\n    && typeof HTMLImageElement !== 'undefined'\n    && typeof HTMLCanvasElement !== 'undefined'\n    && typeof HTMLVideoElement !== 'undefined'\n    && typeof ImageData !== 'undefined'\n    && typeof CanvasRenderingContext2D !== 'undefined';\n}\n", "import { createBrowserEnv } from './createBrowserEnv';\nimport { createFileSystem } from './createFileSystem';\nimport { createNodejsEnv } from './createNodejsEnv';\nimport { isBrowser } from './isBrowser';\nimport { isNodejs } from './isNodejs';\nimport { Environment } from './types';\n\nlet environment: Environment | null;\n\nfunction getEnv(): Environment {\n  if (!environment) {\n    throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');\n  }\n  return environment;\n}\n\nfunction setEnv(env: Environment) {\n  environment = env;\n}\n\nfunction initialize() {\n  // check for isBrowser() first to prevent electron renderer process\n  // to be initialized with wrong environment due to isNodejs() returning true\n  if (isBrowser()) return setEnv(createBrowserEnv());\n  if (isNodejs()) return setEnv(createNodejsEnv());\n  return null;\n}\n\nfunction monkeyPatch(env: Partial<Environment>) {\n  if (!environment) {\n    initialize();\n  }\n\n  if (!environment) {\n    throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');\n  }\n\n  const { Canvas = environment.Canvas, Image = environment.Image } = env;\n  environment.Canvas = Canvas;\n  environment.Image = Image;\n  environment.createCanvasElement = env.createCanvasElement || (() => new Canvas());\n  environment.createImageElement = env.createImageElement || (() => new Image());\n\n  environment.ImageData = env.ImageData || environment.ImageData;\n  environment.Video = env.Video || environment.Video;\n  environment.fetch = env.fetch || environment.fetch;\n  environment.readFile = env.readFile || environment.readFile;\n}\n\nexport const env = {\n  getEnv,\n  setEnv,\n  initialize,\n  createBrowserEnv,\n  createFileSystem,\n  createNodejsEnv,\n  monkeyPatch,\n  isBrowser,\n  isNodejs,\n};\n\ninitialize();\n\nexport * from './types';\n", "import { env } from '../env/index';\n\nexport function resolveInput(arg: string | any) {\n  if (!env.isNodejs() && typeof arg === 'string') {\n    return document.getElementById(arg);\n  }\n  return arg;\n}\n", "import { env } from '../env/index';\nimport { resolveInput } from './resolveInput';\n\nexport function getContext2dOrThrow(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D): CanvasRenderingContext2D {\n  const { Canvas, CanvasRenderingContext2D } = env.getEnv();\n\n  if (canvasArg instanceof CanvasRenderingContext2D) {\n    return canvasArg;\n  }\n\n  const canvas = resolveInput(canvasArg);\n\n  if (!(canvas instanceof Canvas)) {\n    throw new Error('resolveContext2d - expected canvas to be of instance of Canvas');\n  }\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    throw new Error('resolveContext2d - canvas 2d context is null');\n  }\n\n  return ctx;\n}\n", "/* eslint-disable max-classes-per-file */\nimport { IDimensions, IPoint } from '../classes/index';\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\nimport { resolveInput } from '../dom/resolveInput';\n\n// eslint-disable-next-line no-shadow\nexport enum AnchorPosition {\n  // eslint-disable-next-line no-unused-vars\n  TOP_LEFT = 'TOP_LEFT',\n  // eslint-disable-next-line no-unused-vars\n  TOP_RIGHT = 'TOP_RIGHT',\n  // eslint-disable-next-line no-unused-vars\n  BOTTOM_LEFT = 'BOTTOM_LEFT',\n  // eslint-disable-next-line no-unused-vars\n  BOTTOM_RIGHT = 'BOTTOM_RIGHT'\n}\n\nexport interface IDrawTextFieldOptions {\n  anchorPosition?: AnchorPosition\n  backgroundColor?: string\n  fontColor?: string\n  fontSize?: number\n  fontStyle?: string\n  padding?: number\n}\n\nexport class DrawTextFieldOptions implements IDrawTextFieldOptions {\n  public anchorPosition: AnchorPosition\n\n  public backgroundColor: string\n\n  public fontColor: string\n\n  public fontSize: number\n\n  public fontStyle: string\n\n  public padding: number\n\n  constructor(options: IDrawTextFieldOptions = {}) {\n    const {\n      anchorPosition, backgroundColor, fontColor, fontSize, fontStyle, padding,\n    } = options;\n    this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;\n    this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)';\n    this.fontColor = fontColor || 'rgba(255, 255, 255, 1)';\n    this.fontSize = fontSize || 14;\n    this.fontStyle = fontStyle || 'Georgia';\n    this.padding = padding || 4;\n  }\n}\n\nexport class DrawTextField {\n  public text: string[]\n\n  public anchor : IPoint\n\n  public options: DrawTextFieldOptions\n\n  constructor(\n    text: string | string[] | DrawTextField,\n    anchor: IPoint,\n    options: IDrawTextFieldOptions = {},\n  ) {\n    // eslint-disable-next-line no-nested-ternary\n    this.text = typeof text === 'string'\n      ? [text]\n      : (text instanceof DrawTextField ? text.text : text);\n    this.anchor = anchor;\n    this.options = new DrawTextFieldOptions(options);\n  }\n\n  measureWidth(ctx: CanvasRenderingContext2D): number {\n    const { padding } = this.options;\n    return this.text.map((l) => ctx.measureText(l).width).reduce((w0, w1) => (w0 < w1 ? w1 : w0), 0) + (2 * padding);\n  }\n\n  measureHeight(): number {\n    const { fontSize, padding } = this.options;\n    return this.text.length * fontSize + (2 * padding);\n  }\n\n  getUpperLeft(ctx: CanvasRenderingContext2D, canvasDims?: IDimensions): IPoint {\n    const { anchorPosition } = this.options;\n    const isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;\n    const isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;\n\n    const textFieldWidth = this.measureWidth(ctx);\n    const textFieldHeight = this.measureHeight();\n    const x = (isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x);\n    const y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y;\n\n    // adjust anchor if text box exceeds canvas borders\n    if (canvasDims) {\n      const { width, height } = canvasDims;\n      const newX = Math.max(Math.min(x, width - textFieldWidth), 0);\n      const newY = Math.max(Math.min(y, height - textFieldHeight), 0);\n      return { x: newX, y: newY };\n    }\n    return { x, y };\n  }\n\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\n    const canvas = resolveInput(canvasArg);\n    const ctx = getContext2dOrThrow(canvas);\n\n    const {\n      backgroundColor, fontColor, fontSize, fontStyle, padding,\n    } = this.options;\n\n    ctx.font = `${fontSize}px ${fontStyle}`;\n    const maxTextWidth = this.measureWidth(ctx);\n    const textHeight = this.measureHeight();\n\n    ctx.fillStyle = backgroundColor;\n    const upperLeft = this.getUpperLeft(ctx, canvas);\n    ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);\n\n    ctx.fillStyle = fontColor;\n    this.text.forEach((textLine, i) => {\n      const x = padding + upperLeft.x;\n      const y = padding + upperLeft.y + ((i + 1) * fontSize);\n      ctx.fillText(textLine, x, y);\n    });\n  }\n}\n", "/* eslint-disable max-classes-per-file */\nimport { Box, IBoundingBox, IRect } from '../classes/index';\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\nimport {\n  AnchorPosition, DrawTextField, DrawTextFieldOptions, IDrawTextFieldOptions,\n} from './DrawTextField';\n\nexport interface IDrawBoxOptions {\n  boxColor?: string\n  lineWidth?: number\n  drawLabelOptions?: IDrawTextFieldOptions\n  label?: string\n}\n\nexport class DrawBoxOptions {\n  public boxColor: string\n\n  public lineWidth: number\n\n  public drawLabelOptions: DrawTextFieldOptions\n\n  public label?: string\n\n  constructor(options: IDrawBoxOptions = {}) {\n    const {\n      boxColor, lineWidth, label, drawLabelOptions,\n    } = options;\n    this.boxColor = boxColor || 'rgba(0, 0, 255, 1)';\n    this.lineWidth = lineWidth || 2;\n    this.label = label;\n\n    const defaultDrawLabelOptions = {\n      anchorPosition: AnchorPosition.BOTTOM_LEFT,\n      backgroundColor: this.boxColor,\n    };\n    this.drawLabelOptions = new DrawTextFieldOptions({ ...defaultDrawLabelOptions, ...drawLabelOptions });\n  }\n}\n\nexport class DrawBox {\n  public box: Box\n\n  public options: DrawBoxOptions\n\n  constructor(\n    box: IBoundingBox | IRect,\n    options: IDrawBoxOptions = {},\n  ) {\n    this.box = new Box(box);\n    this.options = new DrawBoxOptions(options);\n  }\n\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\n    const ctx = getContext2dOrThrow(canvasArg);\n\n    const { boxColor, lineWidth } = this.options;\n\n    const {\n      x, y, width, height,\n    } = this.box;\n    ctx.strokeStyle = boxColor;\n    ctx.lineWidth = lineWidth;\n    ctx.strokeRect(x, y, width, height);\n\n    const { label } = this.options;\n    if (label) {\n      new DrawTextField([label], { x: x - (lineWidth / 2), y }, this.options.drawLabelOptions).draw(canvasArg);\n    }\n  }\n}\n", "import { Box, IBoundingBox, IRect } from '../classes/index';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isWithFaceDetection, WithFaceDetection } from '../factories/WithFaceDetection';\nimport { round } from '../utils/index';\nimport { DrawBox } from './DrawBox';\n\nexport type TDrawDetectionsInput = IRect | IBoundingBox | FaceDetection | WithFaceDetection<{}>\n\nexport function drawDetections(\n  canvasArg: string | HTMLCanvasElement,\n  detections: TDrawDetectionsInput | Array<TDrawDetectionsInput>,\n) {\n  const detectionsArray = Array.isArray(detections) ? detections : [detections];\n\n  detectionsArray.forEach((det) => {\n    // eslint-disable-next-line no-nested-ternary\n    const score = det instanceof FaceDetection\n      ? det.score\n      : (isWithFaceDetection(det) ? det.detection.score : undefined);\n\n    // eslint-disable-next-line no-nested-ternary\n    const box = det instanceof FaceDetection\n      ? det.box\n      : (isWithFaceDetection(det) ? det.detection.box : new Box(det));\n\n    const label = score ? `${round(score)}` : undefined;\n    new DrawBox(box, { label }).draw(canvasArg);\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\nimport { FaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { FaceExpressions } from './FaceExpressions';\n\nexport class FaceExpressionNet extends FaceProcessor<FaceFeatureExtractorParams> {\n  constructor(faceFeatureExtractor: FaceFeatureExtractor = new FaceFeatureExtractor()) {\n    super('FaceExpressionNet', faceFeatureExtractor);\n  }\n\n  public forwardInput(input: NetInput | tf.Tensor4D): tf.Tensor2D {\n    return tf.tidy(() => tf.softmax(this.runNet(input)));\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  public async predictExpressions(input: TNetInput) {\n    const netInput = await toNetInput(input);\n    const out = await this.forwardInput(netInput);\n    const probabilitesByBatch = await Promise.all(tf.unstack(out).map(async (t) => {\n      const data = await t.data();\n      t.dispose();\n      return data;\n    }));\n    out.dispose();\n\n    const predictionsByBatch = probabilitesByBatch\n      .map((probabilites) => new FaceExpressions(probabilites as Float32Array));\n\n    return netInput.isBatchInput\n      ? predictionsByBatch\n      : predictionsByBatch[0];\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_expression_model';\n  }\n\n  protected getClassifierChannelsIn(): number {\n    return 256;\n  }\n\n  protected getClassifierChannelsOut(): number {\n    return 7;\n  }\n}\n", "import { env } from '../env/index';\n\nexport function isMediaLoaded(media: HTMLImageElement | HTMLVideoElement) : boolean {\n  const { Image, Video } = env.getEnv();\n\n  return (media instanceof Image && media.complete)\n    || (media instanceof Video && media.readyState >= 3);\n}\n", "import { env } from '../env/index';\nimport { isMediaLoaded } from './isMediaLoaded';\n\nexport function awaitMediaLoaded(media: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement) {\n  // eslint-disable-next-line consistent-return\n  return new Promise((resolve, reject) => {\n    if (media instanceof env.getEnv().Canvas || isMediaLoaded(media)) {\n      return resolve(null);\n    }\n\n    function onError(e: Event) {\n      if (!e.currentTarget) return;\n      // eslint-disable-next-line no-use-before-define\n      e.currentTarget.removeEventListener('load', onLoad);\n      e.currentTarget.removeEventListener('error', onError);\n      reject(e);\n    }\n\n    function onLoad(e: Event) {\n      if (!e.currentTarget) return;\n      e.currentTarget.removeEventListener('load', onLoad);\n      e.currentTarget.removeEventListener('error', onError);\n      resolve(e);\n    }\n\n    media.addEventListener('load', onLoad);\n    media.addEventListener('error', onError);\n  });\n}\n", "import { env } from '../env/index';\n\nexport function bufferToImage(buf: Blob): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    if (!(buf instanceof Blob)) reject(new Error('bufferToImage - expected buf to be of type: Blob'));\n    const reader = new FileReader();\n    reader.onload = () => {\n      if (typeof reader.result !== 'string') reject(new Error('bufferToImage - expected reader.result to be a string, in onload'));\n      const img = env.getEnv().createImageElement();\n      img.onload = () => resolve(img);\n      img.onerror = reject;\n      img.src = reader.result as string;\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(buf);\n  });\n}\n", "import { Dimensions, IDimensions } from '../classes/Dimensions';\nimport { env } from '../env/index';\n\nexport function getMediaDimensions(input: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | IDimensions): Dimensions {\n  const { Image, Video } = env.getEnv();\n\n  if (input instanceof Image) {\n    return new Dimensions(input.naturalWidth, input.naturalHeight);\n  }\n  if (input instanceof Video) {\n    return new Dimensions(input.videoWidth, input.videoHeight);\n  }\n  return new Dimensions(input.width, input.height);\n}\n", "import { IDimensions } from '../classes/Dimensions';\nimport { env } from '../env/index';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { getMediaDimensions } from './getMediaDimensions';\nimport { isMediaLoaded } from './isMediaLoaded';\n\nexport function createCanvas({ width, height }: IDimensions): HTMLCanvasElement {\n  const { createCanvasElement } = env.getEnv();\n  const canvas = createCanvasElement();\n  canvas.width = width;\n  canvas.height = height;\n  return canvas;\n}\n\nexport function createCanvasFromMedia(media: HTMLImageElement | HTMLVideoElement | ImageData, dims?: IDimensions): HTMLCanvasElement {\n  const { ImageData } = env.getEnv();\n\n  if (!(media instanceof ImageData) && !isMediaLoaded(media)) {\n    throw new Error('createCanvasFromMedia - media has not finished loading yet');\n  }\n\n  const { width, height } = dims || getMediaDimensions(media);\n  const canvas = createCanvas({ width, height });\n\n  if (media instanceof ImageData) {\n    getContext2dOrThrow(canvas).putImageData(media, 0, 0);\n  } else {\n    getContext2dOrThrow(canvas).drawImage(media, 0, 0, width, height);\n  }\n  return canvas;\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { env } from '../env/index';\nimport { isTensor4D } from '../utils/index';\n\nexport async function imageTensorToCanvas(\n  imgTensor: tf.Tensor,\n  canvas?: HTMLCanvasElement,\n): Promise<HTMLCanvasElement> {\n  const targetCanvas = canvas || env.getEnv().createCanvasElement();\n\n  const [height, width, numChannels] = imgTensor.shape.slice(isTensor4D(imgTensor) ? 1 : 0);\n  const imgTensor3D = tf.tidy(() => imgTensor.as3D(height, width, numChannels).toInt());\n  await tf.browser.toPixels(imgTensor3D, targetCanvas);\n\n  imgTensor3D.dispose();\n\n  return targetCanvas;\n}\n", "import { env } from '../env/index';\n\nexport function isMediaElement(input: any) {\n  const { Image, Canvas, Video } = env.getEnv();\n\n  return input instanceof Image\n    || input instanceof Canvas\n    || input instanceof Video;\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { Dimensions } from '../classes/Dimensions';\nimport { env } from '../env/index';\nimport { padToSquare } from '../ops/padToSquare';\nimport {\n  computeReshapedDimensions, isTensor3D, isTensor4D, range,\n} from '../utils/index';\nimport { createCanvasFromMedia } from './createCanvas';\nimport { imageToSquare } from './imageToSquare';\nimport { TResolvedNetInput } from './types';\n\nexport class NetInput {\n  private _imageTensors: Array<tf.Tensor3D | tf.Tensor4D> = []\n\n  private _canvases: HTMLCanvasElement[] = []\n\n  private _batchSize: number\n\n  private _treatAsBatchInput: boolean = false\n\n  private _inputDimensions: number[][] = []\n\n  private _inputSize: number\n\n  constructor(\n    inputs: Array<TResolvedNetInput>,\n    treatAsBatchInput: boolean = false,\n  ) {\n    if (!Array.isArray(inputs)) {\n      throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${inputs}`);\n    }\n\n    this._treatAsBatchInput = treatAsBatchInput;\n    this._batchSize = inputs.length;\n\n    inputs.forEach((input, idx) => {\n      if (isTensor3D(input)) {\n        this._imageTensors[idx] = input;\n        this._inputDimensions[idx] = input.shape;\n        return;\n      }\n\n      if (isTensor4D(input)) {\n        const batchSize = (input as any).shape[0];\n        if (batchSize !== 1) {\n          throw new Error(`NetInput - tf.Tensor4D with batchSize ${batchSize} passed, but not supported in input array`);\n        }\n\n        this._imageTensors[idx] = input;\n        this._inputDimensions[idx] = (input as any).shape.slice(1);\n        return;\n      }\n\n      const canvas = (input as any) instanceof env.getEnv().Canvas ? input : createCanvasFromMedia(input);\n      this._canvases[idx] = canvas;\n      this._inputDimensions[idx] = [canvas.height, canvas.width, 3];\n    });\n  }\n\n  public get imageTensors(): Array<tf.Tensor3D | tf.Tensor4D> {\n    return this._imageTensors;\n  }\n\n  public get canvases(): HTMLCanvasElement[] {\n    return this._canvases;\n  }\n\n  public get isBatchInput(): boolean {\n    return this.batchSize > 1 || this._treatAsBatchInput;\n  }\n\n  public get batchSize(): number {\n    return this._batchSize;\n  }\n\n  public get inputDimensions(): number[][] {\n    return this._inputDimensions;\n  }\n\n  public get inputSize(): number | undefined {\n    return this._inputSize;\n  }\n\n  public get reshapedInputDimensions(): Dimensions[] {\n    return range(this.batchSize, 0, 1).map(\n      (_, batchIdx) => this.getReshapedInputDimensions(batchIdx),\n    );\n  }\n\n  public getInput(batchIdx: number): tf.Tensor3D | tf.Tensor4D | HTMLCanvasElement {\n    return this.canvases[batchIdx] || this.imageTensors[batchIdx];\n  }\n\n  public getInputDimensions(batchIdx: number): number[] {\n    return this._inputDimensions[batchIdx];\n  }\n\n  public getInputHeight(batchIdx: number): number {\n    return this._inputDimensions[batchIdx][0];\n  }\n\n  public getInputWidth(batchIdx: number): number {\n    return this._inputDimensions[batchIdx][1];\n  }\n\n  public getReshapedInputDimensions(batchIdx: number): Dimensions {\n    if (typeof this.inputSize !== 'number') {\n      throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');\n    }\n\n    const width = this.getInputWidth(batchIdx);\n    const height = this.getInputHeight(batchIdx);\n    return computeReshapedDimensions({ width, height }, this.inputSize);\n  }\n\n  /**\n   * Create a batch tensor from all input canvases and tensors\n   * with size [batchSize, inputSize, inputSize, 3].\n   *\n   * @param inputSize Height and width of the tensor.\n   * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\n   * both sides of the minor dimension oof the image.\n   * @returns The batch tensor.\n   */\n  public toBatchTensor(inputSize: number, isCenterInputs: boolean = true): tf.Tensor4D {\n    this._inputSize = inputSize;\n\n    return tf.tidy(() => {\n      const inputTensors = range(this.batchSize, 0, 1).map((batchIdx) => {\n        const input = this.getInput(batchIdx);\n\n        if (input instanceof tf.Tensor) {\n          // @ts-ignore: error TS2344: Type 'Rank.R4' does not satisfy the constraint 'Tensor<Rank>'.\n          let imgTensor = isTensor4D(input) ? input : input.expandDims<tf.Rank.R4>();\n          // @ts-ignore: error TS2344: Type 'Rank.R4' does not satisfy the constraint 'Tensor<Rank>'.\n          imgTensor = padToSquare(imgTensor, isCenterInputs);\n\n          if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\n            imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize]);\n          }\n\n          return imgTensor.as3D(inputSize, inputSize, 3);\n        }\n\n        if (input instanceof env.getEnv().Canvas) {\n          return tf.browser.fromPixels(imageToSquare(input, inputSize, isCenterInputs));\n        }\n\n        throw new Error(`toBatchTensor - at batchIdx ${batchIdx}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${input}`);\n      });\n\n      // const batchTensor = tf.stack(inputTensors.map(t => t.toFloat())).as4D(this.batchSize, inputSize, inputSize, 3)\n      const batchTensor = tf.stack(inputTensors.map((t) => tf.cast(t, 'float32'))).as4D(this.batchSize, inputSize, inputSize, 3);\n      // const batchTensor = tf.stack(inputTensors.map(t => tf.Tensor.as4D(tf.cast(t, 'float32'))), this.batchSize, inputSize, inputSize, 3);\n\n      return batchTensor;\n    });\n  }\n}\n", "import { env } from '../env/index';\nimport { createCanvas, createCanvasFromMedia } from './createCanvas';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { getMediaDimensions } from './getMediaDimensions';\n\nexport function imageToSquare(input: HTMLImageElement | HTMLCanvasElement, inputSize: number, centerImage: boolean = false) {\n  const { Image, Canvas } = env.getEnv();\n\n  if (!(input instanceof Image || input instanceof Canvas)) {\n    throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');\n  }\n\n  const dims = getMediaDimensions(input);\n  const scale = inputSize / Math.max(dims.height, dims.width);\n  const width = scale * dims.width;\n  const height = scale * dims.height;\n\n  const targetCanvas = createCanvas({ width: inputSize, height: inputSize });\n  const inputCanvas = input instanceof Canvas ? input : createCanvasFromMedia(input);\n\n  const offset = Math.abs(width - height) / 2;\n  const dx = centerImage && width < height ? offset : 0;\n  const dy = centerImage && height < width ? offset : 0;\n  getContext2dOrThrow(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);\n\n  return targetCanvas;\n}\n", "import { isTensor3D, isTensor4D } from '../utils/index';\nimport { awaitMediaLoaded } from './awaitMediaLoaded';\nimport { isMediaElement } from './isMediaElement';\nimport { NetInput } from './NetInput';\nimport { resolveInput } from './resolveInput';\nimport { TNetInput } from './types';\n\n/**\n * Validates the input to make sure, they are valid net inputs and awaits all media elements\n * to be finished loading.\n *\n * @param input The input, which can be a media element or an array of different media elements.\n * @returns A NetInput instance, which can be passed into one of the neural networks.\n */\nexport async function toNetInput(inputs: TNetInput): Promise<NetInput> {\n  if (inputs instanceof NetInput) {\n    return inputs;\n  }\n\n  const inputArgArray = Array.isArray(inputs)\n    ? inputs\n    : [inputs];\n\n  if (!inputArgArray.length) {\n    throw new Error('toNetInput - empty array passed as input');\n  }\n\n  const getIdxHint = (idx: number) => (Array.isArray(inputs) ? ` at input index ${idx}:` : '');\n\n  const inputArray = inputArgArray.map(resolveInput);\n\n  inputArray.forEach((input, i) => {\n    if (!isMediaElement(input) && !isTensor3D(input) && !isTensor4D(input)) {\n      if (typeof inputArgArray[i] === 'string') {\n        throw new Error(`toNetInput -${getIdxHint(i)} string passed, but could not resolve HTMLElement for element id ${inputArgArray[i]}`);\n      }\n\n      throw new Error(`toNetInput -${getIdxHint(i)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);\n    }\n\n    if (isTensor4D(input)) {\n      // if tf.Tensor4D is passed in the input array, the batch size has to be 1\n      const batchSize = input.shape[0];\n      if (batchSize !== 1) {\n        throw new Error(`toNetInput -${getIdxHint(i)} tf.Tensor4D with batchSize ${batchSize} passed, but not supported in input array`);\n      }\n    }\n  });\n\n  // wait for all media elements being loaded\n  await Promise.all(\n    inputArray.map((input) => isMediaElement(input) && awaitMediaLoaded(input)),\n  );\n\n  return new NetInput(inputArray, Array.isArray(inputs));\n}\n", "import { FaceDetection } from '../classes/FaceDetection';\nimport { Rect } from '../classes/Rect';\nimport { env } from '../env/index';\nimport { createCanvas } from './createCanvas';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { imageTensorToCanvas } from './imageTensorToCanvas';\nimport { toNetInput } from './toNetInput';\nimport { TNetInput } from './types';\n\n/**\n * Extracts the image regions containing the detected faces.\n *\n * @param input The image that face detection has been performed on.\n * @param detections The face detection results or face bounding boxes for that image.\n * @returns The Canvases of the corresponding image region for each detected face.\n */\nexport async function extractFaces(\n  input: TNetInput,\n  detections: Array<FaceDetection | Rect>,\n): Promise<HTMLCanvasElement[]> {\n  const { Canvas } = env.getEnv();\n\n  let canvas = input as HTMLCanvasElement;\n\n  if (!(input instanceof Canvas)) {\n    const netInput = await toNetInput(input);\n\n    if (netInput.batchSize > 1) {\n      throw new Error('extractFaces - batchSize > 1 not supported');\n    }\n\n    const tensorOrCanvas = netInput.getInput(0);\n    canvas = tensorOrCanvas instanceof Canvas\n      ? tensorOrCanvas\n      : await imageTensorToCanvas(tensorOrCanvas);\n  }\n\n  const ctx = getContext2dOrThrow(canvas);\n  const boxes = detections.map(\n    (det) => (det instanceof FaceDetection\n      ? det.forSize(canvas.width, canvas.height).box.floor()\n      : det),\n  )\n    .map((box) => box.clipAtImageBorders(canvas.width, canvas.height));\n\n  return boxes.map(({\n    x, y, width, height,\n  }) => {\n    const faceImg = createCanvas({ width, height });\n    getContext2dOrThrow(faceImg)\n      .putImageData(ctx.getImageData(x, y, width, height), 0, 0);\n    return faceImg;\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { Rect } from '../classes/index';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isTensor3D, isTensor4D } from '../utils/index';\n\n/**\n * Extracts the tensors of the image regions containing the detected faces.\n * Useful if you want to compute the face descriptors for the face images.\n * Using this method is faster then extracting a canvas for each face and\n * converting them to tensors individually.\n *\n * @param imageTensor The image tensor that face detection has been performed on.\n * @param detections The face detection results or face bounding boxes for that image.\n * @returns Tensors of the corresponding image region for each detected face.\n */\nexport async function extractFaceTensors(\n  imageTensor: tf.Tensor3D | tf.Tensor4D,\n  detections: Array<FaceDetection | Rect>,\n): Promise<tf.Tensor3D[]> {\n  if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\n    throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\n  }\n\n  if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\n    throw new Error('extractFaceTensors - batchSize > 1 not supported');\n  }\n\n  return tf.tidy(() => {\n    const [imgHeight, imgWidth, numChannels] = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0);\n\n    const boxes = detections.map(\n      (det) => (det instanceof FaceDetection\n        ? det.forSize(imgWidth, imgHeight).box\n        : det),\n    )\n      .map((box) => box.clipAtImageBorders(imgWidth, imgHeight));\n\n    const faceTensors = boxes.map(({\n      x, y, width, height,\n    }) => tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]));\n\n    return faceTensors;\n  });\n}\n", "import { env } from '../env/index';\n\nexport async function fetchOrThrow(\n  url: string,\n  // eslint-disable-next-line no-undef\n  init?: RequestInit,\n): Promise<Response> {\n  const { fetch } = env.getEnv();\n  const res = await fetch(url, init);\n  if (!(res.status < 400)) {\n    throw new Error(`failed to fetch: (${res.status}) ${res.statusText}, from url: ${res.url}`);\n  }\n  return res;\n}\n", "import { bufferToImage } from './bufferToImage';\nimport { fetchOrThrow } from './fetchOrThrow';\n\nexport async function fetchImage(uri: string): Promise<HTMLImageElement> {\n  const res = await fetchOrThrow(uri);\n  const blob = await (res).blob();\n\n  if (!blob.type.startsWith('image/')) {\n    throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${blob.type}, for url: ${res.url}`);\n  }\n  return bufferToImage(blob);\n}\n", "import { fetchOrThrow } from './fetchOrThrow';\n\nexport async function fetchJson<T>(uri: string): Promise<T> {\n  return (await fetchOrThrow(uri)).json();\n}\n", "import { fetchOrThrow } from './fetchOrThrow';\n\nexport async function fetchNetWeights(uri: string): Promise<Float32Array> {\n  return new Float32Array(await (await fetchOrThrow(uri)).arrayBuffer());\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { getModelUris } from '../common/getModelUris';\nimport { fetchJson } from './fetchJson';\n\nexport async function loadWeightMap(\n  uri: string | undefined,\n  defaultModelName: string,\n): Promise<tf.NamedTensorMap> {\n  const { manifestUri, modelBaseUri } = getModelUris(uri, defaultModelName);\n  const manifest = await fetchJson<tf.io.WeightsManifestConfig>(manifestUri);\n  // if (manifest['weightsManifest']) manifest = manifest['weightsManifest'];\n  return tf.io.loadWeights(manifest, modelBaseUri);\n}\n", "export function getModelUris(uri: string | undefined, defaultModelName: string) {\n  const defaultManifestFilename = `${defaultModelName}-weights_manifest.json`;\n\n  if (!uri) {\n    return {\n      modelBaseUri: '',\n      manifestUri: defaultManifestFilename,\n    };\n  }\n\n  if (uri === '/') {\n    return {\n      modelBaseUri: '/',\n      manifestUri: `/${defaultManifestFilename}`,\n    };\n  }\n  // eslint-disable-next-line no-nested-ternary\n  const protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';\n  uri = uri.replace(protocol, '');\n\n  const parts = uri.split('/').filter((s) => s);\n\n  const manifestFile = uri.endsWith('.json')\n    ? parts[parts.length - 1]\n    : defaultManifestFilename;\n\n  let modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');\n  modelBaseUri = uri.startsWith('/') ? `/${modelBaseUri}` : modelBaseUri;\n\n  return {\n    modelBaseUri,\n    manifestUri: modelBaseUri === '/' ? `/${manifestFile}` : `${modelBaseUri}/${manifestFile}`,\n  };\n}\n", "import { IDimensions } from '../classes/index';\nimport { getMediaDimensions } from './getMediaDimensions';\n\nexport function matchDimensions(input: IDimensions, reference: IDimensions, useMediaDimensions: boolean = false) {\n  const { width, height } = useMediaDimensions\n    ? getMediaDimensions(reference)\n    : reference;\n  input.width = width;\n  input.height = height;\n  return { width, height };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops/index';\nimport { denseBlock4 } from './denseBlock';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { FaceFeatureExtractorParams, IFaceFeatureExtractor } from './types';\n\nexport class FaceFeatureExtractor extends NeuralNetwork<FaceFeatureExtractorParams> implements IFaceFeatureExtractor<FaceFeatureExtractorParams> {\n  constructor() {\n    super('FaceFeatureExtractor');\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor4D {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error('FaceFeatureExtractor - load model before inference');\n    }\n\n    return tf.tidy(() => {\n      const batchTensor = tf.cast(input.toBatchTensor(112, true), 'float32');\n      const meanRgb = [122.782, 117.001, 104.298];\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(255)) as tf.Tensor4D;\n\n      let out = denseBlock4(normalized, params.dense0, true);\n      out = denseBlock4(out, params.dense1);\n      out = denseBlock4(out, params.dense2);\n      out = denseBlock4(out, params.dense3);\n      out = tf.avgPool(out, [7, 7], [2, 2], 'valid');\n\n      return out;\n    });\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_feature_extractor_model';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights);\n  }\n}\n", "import * as tf from '../dist/tfjs.esm.js';\n\nimport { ParamMapping } from './common/index';\nimport { getModelUris } from './common/getModelUris';\nimport { loadWeightMap } from './dom/index';\nimport { env } from './env/index';\n\nexport abstract class NeuralNetwork<TNetParams> {\n\n  protected _params: TNetParams | undefined = undefined\n  protected _paramMappings: ParamMapping[] = []\n\n  constructor(protected _name: string) {\n  }\n\n  public get params(): TNetParams | undefined { return this._params }\n  public get paramMappings(): ParamMapping[] { return this._paramMappings }\n  public get isLoaded(): boolean { return !!this.params }\n\n  public getParamFromPath(paramPath: string): tf.Tensor {\n    const { obj, objProp } = this.traversePropertyPath(paramPath)\n    return obj[objProp]\n  }\n\n  public reassignParamFromPath(paramPath: string, tensor: tf.Tensor) {\n    const { obj, objProp } = this.traversePropertyPath(paramPath)\n    obj[objProp].dispose()\n    obj[objProp] = tensor\n  }\n\n  public getParamList() {\n    return this._paramMappings.map(({ paramPath }) => ({\n      path: paramPath,\n      tensor: this.getParamFromPath(paramPath)\n    }))\n  }\n\n  public getTrainableParams() {\n    return this.getParamList().filter(param => param.tensor instanceof tf.Variable)\n  }\n\n  public getFrozenParams() {\n    return this.getParamList().filter(param => !(param.tensor instanceof tf.Variable))\n  }\n\n  public variable() {\n    this.getFrozenParams().forEach(({ path, tensor }) => {\n      this.reassignParamFromPath(path, tensor.variable())\n    })\n  }\n\n  public freeze() {\n    this.getTrainableParams().forEach(({ path, tensor: variable }) => {\n      const tensor = tf.tensor(variable.dataSync())\n      variable.dispose()\n      this.reassignParamFromPath(path, tensor)\n    })\n  }\n\n  public dispose(throwOnRedispose: boolean = true) {\n    this.getParamList().forEach(param => {\n      if (throwOnRedispose && param.tensor.isDisposed) {\n        throw new Error(`param tensor has already been disposed for path ${param.path}`)\n      }\n      param.tensor.dispose()\n    })\n    this._params = undefined\n  }\n\n  public serializeParams(): Float32Array {\n    return new Float32Array(\n      this.getParamList()\n        .map(({ tensor }) => Array.from(tensor.dataSync()) as number[])\n        .reduce((flat, arr) => flat.concat(arr))\n    )\n  }\n\n  public async load(weightsOrUrl: Float32Array | string | undefined): Promise<void> {\n    if (weightsOrUrl instanceof Float32Array) {\n      this.extractWeights(weightsOrUrl)\n      return\n    }\n\n    await this.loadFromUri(weightsOrUrl)\n  }\n\n  public async loadFromUri(uri: string | undefined) {\n    if (uri && typeof uri !== 'string') {\n      throw new Error(`${this._name}.loadFromUri - expected model uri`)\n    }\n\n    const weightMap = await loadWeightMap(uri, this.getDefaultModelName())\n    this.loadFromWeightMap(weightMap)\n  }\n\n  public async loadFromDisk(filePath: string | undefined) {\n    if (filePath && typeof filePath !== 'string') {\n      throw new Error(`${this._name}.loadFromDisk - expected model file path`)\n    }\n\n    const { readFile } = env.getEnv()\n\n    const { manifestUri, modelBaseUri } = getModelUris(filePath, this.getDefaultModelName())\n\n    const fetchWeightsFromDisk = (filePaths: string[]) => Promise.all(\n      filePaths.map(filePath => readFile(filePath).then(buf => buf.buffer))\n    )\n    const loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk)\n    const manifest = JSON.parse((await readFile(manifestUri)).toString())\n    const weightMap = await loadWeights(manifest, modelBaseUri)\n\n    this.loadFromWeightMap(weightMap)\n  }\n\n  public loadFromWeightMap(weightMap: tf.NamedTensorMap) {\n    const {\n      paramMappings,\n      params\n    } = this.extractParamsFromWeigthMap(weightMap)\n\n    this._paramMappings = paramMappings\n    this._params = params\n  }\n\n  public extractWeights(weights: Float32Array) {\n    const {\n      paramMappings,\n      params\n    } = this.extractParams(weights)\n\n    this._paramMappings = paramMappings\n    this._params = params\n  }\n\n  private traversePropertyPath(paramPath: string) {\n    if (!this.params) {\n      throw new Error(`traversePropertyPath - model has no loaded params`)\n    }\n\n    const result = paramPath.split('/').reduce((res: { nextObj: any, obj?: any, objProp?: string }, objProp) => {\n      if (!res.nextObj.hasOwnProperty(objProp)) {\n        throw new Error(`traversePropertyPath - object does not have property ${objProp}, for path ${paramPath}`)\n      }\n\n      return { obj: res.nextObj, objProp, nextObj: res.nextObj[objProp] }\n    }, { nextObj: this.params })\n\n    const { obj, objProp } = result\n    if (!obj || !objProp || !(obj[objProp] instanceof tf.Tensor)) {\n      throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${paramPath}`)\n    }\n\n    return { obj, objProp }\n  }\n\n  protected abstract getDefaultModelName(): string\n  protected abstract extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap): { params: TNetParams, paramMappings: ParamMapping[] }\n  protected abstract extractParams(weights: Float32Array): { params: TNetParams, paramMappings: ParamMapping[] }\n}", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ConvParams, SeparableConvParams } from '../common/index';\nimport { depthwiseSeparableConv } from '../common/depthwiseSeparableConv';\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\n\nexport function denseBlock3(\n  x: tf.Tensor4D,\n  denseBlockParams: DenseBlock3Params,\n  isFirstLayer: boolean = false,\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const out1 = tf.relu(\n      isFirstLayer\n        ? tf.add(\n          tf.conv2d(x, (denseBlockParams.conv0 as ConvParams).filters, [2, 2], 'same'),\n          denseBlockParams.conv0.bias,\n        )\n        : depthwiseSeparableConv(x, denseBlockParams.conv0 as SeparableConvParams, [2, 2]),\n    ) as tf.Tensor4D;\n    const out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1]);\n\n    const in3 = tf.relu(tf.add(out1, out2)) as tf.Tensor4D;\n    const out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1]);\n\n    return tf.relu(tf.add(out1, tf.add(out2, out3))) as tf.Tensor4D;\n  });\n}\n\nexport function denseBlock4(\n  x: tf.Tensor4D,\n  denseBlockParams: DenseBlock4Params,\n  isFirstLayer: boolean = false,\n  isScaleDown: boolean = true,\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const out1 = tf.relu(\n      isFirstLayer\n        ? tf.add(\n          tf.conv2d(x, (denseBlockParams.conv0 as ConvParams).filters, isScaleDown ? [2, 2] : [1, 1], 'same'),\n          denseBlockParams.conv0.bias,\n        )\n        : depthwiseSeparableConv(x, denseBlockParams.conv0 as SeparableConvParams, isScaleDown ? [2, 2] : [1, 1]),\n    ) as tf.Tensor4D;\n    const out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1]);\n\n    const in3 = tf.relu(tf.add(out1, out2)) as tf.Tensor4D;\n    const out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1]);\n\n    const in4 = tf.relu(tf.add(out1, tf.add(out2, out3))) as tf.Tensor4D;\n    const out4 = depthwiseSeparableConv(in4, denseBlockParams.conv3, [1, 1]);\n\n    return tf.relu(tf.add(out1, tf.add(out2, tf.add(out3, out4)))) as tf.Tensor4D;\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { SeparableConvParams } from './types';\n\nexport function depthwiseSeparableConv(\n  x: tf.Tensor4D,\n  params: SeparableConvParams,\n  stride: [number, number],\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    let out = tf.separableConv2d(x, params.depthwise_filter, params.pointwise_filter, stride, 'same');\n    out = tf.add(out, params.bias);\n    return out;\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ConvParams } from './types';\n\nexport function convLayer(\n  x: tf.Tensor4D,\n  params: ConvParams,\n  padding: 'valid' | 'same' = 'same',\n  withRelu: boolean = false,\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const out = tf.add(\n      tf.conv2d(x, params.filters, [1, 1], padding),\n      params.bias,\n    ) as tf.Tensor4D;\n\n    return withRelu ? tf.relu(out) : out;\n  });\n}\n", "import { ParamMapping } from './types';\n\nexport function disposeUnusedWeightTensors(weightMap: any, paramMappings: ParamMapping[]) {\n  Object.keys(weightMap).forEach((path) => {\n    if (!paramMappings.some((pm) => pm.originalPath === path)) {\n      weightMap[path].dispose();\n    }\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ConvParams, ExtractWeightsFunction, ParamMapping } from './types';\n\nexport function extractConvParamsFactory(\n  extractWeights: ExtractWeightsFunction,\n  paramMappings: ParamMapping[],\n) {\n  return (\n    channelsIn: number,\n    channelsOut: number,\n    filterSize: number,\n    mappedPrefix: string,\n  ): ConvParams => {\n    const filters = tf.tensor4d(\n      extractWeights(channelsIn * channelsOut * filterSize * filterSize),\n      [filterSize, filterSize, channelsIn, channelsOut],\n    );\n    const bias = tf.tensor1d(extractWeights(channelsOut));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/bias` },\n    );\n\n    return { filters, bias };\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ExtractWeightsFunction, FCParams, ParamMapping } from './types';\n\nexport function extractFCParamsFactory(\n  extractWeights: ExtractWeightsFunction,\n  paramMappings: ParamMapping[],\n) {\n  return (\n    channelsIn: number,\n    channelsOut: number,\n    mappedPrefix: string,\n  ): FCParams => {\n    const fc_weights = tf.tensor2d(extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);\n    const fc_bias = tf.tensor1d(extractWeights(channelsOut));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/weights` },\n      { paramPath: `${mappedPrefix}/bias` },\n    );\n\n    return {\n      weights: fc_weights,\n      bias: fc_bias,\n    };\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ExtractWeightsFunction, ParamMapping, SeparableConvParams } from './types';\n\nexport function extractSeparableConvParamsFactory(\n  extractWeights: ExtractWeightsFunction,\n  paramMappings: ParamMapping[],\n) {\n  return (channelsIn: number, channelsOut: number, mappedPrefix: string): SeparableConvParams => {\n    const depthwise_filter = tf.tensor4d(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);\n    const pointwise_filter = tf.tensor4d(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);\n    const bias = tf.tensor1d(extractWeights(channelsOut));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/depthwise_filter` },\n      { paramPath: `${mappedPrefix}/pointwise_filter` },\n      { paramPath: `${mappedPrefix}/bias` },\n    );\n\n    return new SeparableConvParams(\n      depthwise_filter,\n      pointwise_filter,\n      bias,\n    );\n  };\n}\n\nexport function loadSeparableConvParamsFactory(\n  // eslint-disable-next-line no-unused-vars\n  extractWeightEntry: <T>(originalPath: string, paramRank: number) => T,\n) {\n  return (prefix: string): SeparableConvParams => {\n    const depthwise_filter = extractWeightEntry<tf.Tensor4D>(`${prefix}/depthwise_filter`, 4);\n    const pointwise_filter = extractWeightEntry<tf.Tensor4D>(`${prefix}/pointwise_filter`, 4);\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1);\n\n    return new SeparableConvParams(\n      depthwise_filter,\n      pointwise_filter,\n      bias,\n    );\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\n// eslint-disable-next-line no-unused-vars\nexport type ExtractWeightsFunction = (numWeights: number) => Float32Array\n\nexport type ParamMapping = {\n  originalPath?: string\n  paramPath: string\n}\n\nexport type ConvParams = {\n  filters: tf.Tensor4D\n  bias: tf.Tensor1D\n}\n\nexport type FCParams = {\n  weights: tf.Tensor2D\n  bias: tf.Tensor1D\n}\n\nexport class SeparableConvParams {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(\n    // eslint-disable-next-line no-unused-vars\n    public depthwise_filter: tf.Tensor4D,\n    // eslint-disable-next-line no-unused-vars\n    public pointwise_filter: tf.Tensor4D,\n    // eslint-disable-next-line no-unused-vars\n    public bias: tf.Tensor1D,\n  // eslint-disable-next-line no-empty-function\n  ) {}\n}\n", "import { isTensor } from '../utils/index';\nimport { ParamMapping } from './types';\n\nexport function extractWeightEntryFactory(weightMap: any, paramMappings: ParamMapping[]) {\n  return (originalPath: string, paramRank: number, mappedPath?: string) => {\n    const tensor = weightMap[originalPath];\n\n    if (!isTensor(tensor, paramRank)) {\n      throw new Error(`expected weightMap[${originalPath}] to be a Tensor${paramRank}D, instead have ${tensor}`);\n    }\n\n    paramMappings.push(\n      { originalPath, paramPath: mappedPath || originalPath },\n    );\n\n    return tensor;\n  };\n}\n", "export function extractWeightsFactory(weights: Float32Array) {\n  let remainingWeights = weights;\n\n  function extractWeights(numWeights: number): Float32Array {\n    const ret = remainingWeights.slice(0, numWeights);\n    remainingWeights = remainingWeights.slice(numWeights);\n    return ret;\n  }\n\n  function getRemainingWeights(): Float32Array {\n    return remainingWeights;\n  }\n\n  return {\n    extractWeights,\n    getRemainingWeights,\n  };\n}\n", "import {\n  extractConvParamsFactory,\n  extractSeparableConvParamsFactory,\n  ExtractWeightsFunction,\n  ParamMapping,\n} from '../common/index';\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\n\nexport function extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\n\n  function extractDenseBlock3Params(channelsIn: number, channelsOut: number, mappedPrefix: string, isFirstLayer: boolean = false): DenseBlock3Params {\n    const conv0 = isFirstLayer\n      ? extractConvParams(channelsIn, channelsOut, 3, `${mappedPrefix}/conv0`)\n      : extractSeparableConvParams(channelsIn, channelsOut, `${mappedPrefix}/conv0`);\n    const conv1 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv1`);\n    const conv2 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv2`);\n\n    return { conv0, conv1, conv2 };\n  }\n\n  function extractDenseBlock4Params(channelsIn: number, channelsOut: number, mappedPrefix: string, isFirstLayer: boolean = false): DenseBlock4Params {\n    const { conv0, conv1, conv2 } = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer);\n    const conv3 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv3`);\n\n    return {\n      conv0, conv1, conv2, conv3,\n    };\n  }\n\n  return {\n    extractDenseBlock3Params,\n    extractDenseBlock4Params,\n  };\n}\n", "import { extractWeightsFactory, ParamMapping } from '../common/index';\nimport { extractorsFactory } from './extractorsFactory';\nimport { FaceFeatureExtractorParams } from './types';\n\nexport function extractParams(weights: Float32Array): { params: FaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const {\n    extractDenseBlock4Params,\n  } = extractorsFactory(extractWeights, paramMappings);\n\n  const dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);\n  const dense1 = extractDenseBlock4Params(32, 64, 'dense1');\n  const dense2 = extractDenseBlock4Params(64, 128, 'dense2');\n  const dense3 = extractDenseBlock4Params(128, 256, 'dense3');\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return {\n    paramMappings,\n    params: {\n      dense0, dense1, dense2, dense3,\n    },\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ConvParams } from './types';\n\n// eslint-disable-next-line no-unused-vars\nexport function loadConvParamsFactory(extractWeightEntry: <T>(originalPath: string, paramRank: number) => T) {\n  return (prefix: string): ConvParams => {\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/filters`, 4);\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1);\n\n    return { filters, bias };\n  };\n}\n", "import { extractWeightEntryFactory, loadSeparableConvParamsFactory, ParamMapping } from '../common/index';\nimport { loadConvParamsFactory } from '../common/loadConvParamsFactory';\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\n\nexport function loadParamsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  const extractConvParams = loadConvParamsFactory(extractWeightEntry);\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\n\n  function extractDenseBlock3Params(prefix: string, isFirstLayer: boolean = false): DenseBlock3Params {\n    const conv0 = isFirstLayer\n      ? extractConvParams(`${prefix}/conv0`)\n      : extractSeparableConvParams(`${prefix}/conv0`);\n    const conv1 = extractSeparableConvParams(`${prefix}/conv1`);\n    const conv2 = extractSeparableConvParams(`${prefix}/conv2`);\n\n    return { conv0, conv1, conv2 };\n  }\n\n  function extractDenseBlock4Params(prefix: string, isFirstLayer: boolean = false): DenseBlock4Params {\n    const conv0 = isFirstLayer\n      ? extractConvParams(`${prefix}/conv0`)\n      : extractSeparableConvParams(`${prefix}/conv0`);\n    const conv1 = extractSeparableConvParams(`${prefix}/conv1`);\n    const conv2 = extractSeparableConvParams(`${prefix}/conv2`);\n    const conv3 = extractSeparableConvParams(`${prefix}/conv3`);\n\n    return {\n      conv0, conv1, conv2, conv3,\n    };\n  }\n\n  return {\n    extractDenseBlock3Params,\n    extractDenseBlock4Params,\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { disposeUnusedWeightTensors, ParamMapping } from '../common/index';\nimport { loadParamsFactory } from './loadParamsFactory';\nimport { FaceFeatureExtractorParams } from './types';\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n): { params: FaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractDenseBlock4Params,\n  } = loadParamsFactory(weightMap, paramMappings);\n\n  const params = {\n    dense0: extractDenseBlock4Params('dense0', true),\n    dense1: extractDenseBlock4Params('dense1'),\n    dense2: extractDenseBlock4Params('dense2'),\n    dense3: extractDenseBlock4Params('dense3'),\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { fullyConnectedLayer } from '../common/fullyConnectedLayer';\nimport { NetInput } from '../dom/index';\nimport {\n  FaceFeatureExtractorParams,\n  IFaceFeatureExtractor,\n  TinyFaceFeatureExtractorParams,\n} from '../faceFeatureExtractor/types';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { NetParams } from './types';\nimport { seperateWeightMaps } from './util';\n\nexport abstract class FaceProcessor<\n  TExtractorParams extends FaceFeatureExtractorParams | TinyFaceFeatureExtractorParams\n>\n  extends NeuralNetwork<NetParams> {\n  protected _faceFeatureExtractor: IFaceFeatureExtractor<TExtractorParams>\n\n  constructor(_name: string, faceFeatureExtractor: IFaceFeatureExtractor<TExtractorParams>) {\n    super(_name);\n    this._faceFeatureExtractor = faceFeatureExtractor;\n  }\n\n  public get faceFeatureExtractor(): IFaceFeatureExtractor<TExtractorParams> {\n    return this._faceFeatureExtractor;\n  }\n\n  protected abstract getDefaultModelName(): string\n\n  protected abstract getClassifierChannelsIn(): number\n\n  protected abstract getClassifierChannelsOut(): number\n\n  public runNet(input: NetInput | tf.Tensor4D): tf.Tensor2D {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error(`${this._name} - load model before inference`);\n    }\n\n    return tf.tidy(() => {\n      const bottleneckFeatures = input instanceof NetInput\n        ? this.faceFeatureExtractor.forwardInput(input)\n        : input;\n      return fullyConnectedLayer(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);\n    });\n  }\n\n  public dispose(throwOnRedispose: boolean = true) {\n    this.faceFeatureExtractor.dispose(throwOnRedispose);\n    super.dispose(throwOnRedispose);\n  }\n\n  public loadClassifierParams(weights: Float32Array) {\n    const { params, paramMappings } = this.extractClassifierParams(weights);\n    this._params = params;\n    this._paramMappings = paramMappings;\n  }\n\n  public extractClassifierParams(weights: Float32Array) {\n    return extractParams(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    const { featureExtractorMap, classifierMap } = seperateWeightMaps(weightMap);\n\n    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);\n\n    return extractParamsFromWeigthMap(classifierMap);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    const cIn = this.getClassifierChannelsIn();\n    const cOut = this.getClassifierChannelsOut();\n    const classifierWeightSize = (cOut * cIn) + cOut;\n\n    const featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);\n    const classifierWeights = weights.slice(weights.length - classifierWeightSize);\n\n    this.faceFeatureExtractor.extractWeights(featureExtractorWeights);\n    return this.extractClassifierParams(classifierWeights);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { FCParams } from './types';\n\nexport function fullyConnectedLayer(\n  x: tf.Tensor2D,\n  params: FCParams,\n): tf.Tensor2D {\n  return tf.tidy(() => tf.add(\n    tf.matMul(x, params.weights),\n    params.bias,\n  ));\n}\n", "import { extractFCParamsFactory, extractWeightsFactory, ParamMapping } from '../common/index';\nimport { NetParams } from './types';\n\nexport function extractParams(weights: Float32Array, channelsIn: number, channelsOut: number): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);\n\n  const fc = extractFCParams(channelsIn, channelsOut, 'fc');\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return {\n    paramMappings,\n    params: { fc },\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport {\n  disposeUnusedWeightTensors, extractWeightEntryFactory, FCParams, ParamMapping,\n} from '../common/index';\nimport { NetParams } from './types';\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  function extractFcParams(prefix: string): FCParams {\n    const weights = extractWeightEntry(`${prefix}/weights`, 2);\n    const bias = extractWeightEntry(`${prefix}/bias`, 1);\n    return { weights, bias };\n  }\n\n  const params = {\n    fc: extractFcParams('fc'),\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nexport function seperateWeightMaps(weightMap: tf.NamedTensorMap) {\n  const featureExtractorMap: tf.NamedTensorMap = {};\n  const classifierMap: tf.NamedTensorMap = {};\n\n  Object.keys(weightMap).forEach((key) => {\n    const map = key.startsWith('fc') ? classifierMap : featureExtractorMap;\n    map[key] = weightMap[key];\n  });\n\n  return { featureExtractorMap, classifierMap };\n}\n", "export const FACE_EXPRESSION_LABELS = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'];\n\nexport class FaceExpressions {\n  public neutral: number\n\n  public happy: number\n\n  public sad: number\n\n  public angry: number\n\n  public fearful: number\n\n  public disgusted: number\n\n  public surprised: number\n\n  constructor(probabilities: number[] | Float32Array) {\n    if (probabilities.length !== 7) {\n      throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${probabilities.length}`);\n    }\n\n    FACE_EXPRESSION_LABELS.forEach((expression, idx) => {\n      this[expression] = probabilities[idx];\n    });\n  }\n\n  asSortedArray() {\n    return FACE_EXPRESSION_LABELS\n      .map((expression) => ({ expression, probability: this[expression] as number }))\n      .sort((e0, e1) => e1.probability - e0.probability);\n  }\n}\n", "import { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\n\nexport type WithFaceExpressions<TSource> = TSource & {\n  expressions: FaceExpressions\n}\n\nexport function isWithFaceExpressions(obj: any): obj is WithFaceExpressions<{}> {\n  return obj.expressions instanceof FaceExpressions;\n}\n\nexport function extendWithFaceExpressions<\n  TSource\n>(\n  sourceObj: TSource,\n  expressions: FaceExpressions,\n): WithFaceExpressions<TSource> {\n  const extension = { expressions };\n  return { ...sourceObj, ...extension };\n}\n", "import { IPoint, Point } from '../classes/index';\nimport { FaceExpressions } from '../faceExpressionNet/index';\nimport { isWithFaceDetection } from '../factories/WithFaceDetection';\nimport { isWithFaceExpressions, WithFaceExpressions } from '../factories/WithFaceExpressions';\nimport { round } from '../utils/index';\nimport { DrawTextField } from './DrawTextField';\n\nexport type DrawFaceExpressionsInput = FaceExpressions | WithFaceExpressions<{}>\n\nexport function drawFaceExpressions(\n  canvasArg: string | HTMLCanvasElement,\n  faceExpressions: DrawFaceExpressionsInput | Array<DrawFaceExpressionsInput>,\n  minConfidence = 0.1,\n  textFieldAnchor?: IPoint,\n) {\n  const faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions];\n\n  faceExpressionsArray.forEach((e) => {\n    // eslint-disable-next-line no-nested-ternary\n    const expr = e instanceof FaceExpressions\n      ? e\n      : (isWithFaceExpressions(e) ? e.expressions : undefined);\n    if (!expr) {\n      throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof');\n    }\n\n    const sorted = expr.asSortedArray();\n    const resultsToDisplay = sorted.filter((exprLocal) => exprLocal.probability > minConfidence);\n\n    const anchor = isWithFaceDetection(e)\n      ? e.detection.box.bottomLeft\n      : (textFieldAnchor || new Point(0, 0));\n\n    const drawTextField = new DrawTextField(\n      resultsToDisplay.map((exprLocal) => `${exprLocal.expression} (${round(exprLocal.probability)})`),\n      anchor,\n    );\n    drawTextField.draw(canvasArg);\n  });\n}\n", "import { FaceDetection } from '../classes/FaceDetection';\nimport { FaceLandmarks } from '../classes/FaceLandmarks';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { isWithFaceDetection, WithFaceDetection } from './WithFaceDetection';\n\nexport type WithFaceLandmarks<\n  TSource extends WithFaceDetection<{}>,\n  TFaceLandmarks extends FaceLandmarks = FaceLandmarks68 > = TSource & {\n    landmarks: TFaceLandmarks\n    unshiftedLandmarks: TFaceLandmarks\n    alignedRect: FaceDetection\n  }\n\nexport function isWithFaceLandmarks(obj: any): obj is WithFaceLandmarks<WithFaceDetection<{}>, FaceLandmarks> {\n  return isWithFaceDetection(obj)\n    // eslint-disable-next-line dot-notation\n    && obj['landmarks'] instanceof FaceLandmarks\n    // eslint-disable-next-line dot-notation\n    && obj['unshiftedLandmarks'] instanceof FaceLandmarks\n    // eslint-disable-next-line dot-notation\n    && obj['alignedRect'] instanceof FaceDetection;\n}\n\nexport function extendWithFaceLandmarks<\n  TSource extends WithFaceDetection<{}>,\n  TFaceLandmarks extends FaceLandmarks = FaceLandmarks68 >(sourceObj: TSource, unshiftedLandmarks: TFaceLandmarks): WithFaceLandmarks<TSource, TFaceLandmarks> {\n  const { box: shift } = sourceObj.detection;\n  const landmarks = unshiftedLandmarks.shiftBy<TFaceLandmarks>(shift.x, shift.y);\n\n  const rect = landmarks.align();\n  const { imageDims } = sourceObj.detection;\n  const alignedRect = new FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);\n\n  const extension = {\n    landmarks,\n    unshiftedLandmarks,\n    alignedRect,\n  };\n\n  return { ...sourceObj, ...extension };\n}\n", "/* eslint-disable max-classes-per-file */\nimport { IPoint } from '../classes/index';\nimport { FaceLandmarks } from '../classes/FaceLandmarks';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { isWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { drawContour } from './drawContour';\n\nexport interface IDrawFaceLandmarksOptions {\n  drawLines?: boolean\n  drawPoints?: boolean\n  lineWidth?: number\n  pointSize?: number\n  lineColor?: string\n  pointColor?: string\n}\n\nexport class DrawFaceLandmarksOptions {\n  public drawLines: boolean\n\n  public drawPoints: boolean\n\n  public lineWidth: number\n\n  public pointSize: number\n\n  public lineColor: string\n\n  public pointColor: string\n\n  constructor(options: IDrawFaceLandmarksOptions = {}) {\n    const {\n      drawLines = true, drawPoints = true, lineWidth, lineColor, pointSize, pointColor,\n    } = options;\n    this.drawLines = drawLines;\n    this.drawPoints = drawPoints;\n    this.lineWidth = lineWidth || 1;\n    this.pointSize = pointSize || 2;\n    this.lineColor = lineColor || 'rgba(0, 255, 255, 1)';\n    this.pointColor = pointColor || 'rgba(255, 0, 255, 1)';\n  }\n}\n\nexport class DrawFaceLandmarks {\n  public faceLandmarks: FaceLandmarks\n\n  public options: DrawFaceLandmarksOptions\n\n  constructor(\n    faceLandmarks: FaceLandmarks,\n    options: IDrawFaceLandmarksOptions = {},\n  ) {\n    this.faceLandmarks = faceLandmarks;\n    this.options = new DrawFaceLandmarksOptions(options);\n  }\n\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\n    const ctx = getContext2dOrThrow(canvasArg);\n\n    const {\n      drawLines, drawPoints, lineWidth, lineColor, pointSize, pointColor,\n    } = this.options;\n\n    if (drawLines && this.faceLandmarks instanceof FaceLandmarks68) {\n      ctx.strokeStyle = lineColor;\n      ctx.lineWidth = lineWidth;\n      drawContour(ctx, this.faceLandmarks.getJawOutline());\n      drawContour(ctx, this.faceLandmarks.getLeftEyeBrow());\n      drawContour(ctx, this.faceLandmarks.getRightEyeBrow());\n      drawContour(ctx, this.faceLandmarks.getNose());\n      drawContour(ctx, this.faceLandmarks.getLeftEye(), true);\n      drawContour(ctx, this.faceLandmarks.getRightEye(), true);\n      drawContour(ctx, this.faceLandmarks.getMouth(), true);\n    }\n\n    if (drawPoints) {\n      ctx.strokeStyle = pointColor;\n      ctx.fillStyle = pointColor;\n\n      const drawPoint = (pt: IPoint) => {\n        ctx.beginPath();\n        ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI);\n        ctx.fill();\n      };\n      this.faceLandmarks.positions.forEach(drawPoint);\n    }\n  }\n}\n\nexport type DrawFaceLandmarksInput = FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>>\n\nexport function drawFaceLandmarks(\n  canvasArg: string | HTMLCanvasElement,\n  faceLandmarks: DrawFaceLandmarksInput | Array<DrawFaceLandmarksInput>,\n) {\n  const faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];\n  faceLandmarksArray.forEach((f) => {\n    // eslint-disable-next-line no-nested-ternary\n    const landmarks = f instanceof FaceLandmarks\n      ? f\n      : (isWithFaceLandmarks(f) ? f.landmarks : undefined);\n    if (!landmarks) {\n      throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof');\n    }\n\n    new DrawFaceLandmarks(landmarks).draw(canvasArg);\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { fullyConnectedLayer } from '../common/fullyConnectedLayer';\nimport { seperateWeightMaps } from '../faceProcessor/util';\nimport { TinyXception } from '../xception/TinyXception';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport {\n  AgeAndGenderPrediction, Gender, NetOutput, NetParams,\n} from './types';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\n\nexport class AgeGenderNet extends NeuralNetwork<NetParams> {\n  private _faceFeatureExtractor: TinyXception\n\n  constructor(faceFeatureExtractor: TinyXception = new TinyXception(2)) {\n    super('AgeGenderNet');\n    this._faceFeatureExtractor = faceFeatureExtractor;\n  }\n\n  public get faceFeatureExtractor(): TinyXception {\n    return this._faceFeatureExtractor;\n  }\n\n  public runNet(input: NetInput | tf.Tensor4D): NetOutput {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error(`${this._name} - load model before inference`);\n    }\n\n    return tf.tidy(() => {\n      const bottleneckFeatures = input instanceof NetInput\n        ? this.faceFeatureExtractor.forwardInput(input)\n        : input;\n\n      const pooled = tf.avgPool(bottleneckFeatures, [7, 7], [2, 2], 'valid').as2D(bottleneckFeatures.shape[0], -1);\n      const age = fullyConnectedLayer(pooled, params.fc.age).as1D();\n      const gender = fullyConnectedLayer(pooled, params.fc.gender);\n      return { age, gender };\n    });\n  }\n\n  public forwardInput(input: NetInput | tf.Tensor4D): NetOutput {\n    return tf.tidy(() => {\n      const { age, gender } = this.runNet(input);\n      return { age, gender: tf.softmax(gender) };\n    });\n  }\n\n  public async forward(input: TNetInput): Promise<NetOutput> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  public async predictAgeAndGender(input: TNetInput): Promise<AgeAndGenderPrediction | AgeAndGenderPrediction[]> {\n    const netInput = await toNetInput(input);\n    const out = await this.forwardInput(netInput);\n\n    const ages = tf.unstack(out.age);\n    const genders = tf.unstack(out.gender);\n    const ageAndGenderTensors = ages.map((ageTensor, i) => ({\n      ageTensor,\n      genderTensor: genders[i],\n    }));\n\n    const predictionsByBatch = await Promise.all(\n      ageAndGenderTensors.map(async ({ ageTensor, genderTensor }) => {\n        const age = (await ageTensor.data())[0];\n        const probMale = (await genderTensor.data())[0];\n        const isMale = probMale > 0.5;\n        const gender = isMale ? Gender.MALE : Gender.FEMALE;\n        const genderProbability = isMale ? probMale : (1 - probMale);\n\n        ageTensor.dispose();\n        genderTensor.dispose();\n        return { age, gender, genderProbability };\n      }),\n    );\n    out.age.dispose();\n    out.gender.dispose();\n\n    return netInput.isBatchInput ? predictionsByBatch as AgeAndGenderPrediction[] : predictionsByBatch[0] as AgeAndGenderPrediction;\n  }\n\n  protected getDefaultModelName(): string {\n    return 'age_gender_model';\n  }\n\n  public dispose(throwOnRedispose: boolean = true) {\n    this.faceFeatureExtractor.dispose(throwOnRedispose);\n    super.dispose(throwOnRedispose);\n  }\n\n  public loadClassifierParams(weights: Float32Array) {\n    const { params, paramMappings } = this.extractClassifierParams(weights);\n    this._params = params;\n    this._paramMappings = paramMappings;\n  }\n\n  public extractClassifierParams(weights: Float32Array) {\n    return extractParams(weights);\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    const { featureExtractorMap, classifierMap } = seperateWeightMaps(weightMap);\n\n    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);\n\n    return extractParamsFromWeigthMap(classifierMap);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    const classifierWeightSize = (512 * 1 + 1) + (512 * 2 + 2);\n\n    const featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);\n    const classifierWeights = weights.slice(weights.length - classifierWeightSize);\n\n    this.faceFeatureExtractor.extractWeights(featureExtractorWeights);\n    return this.extractClassifierParams(classifierWeights);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ConvParams, depthwiseSeparableConv } from '../common/index';\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops/index';\nimport { range } from '../utils/index';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\n\nfunction conv(x: tf.Tensor4D, params: ConvParams, stride: [number, number]): tf.Tensor4D {\n  return tf.add(tf.conv2d(x, params.filters, stride, 'same'), params.bias);\n}\n\nfunction reductionBlock(x: tf.Tensor4D, params: ReductionBlockParams, isActivateInput: boolean = true): tf.Tensor4D {\n  let out = isActivateInput ? tf.relu(x) : x;\n  out = depthwiseSeparableConv(out, params.separable_conv0, [1, 1]);\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv1, [1, 1]);\n  out = tf.maxPool(out, [3, 3], [2, 2], 'same');\n  out = tf.add(out, conv(x, params.expansion_conv, [2, 2]));\n  return out;\n}\n\nfunction mainBlock(x: tf.Tensor4D, params: MainBlockParams): tf.Tensor4D {\n  let out = depthwiseSeparableConv(tf.relu(x), params.separable_conv0, [1, 1]);\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv1, [1, 1]);\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv2, [1, 1]);\n  out = tf.add(out, x);\n  return out;\n}\n\nexport class TinyXception extends NeuralNetwork<TinyXceptionParams> {\n  private _numMainBlocks: number\n\n  constructor(numMainBlocks: number) {\n    super('TinyXception');\n    this._numMainBlocks = numMainBlocks;\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor4D {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error('TinyXception - load model before inference');\n    }\n\n    return tf.tidy(() => {\n      const batchTensor = tf.cast(input.toBatchTensor(112, true), 'float32');\n      const meanRgb = [122.782, 117.001, 104.298];\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256)) as tf.Tensor4D;\n\n      let out = tf.relu(conv(normalized, params.entry_flow.conv_in, [2, 2]));\n      out = reductionBlock(out, params.entry_flow.reduction_block_0, false);\n      out = reductionBlock(out, params.entry_flow.reduction_block_1);\n\n      range(this._numMainBlocks, 0, 1).forEach((idx) => {\n        out = mainBlock(out, params.middle_flow[`main_block_${idx}`]);\n      });\n\n      out = reductionBlock(out, params.exit_flow.reduction_block);\n      out = tf.relu(depthwiseSeparableConv(out, params.exit_flow.separable_conv, [1, 1]));\n      return out;\n    });\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  protected getDefaultModelName(): string {\n    return 'tiny_xception_model';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap, this._numMainBlocks);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights, this._numMainBlocks);\n  }\n}\n", "import { extractConvParamsFactory, extractSeparableConvParamsFactory, extractWeightsFactory } from '../common/index';\nimport { ExtractWeightsFunction, ParamMapping } from '../common/types';\nimport { range } from '../utils/index';\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\n\n  function extractReductionBlockParams(channelsIn: number, channelsOut: number, mappedPrefix: string): ReductionBlockParams {\n    const separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, `${mappedPrefix}/separable_conv0`);\n    const separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/separable_conv1`);\n    const expansion_conv = extractConvParams(channelsIn, channelsOut, 1, `${mappedPrefix}/expansion_conv`);\n\n    return { separable_conv0, separable_conv1, expansion_conv };\n  }\n\n  function extractMainBlockParams(channels: number, mappedPrefix: string): MainBlockParams {\n    const separable_conv0 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv0`);\n    const separable_conv1 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv1`);\n    const separable_conv2 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv2`);\n\n    return { separable_conv0, separable_conv1, separable_conv2 };\n  }\n\n  return {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams,\n  };\n}\n\nexport function extractParams(weights: Float32Array, numMainBlocks: number): { params: TinyXceptionParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams,\n  } = extractorsFactory(extractWeights, paramMappings);\n\n  const entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in');\n  const entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0');\n  const entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1');\n\n  const entry_flow = {\n    conv_in: entry_flow_conv_in,\n    reduction_block_0: entry_flow_reduction_block_0,\n    reduction_block_1: entry_flow_reduction_block_1,\n  };\n\n  const middle_flow = {};\n  range(numMainBlocks, 0, 1).forEach((idx) => {\n    middle_flow[`main_block_${idx}`] = extractMainBlockParams(128, `middle_flow/main_block_${idx}`);\n  });\n\n  const exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block');\n  const exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv');\n\n  const exit_flow = {\n    reduction_block: exit_flow_reduction_block,\n    separable_conv: exit_flow_separable_conv,\n  };\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return {\n    paramMappings,\n    params: { entry_flow, middle_flow, exit_flow },\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport {\n  disposeUnusedWeightTensors,\n  extractWeightEntryFactory,\n  loadSeparableConvParamsFactory,\n  ParamMapping,\n} from '../common/index';\nimport { loadConvParamsFactory } from '../common/loadConvParamsFactory';\nimport { range } from '../utils/index';\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\n\nfunction loadParamsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  const extractConvParams = loadConvParamsFactory(extractWeightEntry);\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\n\n  function extractReductionBlockParams(mappedPrefix: string): ReductionBlockParams {\n    const separable_conv0 = extractSeparableConvParams(`${mappedPrefix}/separable_conv0`);\n    const separable_conv1 = extractSeparableConvParams(`${mappedPrefix}/separable_conv1`);\n    const expansion_conv = extractConvParams(`${mappedPrefix}/expansion_conv`);\n\n    return { separable_conv0, separable_conv1, expansion_conv };\n  }\n\n  function extractMainBlockParams(mappedPrefix: string): MainBlockParams {\n    const separable_conv0 = extractSeparableConvParams(`${mappedPrefix}/separable_conv0`);\n    const separable_conv1 = extractSeparableConvParams(`${mappedPrefix}/separable_conv1`);\n    const separable_conv2 = extractSeparableConvParams(`${mappedPrefix}/separable_conv2`);\n\n    return { separable_conv0, separable_conv1, separable_conv2 };\n  }\n\n  return {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams,\n  };\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n  numMainBlocks: number,\n): { params: TinyXceptionParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams,\n  } = loadParamsFactory(weightMap, paramMappings);\n\n  const entry_flow_conv_in = extractConvParams('entry_flow/conv_in');\n  const entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0');\n  const entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1');\n\n  const entry_flow = {\n    conv_in: entry_flow_conv_in,\n    reduction_block_0: entry_flow_reduction_block_0,\n    reduction_block_1: entry_flow_reduction_block_1,\n  };\n\n  const middle_flow = {};\n  range(numMainBlocks, 0, 1).forEach((idx) => {\n    middle_flow[`main_block_${idx}`] = extractMainBlockParams(`middle_flow/main_block_${idx}`);\n  });\n\n  const exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block');\n  const exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv');\n\n  const exit_flow = {\n    reduction_block: exit_flow_reduction_block,\n    separable_conv: exit_flow_separable_conv,\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params: { entry_flow, middle_flow, exit_flow }, paramMappings };\n}\n", "import { extractFCParamsFactory, extractWeightsFactory, ParamMapping } from '../common/index';\nimport { NetParams } from './types';\n\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);\n\n  const age = extractFCParams(512, 1, 'fc/age');\n  const gender = extractFCParams(512, 2, 'fc/gender');\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return {\n    paramMappings,\n    params: { fc: { age, gender } },\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport {\n  disposeUnusedWeightTensors, extractWeightEntryFactory, FCParams, ParamMapping,\n} from '../common/index';\nimport { NetParams } from './types';\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  function extractFcParams(prefix: string): FCParams {\n    const weights = extractWeightEntry(`${prefix}/weights`, 2);\n    const bias = extractWeightEntry(`${prefix}/bias`, 1);\n    return { weights, bias };\n  }\n\n  const params = {\n    fc: {\n      age: extractFcParams('fc/age'),\n      gender: extractFcParams('fc/gender'),\n    },\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { FCParams } from '../common/index';\n\n// eslint-disable-next-line no-shadow\nexport enum Gender {\n  // eslint-disable-next-line no-unused-vars\n  FEMALE = 'female',\n  // eslint-disable-next-line no-unused-vars\n  MALE = 'male'\n}\n\nexport type AgeAndGenderPrediction = {\n  age: number\n  gender: Gender\n  genderProbability: number\n}\n\nexport type NetOutput = { age: tf.Tensor1D, gender: tf.Tensor2D }\n\nexport type NetParams = {\n  fc: {\n    age: FCParams\n    gender: FCParams\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { IDimensions, Point } from '../classes/index';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { FaceFeatureExtractorParams, TinyFaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { isEven } from '../utils/index';\n\nexport abstract class FaceLandmark68NetBase<\n  TExtractorParams extends FaceFeatureExtractorParams | TinyFaceFeatureExtractorParams\n>\n  extends FaceProcessor<TExtractorParams> {\n  public postProcess(output: tf.Tensor2D, inputSize: number, originalDimensions: IDimensions[]): tf.Tensor2D {\n    const inputDimensions = originalDimensions.map(({ width, height }) => {\n      const scale = inputSize / Math.max(height, width);\n      return {\n        width: width * scale,\n        height: height * scale,\n      };\n    });\n\n    const batchSize = inputDimensions.length;\n\n    return tf.tidy(() => {\n      const createInterleavedTensor = (fillX: number, fillY: number) => tf.stack([tf.fill([68], fillX, 'float32'), tf.fill([68], fillY, 'float32')], 1).as2D(1, 136).as1D();\n\n      // eslint-disable-next-line no-unused-vars\n      const getPadding = (batchIdx: number, cond: (w: number, h: number) => boolean): number => {\n        const { width, height } = inputDimensions[batchIdx];\n        return cond(width, height) ? Math.abs(width - height) / 2 : 0;\n      };\n\n      const getPaddingX = (batchIdx: number) => getPadding(batchIdx, (w, h) => w < h);\n      const getPaddingY = (batchIdx: number) => getPadding(batchIdx, (w, h) => h < w);\n\n      const landmarkTensors = output\n        .mul(tf.fill([batchSize, 136], inputSize, 'float32'))\n        .sub(tf.stack(Array.from(Array(batchSize), (_, batchIdx) => createInterleavedTensor(\n          getPaddingX(batchIdx),\n          getPaddingY(batchIdx),\n        ))))\n        .div(tf.stack(Array.from(Array(batchSize), (_, batchIdx) => createInterleavedTensor(\n          inputDimensions[batchIdx].width,\n          inputDimensions[batchIdx].height,\n        ))));\n\n      return landmarkTensors as tf.Tensor2D;\n    });\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor2D {\n    return tf.tidy(() => {\n      const out = this.runNet(input);\n      return this.postProcess(\n        out,\n        input.inputSize as number,\n        input.inputDimensions.map(([height, width]) => ({ height, width })),\n      );\n    });\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  public async detectLandmarks(input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> {\n    const netInput = await toNetInput(input);\n    const landmarkTensors = tf.tidy(\n      () => tf.unstack(this.forwardInput(netInput)),\n    );\n\n    const landmarksForBatch = await Promise.all(landmarkTensors.map(\n      async (landmarkTensor, batchIdx) => {\n        const landmarksArray = Array.from(await landmarkTensor.data());\n        const xCoords = landmarksArray.filter((_, i) => isEven(i));\n        const yCoords = landmarksArray.filter((_, i) => !isEven(i));\n\n        return new FaceLandmarks68(\n          Array(68).fill(0).map((_, i) => new Point(xCoords[i] as number, yCoords[i] as number)),\n          {\n            height: netInput.getInputHeight(batchIdx),\n            width: netInput.getInputWidth(batchIdx),\n          },\n        );\n      },\n    ));\n\n    landmarkTensors.forEach((t) => t.dispose());\n\n    return netInput.isBatchInput ? landmarksForBatch as FaceLandmarks68[] : landmarksForBatch[0] as FaceLandmarks68;\n  }\n\n  protected getClassifierChannelsOut(): number {\n    return 136;\n  }\n}\n", "import { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\nimport { FaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceLandmark68NetBase } from './FaceLandmark68NetBase';\n\nexport class FaceLandmark68Net extends FaceLandmark68NetBase<FaceFeatureExtractorParams> {\n  constructor(faceFeatureExtractor: FaceFeatureExtractor = new FaceFeatureExtractor()) {\n    super('FaceLandmark68Net', faceFeatureExtractor);\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_landmark_68_model';\n  }\n\n  protected getClassifierChannelsIn(): number {\n    return 256;\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops/index';\nimport { denseBlock3 } from './denseBlock';\nimport { extractParamsFromWeigthMapTiny } from './extractParamsFromWeigthMapTiny';\nimport { extractParamsTiny } from './extractParamsTiny';\nimport { IFaceFeatureExtractor, TinyFaceFeatureExtractorParams } from './types';\n\nexport class TinyFaceFeatureExtractor extends NeuralNetwork<TinyFaceFeatureExtractorParams> implements IFaceFeatureExtractor<TinyFaceFeatureExtractorParams> {\n  constructor() {\n    super('TinyFaceFeatureExtractor');\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor4D {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error('TinyFaceFeatureExtractor - load model before inference');\n    }\n\n    return tf.tidy(() => {\n      const batchTensor = tf.cast(input.toBatchTensor(112, true), 'float32');\n      const meanRgb = [122.782, 117.001, 104.298];\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(255)) as tf.Tensor4D;\n\n      let out = denseBlock3(normalized, params.dense0, true);\n      out = denseBlock3(out, params.dense1);\n      out = denseBlock3(out, params.dense2);\n      out = tf.avgPool(out, [14, 14], [2, 2], 'valid');\n\n      return out;\n    });\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_feature_extractor_tiny_model';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMapTiny(weightMap);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParamsTiny(weights);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { disposeUnusedWeightTensors, ParamMapping } from '../common/index';\nimport { loadParamsFactory } from './loadParamsFactory';\nimport { TinyFaceFeatureExtractorParams } from './types';\n\nexport function extractParamsFromWeigthMapTiny(\n  weightMap: tf.NamedTensorMap,\n): { params: TinyFaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractDenseBlock3Params,\n  } = loadParamsFactory(weightMap, paramMappings);\n\n  const params = {\n    dense0: extractDenseBlock3Params('dense0', true),\n    dense1: extractDenseBlock3Params('dense1'),\n    dense2: extractDenseBlock3Params('dense2'),\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "import { extractWeightsFactory, ParamMapping } from '../common/index';\nimport { extractorsFactory } from './extractorsFactory';\nimport { TinyFaceFeatureExtractorParams } from './types';\n\nexport function extractParamsTiny(weights: Float32Array): { params: TinyFaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const {\n    extractDenseBlock3Params,\n  } = extractorsFactory(extractWeights, paramMappings);\n\n  const dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);\n  const dense1 = extractDenseBlock3Params(32, 64, 'dense1');\n  const dense2 = extractDenseBlock3Params(64, 128, 'dense2');\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return {\n    paramMappings,\n    params: { dense0, dense1, dense2 },\n  };\n}\n", "import { TinyFaceFeatureExtractor } from '../faceFeatureExtractor/TinyFaceFeatureExtractor';\nimport { TinyFaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceLandmark68NetBase } from './FaceLandmark68NetBase';\n\nexport class FaceLandmark68TinyNet extends FaceLandmark68NetBase<TinyFaceFeatureExtractorParams> {\n  constructor(faceFeatureExtractor: TinyFaceFeatureExtractor = new TinyFaceFeatureExtractor()) {\n    super('FaceLandmark68TinyNet', faceFeatureExtractor);\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_landmark_68_tiny_model';\n  }\n\n  protected getClassifierChannelsIn(): number {\n    return 128;\n  }\n}\n", "import { FaceLandmark68Net } from './FaceLandmark68Net';\n\nexport * from './FaceLandmark68Net';\nexport * from './FaceLandmark68TinyNet';\n\nexport class FaceLandmarkNet extends FaceLandmark68Net {}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops/index';\nimport { convDown } from './convLayer';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { residual, residualDown } from './residualLayer';\nimport { NetParams } from './types';\n\nexport class FaceRecognitionNet extends NeuralNetwork<NetParams> {\n  constructor() {\n    super('FaceRecognitionNet');\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor2D {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error('FaceRecognitionNet - load model before inference');\n    }\n\n    return tf.tidy(() => {\n      // const batchTensor = input.toBatchTensor(150, true).toFloat()\n      const batchTensor = tf.cast(input.toBatchTensor(150, true), 'float32');\n\n      const meanRgb = [122.782, 117.001, 104.298];\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256)) as tf.Tensor4D;\n\n      let out = convDown(normalized, params.conv32_down);\n      out = tf.maxPool(out, 3, 2, 'valid');\n\n      out = residual(out, params.conv32_1);\n      out = residual(out, params.conv32_2);\n      out = residual(out, params.conv32_3);\n\n      out = residualDown(out, params.conv64_down);\n      out = residual(out, params.conv64_1);\n      out = residual(out, params.conv64_2);\n      out = residual(out, params.conv64_3);\n\n      out = residualDown(out, params.conv128_down);\n      out = residual(out, params.conv128_1);\n      out = residual(out, params.conv128_2);\n\n      out = residualDown(out, params.conv256_down);\n      out = residual(out, params.conv256_1);\n      out = residual(out, params.conv256_2);\n      out = residualDown(out, params.conv256_down_out);\n\n      const globalAvg = out.mean([1, 2]) as tf.Tensor2D;\n      const fullyConnected = tf.matMul(globalAvg, params.fc);\n\n      return fullyConnected;\n    });\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  public async computeFaceDescriptor(input: TNetInput): Promise<Float32Array|Float32Array[]> {\n    const netInput = await toNetInput(input);\n\n    const faceDescriptorTensors = tf.tidy(\n      () => tf.unstack(this.forwardInput(netInput)),\n    );\n\n    const faceDescriptorsForBatch = await Promise.all(faceDescriptorTensors.map(\n      (t) => t.data(),\n    )) as Float32Array[];\n\n    faceDescriptorTensors.forEach((t) => t.dispose());\n\n    return netInput.isBatchInput\n      ? faceDescriptorsForBatch\n      : faceDescriptorsForBatch[0];\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_recognition_model';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { scale } from './scaleLayer';\nimport { ConvLayerParams } from './types';\n\nfunction convLayer(\n  x: tf.Tensor4D,\n  params: ConvLayerParams,\n  strides: [number, number],\n  withRelu: boolean,\n  padding: 'valid' | 'same' = 'same',\n): tf.Tensor4D {\n  const { filters, bias } = params.conv;\n\n  let out = tf.conv2d(x, filters, strides, padding);\n  out = tf.add(out, bias);\n  out = scale(out, params.scale);\n  return withRelu ? tf.relu(out) : out;\n}\n\nexport function conv(x: tf.Tensor4D, params: ConvLayerParams) {\n  return convLayer(x, params, [1, 1], true);\n}\n\nexport function convNoRelu(x: tf.Tensor4D, params: ConvLayerParams) {\n  return convLayer(x, params, [1, 1], false);\n}\n\nexport function convDown(x: tf.Tensor4D, params: ConvLayerParams) {\n  return convLayer(x, params, [2, 2], true, 'valid');\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ScaleLayerParams } from './types';\n\nexport function scale(x: tf.Tensor4D, params: ScaleLayerParams): tf.Tensor4D {\n  return tf.add(tf.mul(x, params.weights), params.biases);\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport {\n  ConvParams, extractWeightsFactory, ExtractWeightsFunction, ParamMapping,\n} from '../common/index';\nimport { isFloat } from '../utils/index';\nimport {\n  ConvLayerParams, NetParams, ResidualLayerParams, ScaleLayerParams,\n} from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n  function extractFilterValues(numFilterValues: number, numFilters: number, filterSize: number): tf.Tensor4D {\n    const weights = extractWeights(numFilterValues);\n    const depth = weights.length / (numFilters * filterSize * filterSize);\n\n    if (isFloat(depth)) {\n      throw new Error(`depth has to be an integer: ${depth}, weights.length: ${weights.length}, numFilters: ${numFilters}, filterSize: ${filterSize}`);\n    }\n\n    return tf.tidy(\n      () => tf.transpose(\n        tf.tensor4d(weights, [numFilters, depth, filterSize, filterSize]),\n        [2, 3, 1, 0],\n      ),\n    );\n  }\n\n  function extractConvParams(\n    numFilterValues: number,\n    numFilters: number,\n    filterSize: number,\n    mappedPrefix: string,\n  ): ConvParams {\n    const filters = extractFilterValues(numFilterValues, numFilters, filterSize);\n    const bias = tf.tensor1d(extractWeights(numFilters));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/bias` },\n    );\n\n    return { filters, bias };\n  }\n\n  function extractScaleLayerParams(numWeights: number, mappedPrefix: string): ScaleLayerParams {\n    const weights = tf.tensor1d(extractWeights(numWeights));\n    const biases = tf.tensor1d(extractWeights(numWeights));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/weights` },\n      { paramPath: `${mappedPrefix}/biases` },\n    );\n\n    return {\n      weights,\n      biases,\n    };\n  }\n\n  function extractConvLayerParams(\n    numFilterValues: number,\n    numFilters: number,\n    filterSize: number,\n    mappedPrefix: string,\n  ): ConvLayerParams {\n    const conv = extractConvParams(numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv`);\n    const scale = extractScaleLayerParams(numFilters, `${mappedPrefix}/scale`);\n\n    return { conv, scale };\n  }\n\n  function extractResidualLayerParams(\n    numFilterValues: number,\n    numFilters: number,\n    filterSize: number,\n    mappedPrefix: string,\n    isDown: boolean = false,\n  ): ResidualLayerParams {\n    const conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv1`);\n    const conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv2`);\n\n    return { conv1, conv2 };\n  }\n\n  return {\n    extractConvLayerParams,\n    extractResidualLayerParams,\n  };\n}\n\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractConvLayerParams,\n    extractResidualLayerParams,\n  } = extractorsFactory(extractWeights, paramMappings);\n\n  const conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');\n  const conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');\n  const conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');\n  const conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');\n\n  const conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);\n  const conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');\n  const conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');\n  const conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');\n\n  const conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);\n  const conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');\n  const conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');\n\n  const conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);\n  const conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');\n  const conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');\n  const conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');\n\n  const fc = tf.tidy(\n    () => tf.transpose(tf.tensor2d(extractWeights(256 * 128), [128, 256]), [1, 0]),\n  );\n  paramMappings.push({ paramPath: 'fc' });\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  const params = {\n    conv32_down,\n    conv32_1,\n    conv32_2,\n    conv32_3,\n    conv64_down,\n    conv64_1,\n    conv64_2,\n    conv64_3,\n    conv128_down,\n    conv128_1,\n    conv128_2,\n    conv256_down,\n    conv256_1,\n    conv256_2,\n    conv256_down_out,\n    fc,\n  };\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { disposeUnusedWeightTensors, extractWeightEntryFactory, ParamMapping } from '../common/index';\nimport { isTensor2D } from '../utils/index';\nimport {\n  ConvLayerParams, NetParams, ResidualLayerParams, ScaleLayerParams,\n} from './types';\n\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  function extractScaleLayerParams(prefix: string): ScaleLayerParams {\n    const weights = extractWeightEntry(`${prefix}/scale/weights`, 1);\n    const biases = extractWeightEntry(`${prefix}/scale/biases`, 1);\n\n    return { weights, biases };\n  }\n\n  function extractConvLayerParams(prefix: string): ConvLayerParams {\n    const filters = extractWeightEntry(`${prefix}/conv/filters`, 4);\n    const bias = extractWeightEntry(`${prefix}/conv/bias`, 1);\n    const scale = extractScaleLayerParams(prefix);\n\n    return { conv: { filters, bias }, scale };\n  }\n\n  function extractResidualLayerParams(prefix: string): ResidualLayerParams {\n    return {\n      conv1: extractConvLayerParams(`${prefix}/conv1`),\n      conv2: extractConvLayerParams(`${prefix}/conv2`),\n    };\n  }\n\n  return {\n    extractConvLayerParams,\n    extractResidualLayerParams,\n  };\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractConvLayerParams,\n    extractResidualLayerParams,\n  } = extractorsFactory(weightMap, paramMappings);\n\n  const conv32_down = extractConvLayerParams('conv32_down');\n  const conv32_1 = extractResidualLayerParams('conv32_1');\n  const conv32_2 = extractResidualLayerParams('conv32_2');\n  const conv32_3 = extractResidualLayerParams('conv32_3');\n\n  const conv64_down = extractResidualLayerParams('conv64_down');\n  const conv64_1 = extractResidualLayerParams('conv64_1');\n  const conv64_2 = extractResidualLayerParams('conv64_2');\n  const conv64_3 = extractResidualLayerParams('conv64_3');\n\n  const conv128_down = extractResidualLayerParams('conv128_down');\n  const conv128_1 = extractResidualLayerParams('conv128_1');\n  const conv128_2 = extractResidualLayerParams('conv128_2');\n\n  const conv256_down = extractResidualLayerParams('conv256_down');\n  const conv256_1 = extractResidualLayerParams('conv256_1');\n  const conv256_2 = extractResidualLayerParams('conv256_2');\n  const conv256_down_out = extractResidualLayerParams('conv256_down_out');\n\n  const { fc } = weightMap;\n  paramMappings.push({ originalPath: 'fc', paramPath: 'fc' });\n\n  if (!isTensor2D(fc)) {\n    throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${fc}`);\n  }\n\n  const params = {\n    conv32_down,\n    conv32_1,\n    conv32_2,\n    conv32_3,\n    conv64_down,\n    conv64_1,\n    conv64_2,\n    conv64_3,\n    conv128_down,\n    conv128_1,\n    conv128_2,\n    conv256_down,\n    conv256_1,\n    conv256_2,\n    conv256_down_out,\n    fc,\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { conv, convDown, convNoRelu } from './convLayer';\nimport { ResidualLayerParams } from './types';\n\nexport function residual(x: tf.Tensor4D, params: ResidualLayerParams): tf.Tensor4D {\n  let out = conv(x, params.conv1);\n  out = convNoRelu(out, params.conv2);\n  out = tf.add(out, x);\n  out = tf.relu(out);\n  return out;\n}\n\nexport function residualDown(x: tf.Tensor4D, params: ResidualLayerParams): tf.Tensor4D {\n  let out = convDown(x, params.conv1);\n  out = convNoRelu(out, params.conv2);\n\n  let pooled = tf.avgPool(x, 2, 2, 'valid') as tf.Tensor4D;\n  const zeros = tf.zeros<tf.Rank.R4>(pooled.shape);\n  const isPad = pooled.shape[3] !== out.shape[3];\n  const isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];\n\n  if (isAdjustShape) {\n    const padShapeX = [...out.shape] as [number, number, number, number];\n    padShapeX[1] = 1;\n    const zerosW = tf.zeros<tf.Rank.R4>(padShapeX);\n    out = tf.concat([out, zerosW], 1);\n\n    const padShapeY = [...out.shape] as [number, number, number, number];\n    padShapeY[2] = 1;\n    const zerosH = tf.zeros<tf.Rank.R4>(padShapeY);\n    out = tf.concat([out, zerosH], 2);\n  }\n\n  pooled = isPad ? tf.concat([pooled, zeros], 3) : pooled;\n  out = tf.add(pooled, out) as tf.Tensor4D;\n\n  out = tf.relu(out);\n  return out;\n}\n", "import { FaceRecognitionNet } from './FaceRecognitionNet';\n\nexport * from './FaceRecognitionNet';\n\nexport function createFaceRecognitionNet(weights: Float32Array) {\n  const net = new FaceRecognitionNet();\n  net.extractWeights(weights);\n  return net;\n}\n", "export type WithFaceDescriptor<TSource> = TSource & {\n  descriptor: Float32Array\n}\n\nexport function extendWithFaceDescriptor<\n  TSource\n>(\n  sourceObj: TSource,\n  descriptor: Float32Array,\n): WithFaceDescriptor<TSource> {\n  const extension = { descriptor };\n  return { ...sourceObj, ...extension };\n}\n", "export type WithAge<TSource> = TSource & {\n  age: number\n}\n\nexport function isWithAge(obj: any): obj is WithAge<{}> {\n  return typeof obj.age === 'number';\n}\n\nexport function extendWithAge<\n  TSource\n>(\n  sourceObj: TSource,\n  age: number,\n): WithAge<TSource> {\n  const extension = { age };\n  return { ...sourceObj, ...extension };\n}\n", "import { Gender } from '../ageGenderNet/types';\nimport { isValidProbablitiy } from '../utils/index';\n\nexport type WithGender<TSource> = TSource & {\n  gender: Gender\n  genderProbability: number\n}\n\nexport function isWithGender(obj: any): obj is WithGender<{}> {\n  return (obj.gender === Gender.MALE || obj.gender === Gender.FEMALE)\n    && isValidProbablitiy(obj.genderProbability);\n}\n\nexport function extendWithGender<\n  TSource\n>(\n  sourceObj: TSource,\n  gender: Gender,\n  genderProbability: number,\n): WithGender<TSource> {\n  const extension = { gender, genderProbability };\n  return { ...sourceObj, ...extension };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { Rect } from '../classes/index';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { mobileNetV1 } from './mobileNetV1';\nimport { nonMaxSuppression } from './nonMaxSuppression';\nimport { outputLayer } from './outputLayer';\nimport { predictionLayer } from './predictionLayer';\nimport { ISsdMobilenetv1Options, SsdMobilenetv1Options } from './SsdMobilenetv1Options';\nimport { NetParams } from './types';\n\nexport class SsdMobilenetv1 extends NeuralNetwork<NetParams> {\n  constructor() {\n    super('SsdMobilenetv1');\n  }\n\n  public forwardInput(input: NetInput) {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error('SsdMobilenetv1 - load model before inference');\n    }\n\n    return tf.tidy(() => {\n      // const batchTensor = input.toBatchTensor(512, false).toFloat()\n      const batchTensor = tf.cast(input.toBatchTensor(512, false), 'float32');\n\n      const x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1)) as tf.Tensor4D;\n      const features = mobileNetV1(x, params.mobilenetv1);\n\n      const {\n        boxPredictions,\n        classPredictions,\n      } = predictionLayer(features.out, features.conv11, params.prediction_layer);\n\n      return outputLayer(boxPredictions, classPredictions, params.output_layer);\n    });\n  }\n\n  public async forward(input: TNetInput) {\n    return this.forwardInput(await toNetInput(input));\n  }\n\n  public async locateFaces(\n    input: TNetInput,\n    options: ISsdMobilenetv1Options = {},\n  ): Promise<FaceDetection[]> {\n    const { maxResults, minConfidence } = new SsdMobilenetv1Options(options);\n\n    const netInput = await toNetInput(input);\n\n    const {\n      boxes: _boxes,\n      scores: _scores,\n    } = this.forwardInput(netInput);\n\n    // TODO batches\n    const boxes = _boxes[0];\n    const scores = _scores[0];\n    for (let i = 1; i < _boxes.length; i++) {\n      _boxes[i].dispose();\n      _scores[i].dispose();\n    }\n\n    // TODO find a better way to filter by minConfidence\n    const scoresData = Array.from(await scores.data());\n\n    const iouThreshold = 0.5;\n    const indices = nonMaxSuppression(\n      boxes,\n      scoresData as number[],\n      maxResults,\n      iouThreshold,\n      minConfidence,\n    );\n\n    const reshapedDims = netInput.getReshapedInputDimensions(0);\n    const inputSize = netInput.inputSize as number;\n    const padX = inputSize / reshapedDims.width;\n    const padY = inputSize / reshapedDims.height;\n\n    const boxesData = boxes.arraySync();\n    const results = indices\n      .map((idx) => {\n        const [top, bottom] = [\n          Math.max(0, boxesData[idx][0]),\n          Math.min(1.0, boxesData[idx][2]),\n        ].map((val) => val * padY);\n        const [left, right] = [\n          Math.max(0, boxesData[idx][1]),\n          Math.min(1.0, boxesData[idx][3]),\n        ].map((val) => val * padX);\n        return new FaceDetection(\n          scoresData[idx] as number,\n          new Rect(\n            left,\n            top,\n            right - left,\n            bottom - top,\n          ),\n          {\n            height: netInput.getInputHeight(0),\n            width: netInput.getInputWidth(0),\n          },\n        );\n      });\n\n    boxes.dispose();\n    scores.dispose();\n\n    return results;\n  }\n\n  protected getDefaultModelName(): string {\n    return 'ssd_mobilenetv1_model';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport {\n  ExtractWeightsFunction, ParamMapping, ConvParams, extractWeightsFactory,\n} from '../common/index';\nimport {\n  MobileNetV1, NetParams, PointwiseConvParams, PredictionLayerParams,\n} from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n  function extractDepthwiseConvParams(numChannels: number, mappedPrefix: string): MobileNetV1.DepthwiseConvParams {\n    const filters = tf.tensor4d(extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);\n    const batch_norm_scale = tf.tensor1d(extractWeights(numChannels));\n    const batch_norm_offset = tf.tensor1d(extractWeights(numChannels));\n    const batch_norm_mean = tf.tensor1d(extractWeights(numChannels));\n    const batch_norm_variance = tf.tensor1d(extractWeights(numChannels));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/batch_norm_scale` },\n      { paramPath: `${mappedPrefix}/batch_norm_offset` },\n      { paramPath: `${mappedPrefix}/batch_norm_mean` },\n      { paramPath: `${mappedPrefix}/batch_norm_variance` },\n    );\n\n    return {\n      filters,\n      batch_norm_scale,\n      batch_norm_offset,\n      batch_norm_mean,\n      batch_norm_variance,\n    };\n  }\n\n  function extractConvParams(\n    channelsIn: number,\n    channelsOut: number,\n    filterSize: number,\n    mappedPrefix: string,\n    isPointwiseConv?: boolean,\n  ): ConvParams {\n    const filters = tf.tensor4d(\n      extractWeights(channelsIn * channelsOut * filterSize * filterSize),\n      [filterSize, filterSize, channelsIn, channelsOut],\n    );\n    const bias = tf.tensor1d(extractWeights(channelsOut));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/${isPointwiseConv ? 'batch_norm_offset' : 'bias'}` },\n    );\n\n    return { filters, bias };\n  }\n\n  function extractPointwiseConvParams(\n    channelsIn: number,\n    channelsOut: number,\n    filterSize: number,\n    mappedPrefix: string,\n  ): PointwiseConvParams {\n    const {\n      filters,\n      bias,\n    } = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true);\n\n    return {\n      filters,\n      batch_norm_offset: bias,\n    };\n  }\n\n  function extractConvPairParams(\n    channelsIn: number,\n    channelsOut: number,\n    mappedPrefix: string,\n  ): MobileNetV1.ConvPairParams {\n    const depthwise_conv = extractDepthwiseConvParams(channelsIn, `${mappedPrefix}/depthwise_conv`);\n    const pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, `${mappedPrefix}/pointwise_conv`);\n\n    return { depthwise_conv, pointwise_conv };\n  }\n\n  function extractMobilenetV1Params(): MobileNetV1.Params {\n    const conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');\n\n    const conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');\n    const conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');\n    const conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');\n    const conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');\n    const conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');\n    const conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');\n    const conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');\n    const conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');\n    const conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');\n    const conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');\n    const conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');\n    const conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');\n    const conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');\n\n    return {\n      conv_0,\n      conv_1,\n      conv_2,\n      conv_3,\n      conv_4,\n      conv_5,\n      conv_6,\n      conv_7,\n      conv_8,\n      conv_9,\n      conv_10,\n      conv_11,\n      conv_12,\n      conv_13,\n    };\n  }\n\n  function extractPredictionLayerParams(): PredictionLayerParams {\n    const conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');\n    const conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');\n    const conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');\n    const conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');\n    const conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');\n    const conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');\n    const conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');\n    const conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');\n\n    const box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');\n    const class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');\n    const box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');\n    const class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');\n    const box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');\n    const class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');\n    const box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');\n    const class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');\n    const box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');\n    const class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');\n    const box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');\n    const class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');\n\n    const box_predictor_0 = {\n      box_encoding_predictor: box_encoding_0_predictor,\n      class_predictor: class_predictor_0,\n    };\n    const box_predictor_1 = {\n      box_encoding_predictor: box_encoding_1_predictor,\n      class_predictor: class_predictor_1,\n    };\n    const box_predictor_2 = {\n      box_encoding_predictor: box_encoding_2_predictor,\n      class_predictor: class_predictor_2,\n    };\n    const box_predictor_3 = {\n      box_encoding_predictor: box_encoding_3_predictor,\n      class_predictor: class_predictor_3,\n    };\n    const box_predictor_4 = {\n      box_encoding_predictor: box_encoding_4_predictor,\n      class_predictor: class_predictor_4,\n    };\n    const box_predictor_5 = {\n      box_encoding_predictor: box_encoding_5_predictor,\n      class_predictor: class_predictor_5,\n    };\n\n    return {\n      conv_0,\n      conv_1,\n      conv_2,\n      conv_3,\n      conv_4,\n      conv_5,\n      conv_6,\n      conv_7,\n      box_predictor_0,\n      box_predictor_1,\n      box_predictor_2,\n      box_predictor_3,\n      box_predictor_4,\n      box_predictor_5,\n    };\n  }\n\n  return {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams,\n  };\n}\n\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams,\n  } = extractorsFactory(extractWeights, paramMappings);\n\n  const mobilenetv1 = extractMobilenetV1Params();\n  const prediction_layer = extractPredictionLayerParams();\n  const extra_dim = tf.tensor3d(\n    extractWeights(5118 * 4),\n    [1, 5118, 4],\n  );\n  const output_layer = {\n    extra_dim,\n  };\n\n  paramMappings.push({ paramPath: 'output_layer/extra_dim' });\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return {\n    params: {\n      mobilenetv1,\n      prediction_layer,\n      output_layer,\n    },\n    paramMappings,\n  };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport {\n  ConvParams, disposeUnusedWeightTensors, extractWeightEntryFactory, ParamMapping,\n} from '../common/index';\nimport { isTensor3D } from '../utils/index';\nimport {\n  BoxPredictionParams, MobileNetV1, NetParams, PointwiseConvParams, PredictionLayerParams,\n} from './types';\n\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  function extractPointwiseConvParams(prefix: string, idx: number, mappedPrefix: string): PointwiseConvParams {\n    const filters = extractWeightEntry(`${prefix}/Conv2d_${idx}_pointwise/weights`, 4, `${mappedPrefix}/filters`);\n    const batch_norm_offset = extractWeightEntry(`${prefix}/Conv2d_${idx}_pointwise/convolution_bn_offset`, 1, `${mappedPrefix}/batch_norm_offset`);\n\n    return { filters, batch_norm_offset };\n  }\n\n  function extractConvPairParams(idx: number): MobileNetV1.ConvPairParams {\n    const mappedPrefix = `mobilenetv1/conv_${idx}`;\n    const prefixDepthwiseConv = `MobilenetV1/Conv2d_${idx}_depthwise`;\n    const mappedPrefixDepthwiseConv = `${mappedPrefix}/depthwise_conv`;\n    const mappedPrefixPointwiseConv = `${mappedPrefix}/pointwise_conv`;\n\n    const filters = extractWeightEntry(`${prefixDepthwiseConv}/depthwise_weights`, 4, `${mappedPrefixDepthwiseConv}/filters`);\n    const batch_norm_scale = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/gamma`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_scale`);\n    const batch_norm_offset = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/beta`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_offset`);\n    const batch_norm_mean = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/moving_mean`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_mean`);\n    const batch_norm_variance = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/moving_variance`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_variance`);\n\n    return {\n      depthwise_conv: {\n        filters,\n        batch_norm_scale,\n        batch_norm_offset,\n        batch_norm_mean,\n        batch_norm_variance,\n      },\n      pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv),\n    };\n  }\n\n  function extractMobilenetV1Params(): MobileNetV1.Params {\n    return {\n      conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),\n      conv_1: extractConvPairParams(1),\n      conv_2: extractConvPairParams(2),\n      conv_3: extractConvPairParams(3),\n      conv_4: extractConvPairParams(4),\n      conv_5: extractConvPairParams(5),\n      conv_6: extractConvPairParams(6),\n      conv_7: extractConvPairParams(7),\n      conv_8: extractConvPairParams(8),\n      conv_9: extractConvPairParams(9),\n      conv_10: extractConvPairParams(10),\n      conv_11: extractConvPairParams(11),\n      conv_12: extractConvPairParams(12),\n      conv_13: extractConvPairParams(13),\n    };\n  }\n\n  function extractConvParams(prefix: string, mappedPrefix: string): ConvParams {\n    const filters = extractWeightEntry(`${prefix}/weights`, 4, `${mappedPrefix}/filters`);\n    const bias = extractWeightEntry(`${prefix}/biases`, 1, `${mappedPrefix}/bias`);\n\n    return { filters, bias };\n  }\n\n  function extractBoxPredictorParams(idx: number): BoxPredictionParams {\n    const box_encoding_predictor = extractConvParams(\n      `Prediction/BoxPredictor_${idx}/BoxEncodingPredictor`,\n      `prediction_layer/box_predictor_${idx}/box_encoding_predictor`,\n    );\n    const class_predictor = extractConvParams(\n      `Prediction/BoxPredictor_${idx}/ClassPredictor`,\n      `prediction_layer/box_predictor_${idx}/class_predictor`,\n    );\n\n    return { box_encoding_predictor, class_predictor };\n  }\n\n  function extractPredictionLayerParams(): PredictionLayerParams {\n    return {\n      conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),\n      conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),\n      conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),\n      conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),\n      conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),\n      conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),\n      conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),\n      conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),\n      box_predictor_0: extractBoxPredictorParams(0),\n      box_predictor_1: extractBoxPredictorParams(1),\n      box_predictor_2: extractBoxPredictorParams(2),\n      box_predictor_3: extractBoxPredictorParams(3),\n      box_predictor_4: extractBoxPredictorParams(4),\n      box_predictor_5: extractBoxPredictorParams(5),\n    };\n  }\n\n  return {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams,\n  };\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n): { params: NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams,\n  } = extractorsFactory(weightMap, paramMappings);\n\n  const extra_dim = weightMap['Output/extra_dim'];\n  paramMappings.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' });\n\n  if (!isTensor3D(extra_dim)) {\n    throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${extra_dim}`);\n  }\n\n  const params = {\n    mobilenetv1: extractMobilenetV1Params(),\n    prediction_layer: extractPredictionLayerParams(),\n    output_layer: {\n      extra_dim,\n    },\n  };\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { pointwiseConvLayer } from './pointwiseConvLayer';\nimport { MobileNetV1 } from './types';\n\nconst epsilon = 0.0010000000474974513;\n\nfunction depthwiseConvLayer(\n  x: tf.Tensor4D,\n  params: MobileNetV1.DepthwiseConvParams,\n  strides: [number, number],\n) {\n  return tf.tidy(() => {\n    let out = tf.depthwiseConv2d(x, params.filters, strides, 'same');\n    out = tf.batchNorm<tf.Rank.R4>(\n      out,\n      params.batch_norm_mean,\n      params.batch_norm_variance,\n      params.batch_norm_offset,\n      params.batch_norm_scale,\n      epsilon,\n    );\n    return tf.clipByValue(out, 0, 6);\n  });\n}\n\nfunction getStridesForLayerIdx(layerIdx: number): [number, number] {\n  return [2, 4, 6, 12].some((idx) => idx === layerIdx) ? [2, 2] : [1, 1];\n}\n\nexport function mobileNetV1(x: tf.Tensor4D, params: MobileNetV1.Params) {\n  return tf.tidy(() => {\n    let conv11;\n    let out = pointwiseConvLayer(x, params.conv_0, [2, 2]);\n\n    const convPairParams = [\n      params.conv_1,\n      params.conv_2,\n      params.conv_3,\n      params.conv_4,\n      params.conv_5,\n      params.conv_6,\n      params.conv_7,\n      params.conv_8,\n      params.conv_9,\n      params.conv_10,\n      params.conv_11,\n      params.conv_12,\n      params.conv_13,\n    ];\n\n    convPairParams.forEach((param, i) => {\n      const layerIdx = i + 1;\n      const depthwiseConvStrides = getStridesForLayerIdx(layerIdx);\n      out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);\n      out = pointwiseConvLayer(out, param.pointwise_conv, [1, 1]);\n      if (layerIdx === 11) {\n        conv11 = out;\n      }\n    });\n\n    if (conv11 === null) {\n      throw new Error('mobileNetV1 - output of conv layer 11 is null');\n    }\n\n    return {\n      out,\n      conv11: conv11 as any,\n    };\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { PointwiseConvParams } from './types';\n\nexport function pointwiseConvLayer(\n  x: tf.Tensor4D,\n  params: PointwiseConvParams,\n  strides: [number, number],\n) {\n  return tf.tidy(() => {\n    let out = tf.conv2d(x, params.filters, strides, 'same');\n    out = tf.add(out, params.batch_norm_offset);\n    return tf.clipByValue(out, 0, 6);\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nfunction IOU(boxes: tf.Tensor2D, i: number, j: number) {\n  const boxesData = boxes.arraySync();\n  const yminI = Math.min(boxesData[i][0], boxesData[i][2]);\n  const xminI = Math.min(boxesData[i][1], boxesData[i][3]);\n  const ymaxI = Math.max(boxesData[i][0], boxesData[i][2]);\n  const xmaxI = Math.max(boxesData[i][1], boxesData[i][3]);\n  const yminJ = Math.min(boxesData[j][0], boxesData[j][2]);\n  const xminJ = Math.min(boxesData[j][1], boxesData[j][3]);\n  const ymaxJ = Math.max(boxesData[j][0], boxesData[j][2]);\n  const xmaxJ = Math.max(boxesData[j][1], boxesData[j][3]);\n  const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n  if (areaI <= 0 || areaJ <= 0) {\n    return 0.0;\n  }\n  const intersectionYmin = Math.max(yminI, yminJ);\n  const intersectionXmin = Math.max(xminI, xminJ);\n  const intersectionYmax = Math.min(ymaxI, ymaxJ);\n  const intersectionXmax = Math.min(xmaxI, xmaxJ);\n  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0)\n      * Math.max(intersectionXmax - intersectionXmin, 0.0);\n  return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n\nexport function nonMaxSuppression(\n  boxes: tf.Tensor2D,\n  scores: number[],\n  maxOutputSize: number,\n  iouThreshold: number,\n  scoreThreshold: number,\n): number[] {\n  const numBoxes = boxes.shape[0];\n  const outputSize = Math.min(\n    maxOutputSize,\n    numBoxes,\n  );\n\n  const candidates = scores\n    .map((score, boxIndex) => ({ score, boxIndex }))\n    .filter((c) => c.score > scoreThreshold)\n    .sort((c1, c2) => c2.score - c1.score);\n\n  const suppressFunc = (x: number) => (x <= iouThreshold ? 1 : 0);\n\n  const selected: number[] = [];\n\n  candidates.forEach((c) => {\n    if (selected.length >= outputSize) {\n      return;\n    }\n    const originalScore = c.score;\n\n    for (let j = selected.length - 1; j >= 0; --j) {\n      const iou = IOU(boxes, c.boxIndex, selected[j]);\n      if (iou === 0.0) continue;\n      c.score *= suppressFunc(iou);\n      if (c.score <= scoreThreshold) break;\n    }\n    if (originalScore === c.score) {\n      selected.push(c.boxIndex);\n    }\n  });\n\n  return selected;\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { OutputLayerParams } from './types';\n\nfunction getCenterCoordinatesAndSizesLayer(x: tf.Tensor2D) {\n  const vec = tf.unstack(tf.transpose(x, [1, 0]));\n\n  const sizes = [\n    tf.sub(vec[2], vec[0]),\n    tf.sub(vec[3], vec[1]),\n  ];\n\n  const centers = [\n    tf.add(vec[0], tf.div(sizes[0], tf.scalar(2))),\n    tf.add(vec[1], tf.div(sizes[1], tf.scalar(2))),\n  ];\n\n  return {\n    sizes,\n    centers,\n  };\n}\n\nfunction decodeBoxesLayer(x0: tf.Tensor2D, x1: tf.Tensor2D) {\n  const {\n    sizes,\n    centers,\n  } = getCenterCoordinatesAndSizesLayer(x0);\n\n  const vec = tf.unstack(tf.transpose(x1, [1, 0]));\n\n  const div0_out = tf.div(tf.mul(tf.exp(tf.div(vec[2], tf.scalar(5))), sizes[0]), tf.scalar(2));\n  const add0_out = tf.add(tf.mul(tf.div(vec[0], tf.scalar(10)), sizes[0]), centers[0]);\n\n  const div1_out = tf.div(tf.mul(tf.exp(tf.div(vec[3], tf.scalar(5))), sizes[1]), tf.scalar(2));\n  const add1_out = tf.add(tf.mul(tf.div(vec[1], tf.scalar(10)), sizes[1]), centers[1]);\n\n  return tf.transpose(\n    tf.stack([\n      tf.sub(add0_out, div0_out),\n      tf.sub(add1_out, div1_out),\n      tf.add(add0_out, div0_out),\n      tf.add(add1_out, div1_out),\n    ]),\n    [1, 0],\n  );\n}\n\nexport function outputLayer(\n  boxPredictions: tf.Tensor4D,\n  classPredictions: tf.Tensor4D,\n  params: OutputLayerParams,\n) {\n  return tf.tidy(() => {\n    const batchSize = boxPredictions.shape[0];\n\n    let boxes = decodeBoxesLayer(\n      tf.reshape(tf.tile(params.extra_dim, [batchSize, 1, 1]), [-1, 4]) as tf.Tensor2D,\n      tf.reshape(boxPredictions, [-1, 4]) as tf.Tensor2D,\n    );\n    boxes = tf.reshape(\n      boxes,\n      [batchSize, (boxes.shape[0] / batchSize), 4],\n    );\n\n    const scoresAndClasses = tf.sigmoid(tf.slice(classPredictions, [0, 0, 1], [-1, -1, -1]));\n    let scores = tf.slice(scoresAndClasses, [0, 0, 0], [-1, -1, 1]) as tf.Tensor;\n\n    scores = tf.reshape(\n      scores,\n      [batchSize, scores.shape[1] as number],\n    );\n\n    const boxesByBatch = tf.unstack(boxes) as tf.Tensor2D[];\n    const scoresByBatch = tf.unstack(scores) as tf.Tensor1D[];\n\n    return {\n      boxes: boxesByBatch,\n      scores: scoresByBatch,\n    };\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { boxPredictionLayer } from './boxPredictionLayer';\nimport { pointwiseConvLayer } from './pointwiseConvLayer';\nimport { PredictionLayerParams } from './types';\n\nexport function predictionLayer(\n  x: tf.Tensor4D,\n  conv11: tf.Tensor4D,\n  params: PredictionLayerParams,\n) {\n  return tf.tidy(() => {\n    const conv0 = pointwiseConvLayer(x, params.conv_0, [1, 1]);\n    const conv1 = pointwiseConvLayer(conv0, params.conv_1, [2, 2]);\n    const conv2 = pointwiseConvLayer(conv1, params.conv_2, [1, 1]);\n    const conv3 = pointwiseConvLayer(conv2, params.conv_3, [2, 2]);\n    const conv4 = pointwiseConvLayer(conv3, params.conv_4, [1, 1]);\n    const conv5 = pointwiseConvLayer(conv4, params.conv_5, [2, 2]);\n    const conv6 = pointwiseConvLayer(conv5, params.conv_6, [1, 1]);\n    const conv7 = pointwiseConvLayer(conv6, params.conv_7, [2, 2]);\n\n    const boxPrediction0 = boxPredictionLayer(conv11, params.box_predictor_0);\n    const boxPrediction1 = boxPredictionLayer(x, params.box_predictor_1);\n    const boxPrediction2 = boxPredictionLayer(conv1, params.box_predictor_2);\n    const boxPrediction3 = boxPredictionLayer(conv3, params.box_predictor_3);\n    const boxPrediction4 = boxPredictionLayer(conv5, params.box_predictor_4);\n    const boxPrediction5 = boxPredictionLayer(conv7, params.box_predictor_5);\n\n    const boxPredictions = tf.concat([\n      boxPrediction0.boxPredictionEncoding,\n      boxPrediction1.boxPredictionEncoding,\n      boxPrediction2.boxPredictionEncoding,\n      boxPrediction3.boxPredictionEncoding,\n      boxPrediction4.boxPredictionEncoding,\n      boxPrediction5.boxPredictionEncoding,\n    ], 1) as tf.Tensor4D;\n\n    const classPredictions = tf.concat([\n      boxPrediction0.classPrediction,\n      boxPrediction1.classPrediction,\n      boxPrediction2.classPrediction,\n      boxPrediction3.classPrediction,\n      boxPrediction4.classPrediction,\n      boxPrediction5.classPrediction,\n    ], 1) as tf.Tensor4D;\n\n    return {\n      boxPredictions,\n      classPredictions,\n    };\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { convLayer } from '../common/index';\nimport { BoxPredictionParams } from './types';\n\nexport function boxPredictionLayer(\n  x: tf.Tensor4D,\n  params: BoxPredictionParams,\n) {\n  return tf.tidy(() => {\n    const batchSize = x.shape[0];\n\n    const boxPredictionEncoding = tf.reshape(\n      convLayer(x, params.box_encoding_predictor),\n      [batchSize, -1, 1, 4],\n    );\n    const classPrediction = tf.reshape(\n      convLayer(x, params.class_predictor),\n      [batchSize, -1, 3],\n    );\n\n    return {\n      boxPredictionEncoding,\n      classPrediction,\n    };\n  });\n}\n", "export interface ISsdMobilenetv1Options {\n  minConfidence?: number\n  maxResults?: number\n}\n\nexport class SsdMobilenetv1Options {\n  protected _name: string = 'SsdMobilenetv1Options'\n\n  private _minConfidence: number\n\n  private _maxResults: number\n\n  constructor({ minConfidence, maxResults }: ISsdMobilenetv1Options = {}) {\n    this._minConfidence = minConfidence || 0.5;\n    this._maxResults = maxResults || 100;\n\n    if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {\n      throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);\n    }\n\n    if (typeof this._maxResults !== 'number') {\n      throw new Error(`${this._name} - expected maxResults to be a number`);\n    }\n  }\n\n  get minConfidence(): number { return this._minConfidence; }\n\n  get maxResults(): number { return this._maxResults; }\n}\n", "import { SsdMobilenetv1 } from './SsdMobilenetv1';\n\nexport * from './SsdMobilenetv1';\nexport * from './SsdMobilenetv1Options';\n\nexport function createSsdMobilenetv1(weights: Float32Array) {\n  const net = new SsdMobilenetv1();\n  net.extractWeights(weights);\n  return net;\n}\n\nexport function createFaceDetectionNet(weights: Float32Array) {\n  return createSsdMobilenetv1(weights);\n}\n\n// alias for backward compatibily\nexport class FaceDetectionNet extends SsdMobilenetv1 {}\n", "import { Point } from '../classes/index';\n\nexport const IOU_THRESHOLD = 0.4;\n\nexport const BOX_ANCHORS = [\n  new Point(0.738768, 0.874946),\n  new Point(2.42204, 2.65704),\n  new Point(4.30971, 7.04493),\n  new Point(10.246, 4.59428),\n  new Point(12.6868, 11.8741),\n];\n\nexport const BOX_ANCHORS_SEPARABLE = [\n  new Point(1.603231, 2.094468),\n  new Point(6.041143, 7.080126),\n  new Point(2.882459, 3.518061),\n  new Point(4.266906, 5.178857),\n  new Point(9.041765, 10.66308),\n];\n\nexport const MEAN_RGB_SEPARABLE: [number, number, number] = [117.001, 114.697, 97.404];\n\nexport const DEFAULT_MODEL_NAME = 'tiny_yolov2_model';\nexport const DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { BoundingBox } from '../classes/BoundingBox';\nimport { Dimensions } from '../classes/Dimensions';\nimport { ObjectDetection } from '../classes/ObjectDetection';\nimport { convLayer } from '../common/index';\nimport { ConvParams, SeparableConvParams } from '../common/types';\nimport { toNetInput } from '../dom/index';\nimport { NetInput } from '../dom/NetInput';\nimport { TNetInput } from '../dom/types';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { sigmoid } from '../ops/index';\nimport { nonMaxSuppression } from '../ops/nonMaxSuppression';\nimport { normalize } from '../ops/normalize';\nimport { TinyYolov2Config, validateConfig } from './config';\nimport { convWithBatchNorm } from './convWithBatchNorm';\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { leaky } from './leaky';\nimport { ITinyYolov2Options, TinyYolov2Options } from './TinyYolov2Options';\nimport { DefaultTinyYolov2NetParams, MobilenetParams, TinyYolov2NetParams } from './types';\n\nexport class TinyYolov2Base extends NeuralNetwork<TinyYolov2NetParams> {\n  public static DEFAULT_FILTER_SIZES = [\n    3, 16, 32, 64, 128, 256, 512, 1024, 1024,\n  ]\n\n  private _config: TinyYolov2Config\n\n  constructor(config: TinyYolov2Config) {\n    super('TinyYolov2');\n    validateConfig(config);\n    this._config = config;\n  }\n\n  public get config(): TinyYolov2Config {\n    return this._config;\n  }\n\n  public get withClassScores(): boolean {\n    return this.config.withClassScores || this.config.classes.length > 1;\n  }\n\n  public get boxEncodingSize(): number {\n    return 5 + (this.withClassScores ? this.config.classes.length : 0);\n  }\n\n  public runTinyYolov2(x: tf.Tensor4D, params: DefaultTinyYolov2NetParams): tf.Tensor4D {\n    let out = convWithBatchNorm(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = convWithBatchNorm(out, params.conv6);\n    out = convWithBatchNorm(out, params.conv7);\n\n    return convLayer(out, params.conv8, 'valid', false);\n  }\n\n  public runMobilenet(x: tf.Tensor4D, params: MobilenetParams): tf.Tensor4D {\n    let out = this.config.isFirstLayerConv2d\n      ? leaky(convLayer(x, params.conv0 as ConvParams, 'valid', false))\n      : depthwiseSeparableConv(x, params.conv0 as SeparableConvParams);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\n\n    return convLayer(out, params.conv8, 'valid', false);\n  }\n\n  public forwardInput(input: NetInput, inputSize: number): tf.Tensor4D {\n    const { params } = this;\n\n    if (!params) {\n      throw new Error('TinyYolov2 - load model before inference');\n    }\n\n    return tf.tidy(() => {\n      // let batchTensor = input.toBatchTensor(inputSize, false).toFloat()\n      let batchTensor = tf.cast(input.toBatchTensor(inputSize, false), 'float32');\n      batchTensor = this.config.meanRgb\n        ? normalize(batchTensor, this.config.meanRgb)\n        : batchTensor;\n      batchTensor = batchTensor.div(tf.scalar(256)) as tf.Tensor4D;\n\n      return this.config.withSeparableConvs\n        ? this.runMobilenet(batchTensor, params as MobilenetParams)\n        : this.runTinyYolov2(batchTensor, params as DefaultTinyYolov2NetParams);\n    });\n  }\n\n  public async forward(input: TNetInput, inputSize: number): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input), inputSize);\n  }\n\n  public async detect(input: TNetInput, forwardParams: ITinyYolov2Options = {}): Promise<ObjectDetection[]> {\n    const { inputSize, scoreThreshold } = new TinyYolov2Options(forwardParams);\n\n    const netInput = await toNetInput(input);\n    const out = await this.forwardInput(netInput, inputSize);\n    const out0 = tf.tidy(() => tf.unstack(out)[0].expandDims()) as tf.Tensor4D;\n\n    const inputDimensions = {\n      width: netInput.getInputWidth(0),\n      height: netInput.getInputHeight(0),\n    };\n\n    const results = await this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold);\n    out.dispose();\n    out0.dispose();\n\n    const boxes = results.map((res) => res.box);\n    const scores = results.map((res) => res.score);\n    const classScores = results.map((res) => res.classScore);\n    const classNames = results.map((res) => this.config.classes[res.label]);\n\n    const indices = nonMaxSuppression(\n      boxes.map((box) => box.rescale(inputSize)),\n      scores,\n      this.config.iouThreshold,\n      true,\n    );\n\n    const detections = indices.map((idx) => new ObjectDetection(\n      scores[idx],\n      classScores[idx],\n      classNames[idx],\n      boxes[idx],\n      inputDimensions,\n    ));\n\n    return detections;\n  }\n\n  protected getDefaultModelName(): string {\n    return '';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap, this.config);\n  }\n\n  protected extractParams(weights: Float32Array) {\n    const filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES;\n\n    const numFilters = filterSizes ? filterSizes.length : undefined;\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n      throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${numFilters} filterSizes in config`);\n    }\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\n  }\n\n  protected async extractBoxes(\n    outputTensor: tf.Tensor4D,\n    inputBlobDimensions: Dimensions,\n    scoreThreshold?: number,\n  ) {\n    const { width, height } = inputBlobDimensions;\n    const inputSize = Math.max(width, height);\n    const correctionFactorX = inputSize / width;\n    const correctionFactorY = inputSize / height;\n\n    const numCells = outputTensor.shape[1];\n    const numBoxes = this.config.anchors.length;\n\n    const [boxesTensor, scoresTensor, classScoresTensor] = tf.tidy(() => {\n      const reshaped = outputTensor.reshape([numCells, numCells, numBoxes, this.boxEncodingSize]);\n\n      const boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\n      const scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\n      const classScores = this.withClassScores\n        ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, this.config.classes.length]), 3)\n        : tf.scalar(0);\n      return [boxes, scores, classScores];\n    });\n\n    const results = [] as any;\n\n    const scoresData = await scoresTensor.array();\n    const boxesData = await boxesTensor.array();\n    for (let row = 0; row < numCells; row++) {\n      for (let col = 0; col < numCells; col++) {\n        for (let anchor = 0; anchor < numBoxes; anchor++) {\n          const score = sigmoid(scoresData[row][col][anchor][0]);\n          if (!scoreThreshold || score > scoreThreshold) {\n            const ctX = ((col + sigmoid(boxesData[row][col][anchor][0])) / numCells) * correctionFactorX;\n            const ctY = ((row + sigmoid(boxesData[row][col][anchor][1])) / numCells) * correctionFactorY;\n            const widthLocal = ((Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x) / numCells) * correctionFactorX;\n            const heightLocal = ((Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y) / numCells) * correctionFactorY;\n\n            const x = (ctX - (widthLocal / 2));\n            const y = (ctY - (heightLocal / 2));\n\n            const pos = { row, col, anchor };\n            const { classScore, label } = this.withClassScores\n              ? await this.extractPredictedClass(classScoresTensor as tf.Tensor4D, pos)\n              : { classScore: 1, label: 0 };\n\n            results.push({\n              box: new BoundingBox(x, y, x + widthLocal, y + heightLocal),\n              score,\n              classScore: score * classScore,\n              label,\n              ...pos,\n            });\n          }\n        }\n      }\n    }\n\n    boxesTensor.dispose();\n    scoresTensor.dispose();\n    classScoresTensor.dispose();\n\n    return results;\n  }\n\n  private async extractPredictedClass(classesTensor: tf.Tensor4D, pos: { row: number, col: number, anchor: number }) {\n    const { row, col, anchor } = pos;\n    const classesData = await classesTensor.array();\n    return Array(this.config.classes.length).fill(0)\n      .map((_, i) => classesData[row][col][anchor][i])\n      .map((classScore, label) => ({\n        classScore,\n        label,\n      }))\n      .reduce((max, curr) => (max.classScore > curr.classScore ? max : curr));\n  }\n}\n", "import { Point } from '../classes/Point';\n\nexport type TinyYolov2Config = {\n  withSeparableConvs: boolean\n  iouThreshold: number\n  anchors: Point[]\n  classes: string[]\n  meanRgb?: [number, number, number]\n  withClassScores?: boolean,\n  filterSizes?: number[]\n  isFirstLayerConv2d?: boolean\n}\n\nconst isNumber = (arg: any) => typeof arg === 'number';\n\nexport function validateConfig(config: any) {\n  if (!config) {\n    throw new Error(`invalid config: ${config}`);\n  }\n\n  if (typeof config.withSeparableConvs !== 'boolean') {\n    throw new Error(`config.withSeparableConvs has to be a boolean, have: ${config.withSeparableConvs}`);\n  }\n\n  if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {\n    throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${config.iouThreshold}`);\n  }\n\n  if (\n    !Array.isArray(config.classes)\n    || !config.classes.length\n    || !config.classes.every((c: any) => typeof c === 'string')\n  ) {\n    throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(config.classes)}`);\n  }\n\n  if (\n    !Array.isArray(config.anchors)\n    || !config.anchors.length\n    || !config.anchors.map((a: any) => a || {}).every((a: any) => isNumber(a.x) && isNumber(a.y))\n  ) {\n    throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(config.anchors)}`);\n  }\n\n  if (config.meanRgb && (\n    !Array.isArray(config.meanRgb)\n    || config.meanRgb.length !== 3\n    || !config.meanRgb.every(isNumber)\n  )) {\n    throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(config.meanRgb)}`);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { leaky } from './leaky';\nimport { ConvWithBatchNorm } from './types';\n\nexport function convWithBatchNorm(x: tf.Tensor4D, params: ConvWithBatchNorm): tf.Tensor4D {\n  return tf.tidy(() => {\n    let out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]) as tf.Tensor4D;\n\n    out = tf.conv2d(out, params.conv.filters, [1, 1], 'valid');\n    out = tf.sub(out, params.bn.sub);\n    out = tf.mul(out, params.bn.truediv);\n    out = tf.add(out, params.conv.bias);\n\n    return leaky(out);\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nexport function leaky(x: tf.Tensor4D): tf.Tensor4D {\n  return tf.tidy(() => {\n    const min = tf.mul(x, tf.scalar(0.10000000149011612));\n    return tf.add(tf.relu(tf.sub(x, min)), min);\n    // return tf.maximum(x, min)\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { SeparableConvParams } from '../common/types';\nimport { leaky } from './leaky';\n\nexport function depthwiseSeparableConv(x: tf.Tensor4D, params: SeparableConvParams): tf.Tensor4D {\n  return tf.tidy(() => {\n    let out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]) as tf.Tensor4D;\n\n    out = tf.separableConv2d(out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid');\n    out = tf.add(out, params.bias);\n\n    return leaky(out);\n  });\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { extractConvParamsFactory } from '../common/index';\nimport { extractSeparableConvParamsFactory } from '../common/extractSeparableConvParamsFactory';\nimport { extractWeightsFactory } from '../common/extractWeightsFactory';\nimport { ExtractWeightsFunction, ParamMapping } from '../common/types';\nimport { TinyYolov2Config } from './config';\nimport { BatchNorm, ConvWithBatchNorm, TinyYolov2NetParams } from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\n\n  function extractBatchNormParams(size: number, mappedPrefix: string): BatchNorm {\n    const sub = tf.tensor1d(extractWeights(size));\n    const truediv = tf.tensor1d(extractWeights(size));\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/sub` },\n      { paramPath: `${mappedPrefix}/truediv` },\n    );\n\n    return { sub, truediv };\n  }\n\n  function extractConvWithBatchNormParams(channelsIn: number, channelsOut: number, mappedPrefix: string): ConvWithBatchNorm {\n    const conv = extractConvParams(channelsIn, channelsOut, 3, `${mappedPrefix}/conv`);\n    const bn = extractBatchNormParams(channelsOut, `${mappedPrefix}/bn`);\n\n    return { conv, bn };\n  }\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\n\n  return {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams,\n  };\n}\n\nexport function extractParams(\n  weights: Float32Array,\n  config: TinyYolov2Config,\n  boxEncodingSize: number,\n  filterSizes: number[],\n): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n  const {\n    extractWeights,\n    getRemainingWeights,\n  } = extractWeightsFactory(weights);\n\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams,\n  } = extractorsFactory(extractWeights, paramMappings);\n\n  let params: TinyYolov2NetParams;\n\n  if (config.withSeparableConvs) {\n    const [s0, s1, s2, s3, s4, s5, s6, s7, s8] = filterSizes;\n\n    const conv0 = config.isFirstLayerConv2d\n      ? extractConvParams(s0, s1, 3, 'conv0')\n      : extractSeparableConvParams(s0, s1, 'conv0');\n    const conv1 = extractSeparableConvParams(s1, s2, 'conv1');\n    const conv2 = extractSeparableConvParams(s2, s3, 'conv2');\n    const conv3 = extractSeparableConvParams(s3, s4, 'conv3');\n    const conv4 = extractSeparableConvParams(s4, s5, 'conv4');\n    const conv5 = extractSeparableConvParams(s5, s6, 'conv5');\n    const conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;\n    const conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;\n    const conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');\n    params = {\n      conv0, conv1, conv2, conv3, conv4, conv5, conv6, conv7, conv8,\n    };\n  } else {\n    const [s0, s1, s2, s3, s4, s5, s6, s7, s8] = filterSizes;\n    const conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');\n    const conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');\n    const conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');\n    const conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');\n    const conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');\n    const conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');\n    const conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');\n    const conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');\n    const conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');\n    params = {\n      conv0, conv1, conv2, conv3, conv4, conv5, conv6, conv7, conv8,\n    };\n  }\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\n  }\n\n  return { params, paramMappings };\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { ConvParams } from '../common/index';\nimport { disposeUnusedWeightTensors } from '../common/disposeUnusedWeightTensors';\nimport { loadSeparableConvParamsFactory } from '../common/extractSeparableConvParamsFactory';\nimport { extractWeightEntryFactory } from '../common/extractWeightEntryFactory';\nimport { ParamMapping } from '../common/types';\nimport { TinyYolov2Config } from './config';\nimport { BatchNorm, ConvWithBatchNorm, TinyYolov2NetParams } from './types';\n\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\n\n  function extractBatchNormParams(prefix: string): BatchNorm {\n    const sub = extractWeightEntry(`${prefix}/sub`, 1);\n    const truediv = extractWeightEntry(`${prefix}/truediv`, 1);\n    return { sub, truediv };\n  }\n\n  function extractConvParams(prefix: string): ConvParams {\n    const filters = extractWeightEntry(`${prefix}/filters`, 4);\n    const bias = extractWeightEntry(`${prefix}/bias`, 1);\n    return { filters, bias };\n  }\n\n  function extractConvWithBatchNormParams(prefix: string): ConvWithBatchNorm {\n    const conv = extractConvParams(`${prefix}/conv`);\n    const bn = extractBatchNormParams(`${prefix}/bn`);\n    return { conv, bn };\n  }\n\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\n\n  return {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams,\n  };\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n  config: TinyYolov2Config,\n): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n  const paramMappings: ParamMapping[] = [];\n\n  const {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams,\n  } = extractorsFactory(weightMap, paramMappings);\n\n  let params: TinyYolov2NetParams;\n\n  if (config.withSeparableConvs) {\n    // eslint-disable-next-line no-mixed-operators\n    const numFilters = (config.filterSizes && config.filterSizes.length || 9);\n    params = {\n      conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),\n      conv1: extractSeparableConvParams('conv1'),\n      conv2: extractSeparableConvParams('conv2'),\n      conv3: extractSeparableConvParams('conv3'),\n      conv4: extractSeparableConvParams('conv4'),\n      conv5: extractSeparableConvParams('conv5'),\n      conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,\n      conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,\n      conv8: extractConvParams('conv8'),\n    };\n  } else {\n    params = {\n      conv0: extractConvWithBatchNormParams('conv0'),\n      conv1: extractConvWithBatchNormParams('conv1'),\n      conv2: extractConvWithBatchNormParams('conv2'),\n      conv3: extractConvWithBatchNormParams('conv3'),\n      conv4: extractConvWithBatchNormParams('conv4'),\n      conv5: extractConvWithBatchNormParams('conv5'),\n      conv6: extractConvWithBatchNormParams('conv6'),\n      conv7: extractConvWithBatchNormParams('conv7'),\n      conv8: extractConvParams('conv8'),\n    };\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings);\n\n  return { params, paramMappings };\n}\n", "export interface ITinyYolov2Options {\n  inputSize?: number\n  scoreThreshold?: number\n}\n\nexport class TinyYolov2Options {\n  protected _name: string = 'TinyYolov2Options'\n\n  private _inputSize: number\n\n  private _scoreThreshold: number\n\n  constructor({ inputSize, scoreThreshold }: ITinyYolov2Options = {}) {\n    this._inputSize = inputSize || 416;\n    this._scoreThreshold = scoreThreshold || 0.5;\n\n    if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {\n      throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);\n    }\n\n    if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {\n      throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`);\n    }\n  }\n\n  get inputSize(): number { return this._inputSize; }\n\n  get scoreThreshold(): number { return this._scoreThreshold; }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { FaceDetection, Point } from '../classes/index';\nimport { ParamMapping } from '../common/types';\nimport { TNetInput } from '../dom/types';\nimport {\n  BOX_ANCHORS,\n  BOX_ANCHORS_SEPARABLE,\n  DEFAULT_MODEL_NAME,\n  DEFAULT_MODEL_NAME_SEPARABLE_CONV,\n  IOU_THRESHOLD,\n  MEAN_RGB_SEPARABLE,\n} from './const';\nimport { TinyYolov2Base } from './TinyYolov2Base';\nimport { ITinyYolov2Options } from './TinyYolov2Options';\nimport { TinyYolov2NetParams } from './types';\n\nexport class TinyYolov2 extends TinyYolov2Base {\n  constructor(withSeparableConvs: boolean = true) {\n    const config = {\n      withSeparableConvs,\n      iouThreshold: IOU_THRESHOLD,\n      classes: ['face'],\n      ...(withSeparableConvs\n        ? {\n          anchors: BOX_ANCHORS_SEPARABLE,\n          meanRgb: MEAN_RGB_SEPARABLE,\n        }\n        : {\n          anchors: BOX_ANCHORS,\n          withClassScores: true,\n        }),\n    };\n\n    super(config);\n  }\n\n  public get withSeparableConvs(): boolean {\n    return this.config.withSeparableConvs;\n  }\n\n  public get anchors(): Point[] {\n    return this.config.anchors;\n  }\n\n  public async locateFaces(input: TNetInput, forwardParams: ITinyYolov2Options): Promise<FaceDetection[]> {\n    const objectDetections = await this.detect(input, forwardParams);\n    return objectDetections.map((det) => new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }));\n  }\n\n  protected getDefaultModelName(): string {\n    return this.withSeparableConvs ? DEFAULT_MODEL_NAME_SEPARABLE_CONV : DEFAULT_MODEL_NAME;\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n    return super.extractParamsFromWeigthMap(weightMap);\n  }\n}\n", "import { TinyYolov2 } from './TinyYolov2';\n\nexport * from './TinyYolov2Options';\n\nexport * from './config';\nexport * from './types';\n\nexport { TinyYolov2 };\n\nexport function createTinyYolov2(weights: Float32Array, withSeparableConvs: boolean = true) {\n  const net = new TinyYolov2(withSeparableConvs);\n  net.extractWeights(weights);\n  return net;\n}\n", "import { ITinyYolov2Options, TinyYolov2Options } from '../tinyYolov2/index';\n\nexport interface ITinyFaceDetectorOptions extends ITinyYolov2Options {}\n\nexport class TinyFaceDetectorOptions extends TinyYolov2Options {\n  protected _name: string = 'TinyFaceDetectorOptions'\n}\n", "export class ComposableTask<T> {\n  public async then(\n    // eslint-disable-next-line no-unused-vars\n    onfulfilled: (value: T) => T | PromiseLike<T>,\n  ): Promise<T> {\n    return onfulfilled(await this.run());\n  }\n\n  public async run(): Promise<T> {\n    throw new Error('ComposableTask - run is not implemented');\n  }\n}\n", "/* eslint-disable max-classes-per-file */\nimport * as tf from '../../dist/tfjs.esm.js';\n\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { extractFaces, extractFaceTensors, TNetInput } from '../dom/index';\nimport { FaceLandmark68Net } from '../faceLandmarkNet/FaceLandmark68Net';\nimport { FaceLandmark68TinyNet } from '../faceLandmarkNet/FaceLandmark68TinyNet';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { extendWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { nets } from './nets';\nimport {\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\n} from './PredictAgeAndGenderTask';\nimport {\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\n} from './PredictFaceExpressionsTask';\n\nexport class DetectFaceLandmarksTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    // eslint-disable-next-line no-unused-vars\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    // eslint-disable-next-line no-unused-vars\n    protected input: TNetInput,\n    // eslint-disable-next-line no-unused-vars\n    protected useTinyLandmarkNet: boolean,\n  ) {\n    super();\n  }\n\n  protected get landmarkNet(): FaceLandmark68Net | FaceLandmark68TinyNet {\n    return this.useTinyLandmarkNet\n      ? nets.faceLandmark68TinyNet\n      : nets.faceLandmark68Net;\n  }\n}\n\nexport class DetectAllFaceLandmarksTask<\n  TSource extends WithFaceDetection<{}>\n> extends DetectFaceLandmarksTaskBase<WithFaceLandmarks<TSource>[], TSource[]> {\n  public async run(): Promise<WithFaceLandmarks<TSource>[]> {\n    const parentResults = await this.parentTask;\n    const detections = parentResults.map((res) => res.detection);\n\n    const faces: Array<HTMLCanvasElement | tf.Tensor3D> = this.input instanceof tf.Tensor\n      ? await extractFaceTensors(this.input, detections)\n      : await extractFaces(this.input, detections);\n\n    const faceLandmarksByFace = await Promise.all(faces.map(\n      (face) => this.landmarkNet.detectLandmarks(face),\n    )) as FaceLandmarks68[];\n\n    faces.forEach((f) => f instanceof tf.Tensor && f.dispose());\n\n    return parentResults.map((parentResult, i) => extendWithFaceLandmarks<TSource>(parentResult, faceLandmarksByFace[i]));\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  }\n\n  withFaceDescriptors() {\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\n  }\n}\n\nexport class DetectSingleFaceLandmarksTask<\n  TSource extends WithFaceDetection<{}>\n> extends DetectFaceLandmarksTaskBase<WithFaceLandmarks<TSource> | undefined, TSource | undefined> {\n  public async run(): Promise<WithFaceLandmarks<TSource> | undefined> {\n    const parentResult = await this.parentTask;\n    if (!parentResult) {\n      return undefined;\n    }\n\n    const { detection } = parentResult;\n    const faces: Array<HTMLCanvasElement | tf.Tensor3D> = this.input instanceof tf.Tensor\n      ? await extractFaceTensors(this.input, [detection])\n      : await extractFaces(this.input, [detection]);\n\n    const landmarks = await this.landmarkNet.detectLandmarks(faces[0]) as FaceLandmarks68;\n\n    faces.forEach((f) => f instanceof tf.Tensor && f.dispose());\n\n    return extendWithFaceLandmarks<TSource>(parentResult, landmarks);\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  }\n\n  withFaceDescriptor() {\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\n  }\n}\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { extractFaces, extractFaceTensors, TNetInput } from '../dom/index';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { isWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\n\nexport async function extractAllFacesAndComputeResults<TSource extends WithFaceDetection<{}>, TResult>(\n  parentResults: TSource[],\n  input: TNetInput,\n  // eslint-disable-next-line no-unused-vars\n  computeResults: (faces: Array<HTMLCanvasElement | tf.Tensor3D>) => Promise<TResult>,\n  extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D> | null,\n  // eslint-disable-next-line no-unused-vars\n  getRectForAlignment: (parentResult: WithFaceLandmarks<TSource, any>) => FaceDetection = ({ alignedRect }) => alignedRect,\n) {\n  const faceBoxes = parentResults.map((parentResult) => (isWithFaceLandmarks(parentResult)\n    ? getRectForAlignment(parentResult)\n    : parentResult.detection));\n  const faces: Array<HTMLCanvasElement | tf.Tensor3D> = extractedFaces || (\n    input instanceof tf.Tensor\n      ? await extractFaceTensors(input, faceBoxes)\n      : await extractFaces(input, faceBoxes)\n  );\n\n  const results = await computeResults(faces);\n\n  faces.forEach((f) => f instanceof tf.Tensor && f.dispose());\n\n  return results;\n}\n\nexport async function extractSingleFaceAndComputeResult<TSource extends WithFaceDetection<{}>, TResult>(\n  parentResult: TSource,\n  input: TNetInput,\n  // eslint-disable-next-line no-unused-vars\n  computeResult: (face: HTMLCanvasElement | tf.Tensor3D) => Promise<TResult>,\n  extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D> | null,\n  // eslint-disable-next-line no-unused-vars\n  getRectForAlignment?: (parentResultLocal: WithFaceLandmarks<TSource, any>) => FaceDetection,\n) {\n  return extractAllFacesAndComputeResults<TSource, TResult>(\n    [parentResult],\n    input,\n    async (faces) => computeResult(faces[0]),\n    extractedFaces,\n    getRectForAlignment,\n  );\n}\n", "import { Point } from '../classes/index';\n\nexport const IOU_THRESHOLD = 0.4;\n\nexport const BOX_ANCHORS = [\n  new Point(1.603231, 2.094468),\n  new Point(6.041143, 7.080126),\n  new Point(2.882459, 3.518061),\n  new Point(4.266906, 5.178857),\n  new Point(9.041765, 10.66308),\n];\n\nexport const MEAN_RGB: [number, number, number] = [117.001, 114.697, 97.404];\n", "import * as tf from '../../dist/tfjs.esm.js';\n\nimport { FaceDetection, Point } from '../classes/index';\nimport { ParamMapping } from '../common/index';\nimport { TNetInput } from '../dom/index';\nimport { ITinyYolov2Options } from '../tinyYolov2/index';\nimport { TinyYolov2Base } from '../tinyYolov2/TinyYolov2Base';\nimport { TinyYolov2NetParams } from '../tinyYolov2/types';\nimport { BOX_ANCHORS, IOU_THRESHOLD, MEAN_RGB } from './const';\n\nexport class TinyFaceDetector extends TinyYolov2Base {\n  constructor() {\n    const config = {\n      withSeparableConvs: true,\n      iouThreshold: IOU_THRESHOLD,\n      classes: ['face'],\n      anchors: BOX_ANCHORS,\n      meanRgb: MEAN_RGB,\n      isFirstLayerConv2d: true,\n      filterSizes: [3, 16, 32, 64, 128, 256, 512],\n    };\n\n    super(config);\n  }\n\n  public get anchors(): Point[] {\n    return this.config.anchors;\n  }\n\n  public async locateFaces(input: TNetInput, forwardParams: ITinyYolov2Options): Promise<FaceDetection[]> {\n    const objectDetections = await this.detect(input, forwardParams);\n    return objectDetections.map((det) => new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }));\n  }\n\n  protected getDefaultModelName(): string {\n    return 'tiny_face_detector_model';\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n    return super.extractParamsFromWeigthMap(weightMap);\n  }\n}\n", "import { AgeGenderNet } from '../ageGenderNet/AgeGenderNet';\nimport { AgeAndGenderPrediction } from '../ageGenderNet/types';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { TNetInput } from '../dom/index';\nimport { FaceExpressionNet } from '../faceExpressionNet/FaceExpressionNet';\nimport { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\nimport { FaceLandmark68Net } from '../faceLandmarkNet/FaceLandmark68Net';\nimport { FaceLandmark68TinyNet } from '../faceLandmarkNet/FaceLandmark68TinyNet';\nimport { FaceRecognitionNet } from '../faceRecognitionNet/FaceRecognitionNet';\nimport { SsdMobilenetv1 } from '../ssdMobilenetv1/SsdMobilenetv1';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\nimport { TinyFaceDetector } from '../tinyFaceDetector/TinyFaceDetector';\nimport { TinyFaceDetectorOptions } from '../tinyFaceDetector/TinyFaceDetectorOptions';\nimport { ITinyYolov2Options, TinyYolov2 } from '../tinyYolov2/index';\n\nexport const nets = {\n  ssdMobilenetv1: new SsdMobilenetv1(),\n  tinyFaceDetector: new TinyFaceDetector(),\n  tinyYolov2: new TinyYolov2(),\n  faceLandmark68Net: new FaceLandmark68Net(),\n  faceLandmark68TinyNet: new FaceLandmark68TinyNet(),\n  faceRecognitionNet: new FaceRecognitionNet(),\n  faceExpressionNet: new FaceExpressionNet(),\n  ageGenderNet: new AgeGenderNet(),\n};\n\n/**\n * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.\n *\n * @param input The input image.\n * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).\n * @returns Bounding box of each face with score.\n */\nexport const ssdMobilenetv1 = (input: TNetInput, options: SsdMobilenetv1Options): Promise<FaceDetection[]> => nets.ssdMobilenetv1.locateFaces(input, options);\n\n/**\n * Attempts to detect all faces in an image using the Tiny Face Detector.\n *\n * @param input The input image.\n * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).\n * @returns Bounding box of each face with score.\n */\nexport const tinyFaceDetector = (input: TNetInput, options: TinyFaceDetectorOptions): Promise<FaceDetection[]> => nets.tinyFaceDetector.locateFaces(input, options);\n\n/**\n * Attempts to detect all faces in an image using the Tiny Yolov2 Network.\n *\n * @param input The input image.\n * @param options (optional, default: see TinyYolov2Options constructor for default parameters).\n * @returns Bounding box of each face with score.\n */\nexport const tinyYolov2 = (input: TNetInput, options: ITinyYolov2Options): Promise<FaceDetection[]> => nets.tinyYolov2.locateFaces(input, options);\n\n/**\n * Detects the 68 point face landmark positions of the face shown in an image.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns 68 point face landmarks or array thereof in case of batch input.\n */\nexport const detectFaceLandmarks = (input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> => nets.faceLandmark68Net.detectLandmarks(input);\n\n/**\n * Detects the 68 point face landmark positions of the face shown in an image\n * using a tinier version of the 68 point face landmark model, which is slightly\n * faster at inference, but also slightly less accurate.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns 68 point face landmarks or array thereof in case of batch input.\n */\nexport const detectFaceLandmarksTiny = (input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> => nets.faceLandmark68TinyNet.detectLandmarks(input);\n\n/**\n * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,\n * which uniquely represents the features of that persons face. The computed face descriptor can\n * be used to measure the similarity between faces, by computing the euclidean distance of two\n * face descriptors.\n *\n * @param inputs The face image extracted from the aligned bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns Face descriptor with 128 entries or array thereof in case of batch input.\n */\nexport const computeFaceDescriptor = (input: TNetInput): Promise<Float32Array | Float32Array[]> => nets.faceRecognitionNet.computeFaceDescriptor(input);\n\n/**\n * Recognizes the facial expressions from a face image.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns Facial expressions with corresponding probabilities or array thereof in case of batch input.\n */\nexport const recognizeFaceExpressions = (input: TNetInput): Promise<FaceExpressions | FaceExpressions[]> => nets.faceExpressionNet.predictExpressions(input);\n\n/**\n * Predicts age and gender from a face image.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns Predictions with age, gender and gender probability or array thereof in case of batch input.\n */\nexport const predictAgeAndGender = (input: TNetInput): Promise<AgeAndGenderPrediction | AgeAndGenderPrediction[]> => nets.ageGenderNet.predictAgeAndGender(input);\n\nexport const loadSsdMobilenetv1Model = (url: string) => nets.ssdMobilenetv1.load(url);\nexport const loadTinyFaceDetectorModel = (url: string) => nets.tinyFaceDetector.load(url);\nexport const loadTinyYolov2Model = (url: string) => nets.tinyYolov2.load(url);\nexport const loadFaceLandmarkModel = (url: string) => nets.faceLandmark68Net.load(url);\nexport const loadFaceLandmarkTinyModel = (url: string) => nets.faceLandmark68TinyNet.load(url);\nexport const loadFaceRecognitionModel = (url: string) => nets.faceRecognitionNet.load(url);\nexport const loadFaceExpressionModel = (url: string) => nets.faceExpressionNet.load(url);\nexport const loadAgeGenderModel = (url: string) => nets.ageGenderNet.load(url);\n\n// backward compatibility\nexport const loadFaceDetectionModel = loadSsdMobilenetv1Model;\nexport const locateFaces = ssdMobilenetv1;\nexport const detectLandmarks = detectFaceLandmarks;\n", "/* eslint-disable max-classes-per-file */\nimport * as tf from '../../dist/tfjs.esm.js';\n\nimport { TNetInput } from '../dom/index';\nimport { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { extendWithFaceExpressions, WithFaceExpressions } from '../factories/WithFaceExpressions';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\nimport { nets } from './nets';\nimport {\n  PredictAllAgeAndGenderTask,\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\n  PredictSingleAgeAndGenderTask,\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\n} from './PredictAgeAndGenderTask';\n\nexport class PredictFaceExpressionsTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    // eslint-disable-next-line no-unused-vars\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    // eslint-disable-next-line no-unused-vars\n    protected input: TNetInput,\n    // eslint-disable-next-line no-unused-vars\n    protected extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D>,\n  ) {\n    super();\n  }\n}\n\nexport class PredictAllFaceExpressionsTask<\n  TSource extends WithFaceDetection<{}>\n> extends PredictFaceExpressionsTaskBase<WithFaceExpressions<TSource>[], TSource[]> {\n  public async run(): Promise<WithFaceExpressions<TSource>[]> {\n    const parentResults = await this.parentTask;\n\n    const faceExpressionsByFace = await extractAllFacesAndComputeResults<TSource, FaceExpressions[]>(\n      parentResults,\n      this.input,\n      async (faces) => Promise.all(faces.map(\n        (face) => nets.faceExpressionNet.predictExpressions(face) as Promise<FaceExpressions>,\n      )),\n      this.extractedFaces,\n    );\n\n    return parentResults.map(\n      (parentResult, i) => extendWithFaceExpressions<TSource>(parentResult, faceExpressionsByFace[i]),\n    );\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderTask(this, this.input);\n  }\n}\n\nexport class PredictSingleFaceExpressionsTask<\n  TSource extends WithFaceDetection<{}>\n> extends PredictFaceExpressionsTaskBase<WithFaceExpressions<TSource> | undefined, TSource | undefined> {\n  public async run(): Promise<WithFaceExpressions<TSource> | undefined> {\n    const parentResult = await this.parentTask;\n    if (!parentResult) {\n      return undefined;\n    }\n\n    const faceExpressions = await extractSingleFaceAndComputeResult<TSource, FaceExpressions>(\n      parentResult,\n      this.input,\n      (face) => nets.faceExpressionNet.predictExpressions(face) as Promise<FaceExpressions>,\n      this.extractedFaces,\n    );\n\n    return extendWithFaceExpressions(parentResult, faceExpressions);\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderTask(this, this.input);\n  }\n}\n\nexport class PredictAllFaceExpressionsWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictAllFaceExpressionsTask<TSource> {\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  }\n\n  withFaceDescriptors() {\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\n  }\n}\n\nexport class PredictSingleFaceExpressionsWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictSingleFaceExpressionsTask<TSource> {\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  }\n\n  withFaceDescriptor() {\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\n  }\n}\n", "/* eslint-disable max-classes-per-file */\nimport * as tf from '../../dist/tfjs.esm.js';\n\nimport { AgeAndGenderPrediction } from '../ageGenderNet/types';\nimport { TNetInput } from '../dom/index';\nimport { extendWithAge, WithAge } from '../factories/WithAge';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { extendWithGender, WithGender } from '../factories/WithGender';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\nimport { nets } from './nets';\nimport {\n  PredictAllFaceExpressionsTask,\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\n  PredictSingleFaceExpressionsTask,\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\n} from './PredictFaceExpressionsTask';\n\nexport class PredictAgeAndGenderTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    // eslint-disable-next-line no-unused-vars\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    // eslint-disable-next-line no-unused-vars\n    protected input: TNetInput,\n    // eslint-disable-next-line no-unused-vars\n    protected extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D>,\n  ) {\n    super();\n  }\n}\n\nexport class PredictAllAgeAndGenderTask<\n  TSource extends WithFaceDetection<{}>\n> extends PredictAgeAndGenderTaskBase<WithAge<WithGender<TSource>>[], TSource[]> {\n  public async run(): Promise<WithAge<WithGender<TSource>>[]> {\n    const parentResults = await this.parentTask;\n\n    const ageAndGenderByFace = await extractAllFacesAndComputeResults<TSource, AgeAndGenderPrediction[]>(\n      parentResults,\n      this.input,\n      async (faces) => Promise.all(faces.map(\n        (face) => nets.ageGenderNet.predictAgeAndGender(face) as Promise<AgeAndGenderPrediction>,\n      )),\n      this.extractedFaces,\n    );\n\n    return parentResults.map((parentResult, i) => {\n      const { age, gender, genderProbability } = ageAndGenderByFace[i];\n      return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age);\n    });\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsTask(this, this.input);\n  }\n}\n\nexport class PredictSingleAgeAndGenderTask<\n  TSource extends WithFaceDetection<{}>\n> extends PredictAgeAndGenderTaskBase<WithAge<WithGender<TSource>> | undefined, TSource | undefined> {\n  public async run(): Promise<WithAge<WithGender<TSource>> | undefined> {\n    const parentResult = await this.parentTask;\n    if (!parentResult) {\n      return undefined;\n    }\n\n    const { age, gender, genderProbability } = await extractSingleFaceAndComputeResult<TSource, AgeAndGenderPrediction>(\n      parentResult,\n      this.input,\n      (face) => nets.ageGenderNet.predictAgeAndGender(face) as Promise<AgeAndGenderPrediction>,\n      this.extractedFaces,\n    );\n\n    return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age);\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsTask(this, this.input);\n  }\n}\n\nexport class PredictAllAgeAndGenderWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictAllAgeAndGenderTask<TSource> {\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  }\n\n  withFaceDescriptors() {\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\n  }\n}\n\nexport class PredictSingleAgeAndGenderWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictSingleAgeAndGenderTask<TSource> {\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  }\n\n  withFaceDescriptor() {\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\n  }\n}\n", "/* eslint-disable max-classes-per-file */\nimport { TNetInput } from '../dom/index';\nimport { extendWithFaceDescriptor, WithFaceDescriptor } from '../factories/WithFaceDescriptor';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\nimport { nets } from './nets';\nimport {\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\n} from './PredictAgeAndGenderTask';\nimport {\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\n} from './PredictFaceExpressionsTask';\n\nexport class ComputeFaceDescriptorsTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    // eslint-disable-next-line no-unused-vars\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    // eslint-disable-next-line no-unused-vars\n    protected input: TNetInput,\n  ) {\n    super();\n  }\n}\n\nexport class ComputeAllFaceDescriptorsTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends ComputeFaceDescriptorsTaskBase<WithFaceDescriptor<TSource>[], TSource[]> {\n  public async run(): Promise<WithFaceDescriptor<TSource>[]> {\n    const parentResults = await this.parentTask;\n\n    const descriptors = await extractAllFacesAndComputeResults<TSource, Float32Array[]>(\n      parentResults,\n      this.input,\n      (faces) => Promise.all(faces.map((face) => nets.faceRecognitionNet.computeFaceDescriptor(face) as Promise<Float32Array>)),\n      null,\n      (parentResult) => parentResult.landmarks.align(null, { useDlibAlignment: true }),\n    );\n\n    return descriptors.map((descriptor, i) => extendWithFaceDescriptor<TSource>(parentResults[i], descriptor));\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  }\n}\n\nexport class ComputeSingleFaceDescriptorTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends ComputeFaceDescriptorsTaskBase<WithFaceDescriptor<TSource> | undefined, TSource | undefined> {\n  public async run(): Promise<WithFaceDescriptor<TSource> | undefined> {\n    const parentResult = await this.parentTask;\n    if (!parentResult) {\n      return undefined;\n    }\n    const descriptor = await extractSingleFaceAndComputeResult<TSource, Float32Array>(\n      parentResult,\n      this.input,\n      (face) => nets.faceRecognitionNet.computeFaceDescriptor(face) as Promise<Float32Array>,\n      null,\n      // eslint-disable-next-line no-shadow\n      (parentResult) => parentResult.landmarks.align(null, { useDlibAlignment: true }),\n    );\n\n    return extendWithFaceDescriptor(parentResult, descriptor);\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\n  }\n}\n", "/* eslint-disable max-classes-per-file */\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { TNetInput } from '../dom/index';\nimport { extendWithFaceDetection, WithFaceDetection } from '../factories/WithFaceDetection';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\nimport { TinyFaceDetectorOptions } from '../tinyFaceDetector/TinyFaceDetectorOptions';\nimport { TinyYolov2Options } from '../tinyYolov2/index';\nimport { ComposableTask } from './ComposableTask';\nimport { DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask } from './DetectFaceLandmarksTasks';\nimport { nets } from './nets';\nimport { PredictAllAgeAndGenderTask, PredictSingleAgeAndGenderTask } from './PredictAgeAndGenderTask';\nimport { PredictAllFaceExpressionsTask, PredictSingleFaceExpressionsTask } from './PredictFaceExpressionsTask';\nimport { FaceDetectionOptions } from './types';\n\nexport class DetectFacesTaskBase<TReturn> extends ComposableTask<TReturn> {\n  constructor(\n    // eslint-disable-next-line no-unused-vars\n    protected input: TNetInput,\n    // eslint-disable-next-line no-unused-vars\n    protected options: FaceDetectionOptions = new SsdMobilenetv1Options(),\n  ) {\n    super();\n  }\n}\n\nexport class DetectAllFacesTask extends DetectFacesTaskBase<FaceDetection[]> {\n  public async run(): Promise<FaceDetection[]> {\n    const { input, options } = this;\n\n    // eslint-disable-next-line no-nested-ternary\n    const faceDetectionFunction = options instanceof TinyFaceDetectorOptions\n      // eslint-disable-next-line no-shadow\n      ? (input: TNetInput) => nets.tinyFaceDetector.locateFaces(input, options)\n      : (\n        // eslint-disable-next-line no-nested-ternary\n        options instanceof SsdMobilenetv1Options\n          // eslint-disable-next-line no-shadow\n          ? (input: TNetInput) => nets.ssdMobilenetv1.locateFaces(input, options)\n          : (\n            options instanceof TinyYolov2Options\n              // eslint-disable-next-line no-shadow\n              ? (input: TNetInput) => nets.tinyYolov2.locateFaces(input, options)\n              : null\n          )\n      );\n\n    if (!faceDetectionFunction) {\n      throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');\n    }\n\n    return faceDetectionFunction(input);\n  }\n\n  private runAndExtendWithFaceDetections(): Promise<WithFaceDetection<{}>[]> {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise<WithFaceDetection<{}>[]>(async (resolve) => {\n      const detections = await this.run();\n      resolve(detections.map((detection) => extendWithFaceDetection({}, detection)));\n    });\n  }\n\n  withFaceLandmarks(useTinyLandmarkNet: boolean = false) {\n    return new DetectAllFaceLandmarksTask(\n      this.runAndExtendWithFaceDetections(),\n      this.input,\n      useTinyLandmarkNet,\n    );\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsTask(\n      this.runAndExtendWithFaceDetections(),\n      this.input,\n    );\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderTask(\n      this.runAndExtendWithFaceDetections(),\n      this.input,\n    );\n  }\n}\n\nexport class DetectSingleFaceTask extends DetectFacesTaskBase<FaceDetection | undefined> {\n  public async run(): Promise<FaceDetection | undefined> {\n    const faceDetections = await new DetectAllFacesTask(this.input, this.options);\n    let faceDetectionWithHighestScore = faceDetections[0];\n    faceDetections.forEach((faceDetection) => {\n      if (faceDetection.score > faceDetectionWithHighestScore.score) {\n        faceDetectionWithHighestScore = faceDetection;\n      }\n    });\n    return faceDetectionWithHighestScore;\n  }\n\n  private runAndExtendWithFaceDetection(): Promise<WithFaceDetection<{}> | undefined> {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise<WithFaceDetection<{}> | undefined>(async (resolve) => {\n      const detection = await this.run();\n      resolve(detection ? extendWithFaceDetection<{}>({}, detection) : undefined);\n    });\n  }\n\n  withFaceLandmarks(useTinyLandmarkNet: boolean = false) {\n    return new DetectSingleFaceLandmarksTask(\n      this.runAndExtendWithFaceDetection(),\n      this.input,\n      useTinyLandmarkNet,\n    );\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsTask(\n      this.runAndExtendWithFaceDetection(),\n      this.input,\n    );\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderTask(\n      this.runAndExtendWithFaceDetection(),\n      this.input,\n    );\n  }\n}\n", "import { TNetInput } from '../dom/index';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\nimport { DetectAllFacesTask, DetectSingleFaceTask } from './DetectFacesTasks';\nimport { FaceDetectionOptions } from './types';\n\nexport function detectSingleFace(\n  input: TNetInput,\n  options: FaceDetectionOptions = new SsdMobilenetv1Options(),\n): DetectSingleFaceTask {\n  return new DetectSingleFaceTask(input, options);\n}\n\nexport function detectAllFaces(\n  input: TNetInput,\n  options: FaceDetectionOptions = new SsdMobilenetv1Options(),\n): DetectAllFacesTask {\n  return new DetectAllFacesTask(input, options);\n}\n", "import { TNetInput } from '../dom/index';\nimport { WithFaceDescriptor, WithFaceDetection, WithFaceLandmarks } from '../factories/index';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/index';\nimport { ITinyYolov2Options, TinyYolov2Options } from '../tinyYolov2/index';\nimport { detectAllFaces } from './detectFaces';\n\n// export allFaces API for backward compatibility\n\nexport async function allFacesSsdMobilenetv1(\n  input: TNetInput,\n  minConfidence?: number,\n): Promise<WithFaceDescriptor<WithFaceLandmarks<WithFaceDetection<{}>>>[]> {\n  return detectAllFaces(input, new SsdMobilenetv1Options(minConfidence ? { minConfidence } : {}))\n    .withFaceLandmarks()\n    .withFaceDescriptors();\n}\n\nexport async function allFacesTinyYolov2(\n  input: TNetInput,\n  forwardParams: ITinyYolov2Options = {},\n): Promise<WithFaceDescriptor<WithFaceLandmarks<WithFaceDetection<{}>>>[]> {\n  return detectAllFaces(input, new TinyYolov2Options(forwardParams))\n    .withFaceLandmarks()\n    .withFaceDescriptors();\n}\n\nexport const allFaces = allFacesSsdMobilenetv1;\n", "export function euclideanDistance(arr1: number[] | Float32Array, arr2: number[] | Float32Array) {\n  if (arr1.length !== arr2.length)\n    throw new Error('euclideanDistance: arr1.length !== arr2.length')\n\n  const desc1 = Array.from(arr1)\n  const desc2 = Array.from(arr2)\n\n  return Math.sqrt(\n    desc1\n      .map((val, i) => val - desc2[i])\n      .reduce((res, diff) => res + Math.pow(diff, 2), 0)\n  )\n}", "import { FaceMatch } from '../classes/FaceMatch';\nimport { LabeledFaceDescriptors } from '../classes/LabeledFaceDescriptors';\nimport { euclideanDistance } from '../euclideanDistance';\nimport { WithFaceDescriptor } from '../factories/index';\n\nexport class FaceMatcher {\n  private _labeledDescriptors: LabeledFaceDescriptors[]\n\n  private _distanceThreshold: number\n\n  constructor(\n    inputs: LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>,\n    distanceThreshold: number = 0.6,\n  ) {\n    this._distanceThreshold = distanceThreshold;\n\n    const inputArray = Array.isArray(inputs) ? inputs : [inputs];\n\n    if (!inputArray.length) {\n      throw new Error('FaceRecognizer.constructor - expected atleast one input');\n    }\n\n    let count = 1;\n    const createUniqueLabel = () => `person ${count++}`;\n\n    this._labeledDescriptors = inputArray.map((desc) => {\n      if (desc instanceof LabeledFaceDescriptors) {\n        return desc;\n      }\n\n      if (desc instanceof Float32Array) {\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc]);\n      }\n\n      if (desc.descriptor && desc.descriptor instanceof Float32Array) {\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);\n      }\n\n      throw new Error('FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>');\n    });\n  }\n\n  public get labeledDescriptors(): LabeledFaceDescriptors[] { return this._labeledDescriptors; }\n\n  public get distanceThreshold(): number { return this._distanceThreshold; }\n\n  public computeMeanDistance(queryDescriptor: Float32Array, descriptors: Float32Array[]): number {\n    return descriptors\n      .map((d) => euclideanDistance(d, queryDescriptor))\n      .reduce((d1, d2) => d1 + d2, 0)\n        / (descriptors.length || 1);\n  }\n\n  public matchDescriptor(queryDescriptor: Float32Array): FaceMatch {\n    return this.labeledDescriptors\n      .map(({ descriptors, label }) => new FaceMatch(\n        label,\n        this.computeMeanDistance(queryDescriptor, descriptors),\n      ))\n      .reduce((best, curr) => (best.distance < curr.distance ? best : curr));\n  }\n\n  public findBestMatch(queryDescriptor: Float32Array): FaceMatch {\n    const bestMatch = this.matchDescriptor(queryDescriptor);\n    return bestMatch.distance < this.distanceThreshold\n      ? bestMatch\n      : new FaceMatch('unknown', bestMatch.distance);\n  }\n\n  public toJSON(): any {\n    return {\n      distanceThreshold: this.distanceThreshold,\n      labeledDescriptors: this.labeledDescriptors.map((ld) => ld.toJSON()),\n    };\n  }\n\n  public static fromJSON(json: any): FaceMatcher {\n    const labeledDescriptors = json.labeledDescriptors\n      .map((ld: any) => LabeledFaceDescriptors.fromJSON(ld));\n    return new FaceMatcher(labeledDescriptors, json.distanceThreshold);\n  }\n}\n", "import { TinyFaceDetector } from './TinyFaceDetector';\n\nexport * from './TinyFaceDetector';\nexport * from './TinyFaceDetectorOptions';\n\nexport function createTinyFaceDetector(weights: Float32Array) {\n  const net = new TinyFaceDetector();\n  net.extractWeights(weights);\n  return net;\n}\n", "import { Dimensions, IDimensions } from './classes/index';\nimport { FaceDetection } from './classes/FaceDetection';\nimport { FaceLandmarks } from './classes/FaceLandmarks';\nimport { extendWithFaceDetection, isWithFaceDetection } from './factories/WithFaceDetection';\nimport { extendWithFaceLandmarks, isWithFaceLandmarks } from './factories/WithFaceLandmarks';\n\nexport function resizeResults<T>(results: T, dimensions: IDimensions): T {\n\n  const { width, height } = new Dimensions(dimensions.width, dimensions.height)\n\n  if (width <= 0 || height <= 0) {\n    throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({ width, height })}`)\n  }\n\n  if (Array.isArray(results)) {\n    // return results.map(obj => resizeResults(obj, { width, height })) as any as T\n    return (results as Array<any>).map(obj => resizeResults(obj, { width, height } as IDimensions)) as any as T\n  }\n\n  if (isWithFaceLandmarks(results)) {\n    const resizedDetection = results.detection.forSize(width, height)\n    const resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height)\n    return extendWithFaceLandmarks(extendWithFaceDetection(results, resizedDetection), resizedLandmarks)\n  }\n\n  if (isWithFaceDetection(results)) {\n    return extendWithFaceDetection(results, results.detection.forSize(width, height))\n  }\n\n  if (results instanceof FaceLandmarks || results instanceof FaceDetection) {\n    return (results as any).forSize(width, height)\n  }\n\n  return results\n}"],
  "mappings": "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",
  "names": []
}
