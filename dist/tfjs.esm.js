/*
  Face-API
  homepage: <https://github.com/vladmandic/face-api>
  author: <https://github.com/vladmandic>'
*/

var NU=Object.create;var zC=Object.defineProperty;var TU=Object.getOwnPropertyDescriptor;var _U=Object.getOwnPropertyNames;var EU=Object.getPrototypeOf,AU=Object.prototype.hasOwnProperty;var Oe=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),Yt=(r,t)=>{for(var e in t)zC(r,e,{get:t[e],enumerable:!0})},$U=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of _U(t))!AU.call(r,o)&&o!==e&&zC(r,o,{get:()=>t[o],enumerable:!(n=TU(t,o))||n.enumerable});return r};var Ou=(r,t,e)=>(e=r!=null?NU(EU(r)):{},$U(t||!r||!r.__esModule?zC(e,"default",{value:r,enumerable:!0}):e,r));var W1=Oe((rlt,G1)=>{G1.exports=je;var co=null;try{co=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function je(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}je.prototype.__isLong__;Object.defineProperty(je.prototype,"__isLong__",{value:!0});function Ln(r){return(r&&r.__isLong__)===!0}je.isLong=Ln;var F1={},R1={};function Gu(r,t){var e,n,o;return t?(r>>>=0,(o=0<=r&&r<256)&&(n=R1[r],n)?n:(e=Xe(r,(r|0)<0?-1:0,!0),o&&(R1[r]=e),e)):(r|=0,(o=-128<=r&&r<128)&&(n=F1[r],n)?n:(e=Xe(r,r<0?-1:0,!1),o&&(F1[r]=e),e))}je.fromInt=Gu;function po(r,t){if(isNaN(r))return t?Vu:mo;if(t){if(r<0)return Vu;if(r>=L1)return V1}else{if(r<=-M1)return Pn;if(r+1>=M1)return B1}return r<0?po(-r,t).neg():Xe(r%cm|0,r/cm|0,t)}je.fromNumber=po;function Xe(r,t,e){return new je(r,t,e)}je.fromBits=Xe;var wx=Math.pow;function JC(r,t,e){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return mo;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return JC(r.substring(1),t,e).neg();for(var o=po(wx(e,8)),s=mo,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),e);if(a<8){var l=po(wx(e,a));s=s.mul(l).add(po(u))}else s=s.mul(o),s=s.add(po(u))}return s.unsigned=t,s}je.fromString=JC;function qs(r,t){return typeof r=="number"?po(r,t):typeof r=="string"?JC(r,t):Xe(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}je.fromValue=qs;var O1=1<<16,QU=1<<24,cm=O1*O1,L1=cm*cm,M1=L1/2,P1=Gu(QU),mo=Gu(0);je.ZERO=mo;var Vu=Gu(0,!0);je.UZERO=Vu;var um=Gu(1);je.ONE=um;var z1=Gu(1,!0);je.UONE=z1;var ZC=Gu(-1);je.NEG_ONE=ZC;var B1=Xe(-1,2147483647,!1);je.MAX_VALUE=B1;var V1=Xe(-1,-1,!0);je.MAX_UNSIGNED_VALUE=V1;var Pn=Xe(0,-2147483648,!1);je.MIN_VALUE=Pn;var yt=je.prototype;yt.toInt=function(){return this.unsigned?this.low>>>0:this.low};yt.toNumber=function(){return this.unsigned?(this.high>>>0)*cm+(this.low>>>0):this.high*cm+(this.low>>>0)};yt.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Pn)){var e=po(t),n=this.div(e),o=n.mul(e).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=po(wx(t,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,c=l.toString(t);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};yt.getHighBits=function(){return this.high};yt.getHighBitsUnsigned=function(){return this.high>>>0};yt.getLowBits=function(){return this.low};yt.getLowBitsUnsigned=function(){return this.low>>>0};yt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Pn)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&(t&1<<e)==0;e--);return this.high!=0?e+33:e+1};yt.isZero=function(){return this.high===0&&this.low===0};yt.eqz=yt.isZero;yt.isNegative=function(){return!this.unsigned&&this.high<0};yt.isPositive=function(){return this.unsigned||this.high>=0};yt.isOdd=function(){return(this.low&1)===1};yt.isEven=function(){return(this.low&1)===0};yt.equals=function(t){return Ln(t)||(t=qs(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};yt.eq=yt.equals;yt.notEquals=function(t){return!this.eq(t)};yt.neq=yt.notEquals;yt.ne=yt.notEquals;yt.lessThan=function(t){return this.comp(t)<0};yt.lt=yt.lessThan;yt.lessThanOrEqual=function(t){return this.comp(t)<=0};yt.lte=yt.lessThanOrEqual;yt.le=yt.lessThanOrEqual;yt.greaterThan=function(t){return this.comp(t)>0};yt.gt=yt.greaterThan;yt.greaterThanOrEqual=function(t){return this.comp(t)>=0};yt.gte=yt.greaterThanOrEqual;yt.ge=yt.greaterThanOrEqual;yt.compare=function(t){if(Ln(t)||(t=qs(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};yt.comp=yt.compare;yt.negate=function(){return!this.unsigned&&this.eq(Pn)?Pn:this.not().add(um)};yt.neg=yt.negate;yt.add=function(t){Ln(t)||(t=qs(t));var e=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,u=t.low>>>16,l=t.low&65535,c=0,p=0,m=0,f=0;return f+=s+l,m+=f>>>16,f&=65535,m+=o+u,p+=m>>>16,m&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,Xe(m<<16|f,c<<16|p,this.unsigned)};yt.subtract=function(t){return Ln(t)||(t=qs(t)),this.add(t.neg())};yt.sub=yt.subtract;yt.multiply=function(t){if(this.isZero())return mo;if(Ln(t)||(t=qs(t)),co){var e=co.mul(this.low,this.high,t.low,t.high);return Xe(e,co.get_high(),this.unsigned)}if(t.isZero())return mo;if(this.eq(Pn))return t.isOdd()?Pn:mo;if(t.eq(Pn))return this.isOdd()?Pn:mo;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(P1)&&t.lt(P1))return po(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,u=t.high&65535,l=t.low>>>16,c=t.low&65535,p=0,m=0,f=0,d=0;return d+=i*c,f+=d>>>16,d&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=i*l,m+=f>>>16,f&=65535,m+=o*c,p+=m>>>16,m&=65535,m+=s*l,p+=m>>>16,m&=65535,m+=i*u,p+=m>>>16,m&=65535,p+=n*c+o*l+s*u+i*a,p&=65535,Xe(f<<16|d,p<<16|m,this.unsigned)};yt.mul=yt.multiply;yt.divide=function(t){if(Ln(t)||(t=qs(t)),t.isZero())throw Error("division by zero");if(co){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?co.div_u:co.div_s)(this.low,this.high,t.low,t.high);return Xe(e,co.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Vu:mo;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return Vu;if(t.gt(this.shru(1)))return z1;s=Vu}else{if(this.eq(Pn)){if(t.eq(um)||t.eq(ZC))return Pn;if(t.eq(Pn))return um;var i=this.shr(1);return n=i.div(t).shl(1),n.eq(mo)?t.isNegative()?um:ZC:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(Pn))return this.unsigned?Vu:mo;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=mo}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:wx(2,a-48),l=po(n),c=l.mul(t);c.isNegative()||c.gt(o);)n-=u,l=po(n,this.unsigned),c=l.mul(t);l.isZero()&&(l=um),s=s.add(l),o=o.sub(c)}return s};yt.div=yt.divide;yt.modulo=function(t){if(Ln(t)||(t=qs(t)),co){var e=(this.unsigned?co.rem_u:co.rem_s)(this.low,this.high,t.low,t.high);return Xe(e,co.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};yt.mod=yt.modulo;yt.rem=yt.modulo;yt.not=function(){return Xe(~this.low,~this.high,this.unsigned)};yt.and=function(t){return Ln(t)||(t=qs(t)),Xe(this.low&t.low,this.high&t.high,this.unsigned)};yt.or=function(t){return Ln(t)||(t=qs(t)),Xe(this.low|t.low,this.high|t.high,this.unsigned)};yt.xor=function(t){return Ln(t)||(t=qs(t)),Xe(this.low^t.low,this.high^t.high,this.unsigned)};yt.shiftLeft=function(t){return Ln(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Xe(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Xe(0,this.low<<t-32,this.unsigned)};yt.shl=yt.shiftLeft;yt.shiftRight=function(t){return Ln(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Xe(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Xe(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};yt.shr=yt.shiftRight;yt.shiftRightUnsigned=function(t){if(Ln(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var n=this.low;return Xe(n>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?Xe(e,0,this.unsigned):Xe(e>>>t-32,0,this.unsigned)};yt.shru=yt.shiftRightUnsigned;yt.shr_u=yt.shiftRightUnsigned;yt.toSigned=function(){return this.unsigned?Xe(this.low,this.high,!1):this};yt.toUnsigned=function(){return this.unsigned?this:Xe(this.low,this.high,!0)};yt.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};yt.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};yt.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};je.fromBytes=function(t,e,n){return n?je.fromBytesLE(t,e):je.fromBytesBE(t,e)};je.fromBytesLE=function(t,e){return new je(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};je.fromBytesBE=function(t,e){return new je(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var S_=Oe(()=>{});var k_=Oe(()=>{});var iE=Oe((sE,uS)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=l.toString();for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(sE,typeof uS=="object"&&uS,typeof define=="function"&&define)});var lE=Oe((aE,cS)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(aE,typeof cS=="object"&&cS,typeof define=="function"&&define)});var cE=Oe((uE,pS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(uE,typeof pS=="object"&&pS,typeof define=="function"&&define)});var mE=Oe((pE,mS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(pE,typeof mS=="object"&&mS,typeof define=="function"&&define)});var dE=Oe((fE,fS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(fE,typeof fS=="object"&&fS,typeof define=="function"&&define)});var gE=Oe((hE,dS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(hE,typeof dS=="object"&&dS,typeof define=="function"&&define)});var hS=Oe(()=>{});var xE=Oe((hSt,Wx)=>{(function(r,t){var e=this,n=256,o=6,s=52,i="random",a=t.pow(n,o),u=t.pow(2,s),l=u*2,c=n-1,p;function m(w,v,k){var E=[];v=v==!0?{entropy:!0}:v||{};var $=g(h(v.entropy?[w,b(r)]:w==null?y():w,3),E),D=new f(E),F=function(){for(var P=D.g(o),W=a,U=0;P<u;)P=(P+U)*n,W*=n,U=D.g(1);for(;P>=l;)P/=2,W/=2,U>>>=1;return(P+U)/W};return F.int32=function(){return D.g(4)|0},F.quick=function(){return D.g(4)/4294967296},F.double=F,g(b(D.S),r),(v.pass||k||function(P,W,U,q){return q&&(q.S&&d(q,D),P.state=function(){return d(D,{})}),U?(t[i]=P,W):P})(F,$,"global"in v?v.global:this==t,v.state)}t["seed"+i]=m;function f(w){var v,k=w.length,E=this,$=0,D=E.i=E.j=0,F=E.S=[];for(k||(w=[k++]);$<n;)F[$]=$++;for($=0;$<n;$++)F[$]=F[D=c&D+w[$%k]+(v=F[$])],F[D]=v;(E.g=function(P){for(var W,U=0,q=E.i,K=E.j,j=E.S;P--;)W=j[q=c&q+1],U=U*n+j[c&(j[q]=j[K=c&K+W])+(j[K]=W)];return E.i=q,E.j=K,U})(n)}function d(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function h(w,v){var k=[],E=typeof w,$;if(v&&E=="object")for($ in w)try{k.push(h(w[$],v-1))}catch(D){}return k.length?k:E=="string"?w:w+"\0"}function g(w,v){for(var k=w+"",E,$=0;$<k.length;)v[c&$]=c&(E^=v[c&$]*19)+k.charCodeAt($++);return b(v)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(e.crypto||e.msCrypto).getRandomValues(w)),b(w)}catch(E){var v=e.navigator,k=v&&v.plugins;return[+new Date,e,k,e.screen,b(r)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),r),typeof Wx=="object"&&Wx.exports){Wx.exports=m;try{p=hS()}catch(w){}}else typeof define=="function"&&define.amd&&define(function(){return m})})([],Math)});var gS=Oe((gSt,yE)=>{var ij=iE(),aj=lE(),lj=cE(),uj=mE(),cj=dE(),pj=gE(),lc=xE();lc.alea=ij;lc.xor128=aj;lc.xorwow=lj;lc.xorshift7=uj;lc.xor4096=cj;lc.tychei=pj;yE.exports=lc});var QD=Oe((JD,kk)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=String(l);for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(JD,typeof kk=="object"&&kk,typeof define=="function"&&define)});var eF=Oe((tF,Nk)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(tF,typeof Nk=="object"&&Nk,typeof define=="function"&&define)});var nF=Oe((rF,Tk)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(rF,typeof Tk=="object"&&Tk,typeof define=="function"&&define)});var sF=Oe((oF,_k)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(oF,typeof _k=="object"&&_k,typeof define=="function"&&define)});var aF=Oe((iF,Ek)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(iF,typeof Ek=="object"&&Ek,typeof define=="function"&&define)});var uF=Oe((lF,Ak)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(lF,typeof Ak=="object"&&Ak,typeof define=="function"&&define)});var pF=Oe((cF,Fb)=>{(function(r,t,e){var n=256,o=6,s=52,i="random",a=e.pow(n,o),u=e.pow(2,s),l=u*2,c=n-1,p;function m(w,v,k){var E=[];v=v==!0?{entropy:!0}:v||{};var $=g(h(v.entropy?[w,b(t)]:w==null?y():w,3),E),D=new f(E),F=function(){for(var P=D.g(o),W=a,U=0;P<u;)P=(P+U)*n,W*=n,U=D.g(1);for(;P>=l;)P/=2,W/=2,U>>>=1;return(P+U)/W};return F.int32=function(){return D.g(4)|0},F.quick=function(){return D.g(4)/4294967296},F.double=F,g(b(D.S),t),(v.pass||k||function(P,W,U,q){return q&&(q.S&&d(q,D),P.state=function(){return d(D,{})}),U?(e[i]=P,W):P})(F,$,"global"in v?v.global:this==e,v.state)}function f(w){var v,k=w.length,E=this,$=0,D=E.i=E.j=0,F=E.S=[];for(k||(w=[k++]);$<n;)F[$]=$++;for($=0;$<n;$++)F[$]=F[D=c&D+w[$%k]+(v=F[$])],F[D]=v;(E.g=function(P){for(var W,U=0,q=E.i,K=E.j,j=E.S;P--;)W=j[q=c&q+1],U=U*n+j[c&(j[q]=j[K=c&K+W])+(j[K]=W)];return E.i=q,E.j=K,U})(n)}function d(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function h(w,v){var k=[],E=typeof w,$;if(v&&E=="object")for($ in w)try{k.push(h(w[$],v-1))}catch(D){}return k.length?k:E=="string"?w:w+"\0"}function g(w,v){for(var k=w+"",E,$=0;$<k.length;)v[c&$]=c&(E^=v[c&$]*19)+k.charCodeAt($++);return b(v)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(w)),b(w)}catch(E){var v=r.navigator,k=v&&v.plugins;return[+new Date,r,k,r.screen,b(t)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(e.random(),t),typeof Fb=="object"&&Fb.exports){Fb.exports=m;try{p=hS()}catch(w){}}else typeof define=="function"&&define.amd?define(function(){return m}):e["seed"+i]=m})(typeof self!="undefined"?self:cF,[],Math)});var $k=Oe((Eae,mF)=>{var NZ=QD(),TZ=eF(),_Z=nF(),EZ=sF(),AZ=aF(),$Z=uF(),Uc=pF();Uc.alea=NZ;Uc.xor128=TZ;Uc.xorwow=_Z;Uc.xorshift7=EZ;Uc.xor4096=AZ;Uc.tychei=$Z;mF.exports=Uc});var Dk=Oe(()=>{});var Wb=Oe(()=>{});var Rg=Oe(()=>{});var IW=Oe(()=>{});var SW=Oe(()=>{});var kW=Oe(()=>{});var NW=Oe((s0,YT)=>{var XT=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};function e(){return Ot.buffer!=gr&&Go(Ot.buffer),mp}function n(){return Ot.buffer!=gr&&Go(Ot.buffer),fp}function o(){return Ot.buffer!=gr&&Go(Ot.buffer),Ad}function s(){return Ot.buffer!=gr&&Go(Ot.buffer),zg}function i(){return Ot.buffer!=gr&&Go(Ot.buffer),Bg}function a(){return Ot.buffer!=gr&&Go(Ot.buffer),Vg}function u(){return Ot.buffer!=gr&&Go(Ot.buffer),Gg}var l=typeof t!="undefined"?t:{},c,p;l.ready=new Promise(function(T,O){c=T,p=O});var m;typeof process!="undefined"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},l),d=[],h="./this.program",g=(T,O)=>{throw O},y=typeof window=="object",b=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=l.ENVIRONMENT_IS_PTHREAD||!1,k="";function E(T){return l.locateFile?l.locateFile(T,k):k+T}var $,D,F,P;function W(T){if(T instanceof Bd)return;X("exiting due to exception: "+T)}var U,q,K;if(w){b?k=Rg().dirname(k)+"/":k=__dirname+"/",K=()=>{q||(U=Wb(),q=Rg())},$=function(G,Y){return K(),G=q.normalize(G),U.readFileSync(G,Y?void 0:"utf8")},F=O=>{var G=$(O,!0);return G.buffer||(G=new Uint8Array(G)),G},D=(O,G,Y)=>{K(),O=q.normalize(O),U.readFile(O,function(ht,wt){ht?Y(ht):G(wt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(O){if(!(O instanceof Bd))throw O}),process.on("unhandledRejection",function(O){throw O}),g=(O,G)=>{if(Au())throw process.exitCode=O,G;W(G),process.exit(O)},l.inspect=function(){return"[Emscripten Module object]"};let T;try{T=IW()}catch(O){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),O}global.Worker=T.Worker}else(y||b)&&(b?k=self.location.href:typeof document!="undefined"&&document.currentScript&&(k=document.currentScript.src),typeof r!="undefined"&&r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",w||($=T=>{var O=new XMLHttpRequest;return O.open("GET",T,!1),O.send(null),O.responseText},b&&(F=T=>{var O=new XMLHttpRequest;return O.open("GET",T,!1),O.responseType="arraybuffer",O.send(null),new Uint8Array(O.response)}),D=(T,O,G)=>{var Y=new XMLHttpRequest;Y.open("GET",T,!0),Y.responseType="arraybuffer",Y.onload=()=>{if(Y.status==200||Y.status==0&&Y.response){O(Y.response);return}G()},Y.onerror=G,Y.send(null)}),P=T=>document.title=T);w&&typeof performance=="undefined"&&(global.performance=SW().performance);var j=console.log.bind(console),Q=console.warn.bind(console);w&&(K(),j=T=>U.writeSync(1,T+`
`),Q=T=>U.writeSync(2,T+`
`));var rt=l.print||j,X=l.printErr||Q;Object.assign(l,f),f=null,l.arguments&&(d=l.arguments),l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit);var nt=4;function st(T){st.shown||(st.shown={}),st.shown[T]||(st.shown[T]=1,X(T))}function it(T,O){if(typeof WebAssembly.Function=="function"){for(var G={i:"i32",j:"i64",f:"f32",d:"f64"},Y={parameters:[],results:O[0]=="v"?[]:[G[O[0]]]},ht=1;ht<O.length;++ht)Y.parameters.push(G[O[ht]]);return new WebAssembly.Function(Y,T)}var wt=[1,0,1,96],Tt=O.slice(0,1),Gt=O.slice(1),sr={i:127,j:126,f:125,d:124};wt.push(Gt.length);for(var ht=0;ht<Gt.length;++ht)wt.push(sr[Gt[ht]]);Tt=="v"?wt.push(0):wt=wt.concat([1,sr[Tt]]),wt[1]=wt.length-2;var qo=new Uint8Array([0,97,115,109,1,0,0,0].concat(wt,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Ko=new WebAssembly.Module(qo),gx=new WebAssembly.Instance(Ko,{e:{f:T}}),Vd=gx.exports.f;return Vd}var ft=[],at;function xt(){if(ft.length)return ft.pop();try{qn.grow(1)}catch(T){throw T instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":T}return qn.length-1}function dt(T,O){for(var G=T;G<T+O;G++){var Y=yp(G);Y&&at.set(Y,G)}}var bt=0,kt=T=>{bt=T},At=Atomics.load,Dt=Atomics.store,qt=Atomics.compareExchange,Kt;l.wasmBinary&&(Kt=l.wasmBinary);var ce=l.noExitRuntime||!0;typeof WebAssembly!="object"&&hp("no native wasm support detected");var Ot,$e,ke=!1,ae;function Ke(T,O){T||hp(O)}function Re(T){var O=l["_"+T];return O}function rn(T,O,G,Y,ht){var wt={string:function(On){var kp=0;if(On!=null&&On!==0){var C1=(On.length<<2)+1;kp=Sp(C1),Rn(On,kp,C1)}return kp},array:function(On){var kp=Sp(On.length);return _l(On,kp),kp}};function Tt(On){return O==="string"?jr(On):O==="boolean"?Boolean(On):On}var Gt=Re(T),sr=[],qo=0;if(Y)for(var Ko=0;Ko<Y.length;Ko++){var gx=wt[G[Ko]];gx?(qo===0&&(qo=PC()),sr[Ko]=gx(Y[Ko])):sr[Ko]=Y[Ko]}var Vd=Gt.apply(null,sr);function kU(On){return qo!==0&&mx(qo),Tt(On)}return Vd=kU(Vd),Vd}function ze(T,O,G,Y){G=G||[];var ht=G.every(function(Tt){return Tt==="number"}),wt=O!=="string";return wt&&ht&&!Y?Re(T):function(){return rn(T,O,G,arguments,Y)}}var Bo=1;function Or(T){var O=new TextDecoder(T);this.decode=G=>(G.buffer instanceof SharedArrayBuffer&&(G=new Uint8Array(G)),O.decode.call(O,G))}var nn=typeof TextDecoder!="undefined"?new Or("utf8"):void 0;function on(T,O,G){for(var Y=O+G,ht=O;T[ht]&&!(ht>=Y);)++ht;if(ht-O>16&&T.subarray&&nn)return nn.decode(T.subarray(O,ht));for(var wt="";O<ht;){var Tt=T[O++];if(!(Tt&128)){wt+=String.fromCharCode(Tt);continue}var Gt=T[O++]&63;if((Tt&224)==192){wt+=String.fromCharCode((Tt&31)<<6|Gt);continue}var sr=T[O++]&63;if((Tt&240)==224?Tt=(Tt&15)<<12|Gt<<6|sr:Tt=(Tt&7)<<18|Gt<<12|sr<<6|T[O++]&63,Tt<65536)wt+=String.fromCharCode(Tt);else{var qo=Tt-65536;wt+=String.fromCharCode(55296|qo>>10,56320|qo&1023)}}return wt}function jr(T,O){return T?on(n(),T,O):""}function oo(T,O,G,Y){if(!(Y>0))return 0;for(var ht=G,wt=G+Y-1,Tt=0;Tt<T.length;++Tt){var Gt=T.charCodeAt(Tt);if(Gt>=55296&&Gt<=57343){var sr=T.charCodeAt(++Tt);Gt=65536+((Gt&1023)<<10)|sr&1023}if(Gt<=127){if(G>=wt)break;O[G++]=Gt}else if(Gt<=2047){if(G+1>=wt)break;O[G++]=192|Gt>>6,O[G++]=128|Gt&63}else if(Gt<=65535){if(G+2>=wt)break;O[G++]=224|Gt>>12,O[G++]=128|Gt>>6&63,O[G++]=128|Gt&63}else{if(G+3>=wt)break;O[G++]=240|Gt>>18,O[G++]=128|Gt>>12&63,O[G++]=128|Gt>>6&63,O[G++]=128|Gt&63}}return O[G]=0,G-ht}function Rn(T,O,G){return oo(T,n(),O,G)}function Vo(T){for(var O=0,G=0;G<T.length;++G){var Y=T.charCodeAt(G);Y>=55296&&Y<=57343&&(Y=65536+((Y&1023)<<10)|T.charCodeAt(++G)&1023),Y<=127?++O:Y<=2047?O+=2:Y<=65535?O+=3:O+=4}return O}var so=typeof TextDecoder!="undefined"?new Or("utf-16le"):void 0;function _l(T,O){e().set(T,O)}function _u(T,O,G){for(var Y=0;Y<T.length;++Y)e()[O++>>0]=T.charCodeAt(Y);G||(e()[O>>0]=0)}function pp(T,O){return T%O>0&&(T+=O-T%O),T}var gr,mp,fp,Ad,zg,Bg,r1,Vg,Gg;v&&(gr=l.buffer);function Go(T){gr=T,l.HEAP8=mp=new Int8Array(T),l.HEAP16=Ad=new Int16Array(T),l.HEAP32=Bg=new Int32Array(T),l.HEAPU8=fp=new Uint8Array(T),l.HEAPU16=zg=new Uint16Array(T),l.HEAPU32=r1=new Uint32Array(T),l.HEAPF32=Vg=new Float32Array(T),l.HEAPF64=Gg=new Float64Array(T)}var Wg=l.INITIAL_MEMORY||16777216;if(v)Ot=l.wasmMemory,gr=l.buffer;else if(l.wasmMemory)Ot=l.wasmMemory;else if(Ot=new WebAssembly.Memory({initial:Wg/65536,maximum:32768,shared:!0}),!(Ot.buffer instanceof SharedArrayBuffer))throw X("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Ot&&(gr=Ot.buffer),Wg=gr.byteLength,Go(gr);var qn,dp=[],El=[],l0=[],Ug=[],Eu=!1,u0=!1,Hg=0;function Au(){return ce||Hg>0}function sn(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)n1(l.preRun.shift());Xg(dp)}function $d(){Eu=!0,!v&&Xg(El)}function c0(){v||(Ut.terminateAllThreads(),u0=!0)}function p0(){if(!v){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)Dd(l.postRun.shift());Xg(Ug)}}function n1(T){dp.unshift(T)}function o1(T){El.unshift(T)}function Dd(T){Ug.unshift(T)}var Al=0,qg=null,Wo=null;function Fd(T){Al++,l.monitorRunDependencies&&l.monitorRunDependencies(Al)}function s1(T){if(Al--,l.monitorRunDependencies&&l.monitorRunDependencies(Al),Al==0&&(qg!==null&&(clearInterval(qg),qg=null),Wo)){var O=Wo;Wo=null,O()}}l.preloadedImages={},l.preloadedAudios={};function hp(T){v?postMessage({cmd:"onAbort",arg:T}):l.onAbort&&l.onAbort(T),T="Aborted("+T+")",X(T),ke=!0,ae=1,T+=". Build with -s ASSERTIONS=1 for more info.";var O=new WebAssembly.RuntimeError(T);throw p(O),O}var m0="data:application/octet-stream;base64,";function Rd(T){return T.startsWith(m0)}function Kg(T){return T.startsWith("file://")}var an;an="tfjs-backend-wasm-threaded-simd.wasm",Rd(an)||(an=E(an));function jg(T){try{if(T==an&&Kt)return new Uint8Array(Kt);if(F)return F(T);throw"both async and sync fetching of the wasm failed"}catch(O){hp(O)}}function gp(){if(!Kt&&(y||b)){if(typeof fetch=="function"&&!Kg(an))return fetch(an,{credentials:"same-origin"}).then(function(T){if(!T.ok)throw"failed to load wasm binary file at '"+an+"'";return T.arrayBuffer()}).catch(function(){return jg(an)});if(D)return new Promise(function(T,O){D(an,function(G){T(new Uint8Array(G))},O)})}return Promise.resolve().then(function(){return jg(an)})}function f0(){var T={env:ax,wasi_snapshot_preview1:ax};function O(Tt,Gt){var sr=Tt.exports;if(l.asm=sr,w0(l.asm.emscripten_tls_init),qn=l.asm.__indirect_function_table,o1(l.asm.__wasm_call_ctors),$e=Gt,!v){var qo=Ut.unusedWorkers.length;Ut.unusedWorkers.forEach(function(Ko){Ut.loadWasmModuleToWorker(Ko,function(){--qo||s1("wasm-instantiate")})})}}v||Fd("wasm-instantiate");function G(Tt){O(Tt.instance,Tt.module)}function Y(Tt){return gp().then(function(Gt){return WebAssembly.instantiate(Gt,T)}).then(function(Gt){return Gt}).then(Tt,function(Gt){X("failed to asynchronously prepare wasm: "+Gt),hp(Gt)})}function ht(){return!Kt&&typeof WebAssembly.instantiateStreaming=="function"&&!Rd(an)&&!Kg(an)&&typeof fetch=="function"?fetch(an,{credentials:"same-origin"}).then(function(Tt){var Gt=WebAssembly.instantiateStreaming(Tt,T);return Gt.then(G,function(sr){return X("wasm streaming compile failed: "+sr),X("falling back to ArrayBuffer instantiation"),Y(G)})}):Y(G)}if(l.instantiateWasm)try{var wt=l.instantiateWasm(T,O);return wt}catch(Tt){return X("Module.instantiateWasm callback failed with error: "+Tt),!1}return ht().catch(p),{}}var i1,a1,d0={};function Xg(T){for(;T.length>0;){var O=T.shift();if(typeof O=="function"){O(l);continue}var G=O.func;typeof G=="number"?O.arg===void 0?yp(G)():yp(G)(O.arg):G(O.arg===void 0?null:O.arg)}}function xp(T){var O=PC(),G=T();return mx(O),G}function FW(T){return T}function l1(T){var O=/\b_Z[\w\d_]+/g;return T.replace(O,function(G){var Y=G;return G===Y?G:Y+" ["+G+"]"})}function h0(T){i()[T>>2]=0;var O=Ut.pthreads[T];delete Ut.pthreads[T],O.worker.terminate(),MC(T),Ut.runningWorkers.splice(Ut.runningWorkers.indexOf(O.worker),1),O.worker.pthread=void 0}function g0(T){var O=Ut.pthreads[T];O.worker.postMessage({cmd:"cancel"})}function Yg(T){var O=Ut.pthreads[T];if(O){i()[T>>2]=0;var G=O.worker;Ut.returnWorkerToPool(G)}}function Zg(T){CU(T)}function x0(T){if(T instanceof Bd||T=="unwind")return ae;g(1,T)}var Ut={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){v?Ut.initWorker():Ut.initMainThread()},initMainThread:function(){for(var T=8,O=0;O<T;++O)Ut.allocateUnusedWorker()},initWorker:function(){ce=!1},pthreads:{},setExitStatus:function(T){ae=T},terminateAllThreads:function(){for(var T in Ut.pthreads){var O=Ut.pthreads[T];O&&O.worker&&Ut.returnWorkerToPool(O.worker)}for(var G=0;G<Ut.unusedWorkers.length;++G){var Y=Ut.unusedWorkers[G];Y.terminate()}Ut.unusedWorkers=[]},returnWorkerToPool:function(T){Ut.runWithoutMainThreadQueuedCalls(function(){delete Ut.pthreads[T.pthread.threadInfoStruct],Ut.unusedWorkers.push(T),Ut.runningWorkers.splice(Ut.runningWorkers.indexOf(T),1),MC(T.pthread.threadInfoStruct),T.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(T){i()[v1>>2]=0;try{T()}finally{i()[v1>>2]=1}},receiveObjectTransfer:function(T){},threadInit:function(){for(var T in Ut.tlsInitFunctions)Ut.tlsInitFunctions[T]()},loadWasmModuleToWorker:function(T,O){T.onmessage=G=>{var Y=G.data,ht=Y.cmd;if(T.pthread&&(Ut.currentProxiedOperationCallerThread=T.pthread.threadInfoStruct),Y.targetThread&&Y.targetThread!=px()){var wt=Ut.pthreads[Y.targetThread];wt?wt.worker.postMessage(Y,Y.transferList):X('Internal error! Worker sent a message "'+ht+'" to target pthread '+Y.targetThread+", but that thread no longer exists!"),Ut.currentProxiedOperationCallerThread=void 0;return}ht==="processQueuedMainThreadWork"?g1():ht==="spawnThread"?Qg(Y):ht==="cleanupThread"?Yg(Y.thread):ht==="killThread"?h0(Y.thread):ht==="cancelThread"?g0(Y.thread):ht==="loaded"?(T.loaded=!0,O&&O(T),T.runPthread&&(T.runPthread(),delete T.runPthread)):ht==="print"?rt("Thread "+Y.threadId+": "+Y.text):ht==="printErr"?X("Thread "+Y.threadId+": "+Y.text):ht==="alert"?alert("Thread "+Y.threadId+": "+Y.text):Y.target==="setimmediate"?T.postMessage(Y):ht==="onAbort"?l.onAbort&&l.onAbort(Y.arg):X("worker sent an unknown command "+ht),Ut.currentProxiedOperationCallerThread=void 0},T.onerror=G=>{var Y="worker sent an error!";throw X(Y+" "+G.filename+":"+G.lineno+": "+G.message),G},w&&(T.on("message",function(G){T.onmessage({data:G})}),T.on("error",function(G){T.onerror(G)}),T.on("detachedExit",function(){})),T.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:Ot,wasmModule:$e})},allocateUnusedWorker:function(){var T=E("tfjs-backend-wasm-threaded-simd.worker.js");Ut.unusedWorkers.push(new Worker(T))},getNewWorker:function(){return Ut.unusedWorkers.length==0&&(Ut.allocateUnusedWorker(),Ut.loadWasmModuleToWorker(Ut.unusedWorkers[0])),Ut.unusedWorkers.pop()}};function y0(){var T=px(),O=i()[T+44>>2],G=i()[T+48>>2],Y=O-G;w1(O,Y),mx(O)}l.establishStackSpace=y0;function Jg(T){if(v)return Fu(1,0,T);try{Zg(T)}catch(O){x0(O)}}var $u=[];function yp(T){var O=$u[T];return O||(T>=$u.length&&($u.length=T+1),$u[T]=O=qn.get(T)),O}function b0(T,O){return yp(T)(O)}l.invokeEntryPoint=b0;function u1(){var T=new Error;if(!T.stack){try{throw new Error}catch(O){T=O}if(!T.stack)return"(no stack trace available)"}return T.stack.toString()}function w0(T,O,G){Ut.tlsInitFunctions.push(T)}function c1(T,O){qn.set(T,O),$u[T]=O}var Du;w?Du=()=>{var T=process.hrtime();return T[0]*1e3+T[1]/1e6}:v?Du=()=>performance.now()-l.__performance_now_clock_drift:Du=()=>performance.now();var v0=!0;function C0(T){return i()[h1()>>2]=T,T}function I0(T,O){var G;if(T===0)G=Date.now();else if((T===1||T===4)&&v0)G=Du();else return C0(28),-1;return i()[O>>2]=G/1e3|0,i()[O+4>>2]=G%1e3*1e3*1e3|0,0}function S0(T,O){return I0(T,O)}function k0(T){x1(T,!b,1,!y),Ut.threadInit()}function N0(T){v?postMessage({cmd:"cleanupThread",thread:T}):Yg(T)}function Qg(T){var O=Ut.getNewWorker();if(!O)return 6;Ut.runningWorkers.push(O);var G=Ut.pthreads[T.pthread_ptr]={worker:O,threadInfoStruct:T.pthread_ptr};O.pthread=G;var Y={cmd:"run",start_routine:T.startRoutine,arg:T.arg,threadInfoStruct:T.pthread_ptr};return O.runPthread=()=>{Y.time=performance.now(),O.postMessage(Y,T.transferList)},O.loaded&&(O.runPthread(),delete O.runPthread),0}function T0(T,O,G,Y){if(typeof SharedArrayBuffer=="undefined")return X("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ht=[],wt=0;if(v&&(ht.length===0||wt))return y1(687865856,T,O,G,Y);if(wt)return wt;var Tt={startRoutine:G,pthread_ptr:T,arg:Y,transferList:ht};return v?(Tt.cmd="spawnThread",postMessage(Tt,ht),0):Qg(Tt)}function _0(){return 2097152}function E0(T,O){if(T==O)postMessage({cmd:"processQueuedMainThreadWork"});else if(v)postMessage({targetThread:T,cmd:"processThreadQueue"});else{var G=Ut.pthreads[T],Y=G&&G.worker;if(!Y)return;Y.postMessage({cmd:"processThreadQueue"})}return 1}function A0(){hp("")}function $0(){w||b||st("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function tx(){return 2147483648}function D0(T,O,G){n().copyWithin(T,O,O+G)}function F0(){return w?kW().cpus().length:navigator.hardwareConcurrency}function Fu(T,O){var G=arguments.length-2,Y=arguments;return xp(function(){for(var ht=G,wt=Sp(ht*8),Tt=wt>>3,Gt=0;Gt<G;Gt++){var sr=Y[2+Gt];u()[Tt+Gt]=sr}return b1(T,ht,wt,O)})}var Od=[];function R0(T,O,G){Od.length=O;for(var Y=G>>3,ht=0;ht<O;ht++)Od[ht]=u()[Y+ht];var wt=T<0,Tt=wt?d0[-T-1]:Q0[T];return Tt.apply(null,Od)}function O0(T){try{return Ot.grow(T-gr.byteLength+65535>>>16),Go(Ot.buffer),1}catch(O){}}function M0(T){var O=n().length;if(T=T>>>0,T<=O)return!1;var G=tx();if(T>G)return!1;for(var Y=1;Y<=4;Y*=2){var ht=O*(1+.2/Y);ht=Math.min(ht,T+100663296);var wt=Math.min(G,pp(Math.max(T,ht),65536)),Tt=O0(wt);if(Tt)return!0}return!1}var ne={inEventHandler:0,removeAllEventListeners:function(){for(var T=ne.eventHandlers.length-1;T>=0;--T)ne._removeHandler(T);ne.eventHandlers=[],ne.deferredCalls=[]},registerRemoveEventListeners:function(){ne.removeEventListenersRegistered||(l0.push(ne.removeAllEventListeners),ne.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(T,O,G){function Y(Tt,Gt){if(Tt.length!=Gt.length)return!1;for(var sr in Tt)if(Tt[sr]!=Gt[sr])return!1;return!0}for(var ht in ne.deferredCalls){var wt=ne.deferredCalls[ht];if(wt.targetFunction==T&&Y(wt.argsList,G))return}ne.deferredCalls.push({targetFunction:T,precedence:O,argsList:G}),ne.deferredCalls.sort(function(Tt,Gt){return Tt.precedence<Gt.precedence})},removeDeferredCalls:function(T){for(var O=0;O<ne.deferredCalls.length;++O)ne.deferredCalls[O].targetFunction==T&&(ne.deferredCalls.splice(O,1),--O)},canPerformEventHandlerRequests:function(){return ne.inEventHandler&&ne.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!ne.canPerformEventHandlerRequests())for(var T=0;T<ne.deferredCalls.length;++T){var O=ne.deferredCalls[T];ne.deferredCalls.splice(T,1),--T,O.targetFunction.apply(null,O.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(T,O){for(var G=0;G<ne.eventHandlers.length;++G)ne.eventHandlers[G].target==T&&(!O||O==ne.eventHandlers[G].eventTypeString)&&ne._removeHandler(G--)},_removeHandler:function(T){var O=ne.eventHandlers[T];O.target.removeEventListener(O.eventTypeString,O.eventListenerFunc,O.useCapture),ne.eventHandlers.splice(T,1)},registerOrRemoveHandler:function(T){var O=function(ht){++ne.inEventHandler,ne.currentEventHandler=T,ne.runDeferredCalls(),T.handlerFunc(ht),ne.runDeferredCalls(),--ne.inEventHandler};if(T.callbackfunc)T.eventListenerFunc=O,T.target.addEventListener(T.eventTypeString,O,T.useCapture),ne.eventHandlers.push(T),ne.registerRemoveEventListeners();else for(var G=0;G<ne.eventHandlers.length;++G)ne.eventHandlers[G].target==T.target&&ne.eventHandlers[G].eventTypeString==T.eventTypeString&&ne._removeHandler(G--)},queueEventHandlerOnThread_iiii:function(T,O,G,Y,ht){xp(function(){var wt=Sp(12);i()[wt>>2]=G,i()[wt+4>>2]=Y,i()[wt+8>>2]=ht,OC(T,637534208,O,Y,wt)})},getTargetThreadForEventCallback:function(T){switch(T){case 1:return 0;case 2:return Ut.currentProxiedOperationCallerThread;default:return T}},getNodeNameForTarget:function(T){return T?T==window?"#window":T==screen?"#screen":T&&T.nodeName?T.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function P0(T){var O=Vo(T)+1,G=RC(O);return Rn(T,G,O),G}function L0(T,O,G,Y){xp(function(){var ht=Sp(12),wt=0;O&&(wt=P0(O)),i()[ht>>2]=wt,i()[ht+4>>2]=G,i()[ht+8>>2]=Y,OC(T,657457152,0,wt,ht)})}function z0(T,O,G,Y){O=O?jr(O):"",L0(T,O,G,Y)}function B0(T){return T>2?jr(T):T}var V0=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function G0(T){T=B0(T);var O=V0[T]||(typeof document!="undefined"?document.querySelector(T):void 0);return O}function Md(T){return G0(T)}function ex(T,O,G){var Y=Md(T);if(!Y)return-4;if(Y.canvasSharedPtr&&(i()[Y.canvasSharedPtr>>2]=O,i()[Y.canvasSharedPtr+4>>2]=G),Y.offscreenCanvas||!Y.controlTransferredOffscreen){Y.offscreenCanvas&&(Y=Y.offscreenCanvas);var ht=!1;if(Y.GLctxObject&&Y.GLctxObject.GLctx){var wt=Y.GLctxObject.GLctx.getParameter(2978);ht=wt[0]===0&&wt[1]===0&&wt[2]===Y.width&&wt[3]===Y.height}Y.width=O,Y.height=G,ht&&Y.GLctxObject.GLctx.viewport(0,0,O,G)}else if(Y.canvasSharedPtr){var Tt=i()[Y.canvasSharedPtr+8>>2];return z0(Tt,T,O,G),1}else return-4;return 0}function rx(T,O,G){return v?Fu(2,1,T,O,G):ex(T,O,G)}function W0(T,O,G){var Y=Md(T);return Y?ex(T,O,G):rx(T,O,G)}function U0(){throw"unwind"}function H0(T){var O=T.getExtension("ANGLE_instanced_arrays");if(O)return T.vertexAttribDivisor=function(G,Y){O.vertexAttribDivisorANGLE(G,Y)},T.drawArraysInstanced=function(G,Y,ht,wt){O.drawArraysInstancedANGLE(G,Y,ht,wt)},T.drawElementsInstanced=function(G,Y,ht,wt,Tt){O.drawElementsInstancedANGLE(G,Y,ht,wt,Tt)},1}function q0(T){var O=T.getExtension("OES_vertex_array_object");if(O)return T.createVertexArray=function(){return O.createVertexArrayOES()},T.deleteVertexArray=function(G){O.deleteVertexArrayOES(G)},T.bindVertexArray=function(G){O.bindVertexArrayOES(G)},T.isVertexArray=function(G){return O.isVertexArrayOES(G)},1}function K0(T){var O=T.getExtension("WEBGL_draw_buffers");if(O)return T.drawBuffers=function(G,Y){O.drawBuffersWEBGL(G,Y)},1}function j0(T){return!!(T.multiDrawWebgl=T.getExtension("WEBGL_multi_draw"))}var or={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(O){or.lastError||(or.lastError=O)},getNewId:function(T){for(var O=or.counter++,G=T.length;G<O;G++)T[G]=null;return O},getSource:function(T,O,G,Y){for(var ht="",wt=0;wt<O;++wt){var Tt=Y?i()[Y+wt*4>>2]:-1;ht+=jr(i()[G+wt*4>>2],Tt<0?void 0:Tt)}return ht},createContext:function(T,O){T.getContextSafariWebGL2Fixed||(T.getContextSafariWebGL2Fixed=T.getContext,T.getContext=function(ht,wt){var Tt=T.getContextSafariWebGL2Fixed(ht,wt);return ht=="webgl"==Tt instanceof WebGLRenderingContext?Tt:null});var G=T.getContext("webgl",O);if(!G)return 0;var Y=or.registerContext(G,O);return Y},registerContext:function(T,O){var G=RC(8);i()[G+4>>2]=px();var Y={handle:G,attributes:O,version:O.majorVersion,GLctx:T};return T.canvas&&(T.canvas.GLctxObject=Y),or.contexts[G]=Y,(typeof O.enableExtensionsByDefault=="undefined"||O.enableExtensionsByDefault)&&or.initExtensions(Y),G},makeContextCurrent:function(T){return or.currentContext=or.contexts[T],l.ctx=ix=or.currentContext&&or.currentContext.GLctx,!(T&&!ix)},getContext:function(T){return or.contexts[T]},deleteContext:function(T){or.currentContext===or.contexts[T]&&(or.currentContext=null),typeof ne=="object"&&ne.removeAllHandlersOnTarget(or.contexts[T].GLctx.canvas),or.contexts[T]&&or.contexts[T].GLctx.canvas&&(or.contexts[T].GLctx.canvas.GLctxObject=void 0),d1(or.contexts[T].handle),or.contexts[T]=null},initExtensions:function(T){if(T||(T=or.currentContext),!T.initExtensionsDone){T.initExtensionsDone=!0;var O=T.GLctx;H0(O),q0(O),K0(O),O.disjointTimerQueryExt=O.getExtension("EXT_disjoint_timer_query"),j0(O);var G=O.getSupportedExtensions()||[];G.forEach(function(Y){!Y.includes("lose_context")&&!Y.includes("debug")&&O.getExtension(Y)})}}},X0=["default","low-power","high-performance"];function Y0(T,O){var G=O>>2,Y=i()[G+6],ht={alpha:!!i()[G+0],depth:!!i()[G+1],stencil:!!i()[G+2],antialias:!!i()[G+3],premultipliedAlpha:!!i()[G+4],preserveDrawingBuffer:!!i()[G+5],powerPreference:X0[Y],failIfMajorPerformanceCaveat:!!i()[G+7],majorVersion:i()[G+8],minorVersion:i()[G+9],enableExtensionsByDefault:i()[G+10],explicitSwapControl:i()[G+11],proxyContextToMainThread:i()[G+12],renderViaOffscreenBackBuffer:i()[G+13]},wt=Md(T);if(!wt||ht.explicitSwapControl)return 0;var Tt=or.createContext(wt,ht);return Tt}function Z0(T,O){return Y0(T,O)}var bp={mappings:{},buffers:[null,[],[]],printChar:function(T,O){var G=bp.buffers[T];O===0||O===10?((T===1?rt:X)(on(G,0)),G.length=0):G.push(O)},varargs:void 0,get:function(){bp.varargs+=4;var T=i()[bp.varargs-4>>2];return T},getStr:function(T){var O=jr(T);return O},get64:function(T,O){return T}};function nx(T){return v?Fu(3,1,T):0}function ox(T,O,G,Y,ht){if(v)return Fu(4,1,T,O,G,Y,ht)}function sx(T,O,G,Y){if(v)return Fu(5,1,T,O,G,Y);for(var ht=0,wt=0;wt<G;wt++){var Tt=i()[O>>2],Gt=i()[O+4>>2];O+=8;for(var sr=0;sr<Gt;sr++)bp.printChar(T,n()[Tt+sr]);ht+=Gt}return i()[Y>>2]=ht,0}function J0(T){kt(T)}Ut.init();var ix,Q0=[null,Jg,rx,nx,ox,sx],p1=!1,ax={__clock_gettime:S0,__emscripten_init_main_thread_js:k0,__emscripten_thread_cleanup:N0,__pthread_create_js:T0,_emscripten_default_pthread_stack_size:_0,_emscripten_notify_thread_queue:E0,abort:A0,emscripten_check_blocking_allowed:$0,emscripten_get_heap_max:tx,emscripten_get_now:Du,emscripten_memcpy_big:D0,emscripten_num_logical_cores:F0,emscripten_receive_on_main_thread_js:R0,emscripten_resize_heap:M0,emscripten_set_canvas_element_size:W0,emscripten_unwind_to_js_event_loop:U0,emscripten_webgl_create_context:Z0,exit:Zg,fd_close:nx,fd_seek:ox,fd_write:sx,memory:Ot||l.wasmMemory,setTempRet0:J0},m1=f0(),tC=l.___wasm_call_ctors=function(){return(tC=l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},eC=l._init=function(){return(eC=l._init=l.asm.init).apply(null,arguments)},rC=l._init_with_threads_count=function(){return(rC=l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},nC=l._get_threads_count=function(){return(nC=l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},oC=l._register_tensor=function(){return(oC=l._register_tensor=l.asm.register_tensor).apply(null,arguments)},sC=l._dispose_data=function(){return(sC=l._dispose_data=l.asm.dispose_data).apply(null,arguments)},iC=l._dispose=function(){return(iC=l._dispose=l.asm.dispose).apply(null,arguments)},aC=l._Abs=function(){return(aC=l._Abs=l.asm.Abs).apply(null,arguments)},lC=l._Add=function(){return(lC=l._Add=l.asm.Add).apply(null,arguments)},uC=l._AddN=function(){return(uC=l._AddN=l.asm.AddN).apply(null,arguments)},cC=l._All=function(){return(cC=l._All=l.asm.All).apply(null,arguments)},pC=l._Any=function(){return(pC=l._Any=l.asm.Any).apply(null,arguments)},mC=l._ArgMax=function(){return(mC=l._ArgMax=l.asm.ArgMax).apply(null,arguments)},fC=l._AvgPool=function(){return(fC=l._AvgPool=l.asm.AvgPool).apply(null,arguments)},dC=l._BatchMatMul=function(){return(dC=l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},hC=l._Ceil=function(){return(hC=l._Ceil=l.asm.Ceil).apply(null,arguments)},gC=l._ClipByValue=function(){return(gC=l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},xC=l._Conv2D=function(){return(xC=l._Conv2D=l.asm.Conv2D).apply(null,arguments)},yC=l._Conv2DBackpropInput=function(){return(yC=l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},bC=l._Cos=function(){return(bC=l._Cos=l.asm.Cos).apply(null,arguments)},wC=l._Cosh=function(){return(wC=l._Cosh=l.asm.Cosh).apply(null,arguments)},vC=l._CropAndResize=function(){return(vC=l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},CC=l._Cumprod=function(){return(CC=l._Cumprod=l.asm.Cumprod).apply(null,arguments)},IC=l._Cumsum=function(){return(IC=l._Cumsum=l.asm.Cumsum).apply(null,arguments)},SC=l._DepthToSpace=function(){return(SC=l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},kC=l._DepthwiseConv2dNative=function(){return(kC=l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},NC=l._Elu=function(){return(NC=l._Elu=l.asm.Elu).apply(null,arguments)},TC=l._Equal=function(){return(TC=l._Equal=l.asm.Equal).apply(null,arguments)},_C=l._Exp=function(){return(_C=l._Exp=l.asm.Exp).apply(null,arguments)},EC=l._FlipLeftRight=function(){return(EC=l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},lx=l._Floor=function(){return(lx=l._Floor=l.asm.Floor).apply(null,arguments)},ux=l._FloorDiv=function(){return(ux=l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},Pd=l._FusedBatchNorm=function(){return(Pd=l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},AC=l._FusedConv2D=function(){return(AC=l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},$C=l._FusedDepthwiseConv2D=function(){return($C=l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},wp=l._Gather=function(){return(wp=l._Gather=l.asm.Gather).apply(null,arguments)},Ld=l._GatherNd=function(){return(Ld=l._GatherNd=l.asm.GatherNd).apply(null,arguments)},zd=l._Greater=function(){return(zd=l._Greater=l.asm.Greater).apply(null,arguments)},f1=l._GreaterEqual=function(){return(f1=l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},vp=l._LeakyRelu=function(){return(vp=l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},Cp=l._Less=function(){return(Cp=l._Less=l.asm.Less).apply(null,arguments)},DC=l._LessEqual=function(){return(DC=l._LessEqual=l.asm.LessEqual).apply(null,arguments)},H=l._Log=function(){return(H=l._Log=l.asm.Log).apply(null,arguments)},tt=l._LogicalAnd=function(){return(tt=l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},gt=l._Max=function(){return(gt=l._Max=l.asm.Max).apply(null,arguments)},$t=l._MaxPool=function(){return($t=l._MaxPool=l.asm.MaxPool).apply(null,arguments)},fe=l._Maximum=function(){return(fe=l._Maximum=l.asm.Maximum).apply(null,arguments)},ge=l._Mean=function(){return(ge=l._Mean=l.asm.Mean).apply(null,arguments)},oe=l._Min=function(){return(oe=l._Min=l.asm.Min).apply(null,arguments)},ee=l._Minimum=function(){return(ee=l._Minimum=l.asm.Minimum).apply(null,arguments)},xr=l._MirrorPad=function(){return(xr=l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},Uo=l._Multiply=function(){return(Uo=l._Multiply=l.asm.Multiply).apply(null,arguments)},Ho=l._Neg=function(){return(Ho=l._Neg=l.asm.Neg).apply(null,arguments)},Ip=l._NonMaxSuppressionV3=function(){return(Ip=l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},Ru=l._NonMaxSuppressionV4=function(){return(Ru=l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},FC=l._NonMaxSuppressionV5=function(){return(FC=l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},ln=l._NotEqual=function(){return(ln=l._NotEqual=l.asm.NotEqual).apply(null,arguments)},$l=l._OneHot=function(){return($l=l._OneHot=l.asm.OneHot).apply(null,arguments)},cx=l._PadV2=function(){return(cx=l._PadV2=l.asm.PadV2).apply(null,arguments)},RW=l._Pow=function(){return(RW=l._Pow=l.asm.Pow).apply(null,arguments)},OW=l._Prelu=function(){return(OW=l._Prelu=l.asm.Prelu).apply(null,arguments)},MW=l._Prod=function(){return(MW=l._Prod=l.asm.Prod).apply(null,arguments)},PW=l._RealDiv=function(){return(PW=l._RealDiv=l.asm.RealDiv).apply(null,arguments)},LW=l._Relu=function(){return(LW=l._Relu=l.asm.Relu).apply(null,arguments)},zW=l._Relu6=function(){return(zW=l._Relu6=l.asm.Relu6).apply(null,arguments)},BW=l._ResizeBilinear=function(){return(BW=l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},VW=l._Reverse=function(){return(VW=l._Reverse=l.asm.Reverse).apply(null,arguments)},GW=l._RotateWithOffset=function(){return(GW=l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},WW=l._Round=function(){return(WW=l._Round=l.asm.Round).apply(null,arguments)},UW=l._Rsqrt=function(){return(UW=l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},HW=l._ScatterNd=function(){return(HW=l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},qW=l._SelectV2=function(){return(qW=l._SelectV2=l.asm.SelectV2).apply(null,arguments)},KW=l._Sigmoid=function(){return(KW=l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},jW=l._Sin=function(){return(jW=l._Sin=l.asm.Sin).apply(null,arguments)},XW=l._Softmax=function(){return(XW=l._Softmax=l.asm.Softmax).apply(null,arguments)},YW=l._SparseFillEmptyRows=function(){return(YW=l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},ZW=l._SparseReshape=function(){return(ZW=l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},JW=l._SparseSegmentReduction=function(){return(JW=l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},QW=l._Sqrt=function(){return(QW=l._Sqrt=l.asm.Sqrt).apply(null,arguments)},tU=l._Square=function(){return(tU=l._Square=l.asm.Square).apply(null,arguments)},eU=l._SquaredDifference=function(){return(eU=l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},rU=l._Step=function(){return(rU=l._Step=l.asm.Step).apply(null,arguments)},nU=l._StridedSlice=function(){return(nU=l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},oU=l._Sub=function(){return(oU=l._Sub=l.asm.Sub).apply(null,arguments)},sU=l._Sum=function(){return(sU=l._Sum=l.asm.Sum).apply(null,arguments)},iU=l._Tan=function(){return(iU=l._Tan=l.asm.Tan).apply(null,arguments)},aU=l._Tanh=function(){return(aU=l._Tanh=l.asm.Tanh).apply(null,arguments)},lU=l._Tile=function(){return(lU=l._Tile=l.asm.Tile).apply(null,arguments)},uU=l._TopK=function(){return(uU=l._TopK=l.asm.TopK).apply(null,arguments)},cU=l._Transform=function(){return(cU=l._Transform=l.asm.Transform).apply(null,arguments)},pU=l._Transpose=function(){return(pU=l._Transpose=l.asm.Transpose).apply(null,arguments)},mU=l.__FusedMatMul=function(){return(mU=l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},RC=l._malloc=function(){return(RC=l._malloc=l.asm.malloc).apply(null,arguments)},d1=l._free=function(){return(d1=l._free=l.asm.free).apply(null,arguments)},fU=l._emscripten_tls_init=function(){return(fU=l._emscripten_tls_init=l.asm.emscripten_tls_init).apply(null,arguments)},h1=l.___errno_location=function(){return(h1=l.___errno_location=l.asm.__errno_location).apply(null,arguments)},px=l._pthread_self=function(){return(px=l._pthread_self=l.asm.pthread_self).apply(null,arguments)},g1=l._emscripten_main_thread_process_queued_calls=function(){return(g1=l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},dU=l.__emscripten_thread_crashed=function(){return(dU=l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},x1=l.__emscripten_thread_init=function(){return(x1=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)},hU=l._emscripten_current_thread_process_queued_calls=function(){return(hU=l._emscripten_current_thread_process_queued_calls=l.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},gU=l._emscripten_main_browser_thread_id=function(){return(gU=l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)},xU=l._emscripten_sync_run_in_main_thread_2=function(){return(xU=l._emscripten_sync_run_in_main_thread_2=l.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},y1=l._emscripten_sync_run_in_main_thread_4=function(){return(y1=l._emscripten_sync_run_in_main_thread_4=l.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)},b1=l._emscripten_run_in_main_runtime_thread_js=function(){return(b1=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},OC=l._emscripten_dispatch_to_thread_=function(){return(OC=l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},MC=l.__emscripten_thread_free_data=function(){return(MC=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},yU=l.__emscripten_thread_exit=function(){return(yU=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},bU=l._memalign=function(){return(bU=l._memalign=l.asm.memalign).apply(null,arguments)},w1=l._emscripten_stack_set_limits=function(){return(w1=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},PC=l.stackSave=function(){return(PC=l.stackSave=l.asm.stackSave).apply(null,arguments)},mx=l.stackRestore=function(){return(mx=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},Sp=l.stackAlloc=function(){return(Sp=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)},wU=l.dynCall_iijjiiii=function(){return(wU=l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},vU=l.dynCall_jiji=function(){return(vU=l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},v1=l.__emscripten_allow_main_runtime_queued_calls=21464;l.cwrap=ze,l.keepRuntimeAlive=Au,l.PThread=Ut,l.PThread=Ut,l.wasmMemory=Ot,l.ExitStatus=Bd;var fx;function Bd(T){this.name="ExitStatus",this.message="Program terminated with exit("+T+")",this.status=T}Wo=function T(){fx||LC(),fx||(Wo=T)};function LC(T){if(T=T||d,Al>0)return;if(v){c(l),$d(),postMessage({cmd:"loaded"});return}if(sn(),Al>0)return;function O(){fx||(fx=!0,l.calledRun=!0,!ke&&($d(),c(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),p0()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),O()},1)):O()}l.run=LC;function CU(T,O){if(ae=T,!O&&v)throw Jg(T),"unwind";Au()||c0(),IU(T)}function IU(T){ae=T,Au()||(Ut.terminateAllThreads(),l.onExit&&l.onExit(T),ke=!0),g(T,new Bd(T))}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();LC();var dx;m&&(dx={uncaughtException:process.listeners("uncaughtException").filter(function(T){return!m.uncaughtException.indexOf(T)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(T){return!m.unhandledRejection.indexOf(T)>-1})});var hx;if(typeof WasmBackendModule!="undefined")hx=WasmBackendModule;else if(typeof t!="undefined")hx=t;else throw new Error("Could not find wasm module in post.js");if(dx){var SU=hx._dispose;hx._dispose=function(){SU(),dx.uncaughtException.forEach(function(T){process.removeListener("uncaughtException",T)}),dx.unhandledRejection.forEach(function(T){process.removeListener("unhandledRejection",T)})}}return t.ready}})();typeof s0=="object"&&typeof YT=="object"?YT.exports=XT:typeof define=="function"&&define.amd?define([],function(){return XT}):typeof s0=="object"&&(s0.WasmBackendModuleThreadedSimd=XT)});var _W=Oe((i0,JT)=>{var ZT=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};var e=typeof t!="undefined"?t:{},n,o;e.ready=new Promise(function(H,tt){n=H,o=tt});var s;typeof process!="undefined"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i=Object.assign({},e),a=[],u="./this.program",l=(H,tt)=>{throw tt},c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function d(H){return e.locateFile?e.locateFile(H,f):f+H}var h,g,y,b;function w(H){if(H instanceof Ld)return;D("exiting due to exception: "+H)}var v,k,E;m?(p?f=Rg().dirname(f)+"/":f=__dirname+"/",E=()=>{k||(v=Wb(),k=Rg())},h=function(tt,gt){return E(),tt=k.normalize(tt),v.readFileSync(tt,gt?void 0:"utf8")},y=H=>{var tt=h(H,!0);return tt.buffer||(tt=new Uint8Array(tt)),tt},g=(H,tt,gt)=>{E(),H=k.normalize(H),v.readFile(H,function($t,fe){$t?gt($t):tt(fe.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(H){if(!(H instanceof Ld))throw H}),process.on("unhandledRejection",function(H){throw H}),l=(H,tt)=>{if(Ad())throw process.exitCode=H,tt;w(tt),process.exit(H)},e.inspect=function(){return"[Emscripten Module object]"}):(c||p)&&(p?f=self.location.href:typeof document!="undefined"&&document.currentScript&&(f=document.currentScript.src),r&&(f=r),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",h=H=>{var tt=new XMLHttpRequest;return tt.open("GET",H,!1),tt.send(null),tt.responseText},p&&(y=H=>{var tt=new XMLHttpRequest;return tt.open("GET",H,!1),tt.responseType="arraybuffer",tt.send(null),new Uint8Array(tt.response)}),g=(H,tt,gt)=>{var $t=new XMLHttpRequest;$t.open("GET",H,!0),$t.responseType="arraybuffer",$t.onload=()=>{if($t.status==200||$t.status==0&&$t.response){tt($t.response);return}gt()},$t.onerror=gt,$t.send(null)},b=H=>document.title=H);var $=e.print||console.log.bind(console),D=e.printErr||console.warn.bind(console);Object.assign(e,i),i=null,e.arguments&&(a=e.arguments),e.thisProgram&&(u=e.thisProgram),e.quit&&(l=e.quit);var F=4;function P(H){P.shown||(P.shown={}),P.shown[H]||(P.shown[H]=1,D(H))}function W(H,tt){if(typeof WebAssembly.Function=="function"){for(var gt={i:"i32",j:"i64",f:"f32",d:"f64"},$t={parameters:[],results:tt[0]=="v"?[]:[gt[tt[0]]]},fe=1;fe<tt.length;++fe)$t.parameters.push(gt[tt[fe]]);return new WebAssembly.Function($t,H)}var ge=[1,0,1,96],oe=tt.slice(0,1),ee=tt.slice(1),xr={i:127,j:126,f:125,d:124};ge.push(ee.length);for(var fe=0;fe<ee.length;++fe)ge.push(xr[ee[fe]]);oe=="v"?ge.push(0):ge=ge.concat([1,xr[oe]]),ge[1]=ge.length-2;var Uo=new Uint8Array([0,97,115,109,1,0,0,0].concat(ge,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Ho=new WebAssembly.Module(Uo),Ip=new WebAssembly.Instance(Ho,{e:{f:H}}),Ru=Ip.exports.f;return Ru}var U=[],q;function K(){if(U.length)return U.pop();try{so.grow(1)}catch(H){throw H instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":H}return so.length-1}function j(H,tt){for(var gt=H;gt<H+tt;gt++){var $t=Fd(gt);$t&&q.set($t,gt)}}var Q=0,rt=H=>{Q=H},X;e.wasmBinary&&(X=e.wasmBinary);var nt=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Eu("no native wasm support detected");var st,it=!1,ft;function at(H,tt){H||Eu(tt)}function xt(H){var tt=e["_"+H];return tt}function dt(H,tt,gt,$t,fe){var ge={string:function(ln){var $l=0;if(ln!=null&&ln!==0){var cx=(ln.length<<2)+1;$l=Pd(cx),ce(ln,$l,cx)}return $l},array:function(ln){var $l=Pd(ln.length);return ke(ln,$l),$l}};function oe(ln){return tt==="string"?qt(ln):tt==="boolean"?Boolean(ln):ln}var ee=xt(H),xr=[],Uo=0;if($t)for(var Ho=0;Ho<$t.length;Ho++){var Ip=ge[gt[Ho]];Ip?(Uo===0&&(Uo=lx()),xr[Ho]=Ip($t[Ho])):xr[Ho]=$t[Ho]}var Ru=ee.apply(null,xr);function FC(ln){return Uo!==0&&ux(Uo),oe(ln)}return Ru=FC(Ru),Ru}function bt(H,tt,gt,$t){gt=gt||[];var fe=gt.every(function(oe){return oe==="number"}),ge=tt!=="string";return ge&&fe&&!$t?xt(H):function(){return dt(H,tt,gt,arguments,$t)}}var kt=1,At=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Dt(H,tt,gt){for(var $t=tt+gt,fe=tt;H[fe]&&!(fe>=$t);)++fe;if(fe-tt>16&&H.subarray&&At)return At.decode(H.subarray(tt,fe));for(var ge="";tt<fe;){var oe=H[tt++];if(!(oe&128)){ge+=String.fromCharCode(oe);continue}var ee=H[tt++]&63;if((oe&224)==192){ge+=String.fromCharCode((oe&31)<<6|ee);continue}var xr=H[tt++]&63;if((oe&240)==224?oe=(oe&15)<<12|ee<<6|xr:oe=(oe&7)<<18|ee<<12|xr<<6|H[tt++]&63,oe<65536)ge+=String.fromCharCode(oe);else{var Uo=oe-65536;ge+=String.fromCharCode(55296|Uo>>10,56320|Uo&1023)}}return ge}function qt(H,tt){return H?Dt(ze,H,tt):""}function Kt(H,tt,gt,$t){if(!($t>0))return 0;for(var fe=gt,ge=gt+$t-1,oe=0;oe<H.length;++oe){var ee=H.charCodeAt(oe);if(ee>=55296&&ee<=57343){var xr=H.charCodeAt(++oe);ee=65536+((ee&1023)<<10)|xr&1023}if(ee<=127){if(gt>=ge)break;tt[gt++]=ee}else if(ee<=2047){if(gt+1>=ge)break;tt[gt++]=192|ee>>6,tt[gt++]=128|ee&63}else if(ee<=65535){if(gt+2>=ge)break;tt[gt++]=224|ee>>12,tt[gt++]=128|ee>>6&63,tt[gt++]=128|ee&63}else{if(gt+3>=ge)break;tt[gt++]=240|ee>>18,tt[gt++]=128|ee>>12&63,tt[gt++]=128|ee>>6&63,tt[gt++]=128|ee&63}}return tt[gt]=0,gt-fe}function ce(H,tt,gt){return Kt(H,ze,tt,gt)}function Ot(H){for(var tt=0,gt=0;gt<H.length;++gt){var $t=H.charCodeAt(gt);$t>=55296&&$t<=57343&&($t=65536+(($t&1023)<<10)|H.charCodeAt(++gt)&1023),$t<=127?++tt:$t<=2047?tt+=2:$t<=65535?tt+=3:tt+=4}return tt}var $e=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):void 0;function ke(H,tt){rn.set(H,tt)}function ae(H,tt,gt){for(var $t=0;$t<H.length;++$t)rn[tt++>>0]=H.charCodeAt($t);gt||(rn[tt>>0]=0)}function Ke(H,tt){return H%tt>0&&(H+=tt-H%tt),H}var Re,rn,ze,Bo,Or,nn,on,jr,oo;function Rn(H){Re=H,e.HEAP8=rn=new Int8Array(H),e.HEAP16=Bo=new Int16Array(H),e.HEAP32=nn=new Int32Array(H),e.HEAPU8=ze=new Uint8Array(H),e.HEAPU16=Or=new Uint16Array(H),e.HEAPU32=on=new Uint32Array(H),e.HEAPF32=jr=new Float32Array(H),e.HEAPF64=oo=new Float64Array(H)}var Vo=e.INITIAL_MEMORY||16777216,so,_l=[],_u=[],pp=[],gr=!1,mp=!1,fp=0;function Ad(){return nt||fp>0}function zg(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Gg(e.preRun.shift());Dd(_l)}function Bg(){gr=!0,Dd(_u)}function r1(){mp=!0}function Vg(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)Wg(e.postRun.shift());Dd(pp)}function Gg(H){_l.unshift(H)}function Go(H){_u.unshift(H)}function Wg(H){pp.unshift(H)}var qn=0,dp=null,El=null;function l0(H){qn++,e.monitorRunDependencies&&e.monitorRunDependencies(qn)}function Ug(H){if(qn--,e.monitorRunDependencies&&e.monitorRunDependencies(qn),qn==0&&(dp!==null&&(clearInterval(dp),dp=null),El)){var tt=El;El=null,tt()}}e.preloadedImages={},e.preloadedAudios={};function Eu(H){e.onAbort&&e.onAbort(H),H="Aborted("+H+")",D(H),it=!0,ft=1,H+=". Build with -s ASSERTIONS=1 for more info.";var tt=new WebAssembly.RuntimeError(H);throw o(tt),tt}var u0="data:application/octet-stream;base64,";function Hg(H){return H.startsWith(u0)}function Au(H){return H.startsWith("file://")}var sn;sn="tfjs-backend-wasm.wasm",Hg(sn)||(sn=d(sn));function $d(H){try{if(H==sn&&X)return new Uint8Array(X);if(y)return y(H);throw"both async and sync fetching of the wasm failed"}catch(tt){Eu(tt)}}function c0(){if(!X&&(c||p)){if(typeof fetch=="function"&&!Au(sn))return fetch(sn,{credentials:"same-origin"}).then(function(H){if(!H.ok)throw"failed to load wasm binary file at '"+sn+"'";return H.arrayBuffer()}).catch(function(){return $d(sn)});if(g)return new Promise(function(H,tt){g(sn,function(gt){H(new Uint8Array(gt))},tt)})}return Promise.resolve().then(function(){return $d(sn)})}function p0(){var H={env:xp,wasi_snapshot_preview1:xp};function tt(oe,ee){var xr=oe.exports;e.asm=xr,st=e.asm.memory,Rn(st.buffer),so=e.asm.__indirect_function_table,Go(e.asm.__wasm_call_ctors),Ug("wasm-instantiate")}l0("wasm-instantiate");function gt(oe){tt(oe.instance)}function $t(oe){return c0().then(function(ee){return WebAssembly.instantiate(ee,H)}).then(function(ee){return ee}).then(oe,function(ee){D("failed to asynchronously prepare wasm: "+ee),Eu(ee)})}function fe(){return!X&&typeof WebAssembly.instantiateStreaming=="function"&&!Hg(sn)&&!Au(sn)&&typeof fetch=="function"?fetch(sn,{credentials:"same-origin"}).then(function(oe){var ee=WebAssembly.instantiateStreaming(oe,H);return ee.then(gt,function(xr){return D("wasm streaming compile failed: "+xr),D("falling back to ArrayBuffer instantiation"),$t(gt)})}):$t(gt)}if(e.instantiateWasm)try{var ge=e.instantiateWasm(H,tt);return ge}catch(oe){return D("Module.instantiateWasm callback failed with error: "+oe),!1}return fe().catch(o),{}}var n1,o1;function Dd(H){for(;H.length>0;){var tt=H.shift();if(typeof tt=="function"){tt(e);continue}var gt=tt.func;typeof gt=="number"?tt.arg===void 0?Fd(gt)():Fd(gt)(tt.arg):gt(tt.arg===void 0?null:tt.arg)}}function Al(H){return H}function qg(H){var tt=/\b_Z[\w\d_]+/g;return H.replace(tt,function(gt){var $t=gt;return gt===$t?gt:$t+" ["+gt+"]"})}var Wo=[];function Fd(H){var tt=Wo[H];return tt||(H>=Wo.length&&(Wo.length=H+1),Wo[H]=tt=so.get(H)),tt}function s1(){var H=new Error;if(!H.stack){try{throw new Error}catch(tt){H=tt}if(!H.stack)return"(no stack trace available)"}return H.stack.toString()}function hp(H,tt){so.set(H,tt),Wo[H]=tt}function m0(){Eu("")}function Rd(){return 2147483648}function Kg(H,tt,gt){ze.copyWithin(H,tt,tt+gt)}function an(H){try{return st.grow(H-Re.byteLength+65535>>>16),Rn(st.buffer),1}catch(tt){}}function jg(H){var tt=ze.length;H=H>>>0;var gt=Rd();if(H>gt)return!1;for(var $t=1;$t<=4;$t*=2){var fe=tt*(1+.2/$t);fe=Math.min(fe,H+100663296);var ge=Math.min(gt,Ke(Math.max(H,fe),65536)),oe=an(ge);if(oe)return!0}return!1}var gp={mappings:{},buffers:[null,[],[]],printChar:function(H,tt){var gt=gp.buffers[H];tt===0||tt===10?((H===1?$:D)(Dt(gt,0)),gt.length=0):gt.push(tt)},varargs:void 0,get:function(){gp.varargs+=4;var H=nn[gp.varargs-4>>2];return H},getStr:function(H){var tt=qt(H);return tt},get64:function(H,tt){return H}};function f0(H){return 0}function i1(H,tt,gt,$t,fe){}function a1(H,tt,gt,$t){for(var fe=0,ge=0;ge<gt;ge++){var oe=nn[tt>>2],ee=nn[tt+4>>2];tt+=8;for(var xr=0;xr<ee;xr++)gp.printChar(H,ze[oe+xr]);fe+=ee}return nn[$t>>2]=fe,0}function d0(H){rt(H)}var Xg=!1,xp={abort:m0,emscripten_get_heap_max:Rd,emscripten_memcpy_big:Kg,emscripten_resize_heap:jg,fd_close:f0,fd_seek:i1,fd_write:a1,setTempRet0:d0},FW=p0(),l1=e.___wasm_call_ctors=function(){return(l1=e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)},h0=e._init=function(){return(h0=e._init=e.asm.init).apply(null,arguments)},g0=e._init_with_threads_count=function(){return(g0=e._init_with_threads_count=e.asm.init_with_threads_count).apply(null,arguments)},Yg=e._get_threads_count=function(){return(Yg=e._get_threads_count=e.asm.get_threads_count).apply(null,arguments)},Zg=e._register_tensor=function(){return(Zg=e._register_tensor=e.asm.register_tensor).apply(null,arguments)},x0=e._dispose_data=function(){return(x0=e._dispose_data=e.asm.dispose_data).apply(null,arguments)},Ut=e._dispose=function(){return(Ut=e._dispose=e.asm.dispose).apply(null,arguments)},y0=e._Abs=function(){return(y0=e._Abs=e.asm.Abs).apply(null,arguments)},Jg=e._Add=function(){return(Jg=e._Add=e.asm.Add).apply(null,arguments)},$u=e._AddN=function(){return($u=e._AddN=e.asm.AddN).apply(null,arguments)},yp=e._All=function(){return(yp=e._All=e.asm.All).apply(null,arguments)},b0=e._Any=function(){return(b0=e._Any=e.asm.Any).apply(null,arguments)},u1=e._ArgMax=function(){return(u1=e._ArgMax=e.asm.ArgMax).apply(null,arguments)},w0=e._AvgPool=function(){return(w0=e._AvgPool=e.asm.AvgPool).apply(null,arguments)},c1=e._BatchMatMul=function(){return(c1=e._BatchMatMul=e.asm.BatchMatMul).apply(null,arguments)},Du=e._Ceil=function(){return(Du=e._Ceil=e.asm.Ceil).apply(null,arguments)},v0=e._ClipByValue=function(){return(v0=e._ClipByValue=e.asm.ClipByValue).apply(null,arguments)},C0=e._Conv2D=function(){return(C0=e._Conv2D=e.asm.Conv2D).apply(null,arguments)},I0=e._Conv2DBackpropInput=function(){return(I0=e._Conv2DBackpropInput=e.asm.Conv2DBackpropInput).apply(null,arguments)},S0=e._Cos=function(){return(S0=e._Cos=e.asm.Cos).apply(null,arguments)},k0=e._Cosh=function(){return(k0=e._Cosh=e.asm.Cosh).apply(null,arguments)},N0=e._CropAndResize=function(){return(N0=e._CropAndResize=e.asm.CropAndResize).apply(null,arguments)},Qg=e._Cumprod=function(){return(Qg=e._Cumprod=e.asm.Cumprod).apply(null,arguments)},T0=e._Cumsum=function(){return(T0=e._Cumsum=e.asm.Cumsum).apply(null,arguments)},_0=e._DepthToSpace=function(){return(_0=e._DepthToSpace=e.asm.DepthToSpace).apply(null,arguments)},E0=e._DepthwiseConv2dNative=function(){return(E0=e._DepthwiseConv2dNative=e.asm.DepthwiseConv2dNative).apply(null,arguments)},A0=e._Elu=function(){return(A0=e._Elu=e.asm.Elu).apply(null,arguments)},$0=e._Equal=function(){return($0=e._Equal=e.asm.Equal).apply(null,arguments)},tx=e._Exp=function(){return(tx=e._Exp=e.asm.Exp).apply(null,arguments)},D0=e._FlipLeftRight=function(){return(D0=e._FlipLeftRight=e.asm.FlipLeftRight).apply(null,arguments)},F0=e._Floor=function(){return(F0=e._Floor=e.asm.Floor).apply(null,arguments)},Fu=e._FloorDiv=function(){return(Fu=e._FloorDiv=e.asm.FloorDiv).apply(null,arguments)},Od=e._FusedBatchNorm=function(){return(Od=e._FusedBatchNorm=e.asm.FusedBatchNorm).apply(null,arguments)},R0=e._FusedConv2D=function(){return(R0=e._FusedConv2D=e.asm.FusedConv2D).apply(null,arguments)},O0=e._FusedDepthwiseConv2D=function(){return(O0=e._FusedDepthwiseConv2D=e.asm.FusedDepthwiseConv2D).apply(null,arguments)},M0=e._Gather=function(){return(M0=e._Gather=e.asm.Gather).apply(null,arguments)},ne=e._GatherNd=function(){return(ne=e._GatherNd=e.asm.GatherNd).apply(null,arguments)},P0=e._Greater=function(){return(P0=e._Greater=e.asm.Greater).apply(null,arguments)},L0=e._GreaterEqual=function(){return(L0=e._GreaterEqual=e.asm.GreaterEqual).apply(null,arguments)},z0=e._LeakyRelu=function(){return(z0=e._LeakyRelu=e.asm.LeakyRelu).apply(null,arguments)},B0=e._Less=function(){return(B0=e._Less=e.asm.Less).apply(null,arguments)},V0=e._LessEqual=function(){return(V0=e._LessEqual=e.asm.LessEqual).apply(null,arguments)},G0=e._Log=function(){return(G0=e._Log=e.asm.Log).apply(null,arguments)},Md=e._LogicalAnd=function(){return(Md=e._LogicalAnd=e.asm.LogicalAnd).apply(null,arguments)},ex=e._Max=function(){return(ex=e._Max=e.asm.Max).apply(null,arguments)},rx=e._MaxPool=function(){return(rx=e._MaxPool=e.asm.MaxPool).apply(null,arguments)},W0=e._Maximum=function(){return(W0=e._Maximum=e.asm.Maximum).apply(null,arguments)},U0=e._Mean=function(){return(U0=e._Mean=e.asm.Mean).apply(null,arguments)},H0=e._Min=function(){return(H0=e._Min=e.asm.Min).apply(null,arguments)},q0=e._Minimum=function(){return(q0=e._Minimum=e.asm.Minimum).apply(null,arguments)},K0=e._MirrorPad=function(){return(K0=e._MirrorPad=e.asm.MirrorPad).apply(null,arguments)},j0=e._Multiply=function(){return(j0=e._Multiply=e.asm.Multiply).apply(null,arguments)},or=e._Neg=function(){return(or=e._Neg=e.asm.Neg).apply(null,arguments)},X0=e._NonMaxSuppressionV3=function(){return(X0=e._NonMaxSuppressionV3=e.asm.NonMaxSuppressionV3).apply(null,arguments)},Y0=e._NonMaxSuppressionV4=function(){return(Y0=e._NonMaxSuppressionV4=e.asm.NonMaxSuppressionV4).apply(null,arguments)},Z0=e._NonMaxSuppressionV5=function(){return(Z0=e._NonMaxSuppressionV5=e.asm.NonMaxSuppressionV5).apply(null,arguments)},bp=e._NotEqual=function(){return(bp=e._NotEqual=e.asm.NotEqual).apply(null,arguments)},nx=e._OneHot=function(){return(nx=e._OneHot=e.asm.OneHot).apply(null,arguments)},ox=e._PadV2=function(){return(ox=e._PadV2=e.asm.PadV2).apply(null,arguments)},sx=e._Pow=function(){return(sx=e._Pow=e.asm.Pow).apply(null,arguments)},J0=e._Prelu=function(){return(J0=e._Prelu=e.asm.Prelu).apply(null,arguments)},ix=e._Prod=function(){return(ix=e._Prod=e.asm.Prod).apply(null,arguments)},Q0=e._RealDiv=function(){return(Q0=e._RealDiv=e.asm.RealDiv).apply(null,arguments)},p1=e._Relu=function(){return(p1=e._Relu=e.asm.Relu).apply(null,arguments)},ax=e._Relu6=function(){return(ax=e._Relu6=e.asm.Relu6).apply(null,arguments)},m1=e._ResizeBilinear=function(){return(m1=e._ResizeBilinear=e.asm.ResizeBilinear).apply(null,arguments)},tC=e._Reverse=function(){return(tC=e._Reverse=e.asm.Reverse).apply(null,arguments)},eC=e._RotateWithOffset=function(){return(eC=e._RotateWithOffset=e.asm.RotateWithOffset).apply(null,arguments)},rC=e._Round=function(){return(rC=e._Round=e.asm.Round).apply(null,arguments)},nC=e._Rsqrt=function(){return(nC=e._Rsqrt=e.asm.Rsqrt).apply(null,arguments)},oC=e._ScatterNd=function(){return(oC=e._ScatterNd=e.asm.ScatterNd).apply(null,arguments)},sC=e._SelectV2=function(){return(sC=e._SelectV2=e.asm.SelectV2).apply(null,arguments)},iC=e._Sigmoid=function(){return(iC=e._Sigmoid=e.asm.Sigmoid).apply(null,arguments)},aC=e._Sin=function(){return(aC=e._Sin=e.asm.Sin).apply(null,arguments)},lC=e._Softmax=function(){return(lC=e._Softmax=e.asm.Softmax).apply(null,arguments)},uC=e._SparseFillEmptyRows=function(){return(uC=e._SparseFillEmptyRows=e.asm.SparseFillEmptyRows).apply(null,arguments)},cC=e._SparseReshape=function(){return(cC=e._SparseReshape=e.asm.SparseReshape).apply(null,arguments)},pC=e._SparseSegmentReduction=function(){return(pC=e._SparseSegmentReduction=e.asm.SparseSegmentReduction).apply(null,arguments)},mC=e._Sqrt=function(){return(mC=e._Sqrt=e.asm.Sqrt).apply(null,arguments)},fC=e._Square=function(){return(fC=e._Square=e.asm.Square).apply(null,arguments)},dC=e._SquaredDifference=function(){return(dC=e._SquaredDifference=e.asm.SquaredDifference).apply(null,arguments)},hC=e._Step=function(){return(hC=e._Step=e.asm.Step).apply(null,arguments)},gC=e._StridedSlice=function(){return(gC=e._StridedSlice=e.asm.StridedSlice).apply(null,arguments)},xC=e._Sub=function(){return(xC=e._Sub=e.asm.Sub).apply(null,arguments)},yC=e._Sum=function(){return(yC=e._Sum=e.asm.Sum).apply(null,arguments)},bC=e._Tan=function(){return(bC=e._Tan=e.asm.Tan).apply(null,arguments)},wC=e._Tanh=function(){return(wC=e._Tanh=e.asm.Tanh).apply(null,arguments)},vC=e._Tile=function(){return(vC=e._Tile=e.asm.Tile).apply(null,arguments)},CC=e._TopK=function(){return(CC=e._TopK=e.asm.TopK).apply(null,arguments)},IC=e._Transform=function(){return(IC=e._Transform=e.asm.Transform).apply(null,arguments)},SC=e._Transpose=function(){return(SC=e._Transpose=e.asm.Transpose).apply(null,arguments)},kC=e.__FusedMatMul=function(){return(kC=e.__FusedMatMul=e.asm._FusedMatMul).apply(null,arguments)},NC=e._malloc=function(){return(NC=e._malloc=e.asm.malloc).apply(null,arguments)},TC=e._free=function(){return(TC=e._free=e.asm.free).apply(null,arguments)},_C=e.___errno_location=function(){return(_C=e.___errno_location=e.asm.__errno_location).apply(null,arguments)},EC=e._emscripten_main_thread_process_queued_calls=function(){return(EC=e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},lx=e.stackSave=function(){return(lx=e.stackSave=e.asm.stackSave).apply(null,arguments)},ux=e.stackRestore=function(){return(ux=e.stackRestore=e.asm.stackRestore).apply(null,arguments)},Pd=e.stackAlloc=function(){return(Pd=e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)},AC=e.dynCall_iijjiiii=function(){return(AC=e.dynCall_iijjiiii=e.asm.dynCall_iijjiiii).apply(null,arguments)},$C=e.dynCall_jiji=function(){return($C=e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)};e.cwrap=bt;var wp;function Ld(H){this.name="ExitStatus",this.message="Program terminated with exit("+H+")",this.status=H}El=function H(){wp||zd(),wp||(El=H)};function zd(H){if(H=H||a,qn>0||(zg(),qn>0))return;function tt(){wp||(wp=!0,e.calledRun=!0,!it&&(Bg(),n(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),Vg()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),tt()},1)):tt()}e.run=zd;function f1(H){ft=H,Ad()||(e.onExit&&e.onExit(H),it=!0),l(H,new Ld(H))}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();zd();var vp;s&&(vp={uncaughtException:process.listeners("uncaughtException").filter(function(H){return!s.uncaughtException.indexOf(H)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(H){return!s.unhandledRejection.indexOf(H)>-1})});var Cp;if(typeof t!="undefined")Cp=t;else if(typeof WasmBackendModuleThreadedSimd!="undefined")Cp=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(vp){var DC=Cp._dispose;Cp._dispose=function(){DC(),vp.uncaughtException.forEach(function(H){process.removeListener("uncaughtException",H)}),vp.unhandledRejection.forEach(function(H){process.removeListener("unhandledRejection",H)})}}return t.ready}})();typeof i0=="object"&&typeof JT=="object"?JT.exports=ZT:typeof define=="function"&&define.amd?define([],function(){return ZT}):typeof i0=="object"&&(i0.WasmBackendModule=ZT)});var ta=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},jo=class{refCount(t){return Kn("refCount")}incRef(t){return Kn("incRef")}timerAvailable(){return!0}time(t){return Kn("time")}read(t){return Kn("read")}readSync(t){return Kn("readSync")}readToGPU(t,e){return Kn("readToGPU")}numDataIds(){return Kn("numDataIds")}disposeData(t,e){return Kn("disposeData")}write(t,e,n){return Kn("write")}move(t,e,n,o,s){return Kn("move")}memory(){return Kn("memory")}floatPrecision(){return Kn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Kn("dispose")}};function Kn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function I1(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,xx(r,t,e)}function DU(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,xx(r,e,n),xx(t,e,n)}function Np(r,t,e){return Math.max(r,Math.min(t,e))}function FU(r){return r%2===0?r:r+1}function xx(r,t,e){let n=r[t];r[t]=r[e],r[e]=n}function RU(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function OU(r,t){let e=Math.random();return t*e+(1-e)*r}function MU(r,t){let e=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(t[n]);e+=o*o}return e}function A(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Me(r,t,e=""){A(Mn(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function jn(r){A(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Xo(r,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(r)||yr(r)&&!e)for(let n=0;n<r.length;++n)Xo(r[n],t,e);else t.push(r);return t}function Jt(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function PU(r){return r.length===0}function Mn(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function ea(r){return r%1===0}function LU(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function zU(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function BU(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return I1(t),t}function Pu(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function VU(r,t=n=>0,e){return new Promise((n,o)=>{let s=0,i=()=>{if(r()){n();return}s++;let a=t(s);if(e!=null&&s>=e){o();return}setTimeout(i,a)};i()})}function GU(r,t){let e=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=r.slice();return o[n]=t/e,o}function mr(r,t){let e=t.length;return r=r==null?t.map((n,o)=>o):[].concat(r),A(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),A(r.every(n=>ea(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function BC(r,t){let e=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:mr(t,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(e.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(e.push(r[a]),n.push(a))}return{newShape:e,keptDims:n}}function VC(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function GC(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function WC(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function UC(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function WU(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function yr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function yx(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function HC(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function Yo(r){return typeof r=="string"||r instanceof String}function S1(r){return typeof r=="boolean"}function k1(r){return typeof r=="number"}function Tp(r){return Array.isArray(r)?Tp(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":k1(r)?"float32":Yo(r)?"string":S1(r)?"bool":"float32"}function yi(r){return!!(r&&r.constructor&&r.call&&r.apply)}function _p(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function bi(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function N1(r,t,e,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=e[r+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=N1(r+u*a,i,e,n)}return o}function Mu(r,t,e=!1){if(r.length===0)return t[0];let n=r.reduce((o,s)=>o*s)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return N1(0,r,t,e)}function Gd(r,t){let e=Ep(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function Ep(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function UU(r,t){let e=r.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Mu(r,new Float32Array(e));if(t==="int32")return Mu(r,new Int32Array(e));if(t==="bool")return Mu(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Wd(r){r.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function HU(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function qU(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function Ud(r){return r&&r.then&&typeof r.then=="function"}var T1="tfjsflags",Hd=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=jU,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(Ud(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);T1 in t&&t[T1].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=YU(o,s)})}};function jU(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(XU(t,n[0],n[1]),n.join("="))),t}function XU(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function YU(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function V(){return qC}var qC=null;function _1(r){qC=r}var KC;function jC(){if(KC==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");KC=r}return KC}function ZU(){let r=jC();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function qd(r,t){let e=ZU();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var wi="Abs",ra="Acos",na="Acosh",Xn="Add",Zo="AddN",oa="All",sa="Any",Jo="ArgMax",Dl="ArgMin",ia="Asin",aa="Asinh",la="Atan",ua="Atanh",ca="Atan2",Qo="AvgPool",Ap="AvgPoolGrad",Fl="AvgPool3D",$p="AvgPool3DGrad",ts="BatchMatMul",vi="BatchToSpaceND",Dp="Bincount",E1="BroadcastTo",Fp="BroadcastArgs",io="Cast",es="Ceil",ao="ClipByValue",Rp="Complex",Rl="ComplexAbs",Ci="Concat",rs="Conv2D",Op="Conv2DBackpropFilter",ns="Conv2DBackpropInput",Ol="Conv3D",Mp="Conv3DBackpropFilterV2",Pp="Conv3DBackpropInputV2",os="Cos",ss="Cosh",pa="Cumprod",is="Cumsum",ma="CropAndResize",Lp="DenseBincount",fa="DepthToSpace",as="DepthwiseConv2dNative",zp="DepthwiseConv2dNativeBackpropFilter",Bp="DepthwiseConv2dNativeBackpropInput",Vp="Diag",Ml="Dilation2D",Kd="Dilation2DBackpropInput",jd="Dilation2DBackpropFilter",ls="RealDiv",Gp="Einsum",us="Elu",Wp="EluGrad",da="Erf",ha="Equal",cs="Exp",Ii="ExpandDims",ga="Expm1",Up="FFT",Pl="Fill",xa="FlipLeftRight",ps="Floor",ms="FloorDiv",fs="FusedBatchNorm",Si="GatherV2",ya="GatherNd",ba="Greater",ds="GreaterEqual",lo="Identity",Hp="IFFT",qp="Imag",wa="IsFinite",va="IsInf",Ca="IsNan",hs="LeakyRelu",Ia="Less",Sa="LessEqual",Kp="LinSpace",gs="Log",ka="Log1p",Na="LogicalAnd",Lu="LogicalNot",zu="LogicalOr",A1="LogSoftmax",Hat="LowerBound",Ll="LRN",jp="LRNGrad",xs="Max",ys="Maximum",bs="MaxPool",Xp="MaxPoolGrad",zl="MaxPool3D",Yp="MaxPool3DGrad",Zp="MaxPoolWithArgmax",ws="Mean",vs="Min",Cs="Minimum",Is="MirrorPad",Ta="Mod",Jp="Multinomial",Ss="Multiply",ki="Neg",_a="NotEqual",Ea="NonMaxSuppressionV3",Aa="NonMaxSuppressionV4",$a="NonMaxSuppressionV5",Ni="OnesLike",ks="OneHot",Ti="Pack",Ns="PadV2",qat="Pool",Ts="Pow",_s="Prelu",Es="Prod",Bl="Range",Qp="Real",Da="Reciprocal",As="Relu",_i="Reshape",Vl="ResizeNearestNeighbor",tm="ResizeNearestNeighborGrad",$s="ResizeBilinear",em="ResizeBilinearGrad",Ds="Relu6",Fs="Reverse",Rs="Round",Os="Rsqrt",Fa="ScatterNd",rm="SearchSorted",Ei="Select",Ra="Selu",Ai="Slice",Ms="Sin",Oa="Sinh",Ma="Sign",Ps="Sigmoid",Pa="Softplus",Ls="Sqrt",zs="Sum",$i="SpaceToBatchND",Di="SplitV",Bs="Softmax",Gl="SparseFillEmptyRows",La="SparseReshape",Wl="SparseSegmentMean",Ul="SparseSegmentSum",nm="SparseToDense",Vs="SquaredDifference",Hl="Square",za="StridedSlice",om="StringNGrams",sm="StringSplit",im="StringToHashBucketFast",Gs="Sub",Ws="Tan",Us="Tanh",Yn="Tile",Ba="TopK",Va="Transform",Hs="Transpose",am="Unique",Fi="Unpack",ql="UnsortedSegmentSum",Kat="UpperBound",Ri="ZerosLike",uo="Step",Xd="FromPixels",Ga="RotateWithOffset",Oi="_FusedMatMul",Mi="FusedConv2D",Pi="FusedDepthwiseConv2D";function Li(...r){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...r)}function JU(...r){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...r)}var lm=qd("kernelRegistry",()=>new Map),Yd=qd("gradRegistry",()=>new Map);function Zd(r,t){let e=YC(r,t);return lm.get(e)}function XC(r){return Yd.get(r)}function bx(r){let t=lm.entries(),e=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&e.push(i)}return e}function Bu(r){let{kernelName:t,backendName:e}=r,n=YC(t,e);lm.has(n)&&Li(`The kernel '${t}' for backend '${e}' is already registered`),lm.set(n,r)}function D1(r){let{kernelName:t}=r;Yd.has(t)&&V().getBool("DEBUG")&&Li(`Overriding the gradient for '${t}'`),Yd.set(t,r)}function Jat(r,t){let e=YC(r,t);if(!lm.has(e))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);lm.delete(e)}function Qat(r){if(!Yd.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);Yd.delete(r)}function tlt(r,t){bx(r).forEach(n=>{let o=Object.assign({},n,{backendName:t});Bu(o)})}function YC(r,t){return`${t}_${r}`}var x={};Yt(x,{arraysEqual:()=>Mn,assert:()=>A,assertNonNegativeIntegerDimensions:()=>Wd,assertNonNull:()=>jn,assertShapesMatch:()=>Me,bytesFromStringArray:()=>HC,bytesPerElement:()=>yx,checkConversionForErrors:()=>WC,clamp:()=>Np,computeStrides:()=>bi,createScalarValue:()=>s4,createShuffledIndices:()=>BU,decodeString:()=>mm,distSquared:()=>MU,encodeString:()=>jl,fetch:()=>a4,fingerPrint64:()=>o4,flatten:()=>Xo,getArrayFromDType:()=>GC,getTypedArrayFromDType:()=>VC,hasEncodingLoss:()=>WU,hexToLong:()=>Jd,indexToLoc:()=>qU,inferDtype:()=>Tp,inferFromImplicitShape:()=>GU,isBoolean:()=>S1,isFunction:()=>yi,isInt:()=>ea,isNumber:()=>k1,isPromise:()=>Ud,isScalarShape:()=>PU,isString:()=>Yo,isTypedArray:()=>yr,isValidDtype:()=>UC,locToIndex:()=>HU,makeOnesTypedArray:()=>Gd,makeZerosNestedTypedArray:()=>UU,makeZerosTypedArray:()=>Ep,nearestDivisor:()=>_p,nearestLargerEven:()=>FU,now:()=>Hu,parseAxisParam:()=>mr,randUniform:()=>OU,repeatedTry:()=>VU,rightPad:()=>Pu,shuffle:()=>I1,shuffleCombo:()=>DU,sizeFromShape:()=>Jt,sizeToSquarishShape:()=>zU,squeezeShape:()=>BC,sum:()=>RU,swap:()=>xx,tanh:()=>LU,toNestedArray:()=>Mu,toTypedArray:()=>pm});var tI=Ou(W1());var Uu=tI.default||tI;function Jd(r){return Uu.fromString(r,!0,16)}var H1=Jd("c3a5c85c97cb3127"),Wu=Jd("b492b66fbe98f273"),un=Jd("9ae16a3b2f90404f");function QC(r){return r.xor(r.shru(47))}function q1(r,t,e){let n=r.slice(t,t+e);return Uu.fromBytes(Array.from(n),!0,!0)}function Be(r,t){return q1(r,t,8)}function U1(r,t){return q1(r,t,4)}function Ar(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function Kl(r,t,e=Jd("9ddfea08eb382d69")){let n=r.xor(t).mul(e);n=n.xor(n.shru(47));let o=t.xor(n).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function t4(r,t,e,n,o,s){o=o.add(r),s=Ar(s.add(o).add(n),21);let i=o;return o=o.add(t),o=o.add(e),s=s.add(Ar(o,44)),[o.add(n),s.add(i)]}function vx(r,t,e,n){return t4(Be(r,t),Be(r,t+8),Be(r,t+16),Be(r,t+24),e,n)}function e4(r,t=r.length){if(t>=8){let e=un.add(t*2),n=Be(r,0).add(un),o=Be(r,t-8),s=Ar(o,37).mul(e).add(n),i=Ar(n,25).add(o).mul(e);return Kl(s,i,e)}if(t>=4){let e=un.add(t*2),n=U1(r,0);return Kl(n.shl(3).add(t),U1(r,t-4),e)}if(t>0){let e=r[0],n=r[t>>1],o=r[t-1],s=e+(n<<8),i=t+(o<<2);return QC(un.mul(s).xor(H1.mul(i))).mul(un)}return un}function r4(r,t=r.length){let e=un.add(t*2),n=Be(r,0).mul(Wu),o=Be(r,8),s=Be(r,t-8).mul(e),i=Be(r,t-16).mul(un);return Kl(Ar(n.add(o),43).add(Ar(s,30)).add(i),n.add(Ar(o.add(un),18)).add(s),e)}function n4(r,t=r.length){let e=un.add(t*2),n=Be(r,0).mul(un),o=Be(r,8),s=Be(r,t-8).mul(e),i=Be(r,t-16).mul(un),a=Ar(n.add(o),43).add(Ar(s,30)).add(i),u=Kl(a,n.add(Ar(o.add(un),18)).add(s),e),l=Be(r,16).mul(e),c=Be(r,24),p=a.add(Be(r,t-32)).mul(e),m=u.add(Be(r,t-24)).mul(e);return Kl(Ar(l.add(c),43).add(Ar(p,30)).add(m),l.add(Ar(c.add(n),18)).add(p),e)}function o4(r,t=r.length){let e=Uu.fromNumber(81,!0);if(t<=32)return t<=16?e4(r,t):r4(r,t);if(t<=64)return n4(r,t);let n=e,o=e.mul(Wu).add(113),s=QC(o.mul(un).add(113)).mul(un),i=[Uu.UZERO,Uu.UZERO],a=[Uu.UZERO,Uu.UZERO];n=n.mul(un).add(Be(r,0));let u=0,l=(t-1>>6)*64,c=l+(t-1&63)-63;do n=Ar(n.add(o).add(i[0]).add(Be(r,u+8)),37).mul(Wu),o=Ar(o.add(i[1]).add(Be(r,u+48)),42).mul(Wu),n=n.xor(a[1]),o=o.add(i[0]).add(Be(r,u+40)),s=Ar(s.add(a[0]),33).mul(Wu),i=vx(r,u,i[1].mul(Wu),n.add(a[0])),a=vx(r,u+32,s.add(a[1]),o.add(Be(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let p=Wu.add(s.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=Ar(n.add(o).add(i[0]).add(Be(r,u+8)),37).mul(p),o=Ar(o.add(i[1]).add(Be(r,u+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Be(r,u+40))),s=Ar(s.add(a[0]),33).mul(p),i=vx(r,u,i[1].mul(p),n.add(a[0])),a=vx(r,u+32,s.add(a[1]),o.add(Be(r,u+16))),[s,n]=[n,s],Kl(Kl(i[0],a[0],p).add(QC(o).mul(H1)).add(s),Kl(i[1],a[1],p).add(n),p)}function s4(r,t){return t==="string"?jl(r):pm([r],t)}function i4(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function pm(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Xo(r)),V().getBool("DEBUG")&&WC(r,t),i4(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Hu(){return V().platform.now()}function a4(r,t){return V().platform.fetch(r,t)}function jl(r,t="utf-8"){return t=t||"utf-8",V().platform.encode(r,t)}function mm(r,t="utf-8"){return t=t||"utf-8",V().platform.decode(r,t)}var Cx=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new eI)}profileKernel(t,e,n){let o,s=()=>{o=n()},i,a=Hu();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:Hu()-a})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let c=o[l];c.data().then(p=>{l4(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:o,inputs:s,extraInfo:i}=t;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(e,a,u[0],u[1],s,u[2])})})}};function l4(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var eI=class{logKernelProfile(t,e,n,o,s,i){let a=typeof o=="number"?Pu(`${o}ms`,9):o.error,u=Pu(t,25),l=e.rank,c=e.size,p=Pu(e.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||e.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function K1(r,t,e){let n={},o={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],c=l.inputs;for(let p in c){let m=c[p],f=!1;for(let d=0;d<t.length;d++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[e.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let c={};for(let m in l.inputs){let f=l.inputs[m];n[f.id]&&(c[m]=f)}let p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,a.push(p)}}return a}function j1(r,t,e,n){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=e(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=s.inputs[u];if(!Mn(l.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=l;else{let p=r[c.id];r[c.id]=n(p,l),p.dispose()}}}}var X1=20,Qd=3,rI=7;function Y1(r,t,e,n){let o=bi(t),s=u4(r,t,e,o),i=t.length,a=Ix(r,t,e,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function u4(r,t,e,n){let o=Jt(t),s=n[n.length-1],i=new Array(s).fill(0),a=t.length,u=e==="complex64"?eh(r):r;if(a>1)for(let l=0;l<o/s;l++){let c=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],th(u[c+p],0,e).length)}return i}function th(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(rI))} + ${parseFloat(r[1].toFixed(rI))}j`:Yo(r)?n=`'${r}'`:e==="bool"?n=Z1(r):n=parseFloat(r.toFixed(rI)).toString(),Pu(n,t)}function Z1(r){return r===0?"false":"true"}function Ix(r,t,e,n,o,s=!0){let i=e==="complex64"?2:1,a=t[0],u=t.length;if(u===0){if(e==="complex64"){let h=eh(r);return[th(h[0],0,e)]}return e==="bool"?[Z1(r[0])]:[r[0].toString()]}if(u===1){if(a>X1){let g=Qd*i,y=Array.from(r.slice(0,g)),b=Array.from(r.slice((a-Qd)*i,a*i));return e==="complex64"&&(y=eh(y),b=eh(b)),["["+y.map((w,v)=>th(w,o[v],e)).join(", ")+", ..., "+b.map((w,v)=>th(w,o[a-Qd+v],e)).join(", ")+"]"]}let h=e==="complex64"?eh(r):Array.from(r);return["["+h.map((g,y)=>th(g,o[y],e)).join(", ")+"]"]}let l=t.slice(1),c=n.slice(1),p=n[0]*i,m=[];if(a>X1){for(let h=0;h<Qd;h++){let g=h*p,y=g+p;m.push(...Ix(r.slice(g,y),l,e,c,o,!1))}m.push("...");for(let h=a-Qd;h<a;h++){let g=h*p,y=g+p;m.push(...Ix(r.slice(g,y),l,e,c,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,y=g+p;m.push(...Ix(r.slice(g,y),l,e,c,o,h===a-1))}let f=u===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<u;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function eh(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var pe=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Jt(t),n!=null){let o=n.length;A(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||GC(e,this.size),this.strides=bi(t)}set(t,...e){e.length===0&&(e=[0]),A(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ks().makeTensor(this.values,this.shape,this.dtype)}},Ks=null,fm=null,c4=null;function J1(r){Ks=r}function Q1(r){fm=r}function t_(r){c4=r}var Lt=class{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Jt(t),this.strides=bi(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return fm.buffer(this.shape,this.dtype,t)}bufferSync(){return fm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Mu(this.shape,t,this.dtype==="complex64")}arraySync(){return Mu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=Ks().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>mm(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ks().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=Ks().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>mm(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await Ks().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ks().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return fm.print(this,t)}clone(){return this.throwIfDisposed(),fm.clone(this)}toString(t=!1){let e=this.dataSync();return Y1(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),fm.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Ks().makeVariable(this,t,e,n)}};Object.defineProperty(Lt,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function L(){return qd("Tensor",()=>Lt)}L();var Wa=class extends Lt{constructor(t,e,n,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Mn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ks().disposeTensor(this),this.dataId=t.dataId,Ks().incRef(this,null)}dispose(){Ks().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Wa,Symbol.hasInstance,{value:r=>r instanceof Lt&&r.assign!=null&&r.assign instanceof Function});var fo={};Yt(fo,{assertTypesMatch:()=>lI,getTensorsInContainer:()=>rh,isTensorInList:()=>m4,makeTypesMatch:()=>jt});var nI;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(nI||(nI={}));var oI;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(oI||(oI={}));var sI;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(sI||(sI={}));var iI;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(iI||(iI={}));var aI;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(aI||(aI={}));var p4={float32:iI,int32:oI,bool:sI,complex64:aI};function ar(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return p4[r][t]}function qu(r){return ar(r,"int32")}function jt(r,t){if(r.dtype===t.dtype)return[r,t];let e=ar(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function lI(r,t){A(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function m4(r,t){return t.some(e=>e.id===r.id)}function rh(r){let t=[];return e_(r,t,new Set),t}function e_(r,t,e){if(r==null)return;if(r instanceof Lt){t.push(r);return}if(!f4(r))return;let n=r;for(let o in n){let s=n[o];e.has(s)||(e.add(s),e_(s,t,e))}}function f4(r){return Array.isArray(r)||typeof r=="object"}function uI(r){return r.kernelName!=null}var Sx=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Xl=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Sx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Li(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Cx(this.backendInstance),!0}setupRegisteredKernels(){bx(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){bx(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=e.factory();if(n&&!(n instanceof jo)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Li(`Initialization of backend ${t} failed`),Li(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return Li(`Initialization of backend ${t} failed`),Li(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let n=this.state.tensorInfo.get(e),o=n.backend,s=this.readSync(e),i=o.refCount(e);o.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=e(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,e,n){t();try{let o=n();return e(),o}catch(o){throw e(),o}}nextTensorId(){return Xl.nextTensorId++}nextVariableId(){return Xl.nextVariableId++}clone(t){let e=_.runKernel(lo,{x:t}),n={x:t},o=i=>({x:()=>{let a="float32",u={x:i},l={dtype:a};return _.runKernel(io,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[e],o,s,{}),e}runKernel(t,e,n){if(this.backendName==null&&this.backend,!(Zd(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-e-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u,l=uI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(uI(t)){let{kernelName:d,inputs:h,attrs:g}=t;this.backendName==null&&this.backend;let y=Zd(d,this.backendName);A(y!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),a=()=>{let b=this.backend.numDataIds();u=y.kernelFunc({inputs:h,attrs:g,backend:this.backend});let w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,b,w);let v=w.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(o){let k=this.getTensorsForGradient(d,h,v);n=this.saveTensorsForBackwardMode(k)}return v}}else{let{forwardFunc:d}=t,h=g=>{!o||(n=g.map(y=>this.keep(this.clone(y))))};a=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>d(this.backend,h));let y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}let{inputs:c,attrs:p}=t,m=uI(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(f=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs)}),o&&this.addTapeNode(l,c,e,m,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:e.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){let o=XC(t);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(A(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(l=>e[l])):a=s.map(l=>e[l]);let u=n.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(t,e,n,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=t;n==="string"&&Yo(t[0])&&(s=t.map(u=>jl(u)));let i=o.write(s,e,n),a=new Lt(e,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let u=this.state.tensorInfo.get(i),l=HC(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromTensorInfo(t,e){let{dataId:n,shape:o,dtype:s}=t,i=new Lt(o,s,n,this.nextTensorId());return this.trackTensor(i,e),i}makeVariable(t,e=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));let s=new Wa(t,e,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*yx(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Wa||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*yx(t.dtype);this.state.numBytes-=n}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},u=XC(t);u!=null&&(o=u.gradFunc),o!=null&&(a.gradient=l=>(l=l.map((c,p)=>{if(c==null){let m=n[p],f=Ep(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),o(l.length>1?l:l[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=rh(t),n=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(t,e,n,o=!1){if(A(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));A(s instanceof Lt,()=>"The result y returned by f() must be a tensor.");let i=K1(this.state.activeTape,e,s);if(!o&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n==null?d4(s.shape):n,j1(a,i,l=>this.tidy(l),h4);let u=e.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let c of l.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return A(yi(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{A(e.every(a=>a instanceof Lt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};e.forEach((a,u)=>{o[u]=a});let s=(a,u)=>(n=t(...e,u),A(n.value instanceof Lt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(yi(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,u)=>{let l=n.gradFunc(a,u),c=Array.isArray(l)?l:[l];A(c.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(m=>m instanceof Lt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){let e=Hu(),n=await this.backend.time(t);return n.wallMs=Hu()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Sx;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};Xl.nextTensorId=0;Xl.nextVariableId=0;function d4(r){let t=Gd(Jt(r),"float32");return _.makeTensor(t,r,"float32")}function cI(){let r=jC();if(r._tfengine==null){let t=new Hd(r);r._tfengine=new Xl(t)}return _1(r._tfengine.ENV),J1(()=>r._tfengine),r._tfengine}var _=cI();function h4(r,t){let e={a:r,b:t};return _.runKernel(Xn,e)}var Yl={};Yt(Yl,{isBrowser:()=>mI,isMobile:()=>y4,mockIsMobile:()=>x4});function g4(){return typeof navigator!="undefined"&&navigator!=null}var pI;function x4(r){pI=r}function y4(r){if(pI!==void 0)return pI;if(r||g4()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function mI(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var ho=V();ho.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ho.registerFlag("IS_BROWSER",()=>mI());ho.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");ho.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ho.registerFlag("PROD",()=>!1);ho.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ho.getBool("DEBUG"));ho.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ho.registerFlag("IS_TEST",()=>!1);ho.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ho.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ho.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Mr(r,t){let e=r;if(yr(r))return t==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||yr(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&n_(r,n,[]),n}function n_(r,t,e){if(e=e||[],!Array.isArray(r)&&!yr(r)){A(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),A(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let o=0;o<r.length;++o)n_(r[o],n,e.concat(o))}function r_(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function C(r,t,e,n="numeric"){if(r instanceof Lt)return r_(n,r.dtype,t,e),r;let o=Tp(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),r_(n,o,t,e),r==null||!yr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Mr(r,o);!yr(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?pm(r,o):Xo(r,[],!0);return _.makeTensor(a,s,o)}function Ua(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>C(s,`${t}[${i}]`,e,n))}var o_="__op";function N(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+o_;let o=(...s)=>{_.startScope(e);try{let i=n(...s);return Ud(i)&&console.error("Cannot return a Promise inside of tidy."),_.endScope(i),i}catch(i){throw _.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function b4(r,t){let e=C(r,"real","complex"),n=C(t,"imag","complex");Me(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:e,imag:n};return _.runKernel(Rp,o)}var zn=N({complex_:b4});function cn(r,t,e,n){if(n==null&&(n=Tp(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!yr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Wd(t);let o=Jt(t),s=Jt(e);A(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],u=i===e.length-1?a!==Jt(t.slice(i)):!0;A(e[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!yr(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?pm(r,n):Xo(r,[],!0),_.makeTensor(r,t,n)}function $r(r,t,e){let n=Mr(r,e);return cn(r,t,n,e)}var nh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var kx=4;async function i_(r,t){let e=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async p=>{let m=await u.bytes(),f=m.reduce((g,y)=>g+y.length,0)+kx*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let y=m[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);d.set(b,h),h+=kx,d.set(y,h),h+=y.length}p(d)});n.push(c)}else n.push(u.data());t!=null&&(l.group=t),e.push(l)}let s=await Promise.all(n);return{data:w4(s),specs:e}}function Nx(r,t){let e={},n,o=0;for(let s of t){let i=s.name,a=s.dtype,u=s.shape,l=Jt(u),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=nh[p.dtype],f=r.slice(o,o+l*m),d=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=S4()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*m}else if(a==="string"){let p=Jt(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(o,o+kx))[0];o+=kx;let d=new Uint8Array(r.slice(o,o+f));c.push(d),o+=f}}else{let p=nh[a],m=r.slice(o,o+l*p);if(a==="float32")c=new Float32Array(m);else if(a==="int32")c=new Int32Array(m);else if(a==="bool")c=new Uint8Array(m);else if(a==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[y*2],d[y]=c[y*2+1];let h=$r(f,u,"float32"),g=$r(d,u,"float32");e[i]=zn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*p}a!=="complex64"&&(e[i]=$r(c,u,a))}return e}function w4(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return e.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var fI=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function s_(r){return fI?Buffer.byteLength(r):new Blob([r]).size}function a_(r){if(fI)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function l_(r){if(fI){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function dm(r){if(r.length===1)return r[0];let t=0;r.forEach(o=>{t+=o.byteLength});let e=new Uint8Array(t),n=0;return r.forEach(o=>{e.set(new Uint8Array(o),n),n+=o.byteLength}),e.buffer}function dI(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function Tx(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}async function hm(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await t(r.weightsManifest);e.weightSpecs=n,e.weightData=o}return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),e}function zi(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:s_(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:s_(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function v4(){let r=e=>{let n=e<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function C4(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function I4(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function S4(){let r=v4(),t=C4(),e=I4();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[e[a>>10]+(a&1023)]+t[a>>10];s[i]=u}return new Float32Array(o)}}var Ne=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ne.instance==null&&(Ne.instance=new Ne),Ne.instance}static registerSaveRouter(t){Ne.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ne.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ne.getHandlers(t,"save")}static getLoadHandlers(t,e){return Ne.getHandlers(t,"load",e)}static getHandlers(t,e,n){let o=[];return(e==="load"?Ne.getInstance().loadRouters:Ne.getInstance().saveRouters).forEach(i=>{let a=i(t,n);a!==null&&o.push(a)}),o}},u_=r=>Ne.registerSaveRouter(r),c_=r=>Ne.registerLoadRouter(r),p_=r=>Ne.getSaveHandlers(r),m_=(r,t)=>Ne.getLoadHandlers(r,t);var hI="tensorflowjs",gI=1,Ku="models_store",Zl="model_info_store";function f_(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function xI(r){let t=r.result;t.createObjectStore(Ku,{keyPath:"modelPath"}),t.createObjectStore(Zl,{keyPath:"modelPath"})}var Bi=class{constructor(t){if(this.indexedDB=f_(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,o)=>{let s=this.indexedDB.open(hI,gI);s.onupgradeneeded=()=>xI(s),s.onsuccess=()=>{let i=s.result;if(e==null){let a=i.transaction(Ku,"readonly"),l=a.objectStore(Ku).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=c=>(i.close(),o(l.error)),a.oncomplete=()=>i.close()}else{let a=zi(e),u=i.transaction(Zl,"readwrite"),l=u.objectStore(Zl),c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(Ku,"readwrite");let f=p.objectStore(Ku).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a});f.onsuccess=()=>n({modelArtifactsInfo:a}),f.onerror=d=>{l=u.objectStore(Zl);let h=l.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(f.error)),h.onerror=g=>(i.close(),o(f.error))}},c.onerror=m=>(i.close(),o(c.error)),u.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};Bi.URL_SCHEME="indexeddb://";var d_=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Bi.URL_SCHEME)?k4(r.slice(Bi.URL_SCHEME.length)):null;Ne.registerSaveRouter(d_);Ne.registerLoadRouter(d_);function k4(r){return new Bi(r)}function N4(r){return r.startsWith(Bi.URL_SCHEME)?r.slice(Bi.URL_SCHEME.length):r}var _x=class{constructor(){this.indexedDB=f_()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(hI,gI);n.onupgradeneeded=()=>xI(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Zl,"readonly"),a=s.objectStore(Zl).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;t(u)},a.onerror=u=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>e(n.error)})}async removeModel(t){return t=N4(t),new Promise((e,n)=>{let o=this.indexedDB.open(hI,gI);o.onupgradeneeded=()=>xI(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Zl,"readwrite"),a=i.objectStore(Zl),u=a.get(t),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{l=s.transaction(Ku,"readwrite");let f=l.objectStore(Ku).delete(t);f.onsuccess=()=>e(u.result.modelArtifactsInfo),f.onerror=d=>n(u.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),n(u.error))}},u.onerror=c=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var Ha="/",gm="tensorflowjs_models",h_="info",T4="model_topology",_4="weight_specs",E4="weight_data",A4="model_metadata";function g_(r){return{info:[gm,r,h_].join(Ha),topology:[gm,r,T4].join(Ha),weightSpecs:[gm,r,_4].join(Ha),weightData:[gm,r,E4].join(Ha),modelMetadata:[gm,r,A4].join(Ha)}}function x_(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function $4(r){let t=r.split(Ha);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(Ha)}function D4(r){return r.startsWith(Vi.URL_SCHEME)?r.slice(Vi.URL_SCHEME.length):r}var Vi=class{constructor(t){if(!V().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=g_(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=zi(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,a_(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw x_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=l_(i),e}};Vi.URL_SCHEME="localstorage://";var y_=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Vi.URL_SCHEME)?F4(r.slice(Vi.URL_SCHEME.length)):null;Ne.registerSaveRouter(y_);Ne.registerLoadRouter(y_);function F4(r){return new Vi(r)}var Ex=class{constructor(){A(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=gm+Ha,n=Ha+h_;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(n)){let i=$4(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=D4(t);let e=g_(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return x_(e),n}};var xm="://",Xr=class{constructor(){this.managers={}}static getInstance(){return Xr.instance==null&&(Xr.instance=new Xr),Xr.instance}static registerManager(t,e){A(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(xm)&&(t=t.slice(0,t.indexOf(xm))),A(t.length>0,()=>"scheme must not be an empty string.");let n=Xr.getInstance();A(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=this.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Ax(r){if(r.indexOf(xm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Xr.getSchemes().join(",")}`);return{scheme:r.split(xm)[0],path:r.split(xm)[1]}}async function b_(r,t,e=!1){A(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=Ne.getLoadHandlers(r);A(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),A(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Ne.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],a=Ax(r).scheme,u=Ax(r).path,l=a===Ax(r).scheme,c=await o.load();e&&l&&await Xr.getManager(a).removeModel(u);let p=await i.save(c);return e&&!l&&await Xr.getManager(a).removeModel(u),p.modelArtifactsInfo}async function w_(){let r=Xr.getSchemes(),t={};for(let e of r){let n=await Xr.getManager(e).listModels();for(let o in n){let s=e+xm+o;t[s]=n[o]}}return t}async function v_(r){let t=Ax(r);return Xr.getManager(t.scheme).removeModel(t.path)}async function C_(r,t){return b_(r,t,!1)}async function I_(r,t){return b_(r,t,!0)}var yI=class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}};if(V().get("IS_BROWSER")){V().setPlatform("browser",new yI);try{Xr.registerManager(Vi.URL_SCHEME,new Ex)}catch(r){}try{Xr.registerManager(Bi.URL_SCHEME,new _x)}catch(r){}}var R4={importFetch:()=>S_()},bI;var wI=class{constructor(){this.util=k_(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return V().global.fetch!=null?V().global.fetch(t,e):(bI==null&&(bI=R4.importFetch()),bI(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}};V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new wI);function Ct(r,t="float32",e){return t=t||"float32",Wd(r),new pe(r,t,e)}function O4(r,t){let e=C(r,"x","cast");if(!UC(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},o={dtype:t};return _.runKernel(io,n,o)}var Z=N({cast_:O4});function M4(r){let e={x:C(r,"x","clone","string_or_numeric")};return _.runKernel(lo,e)}var kn=N({clone_:M4});function vI(r,t=!1){console.log(r.toString(t))}cI();var P4={buffer:Ct,cast:Z,clone:kn,print:vI};Q1(P4);var Pr={};Yt(Pr,{browserFiles:()=>T_,browserHTTPRequest:()=>A_,concatenateArrayBuffers:()=>dm,copyModel:()=>C_,decodeWeights:()=>Nx,encodeWeights:()=>i_,fromMemory:()=>$_,getLoadHandlers:()=>m_,getModelArtifactsForJSON:()=>hm,getModelArtifactsInfoForJSON:()=>zi,getSaveHandlers:()=>p_,http:()=>Dx,isHTTPScheme:()=>$x,listModels:()=>w_,loadWeights:()=>__,moveModel:()=>I_,registerLoadRouter:()=>c_,registerSaveRouter:()=>u_,removeModel:()=>v_,weightsLoaderFactory:()=>kI,withSaveHandler:()=>D_});var L4="model",z4=".json",B4=".weights.bin";function N_(r){return new Promise(t=>setTimeout(t)).then(r)}var qa=class{constructor(t){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(qa.URL_SCHEME)&&(t=t.slice(qa.URL_SCHEME.length)),(t==null||t.length===0)&&(t=L4),this.modelJsonFileName=t+z4,this.weightDataFileName=t+B4}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=Tx(t,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,await N_(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=e,await N_(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:zi(t)}}}};qa.URL_SCHEME="downloads://";var CI=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let u=hm(s,l=>this.loadWeights(l));t(u)},n.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){let e=[],n=[];for(let i of t)e.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,dm(i)])}loadWeightsFile(t,e){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(s=>dI(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=dI(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},V4=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(qa.URL_SCHEME)?G4(r.slice(qa.URL_SCHEME.length)):null;Ne.registerSaveRouter(V4);function G4(r="model"){return new qa(r)}function T_(r){return new CI(r)}function II(r,t,e,n){i(r),e=e==null?0:e,n=n==null?1:n,a(e,n);let o=0,s=u=>(u.then(l=>{let c=e+ ++o/r.length*(n-e);return t(c),l}),u);function i(u){A(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),A(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function SI(r,t){t==null&&(t={});let e=t.fetchFunc==null?V().platform.fetch:t.fetchFunc,n=r.map(p=>e(p,t.requestInit,{isBinary:!0})),o=0,s=.5,a=(t.onProgress==null?await Promise.all(n):await II(n,t.onProgress,o,s)).map(p=>p.arrayBuffer()),u=.5,l=1;return t.onProgress==null?await Promise.all(a):await II(a,t.onProgress,u,l)}async function __(r,t="",e,n){return kI(i=>SI(i,{requestInit:n}))(r,t,e)}function kI(r){return async(t,e="",n)=>{let o=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=nh[y]*Jt(g.shape),w=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:b})};n!=null?n.forEach((v,k)=>{v===g.name&&(w(),i[k]=!0)}):w(),a.push(g.name),h+=b})}),!i.every(f=>f)){let f=n.filter((d,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),l=[];u.forEach(f=>{t[f].paths.forEach(d=>{let h=e+(e.endsWith("/")?"":"/")+d;l.push(h)})});let c=await r(l),p={},m=0;return u.forEach(f=>{let d=t[f].paths.length,h=0;for(let v=0;v<d;v++)h+=c[m+v].byteLength;let g=new ArrayBuffer(h),y=new Uint8Array(g),b=0;for(let v=0;v<d;v++){let k=new Uint8Array(c[m+v]);y.set(k,b),b+=k.byteLength}s[f].forEach(v=>{let k=g.slice(v.groupOffset,v.groupOffset+v.sizeBytes),E=Nx(k,[v.manifestEntry]);for(let $ in E)p[$]=E[$]}),m+=d}),p}}var W4="application/octet-stream",U4="application/json",oh=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(A(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=V().platform.fetch,A(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&A(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=Tx(t,n);e.body.append("model.json",new Blob([JSON.stringify(o)],{type:U4}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:W4}),"model.weights.bin");let s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:zi(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=e.modelTopology,o=e.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return hm(e,s=>this.loadWeights(s))}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=H4(e),s=this.weightPathPrefix||n,i=[];for(let c of t)i.push(...c.weights);let a=[],u=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(p)):a.push(s+p+o);this.weightUrlConverter&&a.push(...await Promise.all(u));let l=await SI(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,dm(l)]}};oh.URL_SCHEME_REGEX=/^https?:\/\//;function H4(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),o=e>t?r.substring(e):"";return[n+"/",o]}function $x(r){return r.match(oh.URL_SCHEME_REGEX)!=null}var E_=(r,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>$x(n)):e=$x(r),e)return Dx(r,t)}return null};Ne.registerSaveRouter(E_);Ne.registerLoadRouter(E_);function Dx(r,t){return new oh(r,t)}function A_(r,t){return Dx(r,t)}var sh=class{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}},NI=class{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}};function $_(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new sh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sh({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function D_(r){return new NI(r)}var R_={};Yt(R_,{confusionMatrix:()=>F_});function q4(r,t,e=!1,n=!1){let o=C(r,"a","matMul"),s=C(t,"b","matMul");[o,s]=jt(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:n};return _.runKernel(ts,i,a)}var zt=N({matMul_:q4});function K4(r,t,e=1,n=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:C(r,"indices","oneHot","int32")},i={depth:t,onValue:e,offValue:n};return _.runKernel(ks,s,i)}var js=N({oneHot_:K4});function j4(r,t){let e=C(r,"x","transpose");if(t==null&&(t=e.shape.map((s,i)=>i).reverse()),A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(s=>{A(s>=0&&s<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1)return e.clone();let n={x:e},o={perm:t};return _.runKernel(Hs,n,o)}var Mt=N({transpose_:j4});function X4(r,t,e){let n=C(r,"labels","confusionMatrix"),o=C(t,"predictions","confusionMatrix");A(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),A(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),A(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),A(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),A(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let s=js(Z(n,"int32"),e),i=js(Z(o,"int32"),e),a=Mt(s),u=zt(a,i);return Z(u,"int32")}var F_=N({confusionMatrix_:X4});var Sr={};Yt(Sr,{assertAndGetBroadcastShape:()=>Bt,getBroadcastDims:()=>O_,getReductionAxes:()=>xe});function O_(r,t){let e=r.length,n=[];for(let o=0;o<e;o++){let s=e-1-o,i=r[s]||1;(t[t.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function xe(r,t){let e=[];for(let n=0;n<t.length;n++){let o=r[r.length-n-1],s=t.length-n-1,i=t[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function Bt(r,t){let e=[],n=Math.max(r.length,t.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)e.unshift(i);else if(i===1)e.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(a)}else e.unshift(s)}return e}var Fx={};Yt(Fx,{fromPixels:()=>rH,fromPixelsAsync:()=>tH,toPixels:()=>eH});function TI(r,t,e){if(jn(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Mr(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}var ju;function M_(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o&&o&&r.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(Zd(Xd,_.backendName)!=null){let d={pixels:r},h={numChannels:t};return _.runKernel(Xd,d,h)}let[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;if(i)p=r.getContext("2d").getImageData(0,0,l,c).data;else if(n||e)p=r.data;else if(s||o||a){if(ju==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")ju=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ju=document.createElement("canvas").getContext("2d");ju.canvas.width=l,ju.canvas.height=c,ju.drawImage(r,0,0,l,c),p=ju.getImageData(0,0,l,c).data}let m;if(t===4)m=new Int32Array(p);else{let d=l*c;m=new Int32Array(d*t);for(let h=0;h<d;h++)for(let g=0;g<t;++g)m[h*t+g]=p[h*4+g]}return TI(m,[c,l,t],"int32")}function Y4(r){return r!=null&&r.data instanceof Uint8Array}function Z4(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function J4(r){return r!=null&&r.width!==0&&r.height!==0}function Q4(r){return Z4()&&!(r instanceof ImageBitmap)&&J4(r)&&!Y4(r)}async function tH(r,t=3){let e=null;if(V().getBool("WRAP_TO_IMAGEBITMAP")&&Q4(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?e=n:e=r}else e=r;return M_(e,t)}async function eH(r,t){let e=C(r,"img","toPixels");if(!(r instanceof Lt)){let l=e;e=Z(l,"int32"),l.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[n,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let i=await e.data(),a=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=i[l*s+m];if(e.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(e.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[m]=f*a}let p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(t!=null){t.width=o,t.height=n;let l=t.getContext("2d"),c=new ImageData(u,o,n);l.putImageData(c,0,0)}return e!==r&&e.dispose(),u}var rH=N({fromPixels_:M_});var Rx={};Yt(Rx,{prepareAndValidate:()=>P_});function P_(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(Jt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=r.shape,u=o.slice();u.pop();let l=1;for(let p=s;p<e;++p)l*=a[p],u.push(a[p]);let c=[...bi(r.shape).map(p=>p/l),1].slice(0,s);return[u,i,l,c]}var ih={};Yt(ih,{calculateShapes:()=>L_,validateInput:()=>Ox,validateUpdateShape:()=>_I});function _I(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(e.rank-o))throw new Error(s+` Output shape length < ${n+(e.rank-o)}`);if(e.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function Ox(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}_I(e,t,r)}function L_(r,t,e){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,u=Jt(t.shape)/a,l=[...bi(e.slice(0,o)),1],c=Jt(e);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}var Ve={};Yt(Ve,{assertParamsValid:()=>oH,computeFlatOffset:()=>uH,computeOutShape:()=>iH,getNormalizedAxes:()=>aH,isSliceContinous:()=>lH,maskToAxes:()=>sH,parseSliceParams:()=>AI,sliceInfo:()=>cH,startForAxis:()=>q_,startIndicesWithElidedDims:()=>W_,stopForAxis:()=>K_,stopIndicesWithElidedDims:()=>U_,stridesForAxis:()=>H_,stridesWithElidedDims:()=>B_});var EI=-2,nH=-1;function oH(r,t,e){let n=r.shape.length;A(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),A(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)A(t[o]+e[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function sH(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function iH(r,t,e){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((t[o]-r[o])/e[o]);return n}function B_(r,t,e,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function V_(r,t,e){return e<=r?e:e-(t-1)}function G_(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function aH(r,t,e,n,o,s,i,a,u){let l=r.length,c=new Array(l),p=new Array(l),m=new Array(l);if(t.length&&e>0){let f=t[0],d=e+1;c=W_(i,f,d,n,r),p=U_(a,f,d,o,r),m=B_(s,f,d,r)}else for(let f=0;f<l;f++)c[f]=q_(i,n,s,r,f,u),p[f]=K_(a,o,s,r,f,u),m[f]=H_(s,f,u);return{begin:c,end:p,strides:m}}function W_(r,t,e,n,o){let s=[...o],i=G_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=V_(t,e,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function U_(r,t,e,n,o){let s=[...o],i=G_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=V_(t,e,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=Np(0,s[a],o[a])}return s}function H_(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function q_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=Np(0,i,u-1),i}function K_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=Np(0,i,u):i=Np(-1,i,u-1),i}function lH(r,t,e){let n=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){n=o;break}for(let o=n+1;o<e.length;o++)if(t[o]>0||e[o]!==r[o])return!1;return!0}function uH(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function AI(r,t,e){let n,o=r.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(i=>{A(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function cH(r,t,e,n,o,s,i,a,u){let l;if(n==null?(l=new Array(t.length),l.fill(1)):l=n,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let w=0;w<p.dims;w++)c&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};pH(p,m);let f=!0,d=!0,h=!0,g=[],y=[];for(let w=0;w<r.length;++w){if(m.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let v=!!(m.shrinkAxisMask&1<<w),k=r[w];if(k===-1){g.push(v?1:-1);continue}let E=[m.beginMask&1<<w,m.endMask&1<<w],$=[m.strides[w]>0?0:-1,m.strides[w]>0?k:k-1];if(v&&m.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&m.strides[w]===1;let D=!!(m.beginMask&1<<w&&m.endMask&1<<w);if(m.beginValid&&m.endValid){if(v){let U=m.begin[w]<0?k+m.begin[w]:m.begin[w];if(m.begin[w]=U,m.end[w]=m.begin[w]+1,U<0||U>=k)throw Error(`slice index ${m.begin[w]} of dimension ${w} out of bounds.`)}else m.begin[w]=z_(m.begin[w],0,m.strides[w],k,E,$),m.end[w]=z_(m.end[w],1,m.strides[w],k,E,$);let W=m.strides[w]===1&&m.begin[w]===0&&m.end[w]===k;f=f&&W,d=d&&(w===0&&m.strides[w]===1||W)}else f=f&&m.strides[w]===1&&D,d=d&&(w===0&&m.strides[w]===1||D);let F,P=!1;if(m.beginValid&&m.endValid?(F=m.end[w]-m.begin[w],P=!0):v?(F=1,P=!0):D&&k>=0&&(m.strides[w]<0?F=-k:F=k,P=!0),P){let W;F===0||F<0!=m.strides[w]<0?W=0:W=Math.trunc(F/m.strides[w])+(F%m.strides[w]!==0?1:0),g.push(W)}else g.push(-1)}for(let w=0;w<m.finalShapeGatherIndices.length;++w){let v=m.finalShapeGatherIndices[w];v>=0?y.push(g[v]):v===EI&&y.push(1)}return{finalShapeSparse:y.filter((w,v)=>m.finalShapeGatherIndices[v]!==EI),finalShape:y,isIdentity:f,sliceDim0:d,isSimpleSlice:h,begin:m.begin,end:m.end,strides:m.strides}}function pH(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(t.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&r.newAxisMask)t.finalShapeGatherIndices.push(EI),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[n]),r.end!=null&&(t.end[e]=r.end[n]),t.strides[e]=r.strides[n],r.beginMask&1<<n&&(t.beginMask|=1<<e),r.endMask&1<<n&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(nH),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function z_(r,t,e,n,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let i=r<0?n+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var et={};Yt(et,{Serializable:()=>ah,SerializationMap:()=>Gi,registerClass:()=>Nn});var ah=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Gi=class{constructor(){this.classNameMap={}}static getMap(){return Gi.instance==null&&(Gi.instance=new Gi),Gi.instance}static register(t){Gi.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Nn(r){A(r.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),A(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Gi.register(r)}var Z_={};Yt(Z_,{TEST_EPSILON_FLOAT16:()=>j_,encodeStrings:()=>Y_,expectArrayBuffersEqual:()=>xH,expectArraysClose:()=>fH,expectArraysEqual:()=>hH,expectNumbersClose:()=>X_,expectPromiseToFail:()=>dH,expectValuesInRange:()=>gH,testEpsilon:()=>Mx});var mH=.001,j_=.1;function fH(r,t,e){return e==null&&(e=Mx()),$I(r,t,(n,o)=>DI(n,o,e))}function Mx(){return _.backend.floatPrecision()===32?mH:j_}function $I(r,t,e){let n=!0;if((yr(r)||yr(t))&&(n=!1),yr(r)&&yr(t)&&(n=!0),n){let i=r.constructor.name,a=t.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(r)&&Array.isArray(t)){let i=Mr(r),a=Mr(t);if(!Mn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=yr(r)?r:Xo(r),s=yr(t)?t:Xo(t);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],u=s[i];if(!e(a,u))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}}function dH(r,t){r().then(()=>t.fail(),()=>t())}function hH(r,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Yo(r)||Yo(r[0])||Yo(t)||Yo(t[0])?$I(r,e,(n,o)=>n==o):$I(r,t,(n,o)=>DI(n,o,0))}function X_(r,t,e){if(e==null&&(e=Mx()),!DI(r,t,e))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`)}function DI(r,t,e){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>e)}function gH(r,t,e){for(let n=0;n<r.length;n++)if(r[n]<t||r[n]>e)throw new Error(`Value out of range:${r[n]} low: ${t}, high: ${e}`)}function xH(r,t){let e=new Float32Array(r),n=new Float32Array(t);if(e.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${e.length}`);for(let o=0;o<n.length;o++)if(e[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${e[o]} instead`)}function Y_(r){for(let t=0;t<r.length;t++){let e=r[t];Array.isArray(e)?Y_(e):r[t]=jl(e)}return r}var J_="3.17.0";function vpt(){V().set("PROD",!0)}function Cpt(){V().set("DEBUG",!0)}function Ipt(){V().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function FI(r){V().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}t_(FI);function Spt(){_.disposeVariables()}function go(){return _}function lh(){return _.memory()}function kpt(r){return _.profile(r)}function B(r,t){return _.tidy(r,t)}function _t(r){rh(r).forEach(e=>e.dispose())}function Pe(r){return _.keep(r)}function Npt(r){return _.time(r)}function yH(r){return _.setBackend(r)}function Tpt(){return _.ready()}function _pt(){return _.backendName}function Ept(r){_.removeBackend(r)}function Apt(r){return _.findBackend(r)}function $pt(r){return _.findBackendFactory(r)}function ym(r,t,e=1){return _.registerBackend(r,t,e)}function Q_(){return _.backend}function Dpt(r,t){V().setPlatform(r,t)}function bH(r,t){let e=C(r,"a","add"),n=C(t,"b","add");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Xn,o)}var J=N({add_:bH});function wH(r,t){let e=C(r,"a","floorDiv"),n=C(t,"b","floorDiv");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(ms,o)}var Xu=N({floorDiv_:wH});function vH(r,t){let e=C(r,"a","div"),n=C(t,"b","div");if([e,n]=jt(e,n),e.dtype==="int32"&&n.dtype==="int32")return Xu(e,n);let o={a:e,b:n},s={};return _.runKernel(ls,o,s)}var ct=N({div_:vH});function CH(r,t){let e=C(r,"a","mul"),n=C(t,"b","mul");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ss,o)}var M=N({mul_:CH});function IH(r){let t=C(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return _.runKernel(Rl,e)}else{let e={x:t};return _.runKernel(wi,e)}}var Te=N({abs_:IH});function SH(r){let e={x:C(r,"x","acos")};return _.runKernel(ra,e)}var uh=N({acos_:SH});function kH(r){let e={x:C(r,"x","acosh")};return _.runKernel(na,e)}var ch=N({acosh_:kH});function NH(r){A(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),A(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((o,s)=>C(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!Mn(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return _.runKernel(Zo,n)}var RI=N({addN_:NH});function TH(r,t=null,e=!1){let o={x:C(r,"x","all","bool")},s={axis:t,keepDims:e};return _.runKernel(oa,o,s)}var Yu=N({all_:TH});function _H(r,t=null,e=!1){let o={x:C(r,"x","any","bool")},s={axis:t,keepDims:e};return _.runKernel(sa,o,s)}var Jl=N({any_:_H});function EH(r,t=0){let n={x:C(r,"x","argMax")},o={axis:t};return _.runKernel(Jo,n,o)}var Xs=N({argMax_:EH});function AH(r,t=0){let n={x:C(r,"x","argMin")},o={axis:t};return _.runKernel(Dl,n,o)}var ph=N({argMin_:AH});function $H(r){let e={x:C(r,"x","asin")};return _.runKernel(ia,e)}var mh=N({asin_:$H});function DH(r){let e={x:C(r,"x","asinh")};return _.runKernel(aa,e)}var fh=N({asinh_:DH});function FH(r){let e={x:C(r,"x","atan")};return _.runKernel(la,e)}var dh=N({atan_:FH});function RH(r,t){let e=C(r,"a","atan2"),n=C(t,"b","atan2");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(ca,o)}var hh=N({atan2_:RH});function OH(r){let e={x:C(r,"x","atanh")};return _.runKernel(ua,e)}var gh=N({atanh_:OH});function MH(r,t,e,n,o="NHWC",s){let i=r[3],a=[...t,i],u=eE(o);return Ju(r,a,e,s,n,null,null,u)}function MI(r,t,e,n,o,s,i="channelsLast"){let[a,u]=Px(t),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return Ju(r,l,e,n,o,s,!1,i)}function PH(r,t,e,n,o,s,i="NDHWC"){let[a,u,l]=OI(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,u,l,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return tE(r,c,e,n,o,!1,p,s)}function Ju(r,t,e,n,o,s,i=!1,a="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,p]=r;else if(a==="channelsFirst")[u,p,l,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,f,,d]=t,[h,g]=Px(e),[y,b]=Px(n),w=bm(m,y),v=bm(f,b),{padInfo:k,outHeight:E,outWidth:$}=BH(o,l,c,h,g,w,v,s,a),D=i?d*p:d,F;return a==="channelsFirst"?F=[u,D,E,$]:a==="channelsLast"&&(F=[u,E,$,D]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:p,outHeight:E,outWidth:$,outChannels:D,padInfo:k,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:r,outShape:F,filterShape:t}}function tE(r,t,e,n,o,s=!1,i="channelsLast",a){let[u,l,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p,m]=r;else if(i==="channelsFirst")[u,m,l,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,d,h,,g]=t,[y,b,w]=OI(e),[v,k,E]=OI(n),$=bm(f,v),D=bm(d,k),F=bm(h,E),{padInfo:P,outDepth:W,outHeight:U,outWidth:q}=VH(o,l,c,p,y,b,w,$,D,F,a),K=s?g*m:g,j;return i==="channelsFirst"?j=[u,K,W,U,q]:i==="channelsLast"&&(j=[u,W,U,q,K]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:m,outDepth:W,outHeight:U,outWidth:q,outChannels:K,padInfo:P,strideDepth:y,strideHeight:b,strideWidth:w,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:$,effectiveFilterHeight:D,effectiveFilterWidth:F,dilationDepth:v,dilationHeight:k,dilationWidth:E,inShape:r,outShape:j,filterShape:t}}function LH(r,t,e,n,o){n==null&&(n=PI(r,t,e));let s=r[0],i=r[1],a=Zu((s-t+2*n)/e+1,o),u=Zu((i-t+2*n)/e+1,o);return[a,u]}function zH(r,t,e,n,o,s){o==null&&(o=PI(r,t,n));let i=r[0],a=r[1],u=r[2],l=Zu((i-t+2*o)/n+1,s),c=Zu((a-t+2*o)/n+1,s),p=Zu((u-t+2*o)/n+1,s);return[l,c,p,e]}function PI(r,t,e,n=1){let o=bm(t,n);return Math.floor((r[0]*(e-1)-e+o)/2)}function Px(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function OI(r){return typeof r=="number"?[r,r,r]:r}function bm(r,t){return t<=1?r:r+(r-1)*(t-1)}function BH(r,t,e,n,o,s,i,a,u){let l,c,p;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=LH([t,e],s,n,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(t/n),p=Math.ceil(e/o);let m=Math.max(0,(c-1)*n+s-t),f=Math.max(0,(p-1)*o+i-e),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),y=f-g;l={top:d,bottom:h,left:g,right:y,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),p=Math.ceil((e-i+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],d=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=Zu((t-s+m+f)/n+1,a),p=Zu((e-i+d+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:c,outWidth:p}}function VH(r,t,e,n,o,s,i,a,u,l,c){let p,m,f,d;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=zH([t,e,n,1],a,1,o,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(t/o),f=Math.ceil(e/s),d=Math.ceil(n/i);let h=(m-1)*o+a-t,g=(f-1)*s+u-e,y=(d-1)*i+l-n,b=Math.floor(h/2),w=h-b,v=Math.floor(g/2),k=g-v,E=Math.floor(y/2),$=y-E;p={top:v,bottom:k,left:E,right:$,front:b,back:w,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((t-a+1)/o),f=Math.ceil((e-u+1)/s),d=Math.ceil((n-l+1)/i);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:d}}function Zu(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Zn(r){let[t,e,n]=Px(r);return t===1&&e===1&&n===1}function Dr(r,t){return Zn(r)||Zn(t)}function eE(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function _e(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")A(ea(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{A(ea(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function GH(r,t){let n={x:C(r,"x","reshape","string_or_numeric")},o={shape:t};return _.runKernel(_i,n,o)}var R=N({reshape_:GH});function WH(r,t,e,n,o){let s=C(r,"x","avgPool","float32"),i=1;A(Dr(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=R(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),_e("avgPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(Qo,l,c);return p=Z(p,s.dtype),u?R(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Ka=N({avgPool_:WH});function UH(r,t,e,n,o,s="NDHWC"){let i=C(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=R(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_e("avgPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(Fl,l,c);return p=Z(p,a.dtype),u?R(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var xh=N({avgPool3d_:UH});function HH(r,t=0){A(r.length>=1,()=>"Pass at least one tensor to concat");let e=Ua(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return kn(e[0]);let n=e,o={axis:t};return _.runKernel(Ci,n,o)}var se=N({concat_:HH});function qH(r){let e={x:C(r,"x","sigmoid","float32")};return _.runKernel(Ps,e)}var Lr=N({sigmoid_:qH});function KH(r,t,e){let n=C(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:e};return _.runKernel(Ai,o,s)}var Ft=N({slice_:KH});function jH(r){let e={x:C(r,"x","tanh","float32")};return _.runKernel(Us,e)}var Ys=N({tanh_:jH});function XH(r,t,e,n,o,s){let i=C(r,"forgetBias","basicLSTMCell"),a=C(t,"lstmKernel","basicLSTMCell"),u=C(e,"lstmBias","basicLSTMCell"),l=C(n,"data","basicLSTMCell"),c=C(o,"c","basicLSTMCell"),p=C(s,"h","basicLSTMCell"),m=se([l,p],1),f=zt(m,a),d=J(f,u),h=d.shape[0],g=d.shape[1]/4,y=[h,g],b=Ft(d,[0,0],y),w=Ft(d,[0,g],y),v=Ft(d,[0,g*2],y),k=Ft(d,[0,g*3],y),E=J(M(Lr(b),Ys(w)),M(c,Lr(J(i,v)))),$=M(Ys(E),Lr(k));return[E,$]}var YH=N({basicLSTMCell_:XH});function ZH(r,t,e){let n=C(r,"x","batchToSpaceND"),o=t.reduce((a,u)=>a*u);A(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),A(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),A(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},i={blockShape:t,crops:e};return _.runKernel(vi,s,i)}var ja=N({batchToSpaceND_:ZH});function rE(r){let t;return r.rank===0||r.rank===1?t=R(r,[1,1,1,r.size]):r.rank===2?t=R(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=R(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function JH(r,t,e,n,o,s){s==null&&(s=.001);let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;n!=null&&(c=C(n,"offset","batchNorm")),A(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:rE(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:s},d=_.runKernel(fs,m,f);return R(d,i.shape)}var xo=N({batchNorm_:JH});function QH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var LI=N({batchNorm2d_:QH});function tq(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var zI=N({batchNorm3d_:tq});function eq(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var BI=N({batchNorm4d_:eq});function rq(r,t,e){let n=C(r,"x","bincount"),o=C(t,"weights","bincount");A(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:e};return _.runKernel(Dp,s,i)}var yh=N({bincount_:rq});function nq(r,t){let e=C(r,"s0","broadcastArgs","int32"),n=C(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:e,s1:n};return _.runKernel(Fp,o)}var VI=N({broadcastArgs_:nq});function oq(r,t){let e=C(r,"broadcastTo","x"),n=e.shape;if(t.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let l=e.shape.slice();for(;l.length<t.length;)l.unshift(1);e=R(e,l)}let o=e.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(o[l]===t[l])s[l]=1;else if(e.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return kn(e);let a={x:e},u={reps:s};return _.runKernel(Yn,a,u)}var Xa=N({broadcastTo_:oq});function sq(r){let e={x:C(r,"x","ceil","float32")};return _.runKernel(es,e)}var bh=N({ceil_:sq});function iq(r,t,e){let n=C(r,"x","clipByValue");A(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let o={x:n},s={clipValueMin:t,clipValueMax:e};return _.runKernel(ao,o,s)}var br=N({clipByValue_:iq});function aq(r){return se(r,0)}var GI=N({concat1d_:aq});function lq(r,t){return se(r,t)}var WI=N({concat2d_:lq});function uq(r,t){return se(r,t)}var UI=N({concat3d_:uq});function cq(r,t){return se(r,t)}var HI=N({concat4d_:cq});function pq(r,t,e,n,o="NHWC",s=[1,1],i){let a=C(r,"x","conv2d","float32"),u=C(t,"filter","conv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=R(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),_e("conv2d",n,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];A(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),A(Dr(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=_.runKernel(rs,m,f);return c?R(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var pn=N({conv2d_:pq});function mq(r,t,e,n,o="NWC",s=1,i){let a=C(r,"x","conv1d"),u=C(t,"filter","conv1d"),l=a,c=!1;a.rank===2&&(c=!0,l=R(a,[1,a.shape[0],a.shape[1]])),A(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),A(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),_e("conv1d",n,i),A(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),A(Dr(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),A(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=R(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=R(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=pn(m,p,[1,e],n,"NHWC",[1,s],i);return c?R(g,[g.shape[2],g.shape[3]]):R(g,[g.shape[0],g.shape[2],g.shape[3]])}var Qu=N({conv1d_:mq});function fq(r,t,e,n,o,s="NHWC",i){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,u=t,l=!1;t.rank===3&&(l=!0,u=R(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,r[0],r[1],r[2]]),A(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),A(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),A(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?u.shape[3]:u.shape[1];A(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),A(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),_e("conv2dDerInput",o,i);let m={dy:u,filter:e},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},d=_.runKernel(ns,m,f);return l?R(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var wm=N({conv2DBackpropInput_:fq});function dq(r,t,e,n,o,s){let i=C(r,"x","conv2dTranspose"),a=C(t,"filter","conv2dTranspose");return wm(e,i,a,n,o,"NHWC",s)}var tc=N({conv2dTranspose_:dq});function hq(r,t,e,n,o="NDHWC",s=[1,1,1]){let i=C(r,"x","conv3d"),a=C(t,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=R(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),A(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),A(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),A(Dr(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:u,filter:a},p={strides:e,pad:n,dataFormat:o,dilations:s},m=_.runKernel(Ol,c,p);return l?R(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var wh=N({conv3d_:hq});function gq(r,t,e,n,o){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,i=t,a=!1;t.rank===4&&(a=!0,i=R(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),A(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),A(l===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:n,inputShape:s},m=_.runKernel(Pp,c,p);return a?R(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Lx=N({conv3DBackpropInput_:gq});function xq(r,t,e,n,o){let s=C(r,"x","conv3dTranspose"),i=C(t,"filter","conv3dTranspose");return Lx(e,s,i,n,o)}var qI=N({conv3dTranspose_:xq});function yq(r){let e={x:C(r,"x","cos","float32")};return _.runKernel(os,e)}var Ya=N({cos_:yq});function bq(r){let e={x:C(r,"x","cosh","float32")};return _.runKernel(ss,e)}var ec=N({cosh_:bq});function wq(r,t=0,e=!1,n=!1){let s={x:C(r,"x","cumprod")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(pa,s,i)}var Ql=N({cumprod_:wq});function vq(r,t=0,e=!1,n=!1){let s={x:C(r,"x","cumsum")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(is,s,i)}var rc=N({cumsum_:vq});function Cq(r,t,e,n=!1){let o=C(r,"x","denseBincount"),s=C(t,"weights","denseBincount");A(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),A(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:n};return _.runKernel(Lp,i,a)}var KI=N({denseBincount_:Cq});function Iq(r,t,e="NHWC"){let n=C(r,"x","depthToSpace","float32"),o=e==="NHWC"?n.shape[1]:n.shape[2],s=e==="NHWC"?n.shape[2]:n.shape[3],i=e==="NHWC"?n.shape[3]:n.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:t,dataFormat:e};return _.runKernel(fa,a,u)}var vh=N({depthToSpace_:Iq});function Sq(r,t,e,n,o="NHWC",s=[1,1],i){let a=C(r,"x","depthwiseConv2d","float32"),u=C(t,"filter","depthwiseConv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=R(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),_e("depthwiseConv2d",n,i);let p={x:l,filter:u},m={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},f=_.runKernel(as,p,m);return c?R(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Zs=N({depthwiseConv2d_:Sq});function kq(r){let e={x:C(r,"x","diag")};return _.runKernel(Vp,e)}var Nq=N({diag_:kq});function Tq(r,t,e,n,o=[1,1],s="NHWC"){let i=C(r,"x","dilation2d"),a=C(t,"filter","dilation2d");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),A(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=R(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);let c={x:u,filter:a},p={strides:e,pad:n,dilations:o},m=_.runKernel(Ml,c,p);return l?R(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ch=N({dilation2d_:Tq});function _q(r,t){let e=C(r,"a","equal","string_or_numeric"),n=C(t,"b","equal","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ha,o)}var kr=N({equal_:_q});function Eq(r,t,e){let n=C(t,"a","where"),o=C(e,"b","where"),s=C(r,"condition","where","bool"),i=Bt(Bt(s.shape,n.shape),o.shape),a=Xa(s,i),u=Xa(n,i),l=Xa(o,i),c={condition:a,t:u,e:l};return _.runKernel(Ei,c)}var Ee=N({where_:Eq});function Aq(r){let e={x:C(r,"x","zerosLike")};return _.runKernel(Ri,e)}var St=N({zerosLike_:Aq});function $q(r,t){let e=C(r,"a","div"),n=C(t,"b","div");[e,n]=jt(e,n);let o=ct(e,n),s=St(o),i=kr(n,s);return Ee(i,s,o)}var Ih=N({divNoNan_:$q});function Dq(r,t){let e=C(r,"t1","dot"),n=C(t,"t2","dot");A((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=n.rank===1?n.size:n.shape[0];if(A(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&n.rank===1){let i=R(e,[1,-1]),a=R(n,[-1,1]),u=zt(i,a);return R(u,[])}else if(e.rank===1&&n.rank===2){let i=R(e,[1,-1]),a=R(n,[n.shape[0],n.shape[1]]),u=zt(i,a);return R(u,[u.size])}else if(e.rank===2&&n.rank===1){let i=R(n,[-1,1]),a=zt(e,i);return R(a,[a.size])}else{let i=R(n,[n.shape[0],n.shape[1]]);return zt(e,i)}}var jI=N({dot_:Dq});function Fq(r,...t){let e=t.map((o,s)=>C(o,`tensors${s}`,"einsum")),n={equation:r};return _.runKernel(Gp,e,n)}var XI=N({einsum_:Fq});function Rq(r){let e={x:C(r,"x","elu","float32")};return _.runKernel(us,e)}var Js=N({elu_:Rq});function Oq(r){let t=C(r,"x","erf");A(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Z(t,"float32"));let e={x:t};return _.runKernel(da,e)}var Sh=N({erf_:Oq});function YI(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function nE(r,t,e){let n=r.length+t.length,o=[],s=0,i=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?o.push(r[s++]):o.push(t[i++]);return o}function ZI(r,t){let e=[],n=r.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&e.push(r[s]);let o=t.map(s=>r[s]);return[e,o]}function yo(r,t){let e=t.map(n=>1);return nE(r,e,t)}function Mq(r,t,e){A(YI(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function JI(r,t){if(YI(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function kh(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Pq(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function Lq(r,t=null,e=!1){let o={x:C(r,"x","max")},s={reductionIndices:t,keepDims:e};return _.runKernel(xs,o,s)}var Fr=N({max_:Lq});function zq(r,t=null,e=!1){let o={x:C(r,"x","min")},s={axis:t,keepDims:e};return _.runKernel(vs,o,s)}var tu=N({min_:zq});function Bq(r,t){let e=C(r,"base","pow"),n=C(t,"exp","pow");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ts,o)}var Yr=N({pow_:Bq});function pt(r,t){if((yr(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&yr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return cn(r,[],[],t)}function Vq(r){let e={x:C(r,"x","sqrt","float32")};return _.runKernel(Ls,e)}var ye=N({sqrt_:Vq});function Gq(r){let t=C(r,"x","square"),e={};return _.runKernel("Square",{x:t},e)}var Wt=N({square_:Gq});function Wq(r,t=null,e=!1){let n=C(r,"x","sum");n.dtype==="bool"&&(n=Z(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(zs,o,s)}var mt=N({sum_:Wq});function Uq(r,t="euclidean",e=null,n=!1){r=C(r,"x","norm");let o=oE(r,t,e),s=o.shape;if(n){let i=mr(e,r.shape);s=yo(o.shape,i)}return R(o,s)}function oE(r,t,e=null){if(r.rank===0)return Te(r);if(r.rank!==1&&e===null)return oE(R(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return mt(Te(r),e);if(t===1/0)return Fr(Te(r),e);if(t===-1/0)return tu(Te(r),e);if(t==="euclidean"||t===2)return ye(mt(Yr(Te(r),pt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Fr(mt(Te(r),e[0]),e[1]-1);if(t===1/0)return Fr(mt(Te(r),e[1]),e[0]);if(t===-1/0)return tu(mt(Te(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return ye(mt(Wt(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var eu=N({norm_:Uq});function Hq(r,t=null,e=!1){return eu(r,"euclidean",t,e)}var Nh=N({euclideanNorm_:Hq});function qq(r){let e={x:C(r,"x","exp")};return _.runKernel(cs,e)}var Ye=N({exp_:qq});function Kq(r,t=0){let e=C(r,"x","expandDims","string_or_numeric");A(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},o={dim:t};return _.runKernel(Ii,n,o)}var fr=N({expandDims_:Kq});function jq(r){let e={x:C(r,"x","expm1")};return _.runKernel(ga,e)}var Th=N({expm1_:jq});function Xq(r,t){let e=C(r,"x","tile","string_or_numeric");A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},o={reps:t};return _.runKernel(Yn,n,o)}var Nr=N({tile_:Xq});function Yq(r,t,e,n="float32"){t==null&&(t=r);let o=Ct([r,t],n),s=r<=t?r:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=R(o.toTensor(),[r,t]);if(e==null)return i;if(e.length===1)return Nr(fr(i,0),[e[0],1,1]);if(e.length===2)return Nr(fr(fr(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return Nr(fr(fr(fr(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var vm=N({eye_:Yq});function Qs(r,t,e){let n={shape:r,value:t,dtype:e};return _.runKernel(Pl,{},n)}function Zq(r){let e={x:C(r,"x","floor","float32")};return _.runKernel(ps,e)}var ti=N({floor_:Zq});function Jq(r,t,e=0,n=0){let o=C(r,"x","gather"),s=C(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:n};return _.runKernel(Si,i,a)}var bo=N({gather_:Jq});function Qq(r,t){let e=C(r,"a","greater","string_or_numeric"),n=C(t,"b","greater","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ba,o)}var Ge=N({greater_:Qq});function tK(r,t){let e=C(r,"a","greaterEqual","string_or_numeric"),n=C(t,"b","greaterEqual","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ds,o)}var Tn=N({greaterEqual_:tK});function eK(r){let e={input:C(r,"input","imag")};return _.runKernel(qp,e)}var nc=N({imag_:eK});function rK(r){let e={x:C(r,"x","isFinite")};return _.runKernel(wa,e)}var tS=N({isFinite_:rK});function nK(r){let e={x:C(r,"x","isInf")};return _.runKernel(va,e)}var eS=N({isInf_:nK});function oK(r){let e={x:C(r,"x","isNaN")};return _.runKernel(Ca,e)}var _h=N({isNaN_:oK});function sK(r,t=.2){let n={x:C(r,"x","leakyRelu")},o={alpha:t};return _.runKernel(hs,n,o)}var Za=N({leakyRelu_:sK});function iK(r,t){let e=C(r,"a","less","string_or_numeric"),n=C(t,"b","less","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ia,o)}var oc=N({less_:iK});function aK(r,t){let e=C(r,"a","lessEqual","string_or_numeric"),n=C(t,"b","lessEqual","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Sa,o)}var _n=N({lessEqual_:aK});function rS(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:t,num:e};return _.runKernel(Kp,{},n)}function lK(r,t=5,e=1,n=1,o=.5){let s=C(r,"x","localResponseNormalization");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),A(ea(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=R(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:t,bias:e,alpha:n,beta:o},c=_.runKernel(Ll,u,l);return a?R(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Eh=N({localResponseNormalization_:lK});function uK(r){let e={x:C(r,"x","log","float32")};return _.runKernel(gs,e)}var wr=N({log_:uK});function cK(r){let e={x:C(r,"x","log1p")};return _.runKernel(ka,e)}var Ja=N({log1p_:cK});function pK(r){return A(yi(r),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let n=C(t,"x","tf.grad","string_or_numeric"),o=e!=null?C(e,"dy","tf.grad"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(n),[n],o);return o!=null&&Me(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Bx(i),i[0]})}}function mK(r){return A(yi(r),()=>"The f passed in grads(f) must be a function"),(t,e)=>{A(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=Ua(t,"args","tf.grads","string_or_numeric"),o=e!=null?C(e,"dy","tf.grads"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(...n),n,o);return o!=null&&Me(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Bx(i),i})}}function fK(r){return A(yi(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{A(t instanceof Lt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),A(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=_.gradients(()=>r(t),[t],e);return Bx(n),{grad:n[0],value:o}}}function dK(r){return A(yi(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{A(Array.isArray(t)&&t.every(o=>o instanceof Lt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),A(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=_.gradients(()=>r(...t),t,e);return e!=null&&Me(n.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Bx(n.grads),n}}function zx(r,t){A(yi(r),()=>"The f passed in variableGrads(f) must be a function"),A(t==null||Array.isArray(t)&&t.every(l=>l instanceof Wa),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let l in _.registeredVariables)t.push(_.registeredVariables[l])}let n=e?t.filter(l=>!l.trainable):null,o=t.length;t=t.filter(l=>l.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=_.gradients(r,t,null,s);A(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),n!=null&&n.forEach(l=>u[l.name]=null),{value:i,grads:u}}function mn(r){return _.customGrad(r)}function Bx(r){if(r.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function hK(r){let e={x:C(r,"x","neg")};return _.runKernel(ki,e)}var Zt=N({neg_:hK});function gK(r){let e={x:C(r,"x","softplus")};return _.runKernel(Pa,e)}var wo=N({softplus_:gK});function xK(r){let t=C(r,"x","logSigmoid");return mn(n=>({value:Zt(wo(Zt(n))),gradFunc:i=>M(i,Lr(Zt(n)))}))(t)}var nS=N({logSigmoid_:xK});function yK(r,t){let e=C(r,"a","sub"),n=C(t,"b","sub");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Gs,o)}var lt=N({sub_:yK});function bK(r,t=-1){let e=C(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return mn((o,s)=>{let a=Fr(o,t,!0),u=lt(o,a),l=lt(Z(u,"float32"),wr(mt(Ye(u),t,!0)));return s([l]),{value:l,gradFunc:(p,m)=>{let[f]=m,d=!0,h=Ye(f);return lt(p,M(mt(p,t,d),h))}}})(e)}var sc=N({logSoftmax_:bK});function wK(r,t=null,e=!1){let n=C(r,"x","logSumExp"),o=mr(t,n.shape),s=Fr(n,o,!0),i=lt(n,s),a=Ye(i),u=mt(a,o),l=wr(u),c=J(R(s,l.shape),l);if(e){let p=yo(c.shape,o);return R(c,p)}return c}var Ah=N({logSumExp_:wK});function vK(r,t){let e=C(r,"a","logicalAnd","bool"),n=C(t,"b","logicalAnd","bool");Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Na,o)}var Tr=N({logicalAnd_:vK});function CK(r){let e={x:C(r,"x","logicalNot","bool")};return _.runKernel(Lu,e)}var Qa=N({logicalNot_:CK});function IK(r,t){let e=C(r,"a","logicalOr","bool"),n=C(t,"b","logicalOr","bool");Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(zu,o)}var ic=N({logicalOr_:IK});function SK(r,t){let e=C(r,"a","logicalXor","bool"),n=C(t,"b","logicalXor","bool");return Bt(e.shape,n.shape),Tr(ic(r,t),Qa(Tr(r,t)))}var oS=N({logicalXor_:SK});var Vx=2147483648;function kK(r,t,e="left"){let n=C(r,"sortedSequence","searchSorted"),o=C(t,"values","searchSorted"),s=n.shape[n.shape.length-1],i=o.shape[o.shape.length-1],a=R(n,[-1,s]),u=R(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Jt(u.shape)>=Vx)throw new Error(`values tensor size must less than ${Vx}`);if(a.shape[1]>=Vx)throw new Error(`trailing dim_size must less than ${Vx} for int32 output type, was ${a.shape[1]}`);let l={sortedSequence:a,values:u},c={side:e};return _.runKernel(rm,l,c)}var Gx=N({searchSorted_:kK});function sS(r,t){return Gx(r,t,"left")}function NK(r,t,e,n,o){let s=C(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=R(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),A(Dr(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),_e("maxPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(bs,l,c);return u?R(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var tl=N({maxPool_:NK});function TK(r,t=[1,1,1],e,n,o,s="NDHWC"){let i=C(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=R(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_e("maxPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(zl,l,c);return u?R(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var $h=N({maxPool3d_:TK});function _K(r,t,e,n,o=!1){let i={x:C(r,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:n,includeBatchInIndex:o},u=_.runKernel(Zp,i,a);return{result:u[0],indexes:u[1]}}var iS=N({maxPoolWithArgmax_:_K});function EK(r,t){let e=C(r,"a","maximum"),n=C(t,"b","maximum");[e,n]=jt(e,n),e.dtype==="bool"&&(e=Z(e,"int32"),n=Z(n,"int32")),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ys,o)}var fn=N({maximum_:EK});function AK(r,t=null,e=!1){let o={x:C(r,"x","mean")},s={axis:t,keepDims:e};return _.runKernel(ws,o,s)}var be=N({mean_:AK});function we(r,t="float32"){if(t==="complex64"){let n=we(r,"float32"),o=we(r,"float32");return zn(n,o)}let e=Ep(Jt(r),t);return _.makeTensor(e,r,t)}function lr(r,t="float32"){if(t==="complex64"){let n=lr(r,"float32"),o=we(r,"float32");return zn(n,o)}let e=Gd(Jt(r),t);return _.makeTensor(e,r,t)}function $K(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=C(r,"x","meshgrid",r instanceof Lt?r.dtype:"float32");if(t===void 0)return[n];let o=C(t,"y","meshgrid",t instanceof Lt?t.dtype:"float32"),s=Jt(n.shape),i=Jt(o.shape);return e==="xy"?(n=R(n,[1,-1]),o=R(o,[-1,1]),[zt(lr([i,1],n.dtype),n),zt(o,lr([1,s],o.dtype))]):(n=R(n,[-1,1]),o=R(o,[1,-1]),[zt(n,lr([1,i],n.dtype)),zt(lr([s,1],o.dtype),o)])}function DK(r,t){let e=C(r,"a","minimum"),n=C(t,"b","minimum");[e,n]=jt(e,n),e.dtype==="bool"&&(e=Z(e,"int32"),n=Z(n,"int32")),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Cs,o)}var ei=N({minimum_:DK});function FK(r,t,e){A(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=C(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<n.rank;a++)A(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(t[a][0]>=0&&t[a][0]<=n.shape[a]-o&&t[a][1]>=0&&t[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:e},i={x:n};return _.runKernel(Is,i,s)}var Dh=N({mirrorPad_:FK});function RK(r,t){let e=C(r,"a","mod"),n=C(t,"b","mod");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ta,o)}var Fh=N({mod_:RK});function OK(r,t=null,e=!1){r=C(r,"x","moments");let n=mr(t,r.shape),o=be(r,n,e),s=o.shape;e||(s=yo(o.shape,n));let i=Wt(lt(Z(r,"float32"),R(o,s))),a=be(i,n,e);return{mean:o,variance:a}}var Cm=N({moments_:OK});function MK(r,t,e,n){let o=C(t,"data","multiRNNCell"),s=Ua(e,"c","multiRNNCell"),i=Ua(n,"h","multiRNNCell"),a=o,u=[];for(let p=0;p<r.length;p++){let m=r[p](a,s[p],i[p]);u.push(m[0]),u.push(m[1]),a=m[1]}let l=[],c=[];for(let p=0;p<u.length;p+=2)l.push(u[p]),c.push(u[p+1]);return[l,c]}var PK=N({multiRNNCell_:MK});function LK(r,t,e,n=!1){let o=C(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let u={logits:i===1?R(o,[1,-1]):o},l={numSamples:t,seed:e,normalized:n},c=_.runKernel(Jp,u,l);return i===1?R(c,[c.size]):c}var aS=N({multinomial_:LK});function zK(r,t){let e=C(r,"a","notEqual","string_or_numeric"),n=C(t,"b","notEqual","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(_a,o)}var vo=N({notEqual_:zK});function BK(r){let e={x:C(r,"x","onesLike")};return _.runKernel(Ni,e)}var dr=N({onesLike_:BK});function VK(r,t){let e=C(r,"v1","outerProduct"),n=C(t,"v2","outerProduct");A(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);let o=R(e,[-1,1]),s=R(n,[1,-1]);return zt(o,s)}var GK=N({outerProduct_:VK});function WK(r,t,e=0){let n=C(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:n};return _.runKernel(Ns,s,o)}var Zr=N({pad_:WK});function UK(r,t,e=0){return A(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Zr(r,[t],e)}var HK=N({pad1d_:UK});function qK(r,t,e=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Zr(r,t,e)}var KK=N({pad2d_:qK});function jK(r,t,e=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Zr(r,t,e)}var XK=N({pad3d_:jK});function YK(r,t,e=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Zr(r,t,e)}var ZK=N({pad4d_:YK});function JK(r,t,e){let n=C(r,"x","spaceToBatchND");A(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),A(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),A(n.shape.reduce((i,a,u)=>u>0&&u<=t.length?i&&(a+e[u-1][0]+e[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:e};return _.runKernel($i,o,s)}var el=N({spaceToBatchND_:JK});function QK(r,t,e,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=C(r,"x","maxPool"),u=a,l=!1;a.rank===3&&(l=!0,u=R(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(Dr(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=MI(u.shape,t,s,o,n),p=[c.dilationHeight,c.dilationWidth],m;n==="same"?m=ej([c.filterHeight,c.filterWidth],p):m=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[d,h]=tj([c.inHeight,c.inWidth],p,m),g=f?n:"valid",y=f?u:el(u,p,d),w=(e==="avg"?()=>Ka(y,t,s,g,i):()=>tl(y,t,s,g,i))(),v=f?w:ja(w,p,h);return l?R(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function tj(r,t,e){let n=e.map(c=>c[0]),o=e.map(c=>c[1]),s=r.concat(n,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),u=t.map((c,p)=>[n[p],a[p]]),l=t.map((c,p)=>[0,i[p]]);return[u,l]}function ej(r,t){let n=r.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var lS=N({pool_:QK});function rj(r,t){let e=C(r,"x","prelu"),n=C(t,"alpha","prelu"),o={x:e,alpha:n};return _.runKernel(_s,o)}var rl=N({prelu_:rj});function nj(r,t=null,e=!1){let n=C(r,"x","prod");n.dtype==="bool"&&(n=Z(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(Es,o,s)}var ac=N({prod_:nj});function oj(r,t,e){let n=Jt(r),o=null;if(e==null||e==="float32")o=new Float32Array(n);else if(e==="int32")o=new Int32Array(n);else if(e==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<n;s++)o[s]=t();return _.makeTensor(o,r,e)}var sj=N({rand_:oj});var qx=Ou(gS());var uc=class{constructor(t,e,n,o,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=qx.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},Ux=class{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;let s=o||Math.random();this.randu=qx.alea(s.toString()),this.randn=new uc(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,t=o*o,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},Hx=class{constructor(t=0,e=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=qx.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function mj(r,t,e=1,n="float32",o){if(e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new Ux(t,e,n,o),i=Ct(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var fj=N({randomGamma_:mj});function dj(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new uc(t,e,n,!1,o),i=Ct(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Kx=N({randomNormal_:dj});function hj(r,t=0,e=1,n="float32",o){let s=Ct(r,n),i=new Hx(t,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var ri=N({randomUniform_:hj});function nl(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:t,step:e,dtype:n};return _.runKernel(Bl,{},o)}function gj(r){let e={input:C(r,"input","real")};return _.runKernel(Qp,e)}var ru=N({real_:gj});function xj(r){let e={x:C(r,"x","reciprocal")};return _.runKernel(Da,e)}var Rh=N({reciprocal_:xj});function yj(r){let e={x:C(r,"x","relu")};return _.runKernel(As,e)}var _r=N({relu_:yj});function bj(r){let e={x:C(r,"x","relu6")};return _.runKernel(Ds,e)}var cc=N({relu6_:bj});function wj(r,t){let n={x:C(r,"x","reverse")},o={dims:t};return _.runKernel(Fs,n,o)}var ir=N({reverse_:wj});function vj(r){let t=C(r,"x","reverse");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ir(t,0)}var Cj=N({reverse1d_:vj});function Ij(r,t){let e=C(r,"x","reverse");return A(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),ir(e,t)}var Sj=N({reverse2d_:Ij});function kj(r,t){let e=C(r,"x","reverse");return A(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),ir(e,t)}var Nj=N({reverse3d_:kj});function Tj(r,t){let e=C(r,"x","reverse");return A(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),ir(e,t)}var _j=N({reverse4d_:Tj});function Ej(r){let e={x:C(r,"x","round")};return _.runKernel(Rs,e)}var pc=N({round_:Ej});function Aj(r){let e={x:C(r,"x","rsqrt","float32")};return _.runKernel(Os,e)}var mc=N({rsqrt_:Aj});function $j(r){let e={x:C(r,"x","selu")};return _.runKernel(Ra,e)}var fc=N({selu_:$j});function Dj(r,t,e,n,o,s=[1,1],i="NHWC"){let a=C(r,"x","separableConv2d"),u=C(t,"depthwiseFilter","separableConv2d"),l=C(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=R(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),A(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let m=u.shape[2],f=u.shape[3];A(l.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${l.shape[2]}.`);let d=Zs(c,u,n,o,i,s),g=pn(d,l,1,"valid",i);return p?R(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Oh=N({separableConv2d_:Dj});async function Fj(r,t){let e=C(r,"x","setdiff1d"),n=C(t,"y","setdiff1d");A(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),A(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),A(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await e.data(),s=await n.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let u=new pe([a],e.dtype),l=new pe([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]}var xS=Fj;function Rj(r){let e={x:C(r,"x","sign")};return _.runKernel(Ma,e)}var Mh=N({sign_:Rj});function Oj(r){let e={x:C(r,"x","sin","float32")};return _.runKernel(Ms,e)}var dc=N({sin_:Oj});function Mj(r){let e={x:C(r,"x","sinh")};return _.runKernel(Oa,e)}var hc=N({sinh_:Mj});function Pj(r,t,e){let n=C(r,"x","slice1d");return A(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Ft(n,[t],[e])}var Ph=N({slice1d_:Pj});function Lj(r,t,e){let n=C(r,"x","slice2d");return A(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Ft(n,t,e)}var jx=N({slice2d_:Lj});function zj(r,t,e){let n=C(r,"x","slice3d");return A(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Ft(n,t,e)}var Lh=N({slice3d_:zj});function Bj(r,t,e){let n=C(r,"x","slice4d");return A(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Ft(n,t,e)}var Im=N({slice4d_:Bj});function Vj(r,t=-1){let e=C(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},o={dim:t};return _.runKernel(Bs,n,o)}var ol=N({softmax_:Vj});function Gj(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Up,t)}var sl=N({fft_:Gj});function Wj(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Hp,t)}var Wi=N({ifft_:Wj});function Uj(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let o=R(r,[e,t]);n=Wi(o)}else{let o=[e,2*(t-1)],s=R(ru(r),[e,t]),i=R(nc(r),[e,t]),a=ir(Ft(s,[0,1],[e,t-2]),1),u=M(ir(Ft(i,[0,1],[e,t-2]),1),pt(-1)),l=se([s,a],1),c=se([i,u],1),p=R(zn(l,c),[o[0],o[1]]);n=Wi(p)}if(n=ru(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=R(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var gc=N({irfft_:Uj});function Hj(r,t,e=0){let o={x:C(r,"x","split")},s={numOrSizeSplits:t,axis:e};return _.runKernel(Di,o,s)}var ur=N({split_:Hj});function qj(r,t){A(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,o;if(t!=null&&t<e){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=t,o=Ft(r,d,h),e=t}else if(t!=null&&t>e){let d=r.shape.map(h=>h);d[r.shape.length-1]=t-e,o=se([r,we(d)],r.shape.length-1),e=t}else o=r;let s=St(o),i=R(zn(o,s),[n,e]),a=sl(i),u=Math.floor(e/2)+1,l=ru(a),c=nc(a),p=ur(l,[u,e-u],l.shape.length-1),m=ur(c,[u,e-u],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,R(zn(p[0],m[0]),f)}var il=N({rfft_:qj});function Kj(r,t){let e=C(r,"a","squaredDifference"),n=C(t,"b","squaredDifference");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n},s={};return _.runKernel(Vs,o,s)}var xc=N({squaredDifference_:Kj});function jj(r,t){let e=C(r,"x","squeeze");return R(e,BC(e.shape,t).newShape)}var zr=N({squeeze_:jj});function Xj(r,t=0){let e=Ua(r,"tensors","stack","string_or_numeric");A(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&A(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,o={axis:t};return _.runKernel(Ti,n,o)}var Ze=N({stack_:Xj});function Yj(r,t=0){let n={x:C(r,"x","step")},o={alpha:t};return _.runKernel(uo,n,o)}var ni=N({step_:Yj});function Zj(r,t,e,n,o=0,s=0,i=0,a=0,u=0){let c={x:C(r,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return _.runKernel(za,c,p)}var zh=N({stridedSlice_:Zj});function Jj(r){let e={x:C(r,"x","tan","float32")};return _.runKernel(Ws,e)}var Bh=N({tan_:Jj});function Fe(r,t){jn(r);let e=Mr(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return cn(r,null,e,t)}function Ui(r,t,e){if(jn(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Mr(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return cn(r,t,n,e)}function Qj(r,t,e){if(jn(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Mr(r,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}function t6(r,t,e){if(jn(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Mr(r,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}function e6(r,t,e){if(jn(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Mr(r,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,cn(r,t,n,e)}function r6(r,t=1,e=!0){let n=C(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},i={k:t,sorted:e},[a,u]=_.runKernel(Ba,s,i);return{values:a,indices:u}}var Vh=N({topk_:r6});function n6(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new uc(t,e,n,!0,o),i=Ct(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var yc=N({truncatedNormal_:n6});function o6(r,t=0){let e=C(r,"x","unique","string_or_numeric");A(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},o={axis:t},[s,i]=_.runKernel(am,n,o);return{values:s,indices:i}}var Sm=N({unique_:o6});function s6(r,t,e){let n=C(r,"x","unsortedSegmentSum"),o=C(t,"segmentIds","unsortedSegmentSum","int32");A(ea(e),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:e};return _.runKernel(ql,s,i)}var Gh=N({unsortedSegmentSum_:s6});function i6(r,t=0){let e=C(r,"x","unstack","string_or_numeric");A(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},o={axis:t};return _.runKernel(Fi,n,o)}var vr=N({unstack_:i6});function yS(r,t){return Gx(r,t,"right")}function bS(r,t=!0,e,n){return _.makeVariable(r,t,e,n)}function Xx(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let n=Ct(r,"int32"),o=Ct([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let i=n.indexToLoc(e[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}async function a6(r){let t=C(r,"condition","whereAsync","bool"),e=await t.data(),n=Xx(t.shape,e);return r!==t&&t.dispose(),n}var Wh=a6;async function l6(r,t,e){let n=C(r,"tensor","boolMask"),o=C(t,"mask","boolMask","bool"),s=e==null?0:e,i=o.rank,a=n.shape;A(i>0,()=>"mask cannot be scalar"),Me(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+i;h++)u*=a[h];let l=a.slice(0,s).concat([u],a.slice(s+i)),c=R(n,l),p=R(o,[-1]),m=await Wh(p),f=zr(m,[1]),d=bo(c,f,s);return r!==n&&n.dispose(),t!==o&&o.dispose(),f.dispose(),c.dispose(),p.dispose(),m.dispose(),d}var Z1t=l6;function u6(r,t,e,n,o=!0){let s=C(r,"v","movingAverage"),i=C(t,"x","movingAverage"),a=C(e,"decay","movingAverage");lI(s,i),A(Mn(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=pt(1),l=lt(u,a),c=M(lt(i,s),l);if(o){A(n!=null,()=>"When using zeroDebias: true, step is required.");let p=C(n,"step","movingAverage");c=ct(c,lt(u,Yr(a,p)))}return J(s,c)}var l_t=N({movingAverage_:u6});function c6(r,t,e){let n=C(r,"indices","scatterND","int32"),o=C(t,"updates","scatterND");Ox(o,n,e);let s={indices:n,updates:o},i={shape:e};return _.runKernel(Fa,s,i)}var bE=N({scatterND_:c6});function wE(r,t,e,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function m6(r,t,e,n=0){let o=C(r,"sparseIndices","sparseToDense","int32"),s=C(t,"sparseValues","sparseToDense","string_or_numeric"),i=C(n,"defaultValue","sparseToDense",s.dtype);wE(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:e};return _.runKernel(nm,a,u)}var Yx=N({sparseToDense_:m6});function f6(r,t){let e=C(t,"indices","gatherND","int32"),o={params:C(r,"x","gatherND","string_or_numeric"),indices:e};return _.runKernel(ya,o)}var vE=N({gatherND_:f6});function CE(r,t){if(t==null)return r.shape.slice();if(Mn(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function d6(r,t,e,n){let o=C(r,"x","dropout");if(A(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof Lt?o.clone():o;let s=CE(o,e),i=1-t,a=ct(ti(J(ri(s,0,1,"float32",n),i)),i);return M(o,a)}var IE=N({dropout_:d6});function SE(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Zx(r,t,e){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let i=2*Math.PI*s/(r+n-1);o[s]=t-e*Math.cos(i)}return Fe(o,"float32")}async function h6(r,t,e=1){let n=C(r,"predictions","inTopK"),o=C(t,"targets","inTopK");A(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),A(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Me(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];A(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=await n.data(),a=await o.data(),[u,l]=[i.length/s,s],c=VC("bool",u);for(let p=0;p<u;p++){let m=p*l,f=i.subarray(m,m+l),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),c[p]=0;for(let h=0;h<e;h++)if(d[h].index===a[p]){c[p]=1;break}}return r!==n&&n.dispose(),t!==o&&o.dispose(),$r(c,o.shape,"bool")}var V_t=h6;var Co={};Yt(Co,{conv2d:()=>kE,depthwiseConv2d:()=>NE,matMul:()=>TE});function g6(r,t,e,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=R(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=R(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),A(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),A(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];A(l===e[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`),A(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),_e("conv2dDerFilter",o,i);let p={x:a,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return _.runKernel(Op,p,m)}var km=N({conv2DBackpropFilter_:g6});function bc(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return M(r,ni(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function wc(r,t){let e=t,n=xe(r.shape,t.shape);return n.length>0&&(e=mt(e,n)),R(e,r.shape)}function vc(r,t,e,n){if(t==="linear")return r;if(t==="relu")return _r(r);if(t==="elu")return Js(r);if(t==="relu6")return cc(r);if(t==="prelu")return rl(r,e);if(t==="leakyrelu")return Za(r,n);if(t==="sigmoid")return Lr(r);throw new Error(`Unknown fused activation ${t}.`)}var Cc=(r,t)=>!(r>0)||t==="linear";function x6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",Cc(_.state.gradientDepth,u)===!1){let k=pn(r,t,e,n,o,s,i);return a!=null&&(k=J(k,a)),vc(k,u,l,c)}let p=C(r,"x","conv2d","float32"),m=C(t,"filter","conv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=R(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),_e("fused conv2d",n,i),A(f.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${m.shape[2]}.`),A(Dr(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=Ju(f.shape,m.shape,e,s,n,i),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=jt(g,p),o==="NHWC"?Bt(h.outShape,g.shape):(A(g.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`),A(g.shape.length===0||g.shape[0]===h.outChannels||g.shape[0]===1,()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${h.outChannels})`)));let y;l!=null&&(y=C(l,"prelu weights","fused conv2d"));let b=(k,E)=>{let[$,D,F,P]=E,W=bc(k,F,u);A(Zn(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let U=wm(D.shape,W,$,e,n),q=km(D,W,$.shape,e,n),K=[U,q];if(P!=null){let j=wc(P,W);K.push(j)}return K},w={x:f,filter:m,bias:g,preluActivationWeights:y},v={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?mn((E,$,D)=>{let F=_.runKernel(Mi,w,v);return D([$,E,F]),d&&(F=R(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:b}})(f,m):mn((E,$,D,F)=>{let P=_.runKernel(Mi,w,v);return F([$,E,P,D]),d&&(P=R(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m,g)}var kE=N({fusedConv2d_:x6});function y6(r,t,e,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=R(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=R(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:a,dy:u},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return _.runKernel(zp,l,c)}var Jx=N({depthwiseConv2dNativeBackpropFilter_:y6});function b6(r,t,e,n,o,s=[1,1],i){let a=t,u=!1;t.rank===3&&(u=!0,a=R(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:a,filter:e},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},p=_.runKernel(Bp,l,c);return u?R(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Qx=N({depthwiseConv2dNativeBackpropInput_:b6});function w6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(Cc(_.state.gradientDepth,u)===!1){let k=Zs(r,t,e,n,o,s,i);return a!=null&&(k=J(k,a)),vc(k,u,l,c)}let p=C(r,"x","depthwiseConv2d","float32"),m=C(t,"filter","depthwiseConv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=R(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),A(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),A(Dr(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),_e("fused depthwiseConv2d",n,i);let h=Ju(f.shape,m.shape,e,s,n,i,!0),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=jt(g,p),Bt(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused depthwiseConv2d"));let b=(k,E)=>{A(Zn(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[$,D,F,P]=E,W=bc(k,F,u),U=Qx(D.shape,W,$,e,n,s,i),q=Jx(D,W,$.shape,e,n,s,i);if(P!=null){let K=wc(g,W);return[U,q,K]}return[U,q]},w={x:f,filter:m,bias:g,preluActivationWeights:y},v={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?mn((E,$,D)=>{let F=_.runKernel(Pi,w,v);return D([$,E,F]),d&&(F=R(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:b}})(f,m):mn((E,$,D,F)=>{let P=_.runKernel(Pi,w,v);return F([$,E,P,D]),d&&(P=R(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m,g)}var NE=N({fusedDepthwiseConv2d_:w6});function v6({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(Cc(_.state.gradientDepth,s)===!1){let W=zt(r,t,e,n);return o!=null&&(W=J(W,o)),vc(W,s,i,a)}let u=C(r,"a","fused matMul"),l=C(t,"b","fused matMul");[u,l]=jt(u,l);let c=e?u.shape[u.rank-2]:u.shape[u.rank-1],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=e?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=Jt(d),y=Jt(h);A(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${e} and transposeB=${n} must match.`);let w=Bt(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([m,f]),v=e?R(u,[g,c,m]):R(u,[g,m,c]),k=n?R(l,[y,f,p]):R(l,[y,p,f]),E;o!=null&&(E=C(o,"bias","fused matMul"),[E]=jt(E,u),Bt(w,E.shape));let $;i!=null&&($=C(i,"prelu weights","fused matMul"));let D=(W,U)=>{let[q,K,j,Q]=U,rt=bc(R(W,j.shape),j,s),X,nt;if(!e&&!n?(X=zt(rt,K,!1,!0),nt=zt(q,rt,!0,!1)):!e&&n?(X=zt(rt,K,!1,!1),nt=zt(rt,q,!0,!1)):e&&!n?(X=zt(K,rt,!1,!0),nt=zt(q,rt,!1,!1)):(X=zt(K,rt,!0,!0),nt=zt(rt,q,!0,!0)),o!=null){let st=wc(Q,rt);return[X,nt,st]}else return[X,nt]},F={a:v,b:k,bias:E,preluActivationWeights:$},P={transposeA:e,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?mn((U,q,K)=>{let j=_.runKernel(Oi,F,P);return K([U,q,j]),{value:R(j,w),gradFunc:D}})(v,k):mn((U,q,K,j)=>{let Q=_.runKernel(Oi,F,P);return j([U,q,Q,K]),{value:R(Q,w),gradFunc:D}})(v,k,E)}var TE=N({fusedMatMul_:v6});function C6(r){return Zx(r,.54,.46)}var _E=N({hammingWindow_:C6});function I6(r){return Zx(r,.5,.5)}var ty=N({hannWindow_:I6});function S6(r,t,e,n=!1,o=0){let s=0,i=[];for(;s+t<=r.size;)i.push(Ft(r,s,t)),s+=e;if(n)for(;s<r.size;){let a=s+t-r.size,u=se([Ft(r,s,t-a),Qs([a],o)]);i.push(u),s+=e}return i.length===0?Ui([],[0,t]):R(se(i),[i.length,t])}var ey=N({frame_:S6});function k6(r,t,e,n,o=ty){n==null&&(n=SE(t));let s=ey(r,t,e),i=M(s,o(t));return il(i,n)}var EE=N({stft_:k6});function N6(r,t,e,n,o="bilinear",s=0){let i=C(r,"image","cropAndResize"),a=C(t,"boxes","cropAndResize","float32"),u=C(e,"boxInd","cropAndResize","int32"),l=a.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),A(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),A(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),A(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),A(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:u},p={method:o,extrapolationValue:s,cropSize:n};return _.runKernel(ma,c,p)}var AE=N({cropAndResize_:N6});function T6(r){let t=C(r,"image","flipLeftRight","float32");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return _.runKernel(xa,e,{})}var $E=N({flipLeftRight_:T6});function _6(r){let t=C(r,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,Nr(t,o)}var DE=N({grayscaleToRGB_:_6});function E6(r,t,e=0,n=.5){let o=C(r,"image","rotateWithOffset","float32");A(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:e,center:n};return _.runKernel(Ga,s,i)}var FE=N({rotateWithOffset_:E6});function Io(r,t,e,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return e=Math.min(e,i),A(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),A(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),A(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),A(t.rank===1,()=>"scores must be a 1D tensor"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function A6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppression","float32"),i=C(t,"scores","nonMaxSuppression","float32"),a=Io(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:e,iouThreshold:n,scoreThreshold:o};return _.runKernel(Ea,{boxes:s,scores:i},u)}var RE=N({nonMaxSuppression_:A6});function OE(r,t,e){let n=$6(r,t,e),o=n<0?-(n+1):n;r.splice(o,0,t)}function $6(r,t,e){return F6(r,t,e||D6)}function D6(r,t){return r>t?1:r<t?-1:0}function F6(r,t,e){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=e(t,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function ry(r,t,e,n,o){return wS(r,t,e,n,o,0)}function ny(r,t,e,n,o,s){return wS(r,t,e,n,o,0,!1,s,!0)}function oy(r,t,e,n,o,s){return wS(r,t,e,n,o,s,!0)}function wS(r,t,e,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<t.length;g++)t[g]>o&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(ME);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<e&&l.length>0;){let g=l.pop(),{score:y,boxIndex:b,suppressBeginIndex:w}=g;if(y<o)break;let v=!1;for(let k=p.length-1;k>=w;--k){let E=R6(r,b,p[k]);if(E>=n){v=!0;break}if(g.score=g.score*O6(n,c,E),g.score<=o)break}g.suppressBeginIndex=p.length,v||(g.score===y?(p.push(b),m.push(g.score)):g.score>o&&OE(l,g,ME))}let f=p.length,d=e-f;a&&d>0&&(p.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=m),u&&(h.validOutputs=f),h}function R6(r,t,e){let n=r.subarray(t*4,t*4+4),o=r.subarray(e*4,e*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(a-s)*(u-i),d=(p-l)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,l),g=Math.max(i,c),y=Math.min(a,p),b=Math.min(u,m),w=Math.max(y-h,0)*Math.max(b-g,0);return w/(f+d-w)}function O6(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function ME(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}async function M6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppressionAsync"),i=C(t,"scores","nonMaxSuppressionAsync"),a=Io(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:p}=ry(l,c,e,n,o);return s!==r&&s.dispose(),i!==t&&i.dispose(),Fe(p,"int32")}var PE=M6;function P6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(r,"boxes","nonMaxSuppression"),a=C(t,"scores","nonMaxSuppression"),u=Io(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=_.runKernel($a,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}var LE=N({nonMaxSuppressionWithScore_:P6});async function L6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(t,"scores","nonMaxSuppressionAsync"),u=Io(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),c=l[0],p=l[1],{selectedIndices:m,selectedScores:f}=oy(c,p,e,n,o,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Fe(m,"int32"),selectedScores:Fe(f)}}var zE=L6;function z6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(r,"boxes","nonMaxSuppression"),a=C(t,"scores","nonMaxSuppression"),u=Io(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,m={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=_.runKernel(Aa,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var BE=N({nonMaxSuppressionPadded_:z6});async function B6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(t,"scores","nonMaxSuppressionAsync"),u=Io(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,[m,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:d,validOutputs:h}=ny(m,f,l,c,p,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Fe(d,"int32"),validOutputs:pt(h,"int32")}}var VE=B6;function V6(r,t,e=!1,n=!1){let o=C(r,"images","resizeBilinear");A(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=R(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel($s,a,u);return i?R(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var sy=N({resizeBilinear_:V6});function G6(r,t,e=!1,n=!1){let o=C(r,"images","resizeNearestNeighbor");A(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=R(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel(Vl,a,u);return i?R(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var iy=N({resizeNearestNeighbor_:G6});function W6(r,t="binary",e=!1,n=.5){let o=C(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=M(Fe([n]),255),c,p,m,f;if(A(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),A(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),A(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),A(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,m]=ur(o,[1,1,1],-1);let g=M(c,s),y=M(p,i),b=M(m,a);f=J(J(g,y),b)}else f=r;if(t==="otsu"){let g=yh(Z(pc(f),"int32"),$r([]),256);l=U6(g,u)}let d=e?_n(f,l):Ge(f,l);return Z(M(d,255),"int32")}function U6(r,t){let e=Fe([-1]),n=Fe([0]),o=Fe([0]),s,i,a,u,l,c;for(let p=0;p<r.size-1;p++){s=Ft(r,0,p+1),i=Ft(r,p+1),l=ct(mt(s),t),c=ct(mt(i),t);let m=mt(M(s,nl(0,s.size)));a=ct(m,mt(s));let f=Qs(i.shape,s.size),d=J(nl(0,i.size),f),h=M(i,d);u=ct(mt(h),mt(i));let g=lt(a,u),y=lt(a,u),b=M(l,c);o=M(M(b,g),y);let w=Ge(o,n);n=Ee(w,o,n),e=Ee(w,Fe([p]),e)}return e}var GE=N({threshold_:W6});function H6(r,t,e="nearest",n="constant",o=0,s){let i=C(r,"image","transform","float32"),a=C(t,"transforms","transform","float32");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:e,fillMode:n,fillValue:o,outputShape:s};return _.runKernel(Va,u,l)}var WE=N({transform_:H6});function q6(r,t,e){A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let n=C(r,"a","bandPart");A(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),e<0&&(e=i);let a=R(nl(0,s,1,"int32"),[-1,1]),u=nl(0,i,1,"int32"),l=lt(a,u),c=Tr(_n(l,pt(+t,"int32")),Tn(l,pt(-e,"int32"))),p=we([s,i],n.dtype);return R(Ze(vr(R(n,[-1,s,i])).map(m=>Ee(c,m,p))),o)}var UE=N({bandPart_:q6});function K6(r){let t;if(Array.isArray(r)){t=!1,A(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)A(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else t=!0,r=ur(r,r.shape[0],0).map(o=>zr(o,[0]));A(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let o=0;o<r.length;++o)e.push(_.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=M(mt(M(e[i],s)),e[i]);s=lt(s,a)}return ct(s,eu(s,"euclidean"))}));return t?Ze(e,0):e}var HE=N({gramSchmidt_:K6});function j6(r,t=!1){if(A(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return qE(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=vr(R(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,c]=qE(u,t);o.push(l),s.push(c)});let i=R(Ze(o,0),r.shape),a=R(Ze(s,0),r.shape);return[i,a]}}function qE(r,t=!1){return _.tidy(()=>{A(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],o=vm(e),s=kn(r),i=Ui([[1]],[1,1]),a=kn(i),u=e>=n?n:e;for(let l=0;l<u;++l){let c=s,p=a,m=o;[a,s,o]=_.tidy(()=>{let f=Ft(s,[l,l],[e-l,1]),d=eu(f),h=Ft(s,[l,l],[1,1]),g=Ee(Ge(h,0),Ui([[-1]]),Ui([[1]])),y=lt(h,M(g,d)),b=ct(f,y);b.shape[0]===1?a=kn(i):a=se([i,Ft(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let w=Zt(ct(zt(g,y),d)),v=Ft(s,[l,0],[e-l,n]),k=M(w,a),E=Mt(a);if(l===0)s=lt(v,zt(k,zt(E,v)));else{let F=lt(v,zt(k,zt(E,v)));s=se([Ft(s,[0,0],[l,n]),F],0)}let $=Mt(k),D=Ft(o,[0,l],[e,o.shape[1]-l]);if(l===0)o=lt(D,zt(zt(D,a),$));else{let F=lt(D,zt(zt(D,a),$));o=se([Ft(o,[0,0],[e,l]),F],1)}return[a,s,o]}),_t([c,p,m])}return!t&&e>n&&(o=Ft(o,[0,0],[e,n]),s=Ft(s,[0,0],[n,n])),[o,s]})}var KE=N({qr_:j6});var Je;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Je||(Je={}));function X6(r,t,e=Je.SUM_BY_NONZERO_WEIGHTS){let n=C(r,"losses","computeWeightedLoss"),o=null;t!=null&&(o=C(t,"weights","computeWeightedLoss"));let s=o==null?n:M(n,o);if(e===Je.NONE)return s;if(e===Je.SUM)return mt(s);if(e===Je.MEAN){if(o==null)return be(s);{let i=n.size/o.size,a=ct(mt(s),mt(o));return i>1?ct(a,pt(i)):a}}if(e===Je.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ct(mt(s),pt(n.size));{let i=M(o,lr(n.shape)),a=Z(mt(vo(i,pt(0))),"float32");return ct(mt(s),a)}}throw Error(`Unknown reduction: ${e}`)}var Br=N({computeWeightedLoss_:X6});function Y6(r,t,e,n=Je.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","absoluteDifference"),s=C(t,"predictions","absoluteDifference"),i=null;e!=null&&(i=C(e,"weights","absoluteDifference")),Me(o.shape,s.shape,"Error in absoluteDifference: ");let a=Te(lt(o,s));return Br(a,i,n)}var jE=N({absoluteDifference_:Y6});function Z6(r,t,e,n,o=Je.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","cosineDistance"),i=C(t,"predictions","cosineDistance"),a=null;n!=null&&(a=C(n,"weights","cosineDistance")),Me(s.shape,i.shape,"Error in cosineDistance: ");let u=pt(1),l=lt(u,mt(M(s,i),e,!0));return Br(l,a,o)}var XE=N({cosineDistance_:Z6});function J6(r,t,e,n=Je.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","hingeLoss"),s=C(t,"predictions","hingeLoss"),i=null;e!=null&&(i=C(e,"weights","hingeLoss")),Me(o.shape,s.shape,"Error in hingeLoss: ");let a=pt(1);o=lt(M(pt(2),o),a);let u=_r(lt(a,M(o,s)));return Br(u,i,n)}var YE=N({hingeLoss_:J6});function Q6(r,t,e,n=1,o=Je.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","huberLoss"),i=C(t,"predictions","huberLoss"),a=null;e!=null&&(a=C(e,"weights","huberLoss")),Me(s.shape,i.shape,"Error in huberLoss: ");let u=pt(n),l=Te(lt(i,s)),c=ei(l,u),p=lt(l,c),m=J(M(pt(.5),Wt(c)),M(u,p));return Br(m,a,o)}var ZE=N({huberLoss_:Q6});function t5(r,t,e,n=1e-7,o=Je.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","logLoss"),i=C(t,"predictions","logLoss"),a=null;e!=null&&(a=C(e,"weights","logLoss")),Me(s.shape,i.shape,"Error in logLoss: ");let u=pt(1),l=pt(n),c=Zt(M(s,wr(J(i,l)))),p=M(lt(u,s),wr(J(lt(u,i),l))),m=lt(c,p);return Br(m,a,o)}var JE=N({logLoss_:t5});function e5(r,t,e,n=Je.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","meanSquaredError"),s=C(t,"predictions","meanSquaredError"),i=null;e!=null&&(i=C(e,"weights","meanSquaredError")),Me(o.shape,s.shape,"Error in meanSquaredError: ");let a=xc(o,s);return Br(a,i,n)}var QE=N({meanSquaredError_:e5});function r5(r,t){let e=C(r,"labels","sigmoidCrossEntropyWithLogits"),n=C(t,"logits","sigmoidCrossEntropyWithLogits");Me(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=_r(n),s=M(n,e),i=Ja(Ye(Zt(Te(n))));return J(lt(o,s),i)}function n5(r,t,e,n=0,o=Je.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"multiClassLabels","sigmoidCrossEntropy"),i=C(t,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=C(e,"weights","sigmoidCrossEntropy")),Me(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=pt(n),c=pt(1),p=pt(.5);s=J(M(s,lt(c,l)),M(p,l))}let u=r5(s,i);return Br(u,a,o)}var tA=N({sigmoidCrossEntropy_:n5});function o5(r,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return mn((o,s,i)=>{let u=Ah(s,[e],!0),l=lt(Z(s,"float32"),u);i([o,l]);let c=Zt(M(l,o));return{value:mt(c,[e]),gradFunc:(f,d)=>{let[h,g]=d,y=yo(f.shape,[e]);return[M(R(f,y),lt(Z(h,"float32"),Ye(g))),M(R(f,y),lt(Ye(g),Z(h,"float32")))]}}})(r,t)}function s5(r,t,e,n=0,o=Je.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"onehotLabels","softmaxCrossEntropy"),i=C(t,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=C(e,"weights","softmaxCrossEntropy")),Me(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let l=pt(n),c=pt(1),p=pt(s.shape[1]);s=J(M(s,lt(c,l)),ct(l,p))}let u=o5(s,i);return Br(u,a,o)}var eA=N({softmaxCrossEntropy_:s5});function i5(r,t,e,n){let o=C(r,"indices","sparseFillEmptyRows","int32"),s=C(t,"values","sparseFillEmptyRows"),i=C(e,"denseShape","sparseFillEmptyRows","int32"),a=C(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=_.runKernel(Gl,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var rA=N({sparseFillEmptyRows_:i5});function a5(r,t,e){let n=C(r,"inputIndices","sparseReshape","int32"),o=C(t,"inputShape","sparseReshape","int32"),s=C(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=_.runKernel(La,i);return{outputIndices:a[0],outputShape:a[1]}}var nA=N({sparseReshape_:a5});function l5(r,t,e){let n=C(r,"data","sparseSegmentMean"),o=C(t,"indices","sparseSegmentMean","int32"),s=C(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Wl,i)}var oA=N({sparseSegmentMean_:l5});function u5(r,t,e){let n=C(r,"data","sparseSegmentSum"),o=C(t,"indices","sparseSegmentSum","int32"),s=C(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Ul,i)}var sA=N({sparseSegmentSum_:u5});function c5(r,t,e,n,o,s,i,a){let u=C(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=C(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:u,dataSplits:l},m=_.runKernel(om,p,c);return{nGrams:m[0],nGramsSplits:m[1]}}var iA=N({stringNGrams_:c5});function p5(r,t,e=!0){let n=C(r,"input","stringSplit","string"),o=C(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:n,delimiter:o},a=_.runKernel(sm,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var aA=N({stringSplit_:p5});function m5(r,t){let e=C(r,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return _.runKernel(im,o,n)}var lA=N({stringToHashBucketFast_:m5});var BRt={fft:sl,ifft:Wi,rfft:il,irfft:gc},HRt={hammingWindow:_E,hannWindow:ty,frame:ey,stft:EE},dn={flipLeftRight:$E,grayscaleToRGB:DE,resizeNearestNeighbor:iy,resizeBilinear:sy,rotateWithOffset:FE,cropAndResize:AE,nonMaxSuppression:RE,nonMaxSuppressionAsync:PE,nonMaxSuppressionWithScore:LE,nonMaxSuppressionWithScoreAsync:zE,nonMaxSuppressionPadded:BE,nonMaxSuppressionPaddedAsync:VE,threshold:GE,transform:WE},uA={bandPart:UE,gramSchmidt:HE,qr:KE},yOt={absoluteDifference:jE,computeWeightedLoss:Br,cosineDistance:XE,hingeLoss:YE,huberLoss:ZE,logLoss:JE,meanSquaredError:QE,sigmoidCrossEntropy:tA,softmaxCrossEntropy:eA},Uh={sparseFillEmptyRows:rA,sparseReshape:nA,sparseSegmentMean:oA,sparseSegmentSum:sA},ay={stringNGrams:iA,stringSplit:aA,stringToHashBucketFast:lA};var Vr=class extends ah{minimize(t,e=!1,n){let{value:o,grads:s}=this.computeGradients(t,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return _t(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return zx(t,e)}dispose(){this.iterations_!=null&&_t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(Vr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var nu=class extends Vr{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:B(()=>St(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:B(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;B(()=>{let c=J(M(u,this.rho),M(Wt(a),1-this.rho)),p=M(ct(ye(J(l,this.epsilon)),ye(J(u,this.epsilon))),a),m=J(M(l,this.rho),M(Wt(p),1-this.rho));u.assign(c),l.assign(m);let f=J(M(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_t(this.accumulatedGrads.map(t=>t.variable)),_t(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};nu.className="Adadelta";Nn(nu);var ou=class extends Vr{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:B(()=>Qs(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;B(()=>{let u=J(a,Wt(i));a.assign(u);let l=J(M(ct(i,ye(J(u,_.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_t(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};ou.className="Adagrad";Nn(ou);var su=class extends Vr{constructor(t,e,n,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=pt(e).variable(),this.accBeta2=pt(n).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);B(()=>{let n=lt(1,this.accBeta1),o=lt(1,this.accBeta2);e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:B(()=>St(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:B(()=>St(a).variable(u))});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,m=J(M(c,this.beta1),M(l,1-this.beta1)),f=J(M(p,this.beta2),M(Wt(l),1-this.beta2)),d=ct(m,n),h=ct(f,o);c.assign(m),p.assign(f);let g=J(M(ct(d,J(ye(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(M(this.accBeta1,this.beta1)),this.accBeta2.assign(M(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&_t(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),B(()=>{this.accBeta1.assign(Yr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Yr(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};su.className="Adam";Nn(su);var iu=class extends Vr{constructor(t,e,n,o=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=pt(0).variable(),this.accBeta1=pt(e).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);B(()=>{let n=lt(1,this.accBeta1),o=ct(-this.learningRate,J(M(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:St(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:St(a).variable(u)});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,m=J(M(c,this.beta1),M(l,1-this.beta1)),f=M(p,this.beta2),d=Te(l),h=fn(f,d);c.assign(m),p.assign(h);let g=J(M(ct(o,n),ct(m,J(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(J(this.iteration,1)),this.accBeta1.assign(M(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&_t(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};iu.className="Adamax";Nn(iu);var Hi=class extends Vr{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=Array.isArray(t)?t[o].tensor:t[n];if(s==null)return;let i=_.registeredVariables[n];B(()=>{let a=J(M(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Pe(pt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};Hi.className="SGD";Nn(Hi);var au=class extends Hi{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=pt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${n}/momentum`,variable:B(()=>St(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[n];a!=null&&B(()=>{let u,l=J(M(this.m,i),a);this.useNesterov?u=J(M(this.c,J(a,M(l,this.m))),s):u=J(M(this.c,l),s),i.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_t(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};au.className="Momentum";Nn(au);var lu=class extends Vr{constructor(t,e=.9,n=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=_.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:B(()=>St(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:B(()=>St(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:B(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;B(()=>{let c=J(M(u,this.decay),M(Wt(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,m=J(M(p,this.decay),M(a,1-this.decay)),f=ct(M(a,this.learningRate),ye(lt(c,J(Wt(m),this.epsilon)))),d=J(M(l,this.momentum),f);u.assign(c),p.assign(m),l.assign(d);let h=lt(s,d);s.assign(h)}else{let p=J(M(u,this.decay),M(Wt(a),1-this.decay)),m=J(M(l,this.momentum),ct(M(a,this.learningRate),ye(J(p,this.epsilon))));u.assign(p),l.assign(m);let f=lt(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_t(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_t(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&_t(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};lu.className="RMSProp";Nn(lu);var oi=class{static sgd(t){return new Hi(t)}static momentum(t,e,n=!1){return new au(t,e,n)}static rmsprop(t,e=.9,n=0,o=null,s=!1){return new lu(t,e,n,o,s)}static adam(t=.001,e=.9,n=.999,o=null){return new su(t,e,n,o)}static adadelta(t=.001,e=.95,n=null){return new nu(t,e,n)}static adamax(t=.002,e=.9,n=.999,o=null,s=0){return new iu(t,e,n,o,s)}static adagrad(t,e=.1){return new ou(t,e)}};var Ic={sgd:oi.sgd,momentum:oi.momentum,adadelta:oi.adadelta,adagrad:oi.adagrad,rmsprop:oi.rmsprop,adamax:oi.adamax,adam:oi.adam};var f5=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function Hh(){return new Promise(r=>f5(()=>r()))}var S={};Yt(S,{ERF_A1:()=>S5,ERF_A2:()=>k5,ERF_A3:()=>N5,ERF_A4:()=>T5,ERF_A5:()=>_5,ERF_P:()=>I5,PARALLELIZE_THRESHOLD:()=>ly,SELU_SCALE:()=>CS,SELU_SCALEALPHA:()=>vS,applyActivation:()=>vc,assertAndGetBroadcastShape:()=>Bt,assertAxesAreInnerMostDims:()=>Mq,assertParamsConsistent:()=>d5,assignToTypedArray:()=>R5,axesAreInnerMostDims:()=>YI,calculateShapes:()=>L_,checkEinsumDimSizes:()=>B5,checkPadOnDimRoundingMode:()=>_e,combineLocations:()=>nE,complexWithEvenIndex:()=>$5,complexWithOddIndex:()=>D5,computeConv2DInfo:()=>Ju,computeConv3DInfo:()=>tE,computeDefaultPad:()=>PI,computeDilation2DInfo:()=>MH,computeOptimalWindowSize:()=>g5,computeOutAndReduceShapes:()=>ZI,computeOutShape:()=>h5,computePool2DInfo:()=>MI,computePool3DInfo:()=>PH,convertConv2DDataFormat:()=>eE,decodeEinsumEquation:()=>L5,eitherStridesOrDilationsAreOne:()=>Dr,expandShapeToKeepDim:()=>yo,exponent:()=>M5,exponents:()=>O5,fromStringArrayToUint8:()=>aX,fromUint8ToStringArray:()=>iX,getAxesPermutation:()=>JI,getBroadcastDims:()=>O_,getComplexWithIndex:()=>F5,getEinsumComputePath:()=>V5,getEinsumPermutation:()=>z5,getFusedBiasGradient:()=>wc,getFusedDyActivation:()=>bc,getImageCenter:()=>x5,getInnerMostAxes:()=>Pq,getPermuted:()=>b5,getReductionAxes:()=>xe,getReshaped:()=>y5,getReshapedPermuted:()=>w5,getSliceBeginCoords:()=>v5,getSliceSize:()=>C5,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>H5,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>q5,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>K5,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Y5,getSparseReshapeInputOutputMismatchErrorMessage:()=>J5,getSparseReshapeInputOutputMultipleErrorMessage:()=>Z5,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>j5,getSparseReshapeNegativeOutputDimErrorMessage:()=>X5,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>rX,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Q5,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>tX,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>eX,getUndoAxesPermutation:()=>kh,isIdentityPermutation:()=>G5,log:()=>JU,mergeRealAndImagArrays:()=>E5,prepareAndValidate:()=>P_,prepareSplitSize:()=>U5,segment_util:()=>SS,shouldFuse:()=>Cc,slice_util:()=>Ve,splitRealAndImagArrays:()=>A5,tupleValuesAreOne:()=>Zn,upcastType:()=>ar,validateInput:()=>Ox,validateUpdateShape:()=>_I,warn:()=>Li});function d5(r,t){let e=r[0].length;r.forEach((o,s)=>{A(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),A(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<e;i++)A(i===t||o[i]===n[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function h5(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var ly=30;function g5(r){return r<=ly?r:_p(r,Math.floor(Math.sqrt(r)))}function x5(r,t,e){let n=e*(typeof r=="number"?r:r[0]),o=t*(typeof r=="number"?r:r[1]);return[n,o]}function y5(r,t,e,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(r[0]/e),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/t[i],t[i]]);o=o.concat(r.slice(s+1))}return o}function b5(r,t,e=!0){let n=[];if(e){n.push(t);for(let o=t+1;o<r;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function w5(r,t,e,n=!0){let o=[];n?o.push(r[0]/e):o.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?n?o.push(t[s-1]*r[s]):o.push(r[s]/t[s-1]):o.push(r[s]);return o}function v5(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function C5(r,t,e){let n=r.slice(0,1);for(let o=0;o<e;++o)n.push(r[o+1]-t[o][0]-t[o][1]);return n}var vS=1.7580993408473768,CS=1.0507009873554805;var I5=.3275911,S5=.254829592,k5=-.284496736,N5=1.421413741,T5=-1.453152027,_5=1.061405429;function E5(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function A5(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function $5(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function D5(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function F5(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function R5(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function O5(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(t?2:-2)*Math.PI*(o/r);e[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:e,imag:n}}function M5(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var IS="->",P5=/->/g,cA=",",pA="...";function L5(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(P5,"").length)/IS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${IS}").`);let[n,o]=r.split(IS);A(n.indexOf(pA)===-1,()=>`The ellipsis notation ("${pA}") is not supported yet.`);let s=n.split(cA),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let m=0;m<n.length;++m){let f=n[m];a.indexOf(f)===-1&&f!==cA&&a.push(f)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let f=0;f<s[m].length;++f)u[m].push(a.indexOf(s[m][f]))}let l=a.length,c=o.length,p=[];for(let m=c;m<l;++m)p.push(m);return{allDims:a,summedDims:p,idDims:u}}function z5(r,t){let e=new Array(r);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let n=[];for(let o=0;o<r;++o)e[o]===-1&&n.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:n}}function B5(r,t,e){let n=new Array(r);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<t[o].length;++i)n[t[o][i]]===void 0?n[t[o][i]]=s[i]:A(n[t[o][i]]===s[i],()=>`Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function V5(r,t){let e=r,n=[],o=0;r.length===0&&e.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],u=W5(t,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:e,steps:n}}function G5(r){return r.every((t,e)=>t===e)}function W5(r,t){let e=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function U5(r,t,e=0){let n=[];if(typeof t=="number")A(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);A(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,u)=>u>0?a+u:a);t[s]=r.shape[e]-i}A(r.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function H5(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function q5(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function K5(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function j5(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function X5(r,t){return`size ${r} must be non-negative, not ${t}`}function Y5(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Z5(r,t){let e=Jt(r),n=Jt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${t}`}function J5(r,t){let e=Jt(r),n=Jt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${t}`}function Q5(){return"segment ids must be >= 0"}function tX(){return"segment ids are not increasing"}function eX(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function rX(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var SS={};Yt(SS,{collectGatherOpShapeInfo:()=>sX,computeOutShape:()=>oX,segOpComputeOptimalWindowSize:()=>nX});function nX(r,t){let e=!1,n;for(r<=ly?(n=r,e=!0):n=_p(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=_p(r,n+1);return n}function oX(r,t,e){let n=[],o=r.length;for(let s=0;s<o;s++)s!==t?n.push(r[s]):n.push(e);return n}function sX(r,t,e,n){let o=t.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let p=0;p<n;++p)if(r.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=r.shape[e],a=[],u=1,l=1,c=1;for(let p=0;p<n;++p)a.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<e;p++)a.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<o;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function iX(r){try{return r.map(t=>mm(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function aX(r){return r.map(t=>jl(t))}var Gr={};Yt(Gr,{nonMaxSuppressionV3Impl:()=>ry,nonMaxSuppressionV4Impl:()=>ny,nonMaxSuppressionV5Impl:()=>oy,whereImpl:()=>Xx});var uy={kernelName:wi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,ni(Z(e,"float32"),-1))}}};var mA={kernelName:ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Wt(Z(e,"float32")),o=ye(lt(pt(1),n));return Zt(ct(r,o))}}}};var fA={kernelName:na,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=ye(lt(Wt(Z(e,"float32")),1));return ct(r,n)}}}};var dA={kernelName:Xn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=r,u=xe(e.shape,o);return u.length>0&&(a=mt(a,u)),R(a,e.shape)},b:()=>{let a=r,u=xe(n.shape,o);return u.length>0&&(a=mt(a,u)),R(a,n.shape)}}}};var hA={kernelName:Zo,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,o)=>{e[o]=()=>r.clone()}),e}};var gA={kernelName:Jo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var xA={kernelName:Dl,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var yA={kernelName:ia,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,ye(lt(pt(1),Wt(Z(e,"float32")))))}}};var bA={kernelName:aa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=ye(J(pt(1),Wt(Z(e,"float32"))));return ct(r,n)}}}};var wA={kernelName:ca,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=J(Wt(e),Wt(n)),u=M(r,ct(n,a)),l=xe(e.shape,o);return l.length>0&&(u=mt(u,l)),R(u,e.shape)},b:()=>{let a=J(Wt(e),Wt(n)),u=Zt(M(r,ct(e,a))),l=xe(n.shape,o);return l.length>0&&(u=mt(u,l)),R(u,n.shape)}}}};var vA={kernelName:la,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(Wt(Z(e,"float32")),1))}}};var CA={kernelName:ua,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,lt(pt(1),Wt(Z(e,"float32"))))}}};function lX(r,t,e,n,o,s){let i=C(r,"dy","avgPool3dGrad"),a=C(t,"input","avgPool3dGrad"),u=i,l=a,c=!1;a.rank===4&&(c=!0,u=R(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=R(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),A(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),A(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),_e("avgPool3dGrad",o,s);let p={dy:u,input:l},m={filterSize:e,strides:n,pad:o,dimRoundingMode:s},f=_.runKernel($p,p,m);return c?R(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var IA=N({avgPool3dGrad_:lX});var SA={kernelName:Fl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>IA(r,n,o,s,i,a)}}};function uX(r,t,e,n,o){let s=C(r,"dy","avgPoolGrad"),i=C(t,"input","avgPoolGrad");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,u=s,l=!1;i.rank===3&&(l=!0,a=R(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=R(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),A(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:u,input:a},p={filterSize:e,strides:n,pad:o},m=_.runKernel(Ap,c,p);return l?R(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var kA=N({avgPoolGrad_:uX});var NA={kernelName:Qo,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i}=e;return{x:()=>kA(r,n,o,s,i)}}};var TA={kernelName:ts,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,o]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>zt(r,o,!1,!0),b:()=>zt(n,r,!0,!1)}:!s&&i?{a:()=>zt(r,o,!1,!1),b:()=>zt(r,n,!0,!1)}:s&&!i?{a:()=>zt(o,r,!1,!0),b:()=>zt(n,r,!1,!1)}:{a:()=>zt(o,r,!0,!0),b:()=>zt(r,n,!0,!0)}}};var _A={kernelName:vi,gradFunc:(r,t,e)=>{let{blockShape:n,crops:o}=e;return{x:()=>el(r,n,o)}}};var EA={kernelName:E1,gradFunc:(r,t,e)=>{let n=e,o=n.inputShape,s=n.shape,i=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])i[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>mt(r,a,!0)}}};var AA={kernelName:io,gradFunc:r=>({x:()=>r.clone()})};var $A={kernelName:es,gradFunc:r=>({x:()=>St(r)})};var DA={kernelName:ao,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>Ee(Tr(Tn(n,o),_n(n,s)),r,St(r))}}};var FA={kernelName:Rl,inputsToSave:["x"],gradFunc:uy.gradFunc};var RA={kernelName:Ci,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:o}=e,s=mr(o,t[0].shape)[0],i=n.map(u=>u[s]);return ur(r,i,s).map(u=>()=>u)}};var OA={kernelName:rs,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{dilations:s,strides:i,pad:a,dataFormat:u}=e;return A(Zn(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>wm(n.shape,r,o,i,a,u),filter:()=>km(n,r,o.shape,i,a,u)}}};var MA={kernelName:ns,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>pn(r,o,s,i,a,1,u),filter:()=>km(r,n,o.shape,s,i,a,u)}}};function cX(r,t,e,n,o){let s=r;r.rank===4&&(s=R(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=t;i.rank===4&&(i=R(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),A(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),A(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},u={strides:n,pad:o,filterShape:e};return _.runKernel(Mp,a,u)}var PA=N({conv3DBackpropFilter_:cX});var LA={kernelName:Ol,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s}=e;A(Zn(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=t;return{x:()=>Lx(i.shape,r,a,o,s),filter:()=>PA(i,r,a.shape,o,s)}}};var zA={kernelName:os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(Zt(dc(Z(e,"float32"))),r)}}};var BA={kernelName:ss,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(hc(Z(e,"float32")),r)}}};var VA={kernelName:is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=JI([o],n.rank),u=rc(r,o,s,!i);return a!=null&&(u=Mt(u,a)),u}}}};var GA={kernelName:as,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=e,a=n==null?[1,1]:n;A(Zn(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[u,l]=t;return A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),A(Dr(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),_e("depthwiseConv2d",s,i),{x:()=>Qx(u.shape,r,l,o,s,a,i),filter:()=>Jx(u,r,l.shape,o,s,a,i)}}};var WA={kernelName:Ml,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,s={x:n,filter:o,dy:r},i={x:n,filter:o,dy:r};return{x:()=>_.runKernel(Kd,s,e),filter:()=>_.runKernel(jd,i,e)}}};var UA={kernelName:us,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>_.runKernel(Wp,n)}}};var HA={kernelName:da,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=M(Ye(Zt(Wt(e))),2/Math.sqrt(Math.PI));return{x:()=>M(r,n)}}};var qA={kernelName:cs,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,e)}}};var KA={kernelName:Ii,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>R(r,e.shape)}}};var jA={kernelName:ga,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,Ye(e))}}};var XA={kernelName:ps,gradFunc:r=>({x:()=>St(r)})};var YA={kernelName:ms,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=ct(r,Z(n,"float32")),u=xe(e.shape,o);return u.length>0?R(mt(a,u),e.shape):a},b:()=>{let a=M(r,Z(e,"float32")),u=xe(n.shape,o);u.length>0&&(a=R(mt(a,u),n.shape));let l=Wt(n);return Zt(ct(a,Z(l,"float32")))}}}};var ZA={kernelName:fs,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[o,s,i,a]=t,u=a==null?pt(1):a,l=xe(s.shape,o.shape),c=[];if(s.rank===1){for(let v=0;v<o.shape.length-1;++v)c.push(o.shape[v]);c.push(1)}let p=lt(o,s),m=M(r,u),f=mc(J(i,pt(n))),d=M(M(M(f,f),f),pt(-.5));return{x:()=>s.rank===1?R(M(M(r,Nr(R(f,[1,1,1,s.shape[0]]),c)),u),o.shape):R(M(M(r,f),u),o.shape),mean:()=>{let v=M(M(f,pt(-1)),m);return s.rank===1&&(v=mt(v,l)),R(v,s.shape)},variance:()=>{let v=M(M(d,p),m);return s.rank===1&&(v=mt(v,l)),R(v,s.shape)},scale:()=>{let v=M(p,f),k=M(r,v);return s.rank===1&&(k=mt(k,l)),R(k,s.shape)},offset:()=>{let v=r;return s.rank===1&&(v=mt(v,l)),R(v,s.shape)}}}};var t2={kernelName:Si,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,o]=t,{axis:s}=e,i=mr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,c=u.slice(0,i),p=c.length,m=u.slice(s,u.length).slice(1),f=m.length,d=JA(0,p),h=JA(p+1,p+1+f),g=QA([c,[l],m]),y=R(r,g),b=R(o,[l]),w=QA([[p],d,h]),v=Mt(y,w),k=Gh(v,b,n.shape[i]),E=kh(w);return k=Mt(k,E),k},indices:()=>o}}};function JA(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function QA(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var e2={kernelName:ds,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>St(e),b:()=>St(n)}}};var r2={kernelName:lo,gradFunc:r=>({x:()=>Z(r,"float32")})};var n2={kernelName:wa,gradFunc:r=>({x:()=>St(r)})};var o2={kernelName:va,gradFunc:r=>({x:()=>St(r)})};var s2={kernelName:Ca,gradFunc:r=>({x:()=>St(r)})};var i2={kernelName:hs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:o}=e,s=Ge(n,0);return{x:()=>Ee(s,r,M(r,o))}}};var a2={kernelName:ka,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(e,1))}}};var l2={kernelName:gs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Z(e,"float32"))}}};var u2={kernelName:A1,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e;return{logits:()=>{let i=Ye(n);return lt(r,M(mt(r,o,!0),i))}}}};function pX(r,t,e,n=5,o=1,s=1,i=.5){let a={x:r,y:t,dy:e},u={depthRadius:n,bias:o,alpha:s,beta:i};return _.runKernel(jp,a,u)}var c2=N({localResponseNormalizationBackprop_:pX});var p2={kernelName:Ll,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{depthRadius:s,bias:i,alpha:a,beta:u}=e;return{x:()=>c2(n,o,r,s,i,a,u)}}};function cy(r,t,e,n){return t.rank<e.rank&&(t=R(t,yo(t.shape,n))),r.rank<e.rank&&(r=R(r,yo(r.shape,n))),{x:()=>M(r,Z(kr(e,t),r.dtype))}}var kS={kernelName:xs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:o}=n,s=t[0],i=t[1],a=mr(o,s.shape),u=cy(r,i,s,a);return{x:()=>u.x()}}};var m2={kernelName:ys,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>M(r,Z(Tn(e,n),"float32")),b:()=>M(r,Z(oc(e,n),"float32"))}}};function mX(r,t,e,n,o,s,i){let a=C(r,"dy","maxPool3dGrad"),u=C(t,"input","maxPool3dGrad"),l=C(e,"output","maxPool3dGrad"),c=a,p=u,m=l,f=!1;u.rank===4&&(f=!0,c=R(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=R(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=R(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),A(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),A(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),A(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),_e("maxPool3dGrad",s,i);let d={dy:c,input:p,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:i},g=_.runKernel(Yp,d,h);return f?R(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var f2=N({maxPool3dGrad_:mX});var d2={kernelName:zl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=e;return{x:()=>f2(r,n,o,s,i,a,u)}}};function fX(r,t,e,n,o,s,i){let a=C(r,"dy","maxPoolGrad"),u=C(t,"input","maxPoolGrad"),l=C(e,"output","maxPoolGrad");A(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),A(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),A(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),_e("maxPoolGrad",s,i);let c={dy:a,input:u,output:l},p={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return _.runKernel(Xp,c,p)}var h2=N({maxPoolGrad_:fX});var g2={kernelName:bs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>h2(r,n,o,s,i,a)}}};var x2={kernelName:ws,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=mr(o,n.shape),a=ZI(n.shape,s)[1],u=Jt(a);return{x:()=>{let c=n.shape.slice();s.forEach(f=>{c[f]=1});let p=R(r,c);return ct(M(p,lr(n.shape,"float32")),u)}}}};var y2={kernelName:vs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:o}=n,[s,i]=t,a=mr(o,s.shape),u=cy(r,i,s,a);return{x:()=>u.x()}}};var b2={kernelName:Cs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>M(r,Z(_n(e,n),"float32")),b:()=>M(r,Z(Ge(e,n),"float32"))}}};var w2={kernelName:Is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ft(r,s,n.shape)}}};var v2={kernelName:Ta,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=xe(e.shape,o);return a.length>0?R(mt(r,a),e.shape):r},b:()=>{let a=M(r,Zt(ti(ct(e,n)))),u=xe(n.shape,o);return u.length>0?R(mt(a,u),n.shape):a}}}};var C2={kernelName:Ss,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=M(r,Z(n,"float32")),u=xe(e.shape,o);return u.length>0?R(mt(a,u),e.shape):a},b:()=>{let a=M(r,Z(e,"float32")),u=xe(n.shape,o);return u.length>0?R(mt(a,u),n.shape):a}}}};var I2={kernelName:ki,gradFunc:r=>({x:()=>Zt(r)})};var S2={kernelName:ks,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>we(e.shape,"float32")}}};var k2={kernelName:Ni,gradFunc:r=>({x:()=>St(r)})};var N2={kernelName:Ti,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return vr(r,n).map(s=>()=>s)}};var NS={kernelName:Ns,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ft(r,s,n.shape)}}};var T2={kernelName:Ts,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,o]=t,s=e,i=n,a=Bt(s.shape,i.shape);return{a:()=>{let c=Z(i,"float32"),p=M(r,M(c,Yr(s,lt(c,pt(1))))),m=xe(s.shape,a);return m.length>0&&(p=mt(p,m)),R(p,s.shape)},b:()=>{let c=Ge(s,0),p=Ee(c,wr(s),St(s)),m=M(r,M(o,p)),f=xe(i.shape,a);return f.length>0&&(m=mt(m,f)),R(m,i.shape)}}}};var _2={kernelName:_s,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,o=Ge(e,0);return{x:()=>Ee(o,r,M(r,n)),alpha:()=>{let s=Ee(o,St(r),M(r,e)),i=xe(n.shape,r.shape);return i.length>0&&(s=mt(s,i)),R(s,n.shape)}}}};function dX(r,t,e){let n=r.shape.slice();n[e]=1;let o=R(t,n),s=Ql(r,e,!0,!1),i=Ql(r,e,!0,!0),a=M(s,i);return M(o,a)}function hX(r,t,e){let n=r.shape.length,o=n-e.length,s=S.getAxesPermutation(e,n),i=r;s!=null&&(i=Mt(r,s));let a=i.shape.slice(),l=a.splice(n-e.length,e.length).reduce((m,f)=>m*f,1);a.push(l);let c=i.reshape(a),p=dX(c,t,o);if(p=p.reshape(i.shape),s!=null){let m=S.getUndoAxesPermutation(s);p=Mt(p,m)}return p}var E2={kernelName:Es,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=[];return o==null?s=n.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>hX(n,r,s)}}};var A2={kernelName:ls,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=ct(r,Z(n,"float32")),u=xe(e.shape,o);return u.length>0?R(mt(a,u),e.shape):a},b:()=>{let a=M(r,Z(e,"float32")),u=xe(n.shape,o);u.length>0&&(a=R(mt(a,u),n.shape));let l=Wt(n);return Zt(ct(a,Z(l,"float32")))}}}};var $2={kernelName:Da,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Zt(Wt(e)))}}};var D2={kernelName:Ds,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=M(_n(e,6),ni(e));return{x:()=>M(r,Z(n,"float32"))}}};var F2={kernelName:As,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,Z(ni(e),"float32"))}}};var R2={kernelName:_i,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>R(r,e.shape)}}};var O2={kernelName:$s,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(em,o,e)}}};var M2={kernelName:Vl,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(tm,o,e)}}};var P2={kernelName:Fs,gradFunc:(r,t,e)=>{let{dims:n}=e,o=mr(n,r.shape);return{x:()=>ir(r,o)}}};var L2={kernelName:Rs,gradFunc:r=>({x:()=>St(r)})};var z2={kernelName:Os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Zt(ct(r,M(Yr(e,1.5),2)))}}};var B2={kernelName:Ei,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>Z(St(e),"float32"),t:()=>M(r,Z(e,r.dtype)),e:()=>M(r,Z(Qa(e),r.dtype))}}};var V2={kernelName:Ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ge(e,pt(0)),o=pt(vS),s=pt(CS),i=M(r,s),a=M(M(r,o),Ye(Z(e,"float32")));return Ee(n,i,a)}}}};var G2={kernelName:Ps,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,M(e,lt(pt(1),e)))}}};var W2={kernelName:Ma,gradFunc:r=>({x:()=>St(r)})};var U2={kernelName:Ms,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(Ya(Z(e,"float32")),r)}}};var H2={kernelName:Oa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(ec(Z(e,"float32")),r)}}};var q2={kernelName:Ai,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:o,size:s}=e,i=n.shape,[a,u]=AI(n,o,s),l=[];for(let c=0;c<r.rank;c++)l.push([a[c],i[c]-a[c]-u[c]]);return{x:()=>Zr(r,l)}}};var K2={kernelName:Bs,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:o}=e,s=!0,i=M(r,n);return{logits:()=>lt(i,M(mt(i,[o],s),n))}}};var j2={kernelName:Pa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,Lr(e))}}};var TS={kernelName:$i,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:o}=e;return{x:()=>ja(r,n,o)}}};var _S={kernelName:Di,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>se(r,n)}}};var X2={kernelName:Ls,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,M(ye(Z(e,"float32")),2))}}};var Y2={kernelName:Hl,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,M(Z(e,"float32"),2))}}};var Z2={kernelName:Vs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=pt(2);return{a:()=>M(r,M(o,lt(e,n))),b:()=>M(r,M(o,lt(n,e)))}}};var J2={kernelName:uo,gradFunc:r=>({x:()=>St(r)})};var Q2={kernelName:Gs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=r,u=xe(e.shape,o);return u.length>0&&(a=mt(a,u)),R(a,e.shape)},b:()=>{let a=r,u=xe(n.shape,o);return u.length>0&&(a=mt(a,u)),R(Zt(a),n.shape)}}}};var t$={kernelName:zs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,o=n.shape.slice(),{axis:s}=e;mr(s,n.shape).forEach(l=>{o[l]=1});let a=R(r,o),u=M(a,lr(n.shape,"float32"));return{x:()=>u}}};var e$={kernelName:Ws,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Wt(Ya(e)))}}};var r$={kernelName:Us,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(lt(pt(1),Wt(e)),r)}}};var n$={kernelName:Yn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:o}=e;return{x:()=>{let i=St(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=J(i,Ft(r,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)i=J(i,Ft(r,[a*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)i=J(i,Ft(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let c=0;c<o[3];++c)i=J(i,Ft(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var o$={kernelName:Hs,gradFunc:(r,t,e)=>{let n=e,{perm:o}=n,s=kh(o);return{x:()=>Mt(r,s)}}};var s$={kernelName:Fi,gradFunc:(r,t,e)=>{let n=e,{axis:o}=n;return{value:()=>Ze(r,o)}}};var i$={kernelName:ql,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>gX(r,e)}}};function gX(r,t){let e=fn(t,St(t)),n=bo(r,e),o=Tn(t,pt(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=fr(o,a+1);o=Tr(o,lr(n.shape,"bool"));let i=St(n);return Ee(o,n,i)}var a$={kernelName:Ri,gradFunc:r=>({x:()=>St(r)})};var xX=[uy,mA,fA,dA,hA,gA,xA,yA,bA,wA,vA,CA,SA,NA,TA,_A,EA,AA,$A,DA,FA,RA,MA,OA,LA,zA,BA,VA,GA,WA,A2,UA,HA,qA,KA,jA,YA,XA,ZA,t2,e2,r2,n2,o2,s2,i2,a2,l2,u2,p2,kS,kS,m2,d2,g2,x2,y2,b2,w2,v2,C2,I2,S2,k2,N2,NS,NS,T2,_2,E2,$2,D2,F2,R2,O2,M2,P2,L2,z2,B2,V2,G2,W2,U2,H2,q2,K2,j2,TS,TS,_S,_S,X2,Z2,Y2,J2,Q2,t$,e$,r$,n$,o$,s$,i$,a$];for(let r of xX)D1(r);L().prototype.abs=function(){return this.throwIfDisposed(),Te(this)};L().prototype.acos=function(){return this.throwIfDisposed(),uh(this)};L().prototype.acosh=function(){return this.throwIfDisposed(),ch(this)};L().prototype.add=function(r){return this.throwIfDisposed(),J(this,r)};L().prototype.all=function(r,t){return this.throwIfDisposed(),Yu(this,r,t)};L().prototype.any=function(r,t){return this.throwIfDisposed(),Jl(this,r,t)};L().prototype.argMax=function(r){return this.throwIfDisposed(),Xs(this,r)};L().prototype.argMin=function(r){return this.throwIfDisposed(),ph(this,r)};L().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),R(this,[])};L().prototype.asType=function(r){return this.throwIfDisposed(),Z(this,r)};L().prototype.as1D=function(){return this.throwIfDisposed(),R(this,[this.size])};L().prototype.as2D=function(r,t){return this.throwIfDisposed(),R(this,[r,t])};L().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),R(this,[r,t,e])};L().prototype.as4D=function(r,t,e,n){return this.throwIfDisposed(),R(this,[r,t,e,n])};L().prototype.as5D=function(r,t,e,n,o){return this.throwIfDisposed(),R(this,[r,t,e,n,o])};L().prototype.asin=function(){return this.throwIfDisposed(),mh(this)};L().prototype.asinh=function(){return this.throwIfDisposed(),fh(this)};L().prototype.atan=function(){return this.throwIfDisposed(),dh(this)};L().prototype.atan2=function(r){return this.throwIfDisposed(),hh(this,r)};L().prototype.atanh=function(){return this.throwIfDisposed(),gh(this)};L().prototype.avgPool=function(r,t,e,n){return this.throwIfDisposed(),Ka(this,r,t,e,n)};L().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),ja(this,r,t)};L().prototype.batchNorm=function(r,t,e,n,o){return this.throwIfDisposed(),xo(this,r,t,e,n,o)};L().prototype.broadcastTo=function(r){return this.throwIfDisposed(),Xa(this,r)};L().prototype.cast=function(r){return this.throwIfDisposed(),Z(this,r)};L().prototype.ceil=function(){return this.throwIfDisposed(),bh(this)};L().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),br(this,r,t)};L().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof Lt&&(r=[r]),se([this,...r],t)};L().prototype.conv1d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Qu(this,r,t,e,n,o,s)};L().prototype.conv2dTranspose=function(r,t,e,n,o){return this.throwIfDisposed(),tc(this,r,t,e,n,o)};L().prototype.conv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),pn(this,r,t,e,n,o,s)};L().prototype.cos=function(){return this.throwIfDisposed(),Ya(this)};L().prototype.cosh=function(){return this.throwIfDisposed(),ec(this)};L().prototype.cumprod=function(r,t,e){return this.throwIfDisposed(),Ql(this,r,t,e)};L().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),rc(this,r,t,e)};L().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),vh(this,r,t)};L().prototype.depthwiseConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Zs(this,r,t,e,n,o,s)};L().prototype.dilation2d=function(r,t,e,n,o){return this.throwIfDisposed(),Ch(this,r,t,e,n,o)};L().prototype.divNoNan=function(r){return this.throwIfDisposed(),Ih(this,r)};L().prototype.div=function(r){return this.throwIfDisposed(),ct(this,r)};L().prototype.dot=function(r){return this.throwIfDisposed(),jI(this,r)};L().prototype.elu=function(){return this.throwIfDisposed(),Js(this)};L().prototype.equal=function(r){return this.throwIfDisposed(),kr(this,r)};L().prototype.erf=function(){return this.throwIfDisposed(),Sh(this)};L().prototype.euclideanNorm=function(r,t){return this.throwIfDisposed(),Nh(this,r,t)};L().prototype.exp=function(){return this.throwIfDisposed(),Ye(this)};L().prototype.expandDims=function(r){return this.throwIfDisposed(),fr(this,r)};L().prototype.expm1=function(){return this.throwIfDisposed(),Th(this)};L().prototype.fft=function(){return this.throwIfDisposed(),sl(this)};L().prototype.flatten=function(){return this.throwIfDisposed(),R(this,[this.size])};L().prototype.floor=function(){return this.throwIfDisposed(),ti(this)};L().prototype.floorDiv=function(r){return this.throwIfDisposed(),Xu(this,r)};L().prototype.gather=function(r,t){return this.throwIfDisposed(),bo(this,r,t)};L().prototype.greaterEqual=function(r){return this.throwIfDisposed(),Tn(this,r)};L().prototype.greater=function(r){return this.throwIfDisposed(),Ge(this,r)};L().prototype.ifft=function(){return this.throwIfDisposed(),Wi(this)};L().prototype.irfft=function(){return this.throwIfDisposed(),gc(this)};L().prototype.isFinite=function(){return this.throwIfDisposed(),tS(this)};L().prototype.isInf=function(){return this.throwIfDisposed(),eS(this)};L().prototype.isNaN=function(){return this.throwIfDisposed(),_h(this)};L().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Za(this,r)};L().prototype.lessEqual=function(r){return this.throwIfDisposed(),_n(this,r)};L().prototype.less=function(r){return this.throwIfDisposed(),oc(this,r)};L().prototype.localResponseNormalization=function(r,t,e,n){return this.throwIfDisposed(),Eh(this,r,t,e,n)};L().prototype.logSigmoid=function(){return this.throwIfDisposed(),nS(this)};L().prototype.logSoftmax=function(r){return this.throwIfDisposed(),sc(this,r)};L().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),Ah(this,r,t)};L().prototype.log=function(){return this.throwIfDisposed(),wr(this)};L().prototype.log1p=function(){return this.throwIfDisposed(),Ja(this)};L().prototype.logicalAnd=function(r){return this.throwIfDisposed(),Tr(this,r)};L().prototype.logicalNot=function(){return this.throwIfDisposed(),Qa(this)};L().prototype.logicalOr=function(r){return this.throwIfDisposed(),ic(this,r)};L().prototype.logicalXor=function(r){return this.throwIfDisposed(),oS(this,r)};L().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),zt(this,r,t,e)};L().prototype.maxPool=function(r,t,e,n){return this.throwIfDisposed(),tl(this,r,t,e,n)};L().prototype.max=function(r,t){return this.throwIfDisposed(),Fr(this,r,t)};L().prototype.maximum=function(r){return this.throwIfDisposed(),fn(this,r)};L().prototype.mean=function(r,t){return this.throwIfDisposed(),be(this,r,t)};L().prototype.min=function(r,t){return this.throwIfDisposed(),tu(this,r,t)};L().prototype.minimum=function(r){return this.throwIfDisposed(),ei(this,r)};L().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),Dh(this,r,t)};L().prototype.mod=function(r){return this.throwIfDisposed(),Fh(this,r)};L().prototype.mul=function(r){return this.throwIfDisposed(),M(this,r)};L().prototype.neg=function(){return this.throwIfDisposed(),Zt(this)};L().prototype.norm=function(r,t,e){return this.throwIfDisposed(),eu(this,r,t,e)};L().prototype.notEqual=function(r){return this.throwIfDisposed(),vo(this,r)};L().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),js(this,r,t,e)};L().prototype.onesLike=function(){return this.throwIfDisposed(),dr(this)};L().prototype.pad=function(r,t){return this.throwIfDisposed(),Zr(this,r,t)};L().prototype.pool=function(r,t,e,n,o,s){return this.throwIfDisposed(),lS(this,r,t,e,n,o,s)};L().prototype.pow=function(r){return this.throwIfDisposed(),Yr(this,r)};L().prototype.prelu=function(r){return this.throwIfDisposed(),rl(this,r)};L().prototype.prod=function(r,t){return this.throwIfDisposed(),ac(this,r,t)};L().prototype.reciprocal=function(){return this.throwIfDisposed(),Rh(this)};L().prototype.relu=function(){return this.throwIfDisposed(),_r(this)};L().prototype.relu6=function(){return this.throwIfDisposed(),cc(this)};L().prototype.reshapeAs=function(r){return this.throwIfDisposed(),R(this,r.shape)};L().prototype.reshape=function(r){return this.throwIfDisposed(),R(this,r)};L().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),sy(this,r,t,e)};L().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),iy(this,r,t,e)};L().prototype.reverse=function(r){return this.throwIfDisposed(),ir(this,r)};L().prototype.rfft=function(){return this.throwIfDisposed(),il(this)};L().prototype.round=function(){return this.throwIfDisposed(),pc(this)};L().prototype.rsqrt=function(){return this.throwIfDisposed(),mc(this)};L().prototype.selu=function(){return this.throwIfDisposed(),fc(this)};L().prototype.separableConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Oh(this,r,t,e,n,o,s)};L().prototype.sigmoid=function(){return this.throwIfDisposed(),Lr(this)};L().prototype.sign=function(){return this.throwIfDisposed(),Mh(this)};L().prototype.sin=function(){return this.throwIfDisposed(),dc(this)};L().prototype.sinh=function(){return this.throwIfDisposed(),hc(this)};L().prototype.slice=function(r,t){return this.throwIfDisposed(),Ft(this,r,t)};L().prototype.softmax=function(r){return this.throwIfDisposed(),ol(this,r)};L().prototype.softplus=function(){return this.throwIfDisposed(),wo(this)};L().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),el(this,r,t)};L().prototype.split=function(r,t){return this.throwIfDisposed(),ur(this,r,t)};L().prototype.sqrt=function(){return this.throwIfDisposed(),ye(this)};L().prototype.square=function(){return this.throwIfDisposed(),Wt(this)};L().prototype.squaredDifference=function(r){return this.throwIfDisposed(),xc(this,r)};L().prototype.squeeze=function(r){return this.throwIfDisposed(),zr(this,r)};L().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof Lt?[this,r]:[this,...r];return Ze(e,t)};L().prototype.step=function(r){return this.throwIfDisposed(),ni(this,r)};L().prototype.stridedSlice=function(r,t,e,n,o,s,i,a){return this.throwIfDisposed(),zh(this,r,t,e,n,o,s,i,a)};L().prototype.sub=function(r){return this.throwIfDisposed(),lt(this,r)};L().prototype.sum=function(r,t){return this.throwIfDisposed(),mt(this,r,t)};L().prototype.tan=function(){return this.throwIfDisposed(),Bh(this)};L().prototype.tanh=function(){return this.throwIfDisposed(),Ys(this)};L().prototype.tile=function(r){return this.throwIfDisposed(),Nr(this,r)};L().prototype.toBool=function(){return this.throwIfDisposed(),Z(this,"bool")};L().prototype.toFloat=function(){return this.throwIfDisposed(),Z(this,"float32")};L().prototype.toInt=function(){return this.throwIfDisposed(),Z(this,"int32")};L().prototype.topk=function(r,t){return this.throwIfDisposed(),Vh(this,r,t)};L().prototype.transpose=function(r){return this.throwIfDisposed(),Mt(this,r)};L().prototype.unique=function(r){return this.throwIfDisposed(),Sm(this,r)};L().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),Gh(this,r,t)};L().prototype.unstack=function(r){return this.throwIfDisposed(),vr(this,r)};L().prototype.where=function(r,t){return this.throwIfDisposed(),Ee(r,this,t)};L().prototype.zerosLike=function(){return this.throwIfDisposed(),St(this)};var En=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,En.prototype)}},Wr=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Wr.prototype)}},z=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}},Nt=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nt.prototype)}},Nm=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nm.prototype)}};var qh=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function ko(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function Qn(r,t){if(!r)throw new Nm(t)}function AS(r,t){let e=0;for(let n of r)n===t&&e++;return e}function Er(r){return r.length===1?r[0]:r}function ve(r){return Array.isArray(r)?r:[r]}function No(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function al(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var So={};function Tm(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function ES(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>ES(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:ES(n))}}}function qi(r,t={},e={},n="object",o=!1){if(typeof r=="string"){let s=r,i;if(s in e)i=e[s];else if(s in So)i=So[s];else if(i=t[s],i==null)throw new z(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new z(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,u;if(i in e?[a,u]=e[i]:i in So?[a,u]=So.className:i in t&&([a,u]=t[i]),a==null)throw new z(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let f of Object.keys(So))l[f]=So[f];for(let f of Object.keys(e))l[f]=e[f];let c=s.config;c.customObjects=l;let p=Object.assign({},So);for(let f of Object.keys(e))So[f]=e[f];ES(s.config);let m=u(a,s.config,e,o);return So=Object.assign({},p),m}else{let l=Object.assign({},So);for(let p of Object.keys(e))So[p]=e[p];let c=new a(s.config);return So=Object.assign({},l),c}}}function yX(r,t){return r<t?-1:r>t?1:0}function Kh(r,t){return-1*yX(r,t)}function To(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function l$(r){if(r==null)throw new z(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function Ki(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new z(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function py(r,t,e=0,n=1/0){return Qn(e>=0),Qn(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(o=>typeof o===t)}function tr(r,t){Array.isArray(r)?(x.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>tr(e,`element ${n+1} of ${t}`))):x.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${u$(r)}.`)}function u$(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>u$(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function c$(r,t,e){let n=e!=null?e():x.now(),o;return(...i)=>{let a=e!=null?e():x.now();return a-n<t||(n=a,o=r(...i)),o}}function my(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var bX=0;function dy(){return bX++}var fy={};function uu(r=""){return r in fy||(fy[r]=0),fy[r]+=1,r+fy[r].toString()}var p$=["channelsFirst","channelsLast"],m$=["nearest","bilinear"],f$=["valid","same","causal"],d$=["max","avg"],h$=["sum","mul","concat","ave"];var _m=new Map;function Le(r){Ki(p$,"DataFormat",r)}function x$(r){Ki(m$,"InterpolationFormat",r)}function hn(r){Ki(f$,"PaddingMode",r)}function $S(r){Ki(d$,"PoolMode",r)}var jh=[],g$="/";function ii(r,t){jh.push(r);try{let e=t();return jh.pop(),e}catch(e){throw jh.pop(),e}}function wX(){return jh.length===0?"":jh.join(g$)+g$}function hy(r){if(!y$(r))throw new Error("Not a valid tensor name: '"+r+"'");return wX()+r}function gy(r){if(!y$(r))throw new Error("Not a valid tensor name: '"+r+"'");_m.has(r)||_m.set(r,0);let t=_m.get(r);if(_m.set(r,_m.get(r)+1),t>0){let e=`${r}_${t}`;return _m.set(e,1),e}else return r}var vX=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function y$(r){return!!r.match(vX)}function b$(r){return r===parseInt(r.toString(),10)}function _o(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let o=t;o<e;++o)n*=r[o];return n}function Sc(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n<t&&(t=n)}return t}function ai(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n>t&&(t=n)}return t}function Jr(r,t){if(t<r)throw new z(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}var DS;function cr(){return DS==null&&(DS=Q_().epsilon()),DS}function gn(){return"channelsLast"}function kc(r,t){return Z(r,t)}function ul(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),R(r,e)}function w$(r,t){return B(()=>{if(r.shape.length!==2)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=ul(r,1);return yy(e,[1,t,1])})}function v$(r){let t=[_o(r.shape)];return R(r,t)}function C$(r){if(r.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],_o(r.shape,1)];return R(r,t)}function ll(r,t,e){return B(()=>{switch(r.rank){case 1:return Ph(r,t,e);case 2:return jx(r,[t,0],[e,r.shape[1]]);case 3:return Lh(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return Im(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Ft(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Ft(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function FS(r,t,e){return B(()=>{switch(r.rank){case 1:return Ph(r,t,e);case 2:return jx(r,[0,t],[r.shape[0],e]);case 3:return Lh(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return Im(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Xh(r,t,e,n){return B(()=>{switch(r.rank){case 1:return Ph(r,t,e);case 2:switch(n){case 1:return ll(r,t,e);case 2:return FS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return ll(r,t,e);case 2:return Lh(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return FS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return ll(r,t,e);case 2:return Im(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return Im(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return FS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Em(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),se(r,t)}function OS(r,t){switch(r.rank){case 1:return GI([r,t]);case 2:return WI([r,t],0);case 3:return UI([r,t],0);case 4:return HI([r,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function yy(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return Nr(r,t)}function Am(r,t=0,e=1,n,o){return Kx(r,t,e,n,o)}function Eo(r,t,e,n){if(r.rank<2||t.rank<2)throw new Nt(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new Nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return Co.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?RS(r.rank,n,gn()):null,activation:e});{let o=r.shape.slice(),s=o.pop();r=R(r,[-1,s]);let i=t.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],c=Array.from({length:t.rank},(d,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=R(Mt(t,c),[u,-1]);let p=[...o,...l],m=!1,f=!1;return R(Co.matMul({a:r,b:t,transposeA:m,transposeB:f,bias:n?RS(r.rank,n,gn()):null,activation:e}),p)}}function by(r,t,e){return B(()=>(Array.isArray(t)?t=Fe(t,"int32"):t=Z(t,"int32"),bo(r,t,e)))}function Nc(r){return M(r,r)}function RS(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?R(t,[1,n[0],1,1,1]):R(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?R(t,[1,1,1,1,n[0]]):R(t,[1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?R(t,[1,n[0],1,1]):R(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?R(t,[1,1,1,n[0]]):R(t,[1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?R(t,[1,n[0],1]):R(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?R(t,[1,1,n[0]]):R(t,[1].concat(n))}else if(r<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function xn(r,t,e){return B(()=>(e==null&&(e=gn()),Le(e),J(r,RS(r.rank,t,e))))}function I$(r,t=1){if(t!==1)throw new Nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Js(r)}function S$(r){return B(()=>ct(r,J(Te(r),1)))}function wy(r,t,e,n){return B(()=>IE(r,t,e,n))}function k$(r){return B(()=>{let t=J(.5,M(.2,r));return br(t,0,1)})}function cu(r,t,e=!1){return e?r():t()}var N$=["fanIn","fanOut","fanAvg"],T$=["normal","uniform","truncatedNormal"];function CX(r){Ki(N$,"FanMode",r)}function IX(r){Ki(T$,"Distribution",r)}var bn=class extends et.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},$m=class extends bn{apply(t,e){return we(t,e)}};$m.className="Zeros";et.registerClass($m);var pu=class extends bn{apply(t,e){return lr(t,e)}};pu.className="Ones";et.registerClass(pu);var Dm=class extends bn{constructor(t){if(super(),typeof t!="object")throw new z(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new z(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return B(()=>M(pt(this.value),lr(t,e)))}getConfig(){return{value:this.value}}};Dm.className="Constant";et.registerClass(Dm);var Fm=class extends bn{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ri(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Fm.className="RandomUniform";et.registerClass(Fm);var Rm=class extends bn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`randomNormal does not support dType ${e}.`);return Am(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Rm.className="RandomNormal";et.registerClass(Rm);var Om=class extends bn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`truncatedNormal does not support dType ${e}.`);return yc(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Om.className="TruncatedNormal";et.registerClass(Om);var Mm=class extends bn{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return B(()=>{if(t.length!==2||t[0]!==t[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return M(this.gain,vm(t[0]))})}getConfig(){return{gain:this.gain}}};Mm.className="Identity";et.registerClass(Mm);function SX(r,t="channelsLast"){let e,n;if(Le(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let o=_o(r,2);e=r[1]*o,n=r[0]*o}else if(t==="channelsLast"){let o=_o(r,0,r.length-2);e=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=_o(r);e=Math.sqrt(o),n=Math.sqrt(o)}return[e,n]}var Ur=class extends bn{constructor(t){if(super(),t.scale<0)throw new z(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,CX(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,IX(this.distribution),this.seed=t.seed}apply(t,e){let n=SX(t),o=n[0],s=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,o):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(o+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`${this.getClassName()} does not support dType ${e}.`);return yc(t,0,a,e,this.seed)}else{let a=Math.sqrt(3*i);return ri(t,-a,a,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Ur.className="VarianceScaling";et.registerClass(Ur);var Tc=class extends Ur{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Tc.className="GlorotUniform";et.registerClass(Tc);var _c=class extends Ur{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};_c.className="GlorotNormal";et.registerClass(_c);var Ec=class extends Ur{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Ec.className="HeNormal";et.registerClass(Ec);var Ac=class extends Ur{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Ac.className="HeUniform";et.registerClass(Ac);var $c=class extends Ur{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};$c.className="LeCunNormal";et.registerClass($c);var Dc=class extends Ur{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Dc.className="LeCunNormal";et.registerClass(Dc);var Pm=class extends bn{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new Nt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return B(()=>{if(t.length<2)throw new Nt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let n=t[0]>t[1]?[t[1],t[0]]:t,o=Am(n,0,1,"float32"),s=uA.gramSchmidt(o);return t[0]>t[1]&&(s=Mt(s)),M(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Pm.className="Orthogonal";et.registerClass(Pm);var _$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function E$(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"initializer")}function Ae(r){return Tm(r)}function de(r){if(typeof r=="string"){let t=r in _$?_$[r]:r;if(t==="GlorotNormal")return new _c;if(t==="GlorotUniform")return new Tc;if(t==="HeNormal")return new Ec;if(t==="HeUniform")return new Ac;if(t==="LeCunNormal")return new $c;if(t==="LeCunUniform")return new Dc;{let e={};return e.className=t,e.config={},E$(e)}}else return r instanceof bn?r:E$(r)}function vy(r){return Array.isArray(r)&&Array.isArray(r[0])}function Lm(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Pt(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new z(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function Qt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new z(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function zm(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,o)=>n*o);return t}var $$="Variable",Yh=class{constructor(t,e="float32",n=$$,o=!0,s=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=dy(),n=n==null?$$:n,this.originalName=hy(n),this.name=gy(this.originalName),this.trainable_=o,this.constraint=s,this.val=bS(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),NX(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function NX(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function Zh(r){return r.map(t=>t.read())}function Bm(r){r.forEach(t=>{t[0].write(t[1])})}var Ce=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Qr=class{constructor(t,e,n,o,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=dy(),i!=null&&(this.originalName=hy(i),this.name=gy(this.originalName)),this.rank=e.length}},TX=0,cl=class{constructor(t,e){this.callArgs=e,this.id=TX++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},_X=0,Vt=class extends et.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=_X++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=No(n)+"_"+uu(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),n=[s].concat(t.inputShape)}this.batchInputShape=n;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Wr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Er(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Er(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} is not connected, no input to return.`);return Er(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Er(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=ve(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=ve(this.inputSpec);if(t.length!==e.length)throw new z(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){let o=t[n],s=e[n];if(s==null)continue;let i=o.rank;if(s.ndim!=null&&i!==s.ndim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new z(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let a=o.shape;for(let u in s.axes){let l=Number(u),c=s.axes[u],p=l>=0?a[l]:a[a.length+l];if(c!=null&&[c,null].indexOf(p)===-1)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let u=s.shape[a],l=o.shape[a];if(u!=null&&l!=null&&u!==l)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=ve(t),o=!0;for(let i of n)if(!(i instanceof Qr)){o=!1;break}let s=!0;for(let i of n)if(i instanceof Qr){s=!1;break}if(o===s)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return ii(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of ve(t))i.push(a.shape);this.build(Er(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e),a=ve(i),u=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=Er(u),this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=EX(t),a=this.computeOutputShape(i),u,l=AX(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,p)=>new Qr(l,c,this,ve(t),e,this.name,p)):u=new Qr(l,a,this,ve(t),e,this.name),this.addInboundNode(t,u,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&t[o]!=null&&t[o]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new En(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new En(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Wr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Zh(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{let e=this.weights;if(e.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],o=Zh(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],u=t[s];if(!x.arraysEqual(i.shape,u.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);n.push([a,u])}Bm(n)})}addWeight(t,e,n,o,s,i,a,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():de("zeros"));let l=o.apply(e,n),c=new Yh(l,n,t,i,a);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=ve(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,n,o,s,i,a=null){let u=ve(t);e=ve(e),n=ve(n),o=ve(o),s=Lm(s),i=Lm(i);let l=[],c=[],p=[];for(let m of u)l.push(m.sourceLayer),c.push(m.nodeIndex),p.push(m.tensorIndex);new cl({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function EX(r){r=ve(r);let t=[];for(let e of r)t.push(e.shape);return Er(t)}function AX(r){return"float32"}function MS(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],u=n.nodeIndices[s],l=MS(i,a,u);for(let c of l)o.indexOf(c)===-1&&o.push(c)}return o}}}var li=class extends Vt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:uu("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];let o=new Qr(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new cl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};li.className="InputLayer";et.registerClass(li);function Cy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new li({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function $X(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return Z(t,r.dtype)}catch(e){throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Ao=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Ao)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=$X(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Qr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Qr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&_t(this.id2Mask)}},Iy=new qh,Sy=new qh;function F$(r){Iy!=null&&Iy.setMaxEntries(r),Sy!=null&&Sy.setMaxEntries(r)}function Fc(r,t,e,n){let o=e==null?!1:e.training,s=Array.isArray(r),i=s?r:[r],a=i.map(d=>d.name),u=[],l=t.names();for(let d of a)l.indexOf(d)!==-1?u.push(t.getValue(d)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().sort().join(","),p=Iy.get(c),m;if(p==null){let d=DX(i,t);p=d.sorted,m=d.recipientCounts,Iy.put(c,p),Sy.put(c,m)}m={},o||Object.assign(m,Sy.get(c));let f=new Ao(t);for(let d=0;d<p.length;++d){if(n!=null){let F=lh().numTensors;F>n.maxNumTensors&&(n.maxNumTensors=F),F<n.minNumTensors&&(n.minNumTensors=F)}let h=p[d],g=h.sourceLayer;if(g instanceof li)continue;let y=[],b=[],w=[],v=!1;for(let F of h.inputs){let P=f.getValue(F),W=f.getMask(F);y.push(P),b.push(W),W!=null&&(v=!0),o||(m[F.name]--,m[F.name]===0&&!t.hasKey(F)&&a.indexOf(F.name)===-1&&!P.isDisposed&&F.sourceLayer.stateful!==!0&&w.push(P))}v&&(e=e||{},e.mask=b[0]);let k=ve(g.apply(y,e)),E=null;g.supportsMasking&&(E=g.computeMask(y,b));let $=RX(h),D=Array.isArray($)?$:[$];for(let F=0;F<D.length;++F){f.hasKey(D[F])||f.add(D[F],k[F],Array.isArray(E)?E[0]:E);let P=a.indexOf(D[F].name);P!==-1&&(u[P]=k[F])}o||_t(w)}return f.disposeMasks(),s?u:u[0]}function DX(r,t){x.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let o=D$(r[0],t);e=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:i,recipientMap:a}=D$(s,t);for(let u of i)o.has(u.name)||(e.push(u),o.add(u.name));for(let u in a)n[u]==null&&(n[u]=new Set),a[u].forEach(l=>n[u].add(l))}}return{sorted:e,recipientCounts:FX(n)}}function FX(r){let t={};for(let e in r)t[e]=r[e].size;return t}function D$(r,t){let e=new Set,n=[],o={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(a.inputs.length===0||u)s.pop(),n.push(a),e.add(a.name),u&&i.pop();else{i.push(s.length-1);for(let l of a.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(a.name),!e.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function RX(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var OX=V();OX.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,F$);var M$={};Yt(M$,{maxNorm:()=>MX,minMaxNorm:()=>zX,nonNeg:()=>LX,unitNorm:()=>PX});function PS(r,t){return B(()=>ye(mt(M(r,r),t,!0)))}var Rc=class extends et.Serializable{getConfig(){return{}}},Vm=class extends Rc{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{let e=PS(t,this.axis),n=br(e,0,this.maxValue);return M(t,ct(n,J(cr(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Vm.className="MaxNorm";et.registerClass(Vm);var Gm=class extends Rc{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>ct(t,J(cr(),PS(t,this.axis))))}getConfig(){return{axis:this.axis}}};Gm.className="UnitNorm";et.registerClass(Gm);var Wm=class extends Rc{apply(t){return _r(t)}};Wm.className="NonNeg";et.registerClass(Wm);var Um=class extends Rc{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{let e=PS(t,this.axis),n=J(M(this.rate,br(e,this.minValue,this.maxValue)),M(1-this.rate,e));return M(t,ct(n,J(cr(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Um.className="MinMaxNorm";et.registerClass(Um);var R$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function We(r){return Tm(r)}function O$(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"constraint")}function Ue(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in R$?R$[r]:r,config:{}};return O$(e)}else return r instanceof Rc?r:O$(r)}function MX(r){return new Vm(r)}function PX(r){return new Gm(r)}function LX(){return new Wm}function zX(r){return new Um(r)}var P$={};Yt(P$,{constant:()=>GX,glorotNormal:()=>XX,glorotUniform:()=>jX,heNormal:()=>YX,heUniform:()=>ZX,identity:()=>qX,leCunNormal:()=>JX,leCunUniform:()=>QX,ones:()=>VX,orthogonal:()=>t8,randomNormal:()=>UX,randomUniform:()=>WX,truncatedNormal:()=>HX,varianceScaling:()=>KX,zeros:()=>BX});function BX(){return new $m}function VX(){return new pu}function GX(r){return new Dm(r)}function WX(r){return new Fm(r)}function UX(r){return new Rm(r)}function HX(r){return new Om(r)}function qX(r){return new Mm(r)}function KX(r){return new Ur(r)}function jX(r){return new Tc(r)}function XX(r){return new _c(r)}function YX(r){return new Ec(r)}function ZX(r){return new Ac(r)}function JX(r){return new $c(r)}function QX(r){return new Dc(r)}function t8(r){return new Pm(r)}var hD={};Yt(hD,{Layer:()=>Vt,RNN:()=>$n,RNNCell:()=>dl,activation:()=>hY,add:()=>SY,alphaDropout:()=>a7,average:()=>kY,averagePooling1d:()=>ZS,averagePooling2d:()=>JS,averagePooling3d:()=>QS,avgPool1d:()=>RY,avgPool2d:()=>MY,avgPool3d:()=>LY,avgPooling1d:()=>OY,avgPooling2d:()=>PY,avgPooling3d:()=>zY,batchNormalization:()=>$Y,bidirectional:()=>QY,concatenate:()=>NY,conv1d:()=>iY,conv2d:()=>aY,conv2dTranspose:()=>lY,conv3d:()=>uY,conv3dTranspose:()=>cY,convLstm2d:()=>XY,convLstm2dCell:()=>YY,cropping2D:()=>mY,dense:()=>gY,depthwiseConv2d:()=>dY,dot:()=>AY,dropout:()=>xY,elu:()=>tY,embedding:()=>IY,flatten:()=>bY,gaussianDropout:()=>i7,gaussianNoise:()=>s7,globalAveragePooling1d:()=>BY,globalAveragePooling2d:()=>VY,globalMaxPool1d:()=>e7,globalMaxPool2d:()=>r7,globalMaxPooling1d:()=>pD,globalMaxPooling2d:()=>mD,gru:()=>WY,gruCell:()=>UY,input:()=>HS,inputLayer:()=>Q8,layerNormalization:()=>DY,leakyReLU:()=>rY,lstm:()=>HY,lstmCell:()=>qY,masking:()=>l7,maxPool1d:()=>n7,maxPool2d:()=>o7,maxPooling1d:()=>fD,maxPooling2d:()=>dD,maxPooling3d:()=>GY,maximum:()=>TY,minimum:()=>_Y,multiply:()=>EY,permute:()=>CY,prelu:()=>nY,reLU:()=>eY,repeatVector:()=>wY,reshape:()=>vY,rnn:()=>ZY,separableConv2d:()=>pY,simpleRNN:()=>KY,simpleRNNCell:()=>jY,softmax:()=>oY,spatialDropout1d:()=>yY,stackedRNNCells:()=>JY,thresholdedReLU:()=>sY,timeDistributed:()=>t7,upSampling2d:()=>fY,zeroPadding2d:()=>FY});async function ji(r){if(r==null)return;let t=[],e=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(o),n.push(i)}}if(t.length>0){let o=await Promise.all(t);for(let s=0;s<o.length;++s)r[e[s]]=o[s][0];_t(n)}}function ky(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var L$;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(L$||(L$={}));var e8=125,pl=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},Ny=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},LS=class extends pl{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=B(()=>J(this.totals[o],M(s,n)));this.totals[o]=a,i!=null&&i.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:B(()=>{let o=M(ct(1,this.seen),this.totals[n]);e[n]=o,this.totals[n].dispose(),Pe(e[n])}))}},Ty=class extends pl{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){let t=[],e=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let u=i[a];t.push(u.data()),e.push(s),n.push(a)}}let o=await Promise.all(t);for(let s=0;s<o.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=o[s][0]}},_y=class extends pl{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Hh,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=e8),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");x.isNumber(this.yieldEvery)&&(this.maybeWait=c$(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){let o=[];this.yield!=null&&(await ji(n),o.push(this.yield(t,e,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await ji(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let n=[];this.epochEnd!=null&&(await ji(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await ji(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let n=[];this.batchEnd!=null&&(await ji(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):x.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await ji(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await ji(t),await this.trainEnd(t))}};function Ey(r,t){return r==null&&(r={}),r instanceof pl?[r]:Array.isArray(r)&&r[0]instanceof pl?r:ve(r).map(n=>new _y(n,t))}var wn=class{constructor(){}static registerCallbackConstructor(t,e){x.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),wn.checkForDuplicate(e),wn.constructors[t]==null&&(wn.constructors[t]=[]),wn.constructors[t].push(e)}static checkForDuplicate(t){for(let e in wn.constructors)wn.constructors[+e].forEach(o=>{if(o===t)throw new z("Duplicate callback constructor.")})}static clear(){wn.constructors={}}static createCallbacks(t){let e=[];for(let n in wn.constructors){let o=+n;t>=o&&e.push(...wn.constructors[o])}return e.map(n=>new n)}};wn.constructors={};function Ay(r,t,e,n,o,s,i,a,u){let l=new Ty,c=[new LS,...wn.createCallbacks(t)];r!=null&&c.push(...r),c.push(l);let p=new Ny(c);return p.setParams({epochs:e,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:u}),{callbackList:p,history:l}}function vn(r,t={},e=!1){return qi(r,et.SerializationMap.getMap().classNameMap,t,"layer",e)}function Jh(r,t){return B(()=>{r.dtype!=="float32"&&(r=Z(r,"float32"));let e=mt(Nc(r),t,!0),n=Qs(e.shape,cr()),o=ye(fn(e,n));return ct(r,o)})}function Xi(r,t){return B(()=>be(Nc(lt(t,r)),-1))}function Hm(r,t){return B(()=>be(Te(lt(t,r)),-1))}function mu(r,t){return B(()=>{let e=lt(r,t),n=br(Te(r),cr(),Number.MAX_VALUE),o=Te(ct(e,n));return M(100,be(o,-1))})}function r8(r,t){return B(()=>{let e=br(t,cr(),Number.MAX_VALUE),n=wr(J(1,e)),o=br(r,cr(),Number.MAX_VALUE),s=wr(J(1,o));return be(Nc(lt(n,s)),-1)})}function n8(r,t){return B(()=>{let e=fn(0,lt(1,M(r,t)));return be(Nc(e),-1)})}function o8(r,t){return B(()=>{let e=fn(0,lt(1,M(r,t)));return be(e,-1)})}function s8(r,t){return B(()=>{let e=mt(M(r,t),-1),n=Fr(M(lt(1,r),t),-1);return fn(0,J(1,lt(n,e)))})}function i8(r,t){return B(()=>{let e=Math.log(2),n=lt(t,r),o=lt(J(n,wo(M(-2,n))),e);return be(o,-1)})}function Oc(r,t,e=!1){return B(()=>{if(e)t=ol(t);else{let n=mt(t,t.shape.length-1,!0);t=ct(t,n)}return t=br(t,cr(),1-cr()),Zt(mt(M(Z(r,"float32"),wr(t)),t.shape.length-1))})}function qm(r,t,e=!1){return B(()=>{let n=Z(ti(v$(r)),"int32");t=br(t,cr(),1-cr());let o=t.shape,s=R(js(n,o[o.length-1]),o);return Oc(s,t,e)})}function a8(r,t){if(!x.arraysEqual(r.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let e=_r(t),n=Zt(Te(t));return J(lt(e,M(t,r)),Ja(Ye(n)))})}function Km(r,t){return B(()=>{let e;return e=br(t,cr(),1-cr()),e=wr(ct(e,lt(1,e))),be(a8(r,e),-1)})}function l8(r,t){return B(()=>{let e=br(r,cr(),1),n=br(t,cr(),1);return mt(M(r,wr(ct(e,n))),-1)})}function u8(r,t){return B(()=>{let e=wr(J(cr(),t));return be(lt(t,M(r,e)),-1)})}function tg(r,t){return B(()=>{let e=Jh(r,-1),n=Jh(t,-1),o=M(e,n);return Zt(mt(o,-1))})}var Qh={meanSquaredError:Xi,meanAbsoluteError:Hm,meanAbsolutePercentageError:mu,meanSquaredLogarithmicError:r8,squaredHinge:n8,hinge:o8,categoricalHinge:s8,logcosh:i8,categoricalCrossentropy:Oc,sparseCategoricalCrossentropy:qm,binaryCrossentropy:Km,kullbackLeiblerDivergence:l8,poisson:u8,cosineProximity:tg};function $y(r){if(typeof r=="string"){if(r in Qh)return Qh[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}else return r}function eg(r,t){return B(()=>{let e=M(.5,dr(t)),n=kc(Ge(t,e),r.dtype);return be(kr(r,n),-1)})}function rg(r,t){return B(()=>kc(kr(Xs(r,-1),Xs(t,-1)),"float32"))}function B$(r,t){return B(()=>Z(mt(Tr(kr(r,1),kr(t,1))),"float32"))}function c8(r,t){return B(()=>Z(mt(Tr(kr(r,1),kr(t,0))),"float32"))}function p8(r,t){return B(()=>Z(mt(Tr(kr(r,0),kr(t,1))),"float32"))}function zS(r,t){return B(()=>{let e=B$(r,t),n=p8(r,t),o=J(e,n);return Z(Ee(Ge(o,0),ct(e,o),0),"float32")})}function V$(r,t){return B(()=>{let e=B$(r,t),n=c8(r,t),o=J(e,n);return Z(Ee(Ge(o,0),ct(e,o),0),"float32")})}function Fy(r,t){return Km(r,t)}function Ry(r,t){return r.rank===t.rank&&(r=zr(r,[r.rank-1])),t=Xs(t,-1),t.dtype!==r.dtype&&(t=Z(t,r.dtype)),Z(kr(r,t),"float32")}var m8=Xi,f8=Xi,d8=Hm,h8=Hm,g8=mu,x8=mu,ng=Oc,y8=tg,BS=qm,Dy={binaryAccuracy:eg,categoricalAccuracy:rg,precision:zS,categoricalCrossentropy:ng,sparseCategoricalCrossentropy:BS,mse:m8,MSE:f8,mae:d8,MAE:h8,mape:g8,MAPE:x8,cosine:y8};function G$(r){if(typeof r=="string"&&r in Dy)return Dy[r];if(typeof r!="string"&&r!=null)return r;throw new z(`Unknown metric ${r}`)}function og(r){if(Qn(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Qh))if(Qh[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(Dy))if(Dy[e]===r){t=e;break}return t!==void 0?t:r.name}}function U$(r){let t={Adagrad:()=>Ic.adagrad(.01),Adadelta:()=>Ic.adadelta(1,.95,cr()),Adam:()=>Ic.adam(.001,.9,.999,cr()),Adamax:()=>Ic.adamax(.002,.9,.999,cr(),0),RMSProp:()=>Ic.rmsprop(.001,.9,0,cr()),SGD:()=>Ic.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new z(`Unknown Optimizer ${r}`)}function GS(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!VS(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function VS(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!VS(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!VS(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function H$(r,t,e,n=console.log){let o=v8(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in r.nodesByDepth)i.push(...r.nodesByDepth[c])}n("_".repeat(t)),Oy(s,e,n),n("=".repeat(t));let a=r.layers;for(let c=0;c<a.length;++c)o?C8(a[c],e,n):I8(a[c],e,i,n),n((c===a.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=w8(r),l=zm(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(t))}function w8(r){let t;return r.collectedTrainableWeights!=null?t=zm(r.collectedTrainableWeights):t=zm(r.trainableWeights),t}function v8(r){let t=!0,e=[],n=[];for(let o in r.nodesByDepth)e.push(r.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of r.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Oy(r,t,e=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);e(n)}function C8(r,t,e){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch(u){o="multiple"}try{n=JSON.stringify(r.outputShape)}catch(u){n="multiple"}let s=r.name,i=r.getClassName(),a=[`${s} (${i})`,o,n,r.countParams().toString()];Oy(a,t,e)}function I8(r,t,e,n){let o,s;try{s=r.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{o=JSON.stringify(r.outputShape)}catch(p){o="multiple"}let i=[];for(let p of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){let f=p.inboundLayers[m].name,d=p.nodeIndices[m],h=p.tensorIndices[m];i.push(`${f}[${d}][${h}]`)}let a=r.name,u=r.getClassName(),l=i.length===0?"":i[0],c=[`${a} (${u})`,s,o,r.countParams().toString(),l];Oy(c,t,n);for(let p=1;p<i.length;++p)Oy(["","","","",i[p]],t,n)}function q$(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function Mc(r,t){if(r===null)return null;if(typeof r=="string")return al(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];q$(t,o,s)?e.push(s):e.push(Mc(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")e[n]=o;else{let s=al(n);e[s]=Mc(o,s)}}return e}}function My(r,t){if(r==null)return null;if(typeof r=="string")return No(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];q$(t,o,s)?e.push(s):e.push(My(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n],s=No(n);(n==="name"||n==="className")&&typeof o=="string"?e[s]=o:e[s]=My(o,n)}return e}}var jm="3.17.0";var Bn=class extends Vt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=uu(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],To(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);To(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let w=b.sourceLayer,v=b.nodeIndex,k=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(k)}for(let b of this.inputs){let w=b.sourceLayer,v=b.nodeIndex,k=b.tensorIndex;Qn(v===0,"input layer has >1 nodes"),Qn(k===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(k)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let w=this.inputLayers[b];if(!(w instanceof li))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let e={},n={},o={},s={},i={},a=[],u=(b,w,v,k,E,$)=>{(k==null||E==null||$==null)&&(k=b.sourceLayer,E=b.nodeIndex,$=b.tensorIndex);let D=k.inboundNodes[E];if(v.indexOf(D)!==-1)throw new Wr(`The tensor ${b.name} at layer "${k.name}" is part of a cycle.`);if(w.indexOf(D)!==-1)return;this.containerNodes.add(Bn.nodeKey(k,E)),k.id in i||(i[k.id]=Object.keys(i).length),v.indexOf(D)===-1&&v.push(D);let F=D.inboundLayers.length;for(let P=0;P<F;P++){let W=D.inputTensors[P],U=D.inboundLayers[P],q=D.nodeIndices[P],K=D.tensorIndices[P];u(W,w,v,U,q,K)}for(w.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},l=[],c=[];for(let b of this.outputs)u(b,l,c);let p=a.slice().reverse();for(let b of p){n[b.id]=b,b.id in e||(e[b.id]=0);let w=e[b.id],v=o[b.outboundLayer.id]==null?0:o[b.outboundLayer.id];w=Math.max(w,v),o[b.outboundLayer.id]=w,s[b.outboundLayer.id]=b.outboundLayer,e[b.id]=w;for(let k=0;k<b.inboundLayers.length;k++){let E=b.inboundLayers[k],$=b.nodeIndices[k],D=E.inboundNodes[$],F=e[D.id]==null?0:e[D.id];e[D.id]=Math.max(w+1,F),n[D.id]=D}}let m={};for(let b in e){let w=e[b];w in m||(m[w]=[]),m[w].push(n[b])}let f={};for(let b in o){let w=o[b];w in f||(f[w]=[]),f[w].push(s[b])}let d=Object.keys(f).map(b=>parseInt(b,10)).sort(Kh);this.layers=[];for(let b of d){let w=f[b];w.sort((v,k)=>{let E=i[v.id],$=i[k.id];return E<$?-1:E>$?1:0});for(let v of w)v instanceof Bn&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,d=Object.keys(m).map(b=>parseInt(b,10)).sort(Kh);let h=this.inputs.slice(),g=[];for(let b of d)for(let w of m[b]){let v=w.outboundLayer;if(v!=null){for(let k of w.inputTensors)if(h.indexOf(k)===-1)throw new Wr(`Graph disconnected: cannot obtain value for tensor ${k} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(let k of w.outputTensors)h.push(k);g.push(v.name)}}this.nodesByDepth=m;let y=this.layers.map(b=>b.name);for(let b of y){let w=y.filter(v=>v===b).length;if(w!==1)throw new Wr(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new cl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let n={},o=0;for(let i of this.layers)for(let a of i.weights){if(n[a.originalName]!=null)throw new z(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,o++}let s=[];for(let i in t){let a=i;if(n[i]==null){let u=i.split("/");a=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],t[i]]);else if(e)throw new z(`Provided weight data has no target variable: ${i}`);delete n[a]}if(e){let i=[];for(let a in n)i.push(a);if(i.length>0)throw new z(`${i.length} of ${o} weights are not set: ${i}`)}Bm(s)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${jm}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let n=My(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return B(()=>{t=ve(t);let n=new Ao;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],t[o]);return Fc(this.outputs,n,e)})}computeMask(t,e){return B(()=>{t=ve(t);let n;return e==null?n=ko(null,t.length):n=ve(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let e=Lm(t);if(e.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<e.length;a++){let u=this.inputLayers[a],l=e[a],c=u.name+"_0_0";n[c]=l}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Kh);if(o.length>1)for(let a of o){let u=this.nodesByDepth[a];for(let l of u){let c=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(c.id)!==-1)continue;let p=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],y=l.nodeIndices[h],b=l.tensorIndices[h],w=`${g.name}_${y}_${b}`,v=n[w];p.push(v)}let m=c.computeOutputShape(Er(p)),f=Lm(m),d=c.inboundNodes.indexOf(l);for(let h=0;h<f.length;h++){let g=`${c.name}_${d}_${h}`;n[g]=f[h]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${u.name}_${l}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let u=i[a];Qn(u in n),s.push(n[u])}return Er(s)}runInternalGraph(t,e){e==null&&(e=ko(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],c=t[u],p=e[u];n[l.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Kh);for(let u of o){let l=this.nodesByDepth[u];for(let c of l){let p=c.outboundLayer,m=c.inputTensors,f=c.outputTensors,d=new Array;for(let h of m)h.id in n&&d.push(n[h.id]);if(d.length===m.length){let h={},g,y,b,w;if(c.callArgs!=null&&(h=c.callArgs),d.length===1){let[v,k]=d[0];h.mask==null&&(h.mask=k),b=ve(p.call(v,h)),w=ve(p.computeMask(v,k)),g=[v],y=[k]}else g=d.map(v=>v[0]),y=d.map(v=>v[1]),h.mask==null&&(h.mask=y),b=ve(p.call(g,h)),w=ve(p.computeMask(g,y));if(p.activityRegularizer)throw new Nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v){let k=f[v],E=b[v],$=w[v];n[k.id]=[E,$]}}}}let s=[],i=[],a=[];for(let u of this.outputs){Qn(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,c]=n[u.id];a.push(l.shape),s.push(l),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},n;for(let o of this.layers){n=o instanceof Bn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=Bn.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new z("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===t)return n;throw new z(`No such layer: ${t}`)}calculateLosses(){return B(()=>{let t=[];for(let e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){let o=Bn.nodeKey(e,n);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),u=i.getConfig(),l=[];for(let p=0;p<i.inboundNodes.length;p++){let m=i.inboundNodes[p],f=Bn.nodeKey(i,p),d={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),d=m.callArgs}catch(h){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let y=m.inboundLayers[g],b=m.nodeIndices[g],w=m.tensorIndices[g],v=Bn.nodeKey(y,b),k=e[v];k==null&&(k=0),h.push([y.name,k,w,d])}l.push(h)}}}let c={};c.name=i.name,c.className=a,c.config=u,c.inboundNodes=l,n.push(c)}t.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=Bn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=Bn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,n={},o=!1){let s={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function u(g,y){let b=[],w;for(let v of y){let k=v[0],E=v[1],$=v[2];if(w=v[3]==null?{}:v[3],!(k in s)){a(g,y);return}let D=s[k];if(D.inboundNodes.length<=E){a(g,y);return}let F=D.inboundNodes[E];b.push(F.outputTensors[$])}b.length>0&&g.apply(Er(b),w)}function l(g){let y=g.name,b=vn(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(o),s[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}let c=e.name,p=e.layers;for(let g of p)l(g);for(;!l$(i);)for(let g of p){let y=s[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let w of b)u(y,w)}}let m=[],f=[],d=e.inputLayers;for(let g of d){let y=g[0],b=g[1],w=g[2];Qn(y in s);let k=s[y].inboundNodes[b].outputTensors;m.push(k[w])}let h=e.outputLayers;for(let g of h){let y=g[0],b=g[1],w=g[2];Qn(y in s);let k=s[y].inboundNodes[b].outputTensors;f.push(k[w])}return new t({inputs:m,outputs:f,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function S8(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return t.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function Py(r,t){return S8(r,t,"classWeight")}async function Ly(r,t,e,n){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=B(()=>{if(r.shape.length===1)return kn(r);if(r.shape.length===2){if(r.shape[1]>1)return Xs(r,1);if(r.shape[1]===1)return R(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());_t(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Fe(i,"float32")}else return null}function K$(r,t){return M(r,t)}var k8=32;function Y$(r,t){let e,n,o=t;e=o.xs,n=o.ys,x.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=j$("input",r.inputNames,e),i=j$("output",r.outputNames,n),a=s[0].shape[0];x.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),x.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)x.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let u=0;u<i.length;u++)x.assert(i[u].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function j$(r,t,e){if(e instanceof Lt)return[e];if(Array.isArray(e))return x.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let o of t){if(e[o]==null)throw new z(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(e[o])}return n}}function N8(r){if(r.length===3)throw new Nt("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function Z$(r,t,e){let n=e.batchesPerEpoch!=null;if(x.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),x.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),x.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),x.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),x.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(X$(e.validationData))x.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=N8(e.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let c=Ey(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:f}=Ay(c,p,e.epochs,null,null,T8(t,e),null,o,l);m.setModel(r),r.history=f,await m.onTrainBegin(),r.stopTraining_=!1;let d=e.initialEpoch==null?0:e.initialEpoch,h=await t.iterator();for(;d<e.epochs;){let g={};await m.onEpochBegin(d);let y=0,b=0;for(n||(h=await t.iterator());!n||y<e.batchesPerEpoch;){let w=await h.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:v,ys:k}=Y$(r,w.value),E={};E.batch=b,E.size=v[0].shape[0],await m.onBatchBegin(b,E);let $=[];if(e.classWeight!=null){let P=Py(e.classWeight,r.outputNames);for(let W=0;W<P.length;++W)$.push(await Ly(k[W],null,P[W]))}let D=v.concat(k).concat($),F=a(D);_t(D);for(let P=0;P<u.length;++P){let W=u[P],U=F[P];E[W]=U,Pe(U)}await m.onBatchEnd(b,E),ky(E),b++,y++}if(n?y>=e.batchesPerEpoch:w.done){if(o){let v;X$(e.validationData)?v=ve(await r.evaluateDataset(e.validationData,{batches:e.validationBatches})):v=ve(r.evaluate(s,i,{batchSize:e.validationBatchSize==null?k8:e.validationBatchSize,verbose:0}));for(let k=0;k<r.metricsNames.length;++k)g[`val_${r.metricsNames[k]}`]=v[k]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(d,g),d++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function T8(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function X$(r){return typeof r.iterator=="function"}function _8(r){return typeof r.next=="function"}async function J$(r,t,e){e=e||{};let n=e.batches!=null,o=r.testFunction,s=[];if(e.verbose>0)throw new Nt("Verbose mode is not implemented yet.");x.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=_8(t)?t:await t.iterator(),a=0,u=0;for(;!n||u<e.batches;){let l=await i.next();if(s=B(()=>{if(l.value){let{xs:c,ys:p}=Y$(r,l.value),m=c.concat(p),f=B(()=>o(m));if(_t(m),u===0)for(let h=0;h<f.length;++h)s.push(pt(0));let d=m[0].shape[0];for(let h=0;h<f.length;++h){let g=f[h],y=s[h];s[h]=B(()=>J(s[h],M(d,g))),u>0&&_t(y)}_t(f),a+=d,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let c=s[l];s[l]=ct(s[l],a),_t(c)}return Er(s)}function zy(r){x.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Xm(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>ll(n,t,e-t)):ll(r,t,e-t)}function By(r,t){return B(()=>r==null?null:Array.isArray(r)?r.map(e=>By(e,t)):by(r,t.dtype==="int32"?t:Z(t,"int32")))}function Vy(r,t){let e=[],n=0,o=null;for(;n<r;)o=n+t,o>=r&&(o=r),e.push([n,o]),n=o;return e}async function E8(r,t,e,n,o,s,i,a,u,l,c,p,m,f,d){o==null&&(o=32),s==null&&(s=1),c==null&&(c=!0),m==null&&(m=0);let h=!1;if(u!=null&&l!=null&&(h=!0),d!=null&&(h=!0,f==null))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(e,o,f,"steps_per_epoch"),y;g!=null&&(y=Jr(0,g)),i==null&&(i=1);let{callbackList:b,history:w}=Ay(a,i,s,m,g,f,o,h,p);b.setModel(r),r.history=w,await b.onTrainBegin(),r.stopTraining_=!1;for(let v=m;v<s;++v){await b.onEpochBegin(v);let k={};if(f!=null)throw new Nt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Nt("batch shuffling is not implemneted yet");c&&x.shuffle(y);let E=Fe(y),$=Vy(g,o);for(let D=0;D<$.length;++D){let F={};if(await b.onBatchBegin(D,F),B(()=>{let P=$[D][0],W=$[D][1],U=ll(E,P,W-P);F.batch=D,F.size=W-P;let q=By(e,U),K=t(q);for(let j=0;j<n.length;++j){let Q=n[j],rt=K[j];F[Q]=rt,Pe(rt)}if(D===$.length-1&&h){let j=r.testLoop(u,l,o);for(let Q=0;Q<n.length;++Q){let rt=n[Q],X=j[Q];Pe(X),k["val_"+rt]=X}}}),await b.onBatchEnd(D,F),ky(F),r.stopTraining_)break}E.dispose()}if(await b.onEpochEnd(v,k),r.stopTraining_)break}return await b.onTrainEnd(),await r.history.syncData(),r.history}async function Q$(r,t,e,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,i,a,u,l,c,p,m;try{let f=n.batchSize==null?32:n.batchSize;zy(f);let d=!1,h=await r.standardizeUserData(t,e,n.sampleWeight,n.classWeight,d,f);o=h[0],s=h[1],m=h[2];let g=!1,y;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Nt("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let F=!0,P=await r.standardizeUserData(u,l,null,null,F,f);c=P[0],p=P[1],y=c.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let F=Math.floor(o[0].shape[0]*(1-n.validationSplit)),P=o[0].shape[0];c=Xm(o,F,P),i=o,o=Xm(o,0,F),p=Xm(s,F,P),a=s,s=Xm(s,0,F),y=c.concat(p)}else n.validationSteps!=null&&(g=!0);let b=o.concat(s).concat(m);r.checkTrainableWeightsConsistency();let w=r.makeTrainFunction(),v=r.getDedupedMetricsNames(),k,E;g?(r.makeTestFunction(),k=r.testFunction,E=v.slice().concat(v.map(F=>"val_"+F))):(k=null,y=[],E=v.slice());let $=Ey(n.callbacks,n.yieldEvery);return await E8(r,w,b,v,f,n.epochs,n.verbose,$,k,y,n.shuffle,E,n.initialEpoch,null,null)}finally{r.isTraining=!1,$o(o,t),$o(s,e),$o(i,t),$o(a,e),$o(c,u),$o(p,l),m!=null&&_t(m)}}function WS(r){let t=[];r instanceof Lt&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(ul(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function $o(r,t){if(r==null)return;let e=[];if(t instanceof Lt)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let n=[];if(r instanceof Lt)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{e.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];e.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function A8(r){return r instanceof Lt}function US(r){return Array.isArray(r)}function tD(r){return!A8(r)&&!US(r)}function eD(r,t,e,n=!0,o=""){if(t==null||t.length===0){if(r!=null){let i=!1;if(US(r)&&r.length>0)i=!0;else if(tD(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(i=>null);let s;if(tD(r)){r=r,s=[];for(let i of t){if(r[i]==null)throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(r[i])}}else if(US(r)){if(r=r,r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new z(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=WS(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c>=0&&l!==c)throw new z(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function $8(r,t,e){let n=To(r.map(s=>s.shape[0]));n.sort();let o=To(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!x.arraysEqual(n,o))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function D8(r,t,e){let n=[Xi,Km,Oc];for(let o=0;o<r.length;++o){let s=r[o],i=t[o],a=e[o];if(i!=null){if(i===Oc&&s.shape[s.shape.length-1]===1)throw new z(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){let p=u[c],m=l[c];if(m!=null&&p!==m)throw new z(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function rD(r,t,e,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new z(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c!==l)throw new z(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function F8(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var R8="layers-model",Vn=class extends Bn{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");H$(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=U$(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Vr))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new z(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),e.push($y(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>$y(a))}else{let i=$y(t.loss);this.outputs.forEach(a=>{e.push(i)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ii("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let o=F8(t.metrics,this.outputNames),s=(i,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,i])};ii("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=o[i];(l=>{let c="",p,m,f;for(let d of l){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===Km?["accuracy","acc"].indexOf(d)!==-1?m=eg:["crossentropy","ce"].indexOf(d)!==-1&&(m=Fy):this.lossFunctions[i]===qm?["accuracy","acc"].indexOf(d)!==-1?m=Ry:["crossentropy","ce"].indexOf(d)!==-1&&(m=BS):["accuracy","acc"].indexOf(d)!==-1?m=rg:["crossentropy","ce"].indexOf(d)!==-1&&(m=ng);let y;["accuracy","acc"].indexOf(d)!==-1?y="acc":["crossentropy","ce"].indexOf(d)!==-1&&(y="ce"),f=m,p=c+y}else f=G$(d),p=c+og(d);let h;ii(p,()=>{h=f}),s(i,p,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){let o=n.batchSize==null?32:n.batchSize;zy(o);let s=!0,i=this.standardizeUserDataXY(t,e,s,o);try{let a=i[0].concat(i[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,a,o,n.verbose,n.steps);return Er(l)}finally{$o(i[0],t),$o(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),J$(this,t,e)}checkNumSamples(t,e,n,o="steps"){let s;if(n!=null){if(s=null,e!=null)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new z("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(e),o=n?e:[e],s=this.retrieveSymbolicTensors(o),i=new Ao;if(t instanceof Lt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new z(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],t[u])}else for(let u of this.inputs){let l=t[u.name];if(l==null)throw new z(`No value is provided for the model's input ${u.name}`);i.add(u,l)}let a=Fc(s,i);return n?a:a[0]}retrieveSymbolicTensors(t){let e=ko(null,t.length),n=t.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],i=s.map(a=>a.name);for(let a=0;a<t.length;++a){let u=i.indexOf(t[a]);if(u!==-1&&(e[a]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw e.forEach((s,i)=>{s==null&&o.push(t[i])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return e}predictLoop(t,e=32,n=!1){return B(()=>{let o=this.checkNumSamples(t);if(n)throw new Nt("Verbose predictLoop() is not implemented yet.");let s=Vy(o,e),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)B(()=>{let l=s[a][0],c=s[a][1],p=Xm(t,l,c),m=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)m.push({key:this.inputs[d],value:p[d]});else m.push({key:this.inputs[0],value:p});let f=new Ao(m);return Fc(this.outputs,f)}).forEach((l,c)=>i[c].push(l));return Er(i.map(a=>se(a,0)))})}predict(t,e={}){let n=WS(t);rD(n,this.inputNames,this.feedInputShapes,!1);try{let o=e.batchSize==null?32:e.batchSize;return zy(o),this.predictLoop(n,o)}finally{$o(n,t)}}predictOnBatch(t){rD(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,o){if(this.optimizer_==null)throw new Wr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===qm?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(t=eD(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=eD(e,this.feedOutputNames,s,!1,"target"),$8(t,e,null),D8(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&t[0].shape[0]%o!==0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,o,s=!0,i){let[a,u]=this.standardizeUserDataXY(t,e,s,i);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let c=Py(o,this.outputNames);l=[];for(let p=0;p<c.length;++p)l.push(await Ly(u[p],null,c[p]))}return[a,u,l]}testLoop(t,e,n,o=0,s){return B(()=>{let i=this.checkNumSamples(e,n,s,"steps"),a=[];if(o>0)throw new Nt("Verbose mode is not implemented yet.");if(s!=null)throw new Nt("steps mode in testLoop() is not implemented yet");{let u=Vy(i,n),l=Fe(Jr(0,i));for(let c=0;c<u.length;++c){let p=u[c][0],m=u[c][1],f=ll(l,p,m-p),d=By(e,f),h=t(d);if(c===0)for(let g=0;g<h.length;++g)a.push(pt(0));for(let g=0;g<h.length;++g){let y=h[g];a[g]=J(a[g],M(m-p,y))}}for(let c=0;c<a.length;++c)a[c]=ct(a[c],i)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){let o=t[n],s=o;AS(t,o)>1&&(s+=`_${AS(t.slice(0,n),o)}`),e.push(s)}return e}makeTrainFunction(){return t=>{let e=[],n=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let p=[];for(let h=0;h<this.inputs.length;++h)p.push({key:this.inputs[h],value:n[h]});let m=new Ao(p),f=Fc(this.outputs,m,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let y=this.lossFunctions[h](o[h],f[h]);s[h]!=null&&(y=K$(y,s[h]));let b=be(y);e.push(b),h===0?d=y:d=J(d,y)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=e[h];else{let y=this.metricsTensors[h][0],b=this.metricsTensors[h][1];g=be(y(o[b],f[b]))}Pe(g),i.push(g)}return d=be(d),this.calculateLosses().forEach(h=>{d=J(d,h)}),d},u=this.collectedTrainableWeights.map(p=>p.read()),l=!0;return[this.optimizer_.minimize(a,l,u)].concat(i)}}makeTestFunction(){this.testFunction=t=>B(()=>{let e=[],n,o=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:o[l]});let a=new Ao(i),u=Fc(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],p=be(c(s[l],u[l]));l===0?n=p:n=J(n,p),e.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],p=this.metricsTensors[l][1],m=be(c(s[p],u[p]));e.push(m)}return e})}async fit(t,e,n={}){return Q$(this,t,e,n)}async fitDataset(t,e){return Z$(this,t,e)}async trainOnBatch(t,e){let n=await this.standardizeUserData(t,e),o=n[0],s=n[1],a=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of a){let c=await l.data();u.push(c[0])}return _t(a),$o(n[0],t),$o(n[1],e),Er(u)}getNamedWeights(t){let e=[],n=t!=null&&t.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<o.length;++i)n&&!o[i].trainable||e.push({name:o[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=lh().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-lh().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=No(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>No(e))}else{let e=Object.keys(this.loss);t={};let n=this.loss;for(let o of e)if(typeof n[o]=="string")t[o]=No(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[No(og(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>No(og(t)));{let t={};for(let e in this.metrics)t[e]=No(og(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Mc(t.optimizer_config),n=vn(e),o;if(typeof t.loss=="string")o=al(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(i=>al(i));else if(t.loss!=null){o={};for(let i in t.loss)o[i]=al(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>al(i));else if(t.metrics!=null){s={};for(let i in t.metrics)s[i]=al(t.metrics[i])}this.compile({loss:o,metrics:s,optimizer:n})}async save(t,e){if(typeof t=="string"){let l=Pr.getSaveHandlers(t);if(l.length===0)throw new z(`Cannot find any save handlers for URL '${t}'`);if(l.length>1)throw new z(`Found more than one (${l.length}) save handlers for URL '${t}'`);t=l[0]}if(t.save==null)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Pr.encodeWeights(this.getNamedWeights(e)),o=!1,s=null,a={modelTopology:this.toJSON(s,o),format:R8,generatedBy:`TensorFlow.js tfjs-layers v${jm}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:c,specs:p}=await Pr.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...p),n.data=Pr.concatenateArrayBuffers([n.data,c])}return this.userDefinedMetadata!=null&&(GS(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,t.save(a)}setUserDefinedMetadata(t){GS(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};Vn.className="Model";et.registerClass(Vn);var Gy=class extends Vn{};Gy.className="Functional";et.registerClass(Gy);async function nD(r,t){"modelTopology"in r||(r={modelTopology:r}),r=r;let e=r.modelTopology;e.model_config!=null&&(e=e.model_config);let n=Mc(e),o=vn(n,t);if(r.weightsManifest!=null){let s=await Pr.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(a=>a.originalName)),i={};for(let a of o.weights)i[a.originalName]=s[a.originalName];o.loadWeights(i),_t(s)}return o}async function oD(r,t){if(t==null&&(t={}),typeof r=="string"){let e=Pr.getLoadHandlers(r,t);if(e.length===0)e.push(Pr.browserHTTPRequest(r,t));else if(e.length>1)throw new z(`Found more than one (${e.length}) load handlers for URL '${r}'`);r=e[0]}return O8(r,void 0,t)}async function O8(r,t,e){if(e==null&&(e={}),r.load==null)throw new z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=e.strict==null?!0:e.strict,i=n.weightData!=null&&n.weightSpecs!=null&&s,a=vn(Mc(o),t,i),u=n.trainingConfig;if(u!=null&&a.loadTrainingConfig(u),n.userDefinedMetadata!=null&&a.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:c}=M8(n.weightData,n.weightSpecs);a.loadWeights(l,s),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),_t(l),_t(c.map(p=>p.tensor))}return a}function M8(r,t){let e=Pr.decodeWeights(r,t),n={},o=[];return t.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:e[s.name]}):n[s.name]=e[s.name]}),{modelWeights:n,optimizerWeights:o}}var Yi=class extends Vn{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:uu("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new z(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Yi||t instanceof Vn,n;if(e){if(n=t,n.outputs.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=Cy({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=MS(this.outputs[0])}this.inboundNodes=[],new cl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ko(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Qt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Vn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},o=!1){let s,i={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new z("Legacy serialization format not supported yet.");s=e}else x.assert(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,i=e;let a=new t(i);if(!(a instanceof Yi))throw new Nt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let u of s){let c=vn(u,void 0,o);o&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}};Yi.className="Sequential";et.registerClass(Yi);function P8(r){return new Vn(r)}function L8(r){return new Yi(r)}function z8(r,t){return t==null&&(t={}),oD(r,t)}function HS(r){return Cy(r)}function B8(r,t){wn.registerCallbackConstructor(r,t)}var tn=class extends et.Serializable{getConfig(){return{}}},Wy=class extends tn{apply(t,e=1){return I$(t,e)}};Wy.className="elu";et.registerClass(Wy);var Uy=class extends tn{apply(t){return fc(t)}};Uy.className="selu";et.registerClass(Uy);var Hy=class extends tn{apply(t){return _r(t)}};Hy.className="relu";et.registerClass(Hy);var qy=class extends tn{apply(t){return B(()=>ei(6,_r(t)))}};qy.className="relu6";et.registerClass(qy);var Ky=class extends tn{apply(t){return t}};Ky.className="linear";et.registerClass(Ky);var jy=class extends tn{apply(t){return Lr(t)}};jy.className="sigmoid";et.registerClass(jy);var Xy=class extends tn{apply(t){return k$(t)}};Xy.className="hardSigmoid";et.registerClass(Xy);var Yy=class extends tn{apply(t){return wo(t)}};Yy.className="softplus";et.registerClass(Yy);var Zy=class extends tn{apply(t){return S$(t)}};Zy.className="softsign";et.registerClass(Zy);var Jy=class extends tn{apply(t){return Ys(t)}};Jy.className="tanh";et.registerClass(Jy);var Ym=class extends tn{apply(t,e=-1){return ol(t,e)}};Ym.className="softmax";et.registerClass(Ym);var Qy=class extends tn{apply(t,e=-1){return sc(t,e)}};Qy.className="logSoftmax";et.registerClass(Qy);var tb=class extends tn{apply(t,e=1){return B(()=>M(Lr(M(t,e)),t))}};tb.className="swish";et.registerClass(tb);var eb=class extends tn{apply(t){return B(()=>M(t,Ys(wo(t))))}};eb.className="mish";et.registerClass(eb);function ui(r){return r.getClassName()}function qS(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"activation")}function ci(r){if(r==null){let t={};return t.className="linear",t.config={},qS(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},qS(t)}else return r instanceof tn?r:qS(r)}function KS(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var rb=class extends et.Serializable{},fu=class extends rb{constructor(t){super(),KS(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return B(()=>{let e=we([1]);return this.hasL1&&(e=J(e,mt(M(this.l1,Te(t))))),this.hasL2&&(e=J(e,mt(M(this.l2,Nc(t))))),R(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};fu.className="L1L2";et.registerClass(fu);function aD(r){return KS(r),new fu({l1:r!=null?r.l1:null,l2:0})}function lD(r){return KS(r),new fu({l2:r!=null?r.l2:null,l1:0})}var sD={l1l2:"L1L2"};function me(r){return Tm(r)}function iD(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"regularizer")}function Ie(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in sD?sD[r]:r,config:{}};return iD(e)}else return r instanceof rb?r:iD(r)}var Zm=class extends Vt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Pt(t);let n=_r(t);return this.maxValue!=null&&(n=br(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};Zm.className="ReLU";et.registerClass(Zm);var Jm=class extends Vt{constructor(t){super(t==null?{}:t),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Pt(t);return Za(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Jm.className="LeakyReLU";et.registerClass(Jm);var Qm=class extends Vt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=de(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ie(t.alphaRegularizer),this.alphaConstraint=Ue(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Qt(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)e[o-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<t.length;++o)n[o]=t[o];this.inputSpec=[new Ce({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=Pt(t),rl(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Ae(this.alphaInitializer),alphaRegularizer:me(this.alphaRegularizer),alphaConstraint:We(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};Qm.className="PReLU";et.registerClass(Qm);var tf=class extends Vt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Nt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Pt(t);return Js(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};tf.className="ELU";et.registerClass(tf);var ef=class extends Vt{constructor(t){super(t==null?{}:t),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let n=Pt(t);return M(n,Z(Ge(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};ef.className="ThresholdedReLU";et.registerClass(ef);var rf=class extends Vt{constructor(t){super(t==null?{}:t),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Ym().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let n=Pt(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};rf.className="Softmax";et.registerClass(rf);function du(r,t,e){if(typeof r=="number")return ko(r,t);if(r.length!==t)throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let o=r[n];if(!b$(o))throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function An(r,t,e,n,o=1){if(r==null)return r;let s=t+(t-1)*(o-1),i;return e==="same"?i=r:i=r-s+1,Math.floor((i+n-1)/n)}function pi(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+ai([e-t,0]);else if(n==="same")r=r*t;else throw new z(`Unsupport padding mode: ${n}.`);return r}function sg(r,t){return B(()=>(Le(t),t==="channelsFirst"?Mt(r,[0,2,3,1]):r))}function jS(r,t){return B(()=>(Le(t),t==="channelsFirst"?Mt(r,[0,2,3,4,1]):r))}function G8(r,t,e,n=1,o="valid",s,i=1){return B(()=>{if(s==null&&(s=gn()),Le(s),r.shape.length!==3)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(r=Mt(r,[0,2,1])),o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Qu(r,t,n,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=xn(a,e)),a})}function uD(r,t,e,n=[1,1],o="valid",s,i,a=null){return B(()=>{if(s==null&&(s=gn()),Le(s),r.rank!==3&&r.rank!==4)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=sg(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Co.conv2d({x:u,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(u=Mt(u,[0,3,1,2])),u})}function W8(r,t,e,n=[1,1,1],o="valid",s,i){return B(()=>{if(s==null&&(s=gn()),Le(s),r.rank!==4&&r.rank!==5)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=jS(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=wh(a,t,n,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=xn(a,e)),s==="channelsFirst"&&(a=Mt(a,[0,4,1,2,3])),a})}var Pc=class extends Vt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Pc.verifyArgs(e),this.rank=t,tr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=du(e.kernelSize,t,"kernelSize"),this.strides=du(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,hn(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Le(this.dataFormat),this.activation=ci(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=de(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ue(e.biasConstraint),this.biasRegularizer=Ie(e.biasRegularizer),this.activityRegularizer=Ie(e.activityRegularizer),this.dilationRate=du(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Qn("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!py(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ui(this.activation),useBias:this.useBias,biasInitializer:Ae(this.biasInitializer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),biasConstraint:We(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},hu=class extends Pc{constructor(t,e){super(t,e),this.kernel=null,hu.verifyArgs(e),this.filters=e.filters,tr(this.filters,"filters"),this.kernelInitializer=de(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ue(e.kernelConstraint),this.kernelRegularizer=Ie(e.kernelRegularizer)}build(t){t=Qt(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[e]}`);let n=t[e],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return B(()=>{t=Pt(t);let n,o=this.bias==null?null:this.bias.read(),s=my(this.activation.getClassName());if(s!=null&&this.rank===2)n=uD(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=G8(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=uD(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=W8(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Nt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=Qt(t);let e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=An(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let t={filters:this.filters,kernelInitializer:Ae(this.kernelInitializer),kernelRegularizer:me(this.kernelRegularizer),kernelConstraint:We(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},ml=class extends hu{constructor(t){super(2,t),ml.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!py(t.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};ml.className="Conv2D";et.registerClass(ml);var fl=class extends hu{constructor(t){super(3,t),fl.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};fl.className="Conv3D";et.registerClass(fl);var nf=class extends ml{constructor(t){if(super(t),this.inputSpec=[new Ce({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Qt(t),t.length!==4)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ce({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{let n=Pt(t);if(n.shape.length!==4)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let u=o[i],l=o[a],c=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],f=this.strides[1],d=pi(u,m,c,this.padding),h=pi(l,f,p,this.padding),g=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Mt(n,[0,2,3,1]));let y=tc(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Mt(y,[0,3,1,2])),this.bias!=null&&(y=xn(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=Qt(t);let e=t.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[o]=pi(e[o],u,i,this.padding),e[s]=pi(e[s],l,a,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};nf.className="Conv2DTranspose";et.registerClass(nf);var of=class extends fl{constructor(t){if(super(t),this.inputSpec=[new Ce({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Qt(t),t.length!==5)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ce({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{let n=Pt(t);if(n.shape.length!==5)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a,u;this.dataFormat==="channelsFirst"?(u=2,i=3,a=4):(u=1,i=2,a=3);let l=o[u],c=o[i],p=o[a],m=this.kernelSize[0],f=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],g=this.strides[1],y=this.strides[2],b=pi(l,h,m,this.padding),w=pi(c,g,f,this.padding),v=pi(p,y,d,this.padding),k=[s,b,w,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Mt(n,[0,2,3,4,1]));let E=qI(n,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Mt(E,[0,4,1,2,3])),this.bias!==null&&(E=xn(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(t){t=Qt(t);let e=t.slice(),n,o,s,i;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,i=4):(n=4,o=1,s=2,i=3);let a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],p=this.strides[1],m=this.strides[2];return e[n]=this.filters,e[o]=pi(e[o],c,a,this.padding),e[s]=pi(e[s],p,u,this.padding),e[i]=pi(e[i],m,l,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};of.className="Conv3DTranspose";et.registerClass(of);var nb=class extends hu{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=de(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ie(e.depthwiseRegularizer),this.depthwiseConstraint=Ue(e.depthwiseConstraint),this.pointwiseInitializer=de(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ie(e.pointwiseRegularizer),this.pointwiseConstraint=Ue(e.pointwiseConstraint)}build(t){if(t=Qt(t),t.length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let n=t[e],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Ce({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{t=Pt(t);let n;if(this.rank===1)throw new Nt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Mt(t,[0,2,3,1])),n=Oh(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=xn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Mt(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ae(this.depthwiseInitializer),t.pointwiseInitializer=Ae(this.pointwiseInitializer),t.depthwiseRegularizer=me(this.depthwiseRegularizer),t.pointwiseRegularizer=me(this.pointwiseRegularizer),t.depthwiseConstraint=We(this.depthwiseConstraint),t.pointwiseConstraint=We(this.pointwiseConstraint),t}};nb.className="SeparableConv";var sf=class extends nb{constructor(t){super(2,t)}};sf.className="SeparableConv2D";et.registerClass(sf);var gu=class extends hu{constructor(t){super(1,t),gu.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!py(t.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};gu.className="Conv1D";et.registerClass(gu);var af=class extends Vt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return B(()=>{if(t=Pt(t),this.dataFormat==="channelsLast"){let n=Xh(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Xh(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Xh(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Xh(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};af.className="Cropping2D";et.registerClass(af);var lf=class extends Vt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,x$(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{let e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return B(()=>{let n=Pt(t),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Mt(n,[0,2,3,1]);let s=this.size[0]*o[2],i=this.size[1]*o[3],a=this.interpolation==="nearest"?dn.resizeNearestNeighbor(n,[s,i]):dn.resizeBilinear(n,[s,i]);return Mt(a,[0,3,1,2])}else{let s=this.size[0]*o[1],i=this.size[1]*o[2];return this.interpolation==="nearest"?dn.resizeNearestNeighbor(n,[s,i]):dn.resizeBilinear(n,[s,i])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}};lf.className="UpSampling2D";et.registerClass(lf);function U8(r,t,e=[1,1],n="valid",o,s){return B(()=>{o==null&&(o=gn()),Le(o);let i=sg(r,o);if(r.rank!==4)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Zs(i,t,e,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Mt(i,[0,3,1,2])),i})}var uf=class extends Pc{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=de(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ue(t.depthwiseConstraint),this.depthwiseRegularizer=Ie(t.depthwiseRegularizer)}build(t){if(t=Qt(t),t.length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let n=t[e],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{t=Pt(t);let n=U8(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=xn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=Qt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=An(e,this.kernelSize[0],this.padding,this.strides[0]),i=An(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],o,s,i]:[t[0],s,i,o]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ae(this.depthwiseInitializer),t.depthwiseRegularizer=me(this.depthwiseRegularizer),t.depthwiseConstraint=We(this.depthwiseRegularizer),t}};uf.className="DepthwiseConv2D";et.registerClass(uf);function XS(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new z("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:r,initialState:t,constants:e}}function YS(r,t,e,n=!1,o,s,i=!1,a=!1){return B(()=>{let u=t.shape.length;if(u<3)throw new z(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Jr(2,u));if(t=Mt(t,l),s!=null)throw new Nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=Z(Z(o,"bool"),"float32"),o.rank===u-1&&(o=fr(o,-1)),o=Mt(o,l)),n&&(t=ir(t,0),o!=null&&(o=ir(o,0)));let c=[],p,m=e,f=t.shape[0],d=vr(t),h;o!=null&&(h=vr(o));for(let y=0;y<f;++y){let b=d[y],w=B(()=>r(b,m));if(o==null)p=w[0],m=w[1];else{let v=B(()=>{let k=h[y],E=lt(dr(k),k),$=J(M(w[0],k),M(m[0],E)),D=m.map((F,P)=>J(M(w[1][P],k),M(F,E)));return{output:$,newStates:D}});p=v.output,m=v.newStates}a&&c.push(p)}let g;return a&&(g=Ze(c,1)),[p,g,m]})}var $n=class extends Vt{constructor(t){super(t);let e;if(t.cell==null)throw new z("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Bc({cells:t.cell}):e=t.cell,e.stateSize==null)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Ce({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Jr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){vy(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let n=e[0],o;if(this.returnSequences?o=[t[0],t[1],n]:o=[t[0],n],this.returnState){let s=[];for(let i of e)s.push([t[0],i]);return[o].concat(s)}else return o}computeMask(t,e){return B(()=>{Array.isArray(e)&&(e=e[0]);let n=this.returnSequences?e:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Nt("Constants support is not implemented in RNN yet.");vy(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new Ce({shape:[n,null,...o]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!x.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new Ce({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>we([n,o])):this.states_=[we([n,this.cell.stateSize])];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>we([n,o])):this.states_[0]=we([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let o=0;o<this.states_.length;++o){let s=t[o],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,a=[n,i];if(!x.arraysEqual(s.shape,a))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Pe(o.clone()))})}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=XS(t,n,o,this.numConstants);t=s.inputs,n=s.initialState,o=s.constants;let i=[],a=[];if(n!=null){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new Ce({shape:l.shape}));a=a.concat(this.stateSpec)}if(o!=null&&(e.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof Qr){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return B(()=>{let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;t=Pt(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new z(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:o},l=YS((d,h)=>{let g=this.cell.call([d].concat(h),a);return[g[0],g.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=l[0],p=l[1],m=l[2];this.stateful&&this.resetStates(m,o);let f=this.returnSequences?p:c;return this.returnState?[f].concat(m):f})}getInitialState(t){return B(()=>{let e=we(t.shape);return e=mt(e,[1,2]),e=ul(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?yy(e,[1,n]):e):this.cell.stateSize>1?[yy(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===$n.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){let o=e.cell,s=vn(o,n);return new t(Object.assign(e,{cell:s}))}};$n.className="RNN";et.registerClass($n);var dl=class extends Vt{},Lc=class extends dl{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,tr(this.units,"units"),this.activation=ci(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ie(t.kernelRegularizer),this.recurrentRegularizer=Ie(t.recurrentRegularizer),this.biasRegularizer=Ie(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Sc([1,ai([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Sc([1,ai([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Qt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let o=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gl({ones:()=>dr(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gl({ones:()=>dr(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=Eo(M(t,i),this.kernel.read()):s=Eo(t,this.kernel.read()),this.bias!=null&&(s=xn(s,this.bias.read())),a!=null&&(n=M(n,a));let u=J(s,Eo(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:ui(this.activation),useBias:this.useBias,kernelInitializer:Ae(this.kernelInitializer),recurrentInitializer:Ae(this.recurrentInitializer),biasInitializer:Ae(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}};Lc.className="SimpleRNNCell";et.registerClass(Lc);var cf=class extends $n{constructor(t){t.cell=new Lc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return new t(e)}};cf.className="SimpleRNN";et.registerClass(cf);var zc=class extends dl{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=t.units,tr(this.units,"units"),this.activation=ci(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ci(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ie(t.kernelRegularizer),this.recurrentRegularizer=Ie(t.recurrentRegularizer),this.biasRegularizer=Ie(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Sc([1,ai([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Sc([1,ai([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Qt(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training==null?!1:e.training,o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gl({ones:()=>dr(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gl({ones:()=>dr(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,u,l;0<this.dropout&&this.dropout<1&&(t=M(t,s[0]));let c=Eo(t,this.kernel.read());this.useBias&&(c=xn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=M(o,i[0]));let p=this.recurrentKernel.read(),[m,f]=ur(p,[2*this.units,this.units],p.rank-1),d=Eo(o,m),[h,g,y]=ur(c,3,c.rank-1),[b,w]=ur(d,2,d.rank-1);a=this.recurrentActivation.apply(J(h,b)),u=this.recurrentActivation.apply(J(g,w));let v=Eo(M(u,o),f);l=this.activation.apply(J(y,v));let k=J(M(a,o),M(J(1,Zt(a)),l));return[k,k]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:ui(this.activation),recurrentActivation:ui(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ae(this.kernelInitializer),recurrentInitializer:Ae(this.recurrentInitializer),biasInitializer:Ae(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}};zc.className="GRUCell";et.registerClass(zc);var pf=class extends $n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new zc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};pf.className="GRU";et.registerClass(pf);var hl=class extends dl{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,tr(this.units,"units"),this.activation=ci(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ci(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ie(t.kernelRegularizer),this.recurrentRegularizer=Ie(t.recurrentRegularizer),this.biasRegularizer=Ie(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Sc([1,ai([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Sc([1,ai([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Qt(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;o=new(e=class extends bn{apply(u,l){let c=s.apply([i]),p=new pu().apply([i]),m=s.apply([i*2]);return OS(OS(c,p),m)}},e.className="CustomInit",e)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return B(()=>{let n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1],s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gl({ones:()=>dr(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gl({ones:()=>dr(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,u,l,c,p;0<this.dropout&&this.dropout<1&&(t=M(t,i[0]));let m=Eo(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=M(o,a[0])),m=J(m,Eo(o,this.recurrentKernel.read())),this.useBias&&(m=xn(m,this.bias.read()));let[f,d,h,g]=ur(m,4,m.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(d),c=J(M(l,s),M(u,this.activation.apply(h))),p=this.recurrentActivation.apply(g);let y=M(p,this.activation.apply(c));return[y,y,c]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:ui(this.activation),recurrentActivation:ui(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ae(this.kernelInitializer),recurrentInitializer:Ae(this.recurrentInitializer),biasInitializer:Ae(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}};hl.className="LSTMCell";et.registerClass(hl);var mf=class extends $n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new hl(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};mf.className="LSTM";et.registerClass(mf);var Bc=class extends dl{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return B(()=>{t=t;let n=t.slice(1),o=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?o.push(n.splice(0,a.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let u=this.cells[a];n=o[a],a===0?i=[t[0]].concat(n):i=[i[0]].concat(n),i=u.call(i,e),s.push(i.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[i[0]].concat(n)})}build(t){vy(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,o)=>{ii(`RNNCell_${o}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(e)};return Object.assign({},t,o)}static fromConfig(t,e,n={}){let o=[];for(let s of e.cells)o.push(vn(s,n));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return Zh(t)}setWeights(t){let e=[];for(let n of this.cells){let o=n.weights.length,s=t.splice(o);for(let i=0;i<n.weights.length;++i)e.push([n.weights[i],s[i]])}Bm(e)}};Bc.className="StackedRNNCells";et.registerClass(Bc);function gl(r){let{ones:t,rate:e,training:n=!1,count:o=1,dropoutFunc:s}=r,i=()=>s!=null?s(t(),e):wy(t(),e),a=()=>cu(i,t,n);return!o||o<=1?Pe(a().clone()):Array(o).fill(void 0).map(a).map(l=>Pe(l.clone()))}var H8=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e};var ob=class extends $n{constructor(t){if(t.unroll)throw new Nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Nt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new Ce({ndim:5})]}call(t,e){return B(()=>{if(this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new z("ConvRNN2D cell does not support constants");let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return B(()=>{let{stateSize:e}=this.cell,n=t.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],i=we(s);return Array.isArray(e)?Array(e.length).fill(i):[i]})}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>we(s)):this.states_=[we(s)];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>we(s)):this.states_[0]=we(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let a=0;a<this.states_.length;++a){let u=t[a],l=s;if(!x.arraysEqual(u.shape,l))throw new z(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Pe(a.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:n,kernelSize:o,padding:s,strides:i,dilationRate:a}=this.cell,u=e==="channelsFirst",l=t[u?3:2],c=t[u?4:3],p=An(l,o[0],s,i[0],a[0]),m=An(c,o[1],s,i[1],a[1]);return[...t.slice(0,2),...u?[n,p,m]:[p,m,n]]}};ob.className="ConvRNN2D";var Vc=class extends hl{constructor(t){let{filters:e,kernelSize:n,strides:o,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,tr(this.filters,"filters"),this.kernelSize=du(n,2,"kernelSize"),this.kernelSize.forEach(u=>tr(u,"kernelSize")),this.strides=du(o||1,2,"strides"),this.strides.forEach(u=>tr(u,"strides")),this.padding=s||"valid",hn(this.padding),this.dataFormat=i||"channelsLast",Le(this.dataFormat),this.dilationRate=du(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>tr(u,"dilationRate"))}build(t){var e;t=Qt(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[n]}`);let o=t[n],s=4,i=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;u=new(e=class extends bn{apply(m,f){let d=l.apply([c]),h=lr([c]),g=l.apply([c*2]);return Em([d,h,g])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return B(()=>{if(t.length!==3)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training||!1,o=t[0],s=t[1],i=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=gl({ones:()=>dr(o),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(st,it,ft)=>!it||!it[ft]?st:M(it[ft],st),c=l(o,u,0),p=l(o,u,1),m=l(o,u,2),f=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=gl({ones:()=>dr(s),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,h=l(s,d,0),g=l(s,d,1),y=l(s,d,2),b=l(s,d,3),w=3,[v,k,E,$]=ur(this.kernel.read(),a,w),[D,F,P,W]=this.useBias?ur(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,v,D,this.padding),p=this.inputConv(p,k,F,this.padding),m=this.inputConv(m,E,P,this.padding),f=this.inputConv(f,$,W,this.padding);let[U,q,K,j]=ur(this.recurrentKernel.read(),a,w);h=this.recurrentConv(h,U),g=this.recurrentConv(g,q),y=this.recurrentConv(y,K),b=this.recurrentConv(b,j);let Q=this.recurrentActivation.apply(J(c,h)),rt=this.recurrentActivation.apply(J(p,g)),X=J(M(rt,i),M(Q,this.activation.apply(J(m,y)))),nt=M(this.recurrentActivation.apply(J(f,b)),this.activation.apply(X));return[nt,nt,X]})}getConfig(){let t=super.getConfig(),{units:e}=t,n=H8(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,o)}inputConv(t,e,n,o){let s=pn(t,e,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?xn(s,n,this.dataFormat):s}recurrentConv(t,e){return pn(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Vc.className="ConvLSTM2DCell";et.registerClass(Vc);var ff=class extends ob{constructor(t){let e=new Vc(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}};ff.className="ConvLSTM2D";et.registerClass(ff);var Gc=class extends Vt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?e[o]:this.noiseShape[o]);return n}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);if(0<this.rate&&this.rate<1){let o=e.training==null?!1:e.training,s=this.getNoiseShape(n);return cu(()=>wy(n,this.rate,s,this.seed),()=>n,o)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};Gc.className="Dropout";et.registerClass(Gc);var df=class extends Gc{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};df.className="SpatialDropout1D";et.registerClass(df);var hf=class extends Vt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,tr(this.units,"units"),this.activation=ci(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ue(t.kernelConstraint),this.biasConstraint=Ue(t.biasConstraint),this.kernelRegularizer=Ie(t.kernelRegularizer),this.biasRegularizer=Ie(t.biasRegularizer),this.activityRegularizer=Ie(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Qt(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Qt(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=my(this.activation.getClassName()),s;return o!=null?s=Eo(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=Eo(n,this.kernel.read()),this.bias!=null&&(s=xn(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let t={units:this.units,activation:ui(this.activation),useBias:this.useBias,kernelInitializer:Ae(this.kernelInitializer),biasInitializer:Ae(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),biasConstraint:We(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};hf.className="Dense";et.registerClass(hf);var gf=class extends Vt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Qt(t);for(let e of t.slice(1))if(e==null)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],_o(t,1)]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Mt(n,o)}return C$(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};gf.className="Flatten";et.registerClass(gf);var xf=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.activation=ci(t.activation)}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);return this.activation.apply(n)})}getConfig(){let t={activation:ui(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};xf.className="Activation";et.registerClass(xf);var yf=class extends Vt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return B(()=>(t=Pt(t),w$(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};yf.className="RepeatVector";et.registerClass(yf);var bf=class extends Vt{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let n="Total size of new array must be unchanged.",o=e.slice(),s=1,i=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(i===null)i=u;else throw new z("Can only specifiy one unknown dimension.");else s*=l}let a=_o(t);if(i!==null){if(s===0||a%s!==0)throw new z(n);o[i]=a/s}else if(a!==s)throw new z(n);return o}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return R(n,s)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};bf.className="Reshape";et.registerClass(bf);var wf=class extends Vt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=Jr(1,t.dims.length+1);if(!x.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ce({ndim:this.dims.length+1})]}computeOutputShape(t){t=Qt(t);let e=t.slice();return this.dims.forEach((n,o)=>{e[o+1]=t[n]}),e}call(t,e){return Mt(Pt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};wf.className="Permute";et.registerClass(wf);var vf=class extends Vt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let n=Pt(t),o=-1;return Jl(vo(n,this.maskValue),o)}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=-1,s=!0,i=Jl(vo(n,this.maskValue),o,s);return M(n,Z(i,n.dtype))})}};vf.className="Masking";et.registerClass(vf);var Cf=class extends Vt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(ve(t.inputLength))}this.inputDim=t.inputDim,tr(this.inputDim,"inputDim"),this.outputDim=t.outputDim,tr(this.outputDim,"outputDim"),this.embeddingsInitializer=de(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ie(t.embeddingsRegularizer),this.activityRegularizer=Ie(t.activityRegularizer),this.embeddingsConstraint=Ue(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return B(()=>this.maskZero?(t=Pt(t),vo(t,St(t))):null)}computeOutputShape(t){if(t=Qt(t),this.inputLength==null)return[...t,this.outputDim];let e=ve(this.inputLength);if(e.length!==t.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let o=0;o<e.length;++o){let s=e[o],i=t[o+1];if(s!=null&&i!=null&&s!==i)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);n.dtype!=="int32"&&(n=kc(n,"int32"));let o=by(this.embeddings.read(),R(n,[n.size]));return R(o,Qt(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ae(this.embeddingsInitializer),embeddingsRegularizer:me(this.embeddingsRegularizer),activityRegularizer:me(this.activityRegularizer),embeddingsConstraint:We(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};Cf.className="Embedding";et.registerClass(Cf);var xl=class extends Vt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Nt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){let s=t[t.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Qt(t)]),t=t,t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=To(e),e.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&To(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return B(()=>{if(t=t,this.reshapeRequired){let n=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=ai(o);for(let i of t){let a=i.rank;for(let u=0;u<s-a;++u)i=ul(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let u of t){let l=u.rank;if(l==null){let c=u.shape,p=c[0],m=c.slice(1).concat([p]),f=R(u,[p].concat(_o(c.slice(1))));f=Mt(f,[1,0]),f=R(f,m),n.push(f),s=!0}else if(l>1){let c=Jr(1,l).concat([0]);n.push(Mt(u,c)),s=!0}else n.push(u)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let u=i.shape,l=u.length,c=u[l-1],p=[c].concat(u.slice(0,u.length-1));i=R(Mt(R(i,[-1,c]),[1,0]),p)}else if(a>1){let u=[a-1].concat(Jr(0,a-1));i=Mt(i,u)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);return n=To(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(e.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:fr(o,0));let n=e[0];for(let o=1;o<e.length-1;++o)n=Tr(n,e[o]);return n})}},If=class extends xl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return e})}};If.className="Add";et.registerClass(If);var Sf=class extends xl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=M(e,t[n]);return e})}};Sf.className="Multiply";et.registerClass(Sf);var kf=class extends xl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return M(1/t.length,e)})}};kf.className="Average";et.registerClass(kf);var Nf=class extends xl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=fn(e,t[n]);return e})}};Nf.className="Maximum";et.registerClass(Nf);var Tf=class extends xl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=ei(e,t[n]);return e})}};Tf.className="Minimum";et.registerClass(Tf);var _f=class extends xl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let o of t)if(o!=null){e=!1;break}if(e)return;let n=[];for(let o=0;o<t.length;++o){let s=t[o].slice();s.splice(this.axis,1);let i=!1;for(let a of n)if(x.arraysEqual(a,s)){i=!0;break}i||n.push(s)}if(n.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return B(()=>Em(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new z("A `Concatenate` layer should be called on a list of inputs.");let e=t,n=e[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of e.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new z("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new z(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return B(()=>{let n=!0;if(e.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let o=[];for(let i=0;i<t.length;++i)e[i]==null?o.push(Z(dr(t[i]),"bool")):e[i].rank<t[i].rank?o.push(fr(e[i],-1)):o.push(e[i]);let s=se(o,this.axis);return Yu(s,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};_f.className="Concatenate";et.registerClass(_f);function ig(r,t){for(;r<0;)r+=t;return r}function q8(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new Nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(x.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),x.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new Nt("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=t.shape.length;e==null&&(e=[n-1,o-2]);let s=e;return B(()=>{let i;if(n>o){i=n-o;let u=[];for(let l=0;l<i;++l)u.push(1);t=R(t,t.shape.concat(u))}else if(o>n){i=o-n;let u=[];for(let l=0;l<i;++l)u.push(1);r=R(r,r.shape.concat(u))}else i=0;let a;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=mt(M(r,t),s[0]):a=mt(M(Mt(r,[1,0]),t),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===t.shape.length-1;a=zt(r,t,u,l)}if(i>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let c=u;c<u+i;++c)l.push(c);a=zr(a,l)}return a.shape.length===1&&(a=fr(a,1)),a})}var Ef=class extends xl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){x.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],n=t[1];if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);if(e[o[0]]!==n[o[1]])throw new z(`Dimension incompatibility: ${e[o[0]]} !== ${n[o[1]]}`)}mergeFunction(t){if(t.length!==2)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,i)=>ig(s,t[i].shape.length)):o=[ig(this.axes,e.shape.length),ig(this.axes,n.shape.length)],this.normalize&&(e=Jh(e,o[0]),n=Jh(n,o[1])),q8(e,n,o)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[ig(this.axes,t.length),ig(this.axes,e.length)],n}computeOutputShape(t){x.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);e.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=e.concat(n);return s.length===1&&s.push(1),s}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};Ef.className="Dot";et.registerClass(Ef);var Af=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);return cu(()=>J(Am(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}};Af.className="GaussianNoise";et.registerClass(Af);var $f=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);return this.rate>0&&this.rate<1?cu(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return M(n,Am(n.shape,1,s))},()=>n,e.training||!1):n})}};$f.className="GaussianDropout";et.registerClass($f);var Df=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Pt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return cu(()=>{let s=Pt(t),i=1.6732632423543772,a=1.0507009873554805,u=-i*a,l=Tn(ri(n),this.rate);l=kc(l,"float32");let c=((1-this.rate)*(1+this.rate*u**2))**-.5,p=-c*u*this.rate,m=J(M(s,l),M(J(l,-1),u));return J(M(m,c),p)},()=>Pt(t),e.training||!1)}return t})}};Df.className="AlphaDropout";et.registerClass(Df);function ag(r,t,e,n,o,s=.001){let i;if(r.rank===2)i=LI(r,t,e,n,o,s);else if(r.rank===3)i=zI(r,t,e,n,o,s);else if(r.rank===4)i=BI(r,t,e,n,o,s);else throw new Nt(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function K8(r,t,e,n,o=.001){return B(()=>{let s=Cm(r,n),i=s.mean,a=s.variance;return[ag(r,i,a,e,t,o),i,a]})}function j8(r,t,e,n,o=.001){return B(()=>{let s=Cm(r,n),i=s.mean,a=s.variance,u=[];for(let d of Jr(0,r.rank))n.indexOf(d)!==-1?u.push(1):u.push(r.shape[d]);let l=R(i,u),c=R(a,u),p=t==null?null:R(t,u),m=e==null?null:R(e,u);return[ag(r,l,c,m,p,o),i,a]})}function X8(r,t,e,n,o=.001){return x.arraysEqual(n.slice().sort(),Jr(0,r.rank-1))?K8(r,t,e,n,o):j8(r,t,e,n,o)}var Ff=class extends Vt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=de(t.betaInitializer||"zeros"),this.gammaInitializer=de(t.gammaInitializer||"ones"),this.movingMeanInitializer=de(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=de(t.movingVarianceInitializer||"ones"),this.betaConstraint=Ue(t.betaConstraint),this.gammaConstraint=Ue(t.gammaConstraint),this.betaRegularizer=Ie(t.betaRegularizer),this.gammaRegularizer=Ie(t.gammaRegularizer)}build(t){t=Qt(t);let e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new z(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Ce({ndim:t.length,axes:{[e]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return B(()=>{let n=e.training==null?!1:e.training,o=Pt(t),s=o.shape,i=s.length,a=Jr(0,i),u=this.axis>=0?this.axis:this.axis+i;a.splice(u,1);let l=ko(1,i);l[u]=s[u];let c=a.slice();c.sort();let p=!x.arraysEqual(c,Jr(0,i).slice(0,i-1)),m=()=>{if(p){let b=R(this.movingMean.read(),l),w=R(this.movingVariance.read(),l),v=this.center?R(this.beta.read(),l):null,k=this.scale?R(this.gamma.read(),l):null;return ag(o,b,w,v,k,this.epsilon)}else return ag(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[f,d,h]=X8(o,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,w,v)=>{B(()=>{let k=1-v,E=b.read(),$=M(lt(E,w),k);b.write(lt(E,$))})};return(()=>{g(this.movingMean,d,this.momentum),g(this.movingVariance,h,this.momentum)})(),f})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ae(this.betaInitializer),gammaInitializer:Ae(this.gammaInitializer),movingMeanInitializer:Ae(this.movingMeanInitializer),movingVarianceInitializer:Ae(this.movingVarianceInitializer),betaRegularizer:me(this.betaRegularizer),gammaRegularizer:me(this.gammaRegularizer),betaConstraint:We(this.betaConstraint),gammaConstraint:We(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};Ff.className="BatchNormalization";et.registerClass(Ff);var Rf=class extends Vt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=de(t.betaInitializer||"zeros"),this.gammaInitializer=de(t.gammaInitializer||"ones"),this.betaRegularizer=Ie(t.betaRegularizer),this.gammaRegularizer=Ie(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Qt(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(let s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==To(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>t[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(t,e){let n=Pt(t),o=n.shape,s=o.length;return B(()=>{let{mean:a,variance:u}=Cm(n,this.axis,!0),l=ko(1,s);for(let h of this.axis)l[h]=o[h];let c=h=>h!=null&&h.shape.length!==s?R(h,l):h,p=this.scale?c(this.gamma.read()):null,m=this.center?c(this.beta.read()):null,f=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(f.push(o[h]),d.push(1)):(f.push(1),d.push(o[h]));return a=Nr(a,f),u=Nr(u,f),p!=null&&(p=Nr(p,d)),m!=null&&(m=Nr(m,d)),ag(n,a,u,m,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ae(this.betaInitializer),gammaInitializer:Ae(this.gammaInitializer),betaRegularizer:me(this.betaRegularizer),gammaRegularizer:me(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};Rf.className="LayerNormalization";et.registerClass(Rf);function Y8(r,t,e){return B(()=>{if(r.rank!==4)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=gn()),e!=="channelsLast"&&e!=="channelsFirst")throw new z(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Zr(r,n)})}var Of=class extends Vt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?gn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new Ce({ndim:4})]}computeOutputShape(t){t=Qt(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return B(()=>Y8(Pt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};Of.className="ZeroPadding2D";et.registerClass(Of);function cb(r,t,e,n,o,s){return B(()=>{Le(o),$S(s),hn(n),e==null&&(e=[1,1]),n==null&&(n="valid"),o==null&&(o=gn()),s==null&&(s="max"),r=sg(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=tl(r,t,e,a):i=Ka(r,t,e,a),o==="channelsFirst"&&(i=Mt(i,[0,3,1,2])),i})}function cD(r,t,e,n,o,s){return B(()=>{Le(o),$S(s),hn(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),o==null&&(o=gn()),s==null&&(s="max"),r=jS(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=$h(r,t,e,a):i=xh(r,t,e,a),o==="channelsFirst"&&(i=Mt(i,[0,4,1,2,3])),i})}var sb=class extends Vt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(tr(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);tr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,hn(this.padding),this.inputSpec=[new Ce({ndim:3})]}computeOutputShape(t){t=Qt(t);let e=An(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=ul(Pt(t),2);let n=this.poolingFunction(Pt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return zr(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},Mf=class extends sb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),cb(t,e,n,o,s,"max")}};Mf.className="MaxPooling1D";et.registerClass(Mf);var Pf=class extends sb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),cb(t,e,n,o,s,"avg")}};Pf.className="AveragePooling1D";et.registerClass(Pf);var ib=class extends Vt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];tr(this.poolSize,"poolSize"),tr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),hn(this.padding),this.inputSpec=[new Ce({ndim:4})]}computeOutputShape(t){t=Qt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=An(e,this.poolSize[0],this.padding,this.strides[0]),n=An(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Pt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Lf=class extends ib{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),cb(t,e,n,o,s,"max")}};Lf.className="MaxPooling2D";et.registerClass(Lf);var zf=class extends ib{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),cb(t,e,n,o,s,"avg")}};zf.className="AveragePooling2D";et.registerClass(zf);var ab=class extends Vt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];tr(this.poolSize,"poolSize"),tr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),hn(this.padding),this.inputSpec=[new Ce({ndim:5})]}computeOutputShape(t){t=Qt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=An(e,this.poolSize[0],this.padding,this.strides[0]),n=An(n,this.poolSize[1],this.padding,this.strides[1]),o=An(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,o]:[t[0],e,n,o,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Pt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Bf=class extends ab{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),cD(t,e,n,o,s,"max")}};Bf.className="MaxPooling3D";et.registerClass(Bf);var Vf=class extends ab{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),cD(t,e,n,o,s,"avg")}};Vf.className="AveragePooling3D";et.registerClass(Vf);var lb=class extends Vt{constructor(t){super(t),this.inputSpec=[new Ce({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Nt}},Gf=class extends lb{constructor(t){super(t||{})}call(t,e){return B(()=>{let n=Pt(t);return be(n,1)})}};Gf.className="GlobalAveragePooling1D";et.registerClass(Gf);var Wf=class extends lb{constructor(t){super(t||{})}call(t,e){return B(()=>{let n=Pt(t);return Fr(n,1)})}};Wf.className="GlobalMaxPooling1D";et.registerClass(Wf);var ub=class extends Vt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),this.inputSpec=[new Ce({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Nt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Uf=class extends ub{call(t,e){return B(()=>{let n=Pt(t);return this.dataFormat==="channelsLast"?be(n,[1,2]):be(n,[2,3])})}};Uf.className="GlobalAveragePooling2D";et.registerClass(Uf);var Hf=class extends ub{call(t,e){return B(()=>{let n=Pt(t);return this.dataFormat==="channelsLast"?Fr(n,[1,2]):Fr(n,[2,3])})}};Hf.className="GlobalMaxPooling2D";et.registerClass(Hf);var pb=class extends Vt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let o=e.layer,s=vn(o,n);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},qf=class extends pb{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Qt(t),t.length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Qt(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),o=t[1];return[n[0],o].concat(n.slice(1))}call(t,e){return B(()=>(t=Pt(t),YS((i,a)=>[Pt(this.layer.call(i,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};qf.className="TimeDistributed";et.registerClass(qf);function Z8(r){Ki(h$,"BidirectionalMergeMode",r)}var J8="concat",Kf=class extends pb{constructor(t){super(t);let e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=vn(n),e.goBackwards=e.goBackwards!==!0;let o={};if(o.className=t.layer.getClassName(),o.config=e,this.backwardLayer=vn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?J8:t.mergeMode,Z8(this.mergeMode),t.weights)throw new Nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,o,s;return this.returnState&&(s=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Er(o)}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=XS(t,n,o,this.numConstants);if(t=s.inputs,n=s.initialState,o=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&o==null)return super.apply(t,e);let i=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);let c=n.map(p=>new Ce({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),a.push(...c)}if(o!=null)throw new Nt("Support for constants in Bidirectional layers is not implemented yet.");let u=i[0]instanceof Qr;for(let l of i)if(l instanceof Qr!==u)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return B(()=>{let n=e.initialState,o,s;if(n==null)o=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let i;this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=ir(s,1));let a;return this.mergeMode==="concat"?a=Em([o,s]):this.mergeMode==="sum"?a=J(o,s):this.mergeMode==="ave"?a=M(.5,J(o,s)):this.mergeMode==="mul"?a=M(o,s):this.mergeMode==null&&(a=[o,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){ii(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),ii(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let n=vn(e.layer);if(delete e.layer,e.numConstants!=null)throw new Nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=e;return o.layer=n,new t(o)}};Kf.className="Bidirectional";et.registerClass(Kf);function Q8(r){return new li(r)}function tY(r){return new tf(r)}function eY(r){return new Zm(r)}function rY(r){return new Jm(r)}function nY(r){return new Qm(r)}function oY(r){return new rf(r)}function sY(r){return new ef(r)}function iY(r){return new gu(r)}function aY(r){return new ml(r)}function lY(r){return new nf(r)}function uY(r){return new fl(r)}function cY(r){return new of(r)}function pY(r){return new sf(r)}function mY(r){return new af(r)}function fY(r){return new lf(r)}function dY(r){return new uf(r)}function hY(r){return new xf(r)}function gY(r){return new hf(r)}function xY(r){return new Gc(r)}function yY(r){return new df(r)}function bY(r){return new gf(r)}function wY(r){return new yf(r)}function vY(r){return new bf(r)}function CY(r){return new wf(r)}function IY(r){return new Cf(r)}function SY(r){return new If(r)}function kY(r){return new kf(r)}function NY(r){return new _f(r)}function TY(r){return new Nf(r)}function _Y(r){return new Tf(r)}function EY(r){return new Sf(r)}function AY(r){return new Ef(r)}function $Y(r){return new Ff(r)}function DY(r){return new Rf(r)}function FY(r){return new Of(r)}function ZS(r){return new Pf(r)}function RY(r){return ZS(r)}function OY(r){return ZS(r)}function JS(r){return new zf(r)}function MY(r){return JS(r)}function PY(r){return JS(r)}function QS(r){return new Vf(r)}function LY(r){return QS(r)}function zY(r){return QS(r)}function BY(r){return new Gf(r)}function VY(r){return new Uf(r)}function pD(r){return new Wf(r)}function mD(r){return new Hf(r)}function fD(r){return new Mf(r)}function dD(r){return new Lf(r)}function GY(r){return new Bf(r)}function WY(r){return new pf(r)}function UY(r){return new zc(r)}function HY(r){return new mf(r)}function qY(r){return new hl(r)}function KY(r){return new cf(r)}function jY(r){return new Lc(r)}function XY(r){return new ff(r)}function YY(r){return new Vc(r)}function ZY(r){return new $n(r)}function JY(r){return new Bc(r)}function QY(r){return new Kf(r)}function t7(r){return new qf(r)}var e7=pD,r7=mD,n7=fD,o7=dD;function s7(r){return new Af(r)}function i7(r){return new $f(r)}function a7(r){return new Df(r)}function l7(r){return new vf(r)}var gD={};Yt(gD,{MAPE:()=>b7,MSE:()=>C7,binaryAccuracy:()=>u7,binaryCrossentropy:()=>c7,categoricalAccuracy:()=>m7,categoricalCrossentropy:()=>f7,cosineProximity:()=>g7,mape:()=>w7,meanAbsoluteError:()=>x7,meanAbsolutePercentageError:()=>y7,meanSquaredError:()=>v7,mse:()=>I7,precision:()=>d7,recall:()=>h7,sparseCategoricalAccuracy:()=>p7});function u7(r,t){return eg(r,t)}function c7(r,t){return Fy(r,t)}function p7(r,t){return Ry(r,t)}function m7(r,t){return rg(r,t)}function f7(r,t){return ng(r,t)}function d7(r,t){return zS(r,t)}function h7(r,t){return V$(r,t)}function g7(r,t){return tg(r,t)}function x7(r,t){return Hm(r,t)}function y7(r,t){return mu(r,t)}function b7(r,t){return mu(r,t)}function w7(r,t){return mu(r,t)}function v7(r,t){return Xi(r,t)}function C7(r,t){return Xi(r,t)}function I7(r,t){return Xi(r,t)}var xD={};Yt(xD,{modelFromJSON:()=>nD});var yD={};Yt(yD,{l1:()=>k7,l1l2:()=>S7,l2:()=>N7});function S7(r){return new fu(r)}function k7(r){return aD(r)}function N7(r){return lD(r)}var fb=class extends pl{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof Vn))throw new Error("model must be a LayersModel, not some other Container");this.model=t}};function mb(r,t){return r<t}function bD(r,t){return r>t}var db=class extends fb{constructor(t){if(super(),t==null&&(t={}),t.restoreBestWeights)throw new Nt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=mb:this.mode==="max"?this.monitorFunc=bD:this.monitor.indexOf("acc")!==-1?this.monitorFunc=bD:this.monitorFunc=mb,this.monitorFunc===mb&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===mb?1/0:-1/0}async onEpochEnd(t,e){await ji(e);let n=this.getMonitorValue(e);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}};function T7(r){return new db(r)}var _7={earlyStopping:T7};var E7=V();E7.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var to;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(to||(to={}));var wD;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(wD||(wD={}));var tk={};function $7(r,t){let e={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t};tk[r]=e}function hb(r){return tk[r]}function D7(r){delete tk[r]}function I(r,t,e,n,o){let s=t.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return Cr(t.inputNames[s.inputIndexStart],e,n,o);if(s.type==="tensors")return t.inputNames.slice(a,u).map(m=>Cr(m,e,n,o));let l=Cr(t.inputNames.slice(a)[0],e,n,o),c=l.dataSync();return s.type==="number"?c[0]:x.toNestedArray(l.shape,c)}let i=t.attrParams[r];return i&&i.value}function Cr(r,t,e,n){let[o,s]=Cn(r);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!t[gb(o,a)]);return i!==void 0?t[gb(o,i)][s]:void 0}function vD(r,t,e){return t[gb(r,e.currentContextId)]}function Do(r,t){let[e,n,o]=Cn(r);return[gb(e,t&&t.currentContextId),n,o]}function gb(r,t){return t?`${r}-${t}`:r}function Cn(r){let t=r.split(":");if(t.length===1)return[r,0,void 0];let e=t[0],n=t.length===3?t[1]:void 0,o=Number(t[t.length-1]);return[e,o,n]}function lg(r,t,e){let n=I("pad",r,t,e);if(n==="explicit"){n=I("explicitPaddings",r,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function mi(r){return r.kept?r:kn(r)}var ek={};Yt(ek,{json:()=>F7});var F7=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var rk={};Yt(rk,{json:()=>R7});var R7=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var nk={};Yt(nk,{json:()=>O7});var O7=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var ok={};Yt(ok,{json:()=>M7});var M7=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var sk={};Yt(sk,{json:()=>P7});var P7=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var ik={};Yt(ik,{json:()=>L7});var L7=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var ak={};Yt(ak,{json:()=>z7});var z7=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var lk={};Yt(lk,{json:()=>B7});var B7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var uk={};Yt(uk,{json:()=>V7});var V7=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var ck={};Yt(ck,{json:()=>G7});var G7=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var pk={};Yt(pk,{json:()=>W7});var W7=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var mk={};Yt(mk,{json:()=>U7});var U7=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var fk={};Yt(fk,{json:()=>H7});var H7=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var dk={};Yt(dk,{json:()=>q7});var q7=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var hk={};Yt(hk,{json:()=>K7});var K7=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var gk={};Yt(gk,{json:()=>j7});var j7=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var xk={};Yt(xk,{json:()=>X7});var X7=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var yk={};Yt(yk,{json:()=>Y7});var Y7=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var bk={};Yt(bk,{json:()=>Z7});var Z7=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var ug=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[ek,rk,nk,ok,sk,ik,ak,lk,uk,ck,pk,mk,fk,dk,hk,gk,xk,yk,bk],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(t,e={}){let n=t.node,o=[],s=[],i=[],a=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),u=[],l=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let m=Object.keys(a);m.forEach(h=>{let g=a[h];g.inputNames.forEach((y,b)=>{let[w,,v]=Do(y),k=a[w];if(k.outputs!=null){let E=k.outputs.indexOf(v);if(E!==-1){let $=`${w}:${E}`;g.inputNames[b]=$}}g.inputs.push(k),k.children.push(g)})}),Object.keys(p).length===0?m.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=Do(h),y=a[g];y!=null&&(y.signatureKey=p[h],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=Do(h),y=a[g];y&&(y.signatureKey=c[h],u.push(y))}):u=o;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:e,functions:f};return i.length>0&&(d.initNodes=i),d}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=hb(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=xb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=xb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=Sb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Sb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=bb(t.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=bb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=Ib(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Ib(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=yb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=yb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=Nb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Nb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=Cb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Cb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=kb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=kb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=wb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=wb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=vb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=vb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=CD(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=CD(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(t){let e=t.nodeDef,n=[],o=[],s={};e!=null&&(s=e.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&o.push(p[m.name]),p),{}));let i=[],a=[];t.signature.inputArg.forEach(p=>{let[m]=Do(p.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:wk(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[m]=f}),Object.keys(s).forEach(p=>{let m=s[p];m.inputNames.forEach((f,d)=>{let[h,,g]=Do(f),y=s[h];if(y.outputs!=null){let b=y.outputs.indexOf(g);if(b!==-1){let w=`${h}:${b}`;m.inputNames[d]=w}}m.inputs.push(y),y.children.push(m)})});let l=t.ret;t.signature.outputArg.forEach(p=>{let[m,f]=Do(l[p.name]),d=s[m];d!=null&&(d.defaultOutput=f,a.push(d))});let c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function J7(r){let t=V().global;if(typeof t.atob!="undefined")return t.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ID(r,t){let e=Array.isArray(r)?String.fromCharCode.apply(null,r):J7(r);return t?e:e.toLowerCase()}function xb(r,t,e,n=!1){let o=r[t];return o!=null?ID(o.s,n):e}function yb(r,t,e){let n=r[t];return n?n.b:e}function bb(r,t,e){let n=r[t]||{},o=n.i!=null?n.i:n.f!=null?n.f:e;return typeof o=="number"?o:parseInt(o,10)}function wk(r){switch(typeof r=="string"&&(r=to[r]),r){case to.DT_FLOAT:case to.DT_HALF:return"float32";case to.DT_INT32:case to.DT_INT64:case to.DT_INT8:case to.DT_UINT8:return"int32";case to.DT_BOOL:return"bool";case to.DT_DOUBLE:return"float32";case to.DT_STRING:return"string";default:return null}}function CD(r,t,e){let n=r[t];return n&&n.func?n.func.name:e}function wb(r,t,e){let n=r[t];return n&&n.type?wk(n.type):e}function vb(r,t,e){let n=r[t];return n&&n.list&&n.list.type?n.list.type.map(o=>wk(o)):e}function SD(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function Cb(r,t,e){let n=r[t];return n&&n.shape?SD(n.shape):e}function Ib(r,t,e){let n=r[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function Sb(r,t,e,n=!1){let o=r[t];return o&&o.list&&o.list.s?o.list.s.map(s=>ID(s,n)):e}function kb(r,t,e){let n=r[t];return n&&n.list&&n.list.shape?n.list.shape.map(o=>SD(o)):e}function Nb(r,t,e){let n=r[t];return n&&n.list&&n.list.b?n.list.b:e}var Tb=class{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return Cr(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return Cr(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return bb(this.node.rawAttrs,t,e);if(n.s!=null)return xb(this.node.rawAttrs,t,e);if(n.b!=null)return yb(this.node.rawAttrs,t,e);if(n.shape!=null)return Cb(this.node.rawAttrs,t,e);if(n.type!=null)return wb(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Ib(this.node.rawAttrs,t,e);if(n.list.s!=null)return Sb(this.node.rawAttrs,t,e);if(n.list.shape!=null)return kb(this.node.rawAttrs,t,e);if(n.list.b!=null)return Nb(this.node.rawAttrs,t,e);if(n.list.type!=null)return vb(this.node.rawAttrs,t,e)}return e}};var kD=(r,t,e)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[J(I("a",r,t,e),I("b",r,t,e))];case"AddN":return[RI(I("tensors",r,t,e))];case"FloorMod":case"Mod":return[Fh(I("a",r,t,e),I("b",r,t,e))];case"Mul":return[M(I("a",r,t,e),I("b",r,t,e))];case"RealDiv":case"Div":return[ct(I("a",r,t,e),I("b",r,t,e))];case"DivNoNan":return[Ih(I("a",r,t,e),I("b",r,t,e))];case"FloorDiv":return[Xu(I("a",r,t,e),I("b",r,t,e))];case"Sub":return[lt(I("a",r,t,e),I("b",r,t,e))];case"Minimum":return[ei(I("a",r,t,e),I("b",r,t,e))];case"Maximum":return[fn(I("a",r,t,e),I("b",r,t,e))];case"Pow":return[Yr(I("a",r,t,e),I("b",r,t,e))];case"SquaredDifference":return[xc(I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ND=(r,t,e)=>{switch(r.op){case"Abs":case"ComplexAbs":return[Te(I("x",r,t,e))];case"Acos":return[uh(I("x",r,t,e))];case"Acosh":return[ch(I("x",r,t,e))];case"Asin":return[mh(I("x",r,t,e))];case"Asinh":return[fh(I("x",r,t,e))];case"Atan":return[dh(I("x",r,t,e))];case"Atan2":return[hh(I("x",r,t,e),I("y",r,t,e))];case"Atanh":return[gh(I("x",r,t,e))];case"Ceil":return[bh(I("x",r,t,e))];case"Complex":return[zn(I("real",r,t,e),I("imag",r,t,e))];case"Cos":return[Ya(I("x",r,t,e))];case"Cosh":return[ec(I("x",r,t,e))];case"Elu":return[Js(I("x",r,t,e))];case"Erf":return[Sh(I("x",r,t,e))];case"Exp":return[Ye(I("x",r,t,e))];case"Expm1":return[Th(I("x",r,t,e))];case"Floor":return[ti(I("x",r,t,e))];case"Log":return[wr(I("x",r,t,e))];case"Log1p":return[Ja(I("x",r,t,e))];case"Imag":return[nc(I("x",r,t,e))];case"Neg":return[Zt(I("x",r,t,e))];case"Reciprocal":return[Rh(I("x",r,t,e))];case"Real":return[ru(I("x",r,t,e))];case"Relu":return[_r(I("x",r,t,e))];case"Round":return[pc(I("x",r,t,e))];case"Selu":return[fc(I("x",r,t,e))];case"Sigmoid":return[Lr(I("x",r,t,e))];case"Sin":return[dc(I("x",r,t,e))];case"Sign":return[Mh(I("x",r,t,e))];case"Sinh":return[hc(I("x",r,t,e))];case"Softplus":return[wo(I("x",r,t,e))];case"Sqrt":return[ye(I("x",r,t,e))];case"Square":return[Wt(I("x",r,t,e))];case"Tanh":return[Ys(I("x",r,t,e))];case"Tan":return[Bh(I("x",r,t,e))];case"ClipByValue":return[br(I("x",r,t,e),I("clipValueMin",r,t,e),I("clipValueMax",r,t,e))];case"Relu6":return[cc(I("x",r,t,e))];case"Rsqrt":return[mc(Cr(r.inputNames[0],t,e))];case"Prod":return[ac(I("x",r,t,e),I("axes",r,t,e))];case"LeakyRelu":return[Za(I("x",r,t,e),I("alpha",r,t,e))];case"Prelu":return[rl(I("x",r,t,e),I("alpha",r,t,e))];case"IsNan":return[_h(Cr(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Gn(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){x.assert(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=t[n];x.assert(o<0||s<0||o===s,()=>e+` Shapes ${r} and ${t} must match`)}}}function TD(r){return!(typeof r=="number"||r.some(t=>t<0))}function jf(r,t,e){let n=_b(r,e),o=!TD(n);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&t.forEach(s=>{n=_b(s.shape,n)}),!TD(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function _b(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let e=[];for(let n=0;n<r.length;++n){let o=r[n],s=t[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[n]=o>=0?o:s}return e}var Eb=class{constructor(t,e,n,o,s,i,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=pt(0),Pe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Gn(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Pe(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,o)=>this.write(n,e[o]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return $r([],[0].concat(this.elementShape));let n=this.readMany(t);return Gn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ze(n,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return $r([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let n=this.readMany(e);return Gn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),se(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,vr(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,o=t.map(u=>(n+=u,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:e.size/n,i=[];B(()=>{e=R(e,[1,n,s]);for(let u=0;u<t.length;++u){let l=u===0?0:o[u-1],c=[0,l,0],p=[1,t[u],s];i[u]=R(Ft(e,c,p),this.elementShape)}return i});let a=[];for(let u=0;u<t.length;u++)a[u]=u;this.writeMany(a,i)}};var yl=class{constructor(t,e,n,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,t!=null&&t.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Gn(e,s.shape,"TensorList shape mismatch: "),Pe(s)}),this.idTensor=pt(0),this.maxNumElements=o,Pe(this.idTensor)}get id(){return this.idTensor.id}copy(){return new yl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Gn(t,this.elementShape,"TensorList shape mismatch: ");let o=jf(this.elementShape,this.tensors,t);return B(()=>{let s=this.tensors.map(i=>R(i,o));return Ze(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=jf(this.elementShape,this.tensors,t),o=this.tensors.pop();return Gn(o.shape,t,"TensorList shape mismatch: "),R(o,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Gn(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Pe(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let e=new yl([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Gn(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=jf(this.elementShape,this.tensors,e);return R(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Gn(this.elementShape,e.shape,"TensorList shape mismatch: "),Pe(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Gn(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=jf(this.elementShape,this.tensors,n);return t.length===0?$r([],[0].concat(o)):B(()=>{let s=t.map(i=>R(this.tensors[i],o));return Ze(s,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Gn(this.elementShape,e,"TensorList shape mismatch: ");let n=jf(this.elementShape,this.tensors,e);return this.size()===0?$r([],[0].concat(n)):B(()=>{let o=this.tensors.map(s=>R(s,n));return se(o,0)})}};function _D(r,t,e){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);let o=r.shape.slice(1);Gn(o,t,"TensorList shape mismatch: ");let s=vr(r);return new yl(s,t,n)}function ED(r,t,e){return new yl([],r,t,e)}function AD(r,t,e,n){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let o=Math.max(...t);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new yl([],e,r.dtype,n),i=vr(r,0);return t.forEach((a,u)=>{s.setItem(a,i[u])}),s}function $D(r,t,e){let n=0,o=t.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=_b(s,e),a=n===0?0:r.size/n,u=B(()=>{let c=[];r=R(r,[1,n,a]);for(let p=0;p<t.length;++p){let m=p===0?0:o[p-1],f=[0,m,0],d=[1,t[p],a];c[p]=R(Ft(r,f,d),i)}return r.dispose(),c}),l=new yl([],e,r.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var DD=async(r,t,e)=>{switch(r.op){case"If":case"StatelessIf":{let n=I("thenBranch",r,t,e),o=I("elseBranch",r,t,e),s=I("cond",r,t,e),i=I("args",r,t,e);return(await s.data())[0]?e.functionMap[n].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let n=I("body",r,t,e),o=I("cond",r,t,e),s=I("args",r,t,e),i=await e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=s;for(;u[0];){let c=l;l=await e.functionMap[n].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);let p=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let m=await e.functionMap[o].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=I("pred",r,t,e);return[mi(n)]}case"Switch":{let n=I("pred",r,t,e),o=I("data",r,t,e);return o.kept||(o=mi(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Cr(o,t,e)!==void 0);if(n){let o=Cr(n,t,e);return[mi(o)]}return}case"Enter":{let n=I("frameName",r,t,e),o=I("tensor",r,t,e);return e.enterFrame(n),[mi(o)]}case"Exit":{let n=I("tensor",r,t,e);return e.exitFrame(),[mi(n)]}case"NextIteration":{let n=I("tensor",r,t,e);return e.nextIteration(),[mi(n)]}case"TensorArrayV3":{let n=I("size",r,t,e),o=I("dtype",r,t,e),s=I("elementShape",r,t,e),i=I("dynamicSize",r,t,e),a=I("clearAfterRead",r,t,e),u=I("identicalElementShapes",r,t,e),l=I("name",r,t,e),c=new Eb(l,o,n,s,u,i,a);return e.addTensorArray(c),[c.idTensor,pt(1)]}case"TensorArrayWriteV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e);return[e.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("dtype",r,t,e);return[e.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id),s=I("dtype",r,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let n=I("tensorArrayId",r,t,e),o=I("tensor",r,t,e),s=I("lengths",r,t,e),i=e.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return[pt(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=I("indices",r,t,e),o=I("tensor",r,t,e),s=I("elementShape",r,t,e),i=I("numElements",r,t,e),a=AD(o,n,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=I("elementShape",r,t,e),o=I("elementDType",r,t,e),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=I(s,r,t,e),a=ED(n,o,i);return e.addTensorList(a),[a.idTensor]}case"TensorListGather":{let n=I("tensorListId",r,t,e),o=I("indices",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=I("numElements",r,t,e);return[e.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=_D(n,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id),s=I("dtype",r,t,e),i=I("elementShape",r,t,e);return[o.concat(s,i)]}case"TensorListPushBack":{let n=I("tensorListId",r,t,e),o=I("tensor",r,t,e),s=e.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e);return[e.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("lengths",r,t,e),i=$D(n,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id);return[pt(o.size(),"int32")]}case"TensorListResize":{let n=I("tensorListId",r,t,e),o=I("size",r,t,e),i=e.getTensorList(n.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function FD(r,t,e){let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=I("numArgs",r,t,e);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=I("strides",r,t,e),p=lg(r,t,e),m=I("dataFormat",r,t,e).toUpperCase(),f=I("dilations",r,t,e),[d,h]=I("args",r,t,e);i&&(h=d,d=void 0);let g=I("leakyreluAlpha",r,t,e);return{stride:c,pad:p,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var RD=(r,t,e)=>{switch(r.op){case"Conv1D":{let n=I("stride",r,t,e),o=I("pad",r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilation",r,t,e);return[Qu(I("x",r,t,e),I("filter",r,t,e),n,o,s,i)]}case"Conv2D":{let n=I("strides",r,t,e),o=lg(r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilations",r,t,e);return[pn(I("x",r,t,e),I("filter",r,t,e),[n[1],n[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=FD(r,t,e);return[Co.conv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=FD(r,t,e);return[Co.depthwiseConv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=I("outputShape",r,t,e),o=I("strides",r,t,e),s=lg(r,t,e);return[tc(I("x",r,t,e),I("filter",r,t,e),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=I("strides",r,t,e),o=lg(r,t,e),s=I("dilations",r,t,e),i=I("dataFormat",r,t,e).toUpperCase();return[Zs(I("input",r,t,e),I("filter",r,t,e),[n[1],n[2]],o,i,[s[1],s[2]])]}case"Conv3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilations",r,t,e);return[wh(I("x",r,t,e),I("filter",r,t,e),[n[1],n[2],n[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[Ka(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[tl(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e),i=I("includeBatchInIndex",r,t,e),{result:a,indexes:u}=iS(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o,i);return[a,u]}case"AvgPool3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[xh(I("x",r,t,e),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[$h(I("x",r,t,e),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("dilations",r,t,e),i=n[1],a=n[2],u=s[1],l=s[2];return[Ch(I("x",r,t,e),I("filter",r,t,e),[i,a],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var OD=(r,t,e)=>{switch(r.op){case"Fill":{let n=I("shape",r,t,e),o=I("dtype",r,t,e),s=I("value",r,t,e);return[Qs(n,s,o)]}case"LinSpace":{let n=I("start",r,t,e),o=I("stop",r,t,e),s=I("num",r,t,e);return[rS(n,o,s)]}case"Multinomial":{let n=I("logits",r,t,e),o=I("numSamples",r,t,e),s=I("seed",r,t,e);return[aS(n,o,s)]}case"OneHot":{let n=I("indices",r,t,e),o=I("depth",r,t,e),s=I("onValue",r,t,e),i=I("offValue",r,t,e);return[js(n,o,s,i)]}case"Ones":return[lr(I("shape",r,t,e),I("dtype",r,t,e))];case"OnesLike":return[dr(I("x",r,t,e))];case"RandomUniform":return[ri(I("shape",r,t,e),I("minval",r,t,e),I("maxval",r,t,e),I("dtype",r,t,e))];case"Range":{let n=I("start",r,t,e),o=I("stop",r,t,e),s=I("step",r,t,e);return[nl(n,o,s,I("dtype",r,t,e))]}case"TruncatedNormal":{let n=I("shape",r,t,e),o=I("mean",r,t,e),s=I("stdDev",r,t,e),i=I("seed",r,t,e);return[yc(n,o,s,I("dtype",r,t,e),i)]}case"Zeros":return[we(I("shape",r,t,e),I("dtype",r,t,e))];case"ZerosLike":return[St(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function vk(r,t,e){let n=I("boxes",r,t,e),o=I("scores",r,t,e),s=I("maxOutputSize",r,t,e),i=I("iouThreshold",r,t,e),a=I("scoreThreshold",r,t,e),u=I("softNmsSigma",r,t,e);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var MD=async(r,t,e)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=vk(r,t,e),l=await dn.nonMaxSuppressionWithScoreAsync(n,o,s,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=vk(r,t,e),u=I("padToMaxOutputSize",r,t,e),l=await dn.nonMaxSuppressionPaddedAsync(n,o,s,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=vk(r,t,e);return[await dn.nonMaxSuppressionAsync(n,o,s,i,a)]}case"Where":{let n=Z(I("condition",r,t,e),"bool"),o=[await Wh(n)];return n.dispose(),o}case"ListDiff":return xS(I("x",r,t,e),I("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var PD=(r,t,e)=>{switch(r.op){case"LowerBound":{let n=I("sortedSequence",r,t,e),o=I("values",r,t,e);return[sS(n,o)]}case"TopKV2":{let n=I("x",r,t,e),o=I("k",r,t,e),s=I("sorted",r,t,e),i=Vh(n,o,s);return[i.values,i.indices]}case"UpperBound":{let n=I("sortedSequence",r,t,e),o=I("values",r,t,e);return[yS(n,o)]}case"Unique":{let n=I("x",r,t,e),o=Sm(n);return[o.values,o.indices]}case"UniqueV2":{let n=I("x",r,t,e),o=I("axis",r,t,e),s=Sm(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var LD=(r,t,e)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let n=I("default",r,t,e);return[Cr(r.name,t,e)||n];case"Placeholder":return[Cr(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=I("x",r,t,e);return[mi(l)]}case"IdentityN":return I("x",r,t,e).map(l=>mi(l));case"Snapshot":let o=I("x",r,t,e);return[mi(o)];case"Shape":return[Fe(I("x",r,t,e).shape,"int32")];case"ShapeN":return I("x",r,t,e).map(l=>Fe(l.shape));case"Size":return[pt(I("x",r,t,e).size,"int32")];case"Rank":return[pt(I("x",r,t,e).rank,"int32")];case"NoOp":return[pt(1)];case"Print":let s=I("x",r,t,e),i=I("data",r,t,e),a=I("message",r,t,e),u=I("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var Ab=class{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=pt(0),this.tensorMap=new Map,Pe(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),B(()=>{let o=vr(e),s=n.length,i=o.length;x.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];Pe(l),this.tensorMap.set(u,l)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return B(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,e);o.push(a)}return Ze(o)})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n!=null?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var zD=async(r,t,e,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=I("keyDType",r,t,e),s=I("valueDType",r,t,e),i=new Ab(o,s);return n.addHashTable(r.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("values",r,t,e);return[await n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("defaultValue",r,t,e);return[await n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=I("tableHandle",r,t,e,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var BD=(r,t,e)=>{switch(r.op){case"ResizeBilinear":{let n=I("images",r,t,e),o=I("size",r,t,e),s=I("alignCorners",r,t,e),i=I("halfPixelCenters",r,t,e);return[dn.resizeBilinear(n,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{let n=I("images",r,t,e),o=I("size",r,t,e),s=I("alignCorners",r,t,e),i=I("halfPixelCenters",r,t,e);return[dn.resizeNearestNeighbor(n,[o[0],o[1]],s,i)]}case"CropAndResize":{let n=I("image",r,t,e),o=I("boxes",r,t,e),s=I("boxInd",r,t,e),i=I("cropSize",r,t,e),a=I("method",r,t,e),u=I("extrapolationValue",r,t,e);return[dn.cropAndResize(n,o,s,i,a,u)]}case"ImageProjectiveTransformV3":{let n=I("images",r,t,e),o=I("transforms",r,t,e),s=I("outputShape",r,t,e),i=I("fillValue",r,t,e),a=I("interpolation",r,t,e),u=I("fillMode",r,t,e);return[dn.transform(n,o,a.toLowerCase(),u.toLowerCase(),i,s)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var VD=(r,t,e)=>{switch(r.op){case"Equal":return[kr(I("a",r,t,e),I("b",r,t,e))];case"NotEqual":return[vo(I("a",r,t,e),I("b",r,t,e))];case"Greater":return[Ge(I("a",r,t,e),I("b",r,t,e))];case"GreaterEqual":return[Tn(I("a",r,t,e),I("b",r,t,e))];case"Less":return[oc(I("a",r,t,e),I("b",r,t,e))];case"LessEqual":return[_n(I("a",r,t,e),I("b",r,t,e))];case"LogicalAnd":return[Tr(I("a",r,t,e),I("b",r,t,e))];case"LogicalNot":return[Qa(I("a",r,t,e))];case"LogicalOr":return[ic(I("a",r,t,e),I("b",r,t,e))];case"Select":case"SelectV2":return[Ee(I("condition",r,t,e),I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var GD=(r,t,e)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[zt(I("a",r,t,e),I("b",r,t,e),I("transposeA",r,t,e),I("transposeB",r,t,e))];case"Einsum":return[XI(I("equation",r,t,e),...I("tensors",r,t,e))];case"Transpose":return[Mt(I("x",r,t,e),I("perm",r,t,e))];case"_FusedMatMul":let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=o==="prelu",a=I("numArgs",r,t,e),u=I("leakyreluAlpha",r,t,e);if(s){if(i&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,c]=I("args",r,t,e);return[Co.matMul({a:I("a",r,t,e),b:I("b",r,t,e),transposeA:I("transposeA",r,t,e),transposeB:I("transposeB",r,t,e),bias:l,activation:o,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var WD=(r,t,e)=>{switch(r.op){case"EuclideanNorm":return[Nh(I("x",r,t,e),I("axis",r,t,e),I("keepDims",r,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[xo(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"FusedBatchNormV3":return[xo(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"LRN":return[Eh(I("x",r,t,e),I("radius",r,t,e),I("bias",r,t,e),I("alpha",r,t,e),I("beta",r,t,e))];case"Softmax":return[ol(I("x",r,t,e))];case"LogSoftmax":return[sc(I("x",r,t,e))];case"SparseToDense":return[Yx(I("sparseIndices",r,t,e),I("outputShape",r,t,e),I("sparseValues",r,t,e),I("defaultValue",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var UD=(r,t,e)=>{switch(r.op){case"Max":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Fr(I("x",r,t,e),i,a)]}case"Mean":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[be(I("x",r,t,e),i,a)]}case"Min":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[tu(I("x",r,t,e),i,a)]}case"Sum":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[mt(I("x",r,t,e),i,a)]}case"All":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Yu(I("x",r,t,e),i,a)]}case"Any":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Jl(I("x",r,t,e),i,a)]}case"ArgMax":{let i=I("axis",r,t,e);return[Xs(I("x",r,t,e),i)]}case"ArgMin":{let i=I("axis",r,t,e);return[ph(I("x",r,t,e),i)]}case"Prod":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[ac(I("x",r,t,e),i,a)]}case"Cumprod":{let i=I("axis",r,t,e),a=I("exclusive",r,t,e),u=I("reverse",r,t,e);return[Ql(I("x",r,t,e),i,a,u)]}case"Cumsum":{let i=I("axis",r,t,e),a=I("exclusive",r,t,e),u=I("reverse",r,t,e);return[rc(I("x",r,t,e),i,a,u)]}case"Bincount":let n=I("x",r,t,e),o=I("weights",r,t,e),s=I("size",r,t,e);return[yh(n,o,s)];case"DenseBincount":{let i=I("x",r,t,e),a=I("weights",r,t,e),u=I("size",r,t,e),l=I("binaryOutput",r,t,e);return[KI(i,a,u,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var HD=(r,t,e)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=I("n",r,t,e),o=I("axis",r,t,e),s=I("tensors",r,t,e);return s=s.slice(0,n),[se(s,o)]}case"Gather":{let n=I("x",r,t,e),o=I("indices",r,t,e);return[bo(n,Z(o,"int32"),0)]}case"GatherV2":{let n=I("axis",r,t,e),o=I("batchDims",r,t,e),s=I("x",r,t,e),i=I("indices",r,t,e);return[bo(s,Z(i,"int32"),n,o)]}case"Reverse":{let n=I("dims",r,t,e),o=[];for(let i=0;i<n.length;i++)n[i]&&o.push(i);let s=I("x",r,t,e);return[ir(s,o)]}case"ReverseV2":{let n=I("axis",r,t,e),o=I("x",r,t,e);return[ir(o,n)]}case"Slice":{let n=I("begin",r,t,e),o=I("size",r,t,e);return[Ft(I("x",r,t,e),n,o)]}case"StridedSlice":{let n=I("begin",r,t,e),o=I("end",r,t,e),s=I("strides",r,t,e),i=I("beginMask",r,t,e),a=I("endMask",r,t,e),u=I("ellipsisMask",r,t,e),l=I("newAxisMask",r,t,e),c=I("shrinkAxisMask",r,t,e),p=I("x",r,t,e);return[zh(p,n,o,s,i,a,u,l,c)]}case"Pack":return B(()=>{let n=I("axis",r,t,e),o=I("tensors",r,t,e),s=o[0].shape,i=zr(o[0]).shape,a=o.map(u=>{let l=x.arraysEqual(u.shape,s);if(!l&&!x.arraysEqual(zr(u).shape,i))throw new Error("the input tensors shape does not match");return l?u:R(u,s)});return[Ze(a,n)]});case"Unpack":{let n=I("axis",r,t,e),o=I("tensor",r,t,e);return vr(o,n)}case"Tile":{let n=I("reps",r,t,e);return[Nr(I("x",r,t,e),n)]}case"Split":case"SplitV":{let n=I("axis",r,t,e),o=I("numOrSizeSplits",r,t,e),s=I("x",r,t,e);return ur(s,o,n)}case"ScatterNd":{let n=I("indices",r,t,e),o=I("values",r,t,e),s=I("shape",r,t,e);return[bE(n,o,s)]}case"GatherNd":{let n=I("x",r,t,e),o=I("indices",r,t,e);return[vE(n,o)]}case"SparseToDense":{let n=I("sparseIndices",r,t,e),o=I("outputShape",r,t,e),s=I("sparseValues",r,t,e),i=I("defaultValue",r,t,e);return[Yx(n,s,o,s.dtype===i.dtype?i:Z(i,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var qD=(r,t,e)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=Uh.sparseFillEmptyRows(I("indices",r,t,e),I("values",r,t,e),I("denseShape",r,t,e),I("defaultValue",r,t,e));return[n,o,s,i]}case"SparseReshape":{let{outputIndices:n,outputShape:o}=Uh.sparseReshape(I("inputIndices",r,t,e),I("inputShape",r,t,e),I("newShape",r,t,e));return[n,o]}case"SparseSegmentMean":return[Uh.sparseSegmentMean(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];case"SparseSegmentSum":return[Uh.sparseSegmentSum(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var KD=(r,t,e)=>{switch(r.op){case"FFT":return[sl(I("x",r,t,e))];case"IFFT":return[Wi(I("x",r,t,e))];case"RFFT":return[il(I("x",r,t,e))];case"IRFFT":return[gc(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var jD=(r,t,e)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:o}=ay.stringNGrams(I("data",r,t,e),I("dataSplits",r,t,e),I("separator",r,t,e),I("nGramWidths",r,t,e),I("leftPad",r,t,e),I("rightPad",r,t,e),I("padWidth",r,t,e),I("preserveShortSequences",r,t,e));return[n,o]}case"StringSplit":{let{indices:n,values:o,shape:s}=ay.stringSplit(I("input",r,t,e),I("delimiter",r,t,e),I("skipEmpty",r,t,e));return[n,o,s]}case"StringToHashBucketFast":return[ay.stringToHashBucketFast(I("input",r,t,e),I("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var XD=(r,t,e)=>{switch(r.op){case"Cast":return[Z(I("x",r,t,e),I("dtype",r,t,e))];case"ExpandDims":{let n=I("axis",r,t,e);return[fr(I("x",r,t,e),n)]}case"Squeeze":{let n=I("axis",r,t,e);return[zr(I("x",r,t,e),n)]}case"Reshape":return[R(I("x",r,t,e),I("shape",r,t,e))];case"MirrorPad":return[Dh(I("x",r,t,e),I("padding",r,t,e),I("mode",r,t,e))];case"PadV2":case"Pad":return[Zr(I("x",r,t,e),I("padding",r,t,e),I("constantValue",r,t,e))];case"SpaceToBatchND":{let n=I("blockShape",r,t,e),o=I("paddings",r,t,e);return[el(I("x",r,t,e),n,o)]}case"BatchToSpaceND":{let n=I("blockShape",r,t,e),o=I("crops",r,t,e);return[ja(I("x",r,t,e),n,o)]}case"DepthToSpace":{let n=I("blockSize",r,t,e),o=I("dataFormat",r,t,e).toUpperCase();return[vh(I("x",r,t,e),n,o)]}case"BroadcastTo":return[Xa(I("x",r,t,e),I("shape",r,t,e))];case"BroadcastArgs":return[VI(I("s0",r,t,e),I("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Ck(r,t,e,n){let o=((s,i,a)=>{switch(s.category){case"arithmetic":return B(()=>kD(s,i,a));case"basic_math":return B(()=>ND(s,i,a));case"control":return DD(s,i,a);case"convolution":return B(()=>RD(s,i,a));case"creation":return B(()=>OD(s,i,a));case"dynamic":return MD(s,i,a);case"evaluation":return B(()=>PD(s,i,a));case"image":return B(()=>BD(s,i,a));case"graph":return B(()=>LD(s,i,a));case"logical":return B(()=>VD(s,i,a));case"matrices":return B(()=>GD(s,i,a));case"normalization":return B(()=>WD(s,i,a));case"reduction":return B(()=>UD(s,i,a));case"slice_join":return B(()=>HD(s,i,a));case"sparse":return B(()=>qD(s,i,a));case"spectral":return B(()=>KD(s,i,a));case"string":return B(()=>jD(s,i,a));case"transformation":return B(()=>XD(s,i,a));case"hash_table":return zD(s,i,a,n);case"custom":let u=hb(s.op);if(u&&u.customExecutor)return u.customExecutor(new Tb(s,i,a));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return x.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var cg=class{constructor(t={},e={},n={},o={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function Ik(r,t,e,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=Object.keys(r).map(m=>Cn(m)[0]),c=[];n!=null&&(c=n.map(m=>Cn(m.name)[0]));let p=[...t];for(;p.length>0;){let m=p.pop();if((Sk(m)||vZ(m)||CZ(m))&&i==null&&(i=m,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),e[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:r,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function YD(r,t,e){let{usedNodes:n,inputs:o}=e,s=[],i=Object.keys(o).map(c=>Cn(c)[0]).map(c=>r.nodes[c]),a=r.initNodes;i.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{n.has(c.name)&&s.push(c)});let u=new Set,l=[];for(;s.length>0;){let c=s.pop();u.add(c.name),t[c.name]||l.push(c),c.children.forEach(p=>{!u.has(p.name)&&n.has(p.name)&&p.inputs.every(m=>u.has(m.name))&&s.push(p)})}return l}var yZ=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],bZ=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],wZ=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Sk(r){return yZ.indexOf(r.op)>=0}function vZ(r){return bZ.indexOf(r.op)>=0}function CZ(r){return wZ.indexOf(r.op)>=0}var Wc=class{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new Wc(t.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(n=>t[n].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let n=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(t,e){let n=Ik(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let a=e.map(l=>l.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return YD(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=n.map(p=>this.graph.nodes[Cn(p)[0]]),s=e.map(p=>Cn(p)[0]),i=s.map(p=>this.graph.nodes[p]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);let a=this.getCompilationKey(o,i),u=this.compiledMap.get(a);u==null&&(u=this.compile(t,i),this.compiledMap.set(a,u));let l={},c={};return B(()=>{let p=new cg(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(t).forEach(h=>{let[g,y]=Cn(h),b=[];b[y]=t[h],m[g]=b});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let y=Ck(g,m,p,this._resourceManager);if(x.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=y,this.checkTensorForDisposal(g.name,g,m,p,f,s,d)}}return this.parent==null&&p.dispose(f),e.map(h=>Cr(h,m,p))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,n,o,s,i,a){e.category==="control"||i.indexOf(t)!==-1||(n[t].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+e.children.length)}),e.inputs.forEach(u=>{if(u.category!=="control"){let l=vD(u.name,n,o);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let p=a[c.id];if(p===1){if(!this.keepTensorForDebug)c.dispose();else{let[m,f]=Do(e.name,o);this.intermediateTensors[m]?this.intermediateTensors[m][f]=c:(this.intermediateTensors[m]=[],this.intermediateTensors[m][f]=c)}delete a[c.id]}else p!=null&&a[c.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let t in this.intermediateTensors)this.intermediateTensors[t].forEach(e=>e.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,e,n=!1,o={},s={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepTensorForDebug=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();let i=new cg(this.weightMap,o,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,i,e,n);let a=e.map(c=>Cr(c,this.tensorsMap,i)),u=a.map(c=>c.id),l=Object.keys(t).map(c=>t[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(t,e,n){let o=t.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,o){let s=Object.keys(t),i=s.map(w=>this.graph.nodes[Cn(w)[0]]),a=n.map(w=>Cn(w)[0]),u=a.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:c,dynamicNode:p,syncInputs:m}=Ik(t,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:e.currentContext})),d=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[v,k]=Cn(w),E=[];E[k]=t[w],d[v]=E});let h={},g=this.getFrozenTensorIds(d),y={};for(;f.length>0;){let w=this.processStack(i,f,e,d,y,g,a,h,l);await Promise.all(w)}p==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=u.filter(w=>!Sk(w)&&!Cr(w.name,d,e)).map(w=>w.name);if(b.length>0){let w="";throw p!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${w}`)}return d}processStack(t,e,n,o,s,i,a,u,l){let c=[];for(;e.length>0;){let p=e.pop();n.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&I("isConstant",p.node,o,n)&&([m]=Do(p.node.name,n)),o[p.node.name]==null){let f=Ck(p.node,o,n,this._resourceManager);m||([m]=Do(p.node.name,n));let d=n.currentContext;x.isPromise(f)?c.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l),h))):(o[m]=f,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l))}else this.processChildNodes(p.node,e,n,o,s,l)}return c}processChildNodes(t,e,n,o,s,i){t.children.forEach(a=>{let[u]=Do(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Cr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!Cr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let n=t[e],[o]=Cn(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);x.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&x.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){let e={};for(let n in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];e[o.name]=t[n]}else e[n]=t[n];return e}checkInputs(t){let e=Object.keys(t).filter(n=>{let[o]=Cn(n);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{let[n]=Cn(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}};var $b=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var IZ="?tfjs-format=file",SZ="model.json",Db=class{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",e==null&&(this.loadOptions={}),this.resourceManager=new $b}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=Pr.browserHTTPRequest(t,this.loadOptions);else{let e=Pr.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(Pr.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let o=Pr.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Wc(ug.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=ug.Instance.transformGraph(t.modelInitializer);this.initializer=new Wc(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let n=Pr.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Lt)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,o)=>(e[n]=t[o],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function kZ(r,t={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${SZ}${IZ}`);let e=new Db(r,t);return await e.load(),e}var ZD="3.17.0";var DF={};Yt(DF,{CSVDataset:()=>Zf,Dataset:()=>fi,FileDataSource:()=>rd,TextLineDataset:()=>Yf,URLDataSource:()=>nd,array:()=>CF,csv:()=>TF,func:()=>_F,generator:()=>EF,microphone:()=>$F,version_data:()=>Jk,webcam:()=>AF,zip:()=>IF});var vF=Ou($k());var yF=Ou($k());function fF(r,t){return Rb(r,t)}function Rb(r,t,e=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(xu(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let a=r[i],u=Rb(a,t,e,n);s[i]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,o.value),o.value}function dF(r,t=Fk){return hF(r,t)}function hF(r,t,e=new Set){let n=r[0];if(e.has(n))throw new Error("Circular references are not supported.");let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(xu(n)){let s=Array.isArray(n)?[]:{};e.add(n);for(let i in n){let a=r.map(l=>l[i]),u=hF(a,t,e);s[i]=u}return e.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function Fk(r){return r===null?null:xu(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function Ob(r,t){let e=new Map;Rb(r,t,e);for(let o of Array.from(e.keys())){let s=e.get(o);if(x.isPromise(s)){let i=await s;e.set(o,i)}}return Rb(r,t,e)}function xu(r){let t=!1;if(V().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:e}=Dk();t=r instanceof e}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Lt)&&!(r instanceof Promise)&&!t)}function gF(r){return r==null||DZ(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Lt||x.isTypedArray(r)}function DZ(r){return r===null||typeof r!="object"&&typeof r!="function"}function xF(r){return fF(r,FZ)}function FZ(r){return r instanceof Lt?{value:r.clone(),recurse:!1}:xu(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var Xf=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}};var Hc=class extends Xf{constructor(){super(Hc.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),n=this.length();for(let o=0;o<n;o++)e[o]=this.get(this.wrap(this.begin+o));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};Hc.INITIAL_CAPACITY=32;function qk(r){return new Rk(r)}function pg(r){return new Ok(r)}function bF(r,t){return new Pb(r,t)}function wF(r,t=bl.FAIL){return new Uk(r,t)}var er=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new Gk(this,t)}filter(t){return new Bk(this,t)}map(t){return new Vk(this,t)}mapAsync(t){return new Mb(this,t)}serialMapAsync(t){return new Mb(this,t).serial()}flatmap(t){return new Wk(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new zk(this,t,e)}columnMajorBatch(t,e=!0,n=Fk){return this.rowMajorBatch(t,e).map(s=>dF(s,n))}concatenate(t,e){return new Pb(qk([this,t]),e)}take(t){return t<0||t==null?this:new Lk(this,t)}skip(t){return t<0||t==null?this:new Pk(this,t)}prefetch(t){return new Lb(this,t)}shuffle(t,e){return new Hk(this,t,e)}serial(){return new Mk(this)}},Rk=class extends er{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:xF(t),done:!1}}},Ok=class extends er{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},Mk=class extends er{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Pk=class extends er{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;_t(t.value)}return this.upstream.next()}},Lk=class extends er{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},zk=class extends er{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}},Bk=class extends er{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;_t(t.value)}}},Vk=class extends er{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=fo.getTensorsInContainer(t.value),n=this.transform(t.value),o=fo.getTensorsInContainer(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},Gk=class extends er{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},Mb=class extends er{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=fo.getTensorsInContainer(t.value),n=await this.transform(t.value),o=fo.getTensorsInContainer(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},qc=class extends er{constructor(){super(),this.outputQueue=new Hc,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Wk=class extends qc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=fo.getTensorsInContainer(t.value),n=this.transform(t.value),o=fo.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return!0}},Pb=class extends er{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}},bl;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(bl||(bl={}));var Uk=class extends er{constructor(t,e=bl.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,n=0;function o(i){return i instanceof er?{value:i.next().then(u=>(e++,u.done&&n++,u.value)),recurse:!1}:{value:null,recurse:!0}}let s=await Ob(this.iterators,o);if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case bl.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case bl.SHORTEST:return{value:null,done:!0};case bl.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},Lb=class extends er{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new Xf(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},Hk=class extends Lb{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=yF.alea(n||x.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}};var fi=class{constructor(){this.size=null}batch(t,e=!0){let n=this;x.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let o;return this.size===1/0||this.size==null?o=this.size:e?o=Math.ceil(this.size/t):o=Math.floor(this.size/t),Dn(async()=>(await n.iterator()).columnMajorBatch(t,e,RZ),o)}concatenate(t){let e=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,Dn(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===1/0?n=1/0:n=null,Dn(async()=>(await e.iterator()).filter(o=>B(()=>t(o))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Dn(async()=>(await e.iterator()).map(n=>B(()=>t(n))),this.size)}mapAsync(t){let e=this;return Dn(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Dn(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,Dn(async()=>{let o=pg(async()=>({value:await e.iterator(),done:!1}));return bF(o.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,Dn(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=vF.alea(e||x.now().toString());return Dn(async()=>{let i=s.int32();return n&&(i+=s.int32()),(await o.iterator()).shuffle(t,i.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,Dn(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};fi.MAX_BUFFER_SIZE=1e4;function Dn(r,t=null){return new class extends fi{constructor(){super(...arguments),this.size=t}async iterator(){return r()}}}function CF(r){return Dn(async()=>qk(r),r.length)}function IF(r){if(!xu(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let e=0;e<r.length;e++)t=t==null?r[e].size:Math.min(t,r[e].size);else if(r instanceof Object)for(let e in r)t=t==null?r[e].size:Math.min(t,r[e].size);return Dn(async()=>{let e=await Ob(r,n=>{if(n instanceof fi)return{value:n.iterator(),recurse:!1};if(xu(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return wF(e,bl.SHORTEST)},t)}function RZ(r){if(r===null)return null;let t=r[0];return gF(t)?{value:OZ(r),recurse:!1}:{value:null,recurse:!0}}function OZ(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Lt?Ze(r):$r(r)}var Yf=class extends fi{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var zb='"',mg=Symbol("out"),SF=Symbol("field"),Bb=Symbol("quote"),Kk=Symbol("quoteafterquote"),kF=Symbol("quoteinquote"),Zf=class extends fi{constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Yf(t),e||(e={}),this.hasHeader=e.hasHeader!==!1,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(x.assert(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&x.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(e).filter(o=>e[o]>1);if(x.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let n=e.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let i=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!a)){let u=e[s],l=null;if(u==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${i} is empty in this line: ${t}`);l=void 0}else{let c=Number(u);if(isNaN(c))a&&a.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!a||!a.dtype)l=c;else switch(a.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(u);break;default:l=c}}a&&a.isLabel?o[i]=l:n[i]=l}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let n=[],o=0,s=t.length,i=mg;for(let a=0;a<s;a++)switch(i){case mg:switch(t.charAt(a)){case zb:o=a+1,i=Bb;break;case this.delimiter:if(o=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),i=mg;break;default:i=SF,o=a;break}break;case SF:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a)),i=mg,o=a+1;break;default:}break;case Bb:switch(t.charAt(a)){case zb:i=Kk;break;default:}break;case Kk:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a-1)),i=mg,o=a+1;break;case zb:i=Bb;break;default:i=kF;break}break;case kF:switch(t.charAt(a)){case zb:i=Bb;break;default:}break;default:}if(i===Kk?n.push(t.substring(o,s-1)):n.push(t.substring(o)),e&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var Jf=class extends er{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!V().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let e=new Jf(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],e=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((o,s)=>n.set(o,s*e)),n}getTensorFromAudioDataArray(t,e){let n=new Float32Array(x.sizeFromShape(e));return n.set(t,n.length-t.length),$r(n,e)}};var Qf=class extends er{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Fe([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,i=(1-o)/2,a=s+n,u=o+i;this.cropBox=Ui([i,s,u,a],[1,4])}else this.cropBox=Ui([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(!V().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}let n=new Qf(t,e);return await n.start(),n}async start(){this.webcamConfig.facingMode&&x.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Fx.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return B(()=>{let e=fr(Z(t,"float32"),0),n;n=dn.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return R(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var td=class{};var fg=class extends er{split(t){return new jk(this,t)}},jk=class extends fg{constructor(t,e){super(),this.upstream=t,this.impl=new Xk(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Xk=class extends qc{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let n of e.slice(0,-1))this.outputQueue.push(n);return this.carryover=e[e.length-1],!0}};var Vb=class extends er{decodeUTF8(){return new Yk(this)}},Yk=class extends fg{constructor(t){super(),this.upstream=t,this.impl=new Zk(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Zk=class extends qc{constructor(t){if(super(),this.upstream=t,V().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=Dk();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let n;return V().get("IS_BROWSER")?n=this.decoder.decode(e,{stream:!0}):n=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(n),!0}};var ed=class extends Vb{constructor(t,e={}){super(),this.file=t,this.options=e,x.assert(t instanceof Uint8Array||(V().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=a=>{let u=s.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));e(u)},s.onabort=a=>n(new Error("Aborted")),s.onerror=a=>n(new Error(a.type));let i=this.file.slice(this.offset,o);s.readAsArrayBuffer(i)}this.offset=o}),done:!1}}};async function NF(r,t={},e){let n,o;typeof r=="string"?n=r:(n=r.url,o=MZ(r));let s=await(e||x.fetch)(n,o);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new ed(i,t)}else throw new Error(s.statusText)}var MZ=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function Gb(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var rd=class extends td{constructor(t,e={}){super(),this.input=t,this.options=e}async iterator(){if(Gb(this.input)&&V().get("IS_NODE")){let t=Wb();this.input=t.readFileSync(this.input.slice(7))}return new ed(this.input,this.options)}};var nd=class extends td{constructor(t,e={}){super(),this.url=t,this.fileOptions=e}async iterator(){return Gb(this.url)?new rd(this.url,this.fileOptions).iterator():NF(this.url,this.fileOptions)}};function TF(r,t={}){return new Zf(new nd(r),t)}function _F(r){let t=pg(r);return Dn(async()=>t)}function EF(r){return Dn(async()=>{let t=await r();return pg(()=>t.next())})}async function AF(r,t){return Qf.create(r,t)}async function $F(r){return Jf.create(r)}var Jk="3.17.0";function ot(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&x.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var PZ=Gr.whereImpl,yu=class extends jo{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new ta(this,go())}nextDataId(){return yu.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,V().get("IS_NODE")&&S.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:n,refCount:1}),o}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&x.isString(n[0])){let s=n.map(i=>x.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return{dataId:o,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,n,o,s){this.data.set(t,{values:e,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:n}=this.data.get(t);if(e==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return S.mergeRealAndImagArrays(o,s)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId);if(t.dtype==="string")try{let n=e.map(o=>x.decodeString(o));return Ct(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(t.shape,t.dtype,e)}makeOutput(t,e,n){return go().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let e=x.now();return t(),{kernelMs:x.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ot([t],"where");let e=this.readSync(t.dataId);return PZ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};yu.nextDataId=0;var ow={};Yt(ow,{addImpl:()=>tN,bincountImpl:()=>id,bincountReduceImpl:()=>Ub,ceilImpl:()=>eN,concatImpl:()=>Kc,equalImpl:()=>rN,expImpl:()=>oN,expm1Impl:()=>iN,floorImpl:()=>aN,gatherNdImpl:()=>Hb,gatherV2Impl:()=>qb,greaterEqualImpl:()=>uN,greaterImpl:()=>lN,lessEqualImpl:()=>pN,lessImpl:()=>cN,linSpaceImpl:()=>Kb,logImpl:()=>mN,maxImpl:()=>jb,maximumImpl:()=>fN,minimumImpl:()=>dN,multiplyImpl:()=>dg,negImpl:()=>hN,notEqualImpl:()=>gN,prodImpl:()=>xN,rangeImpl:()=>Xc,rsqrtImpl:()=>yN,scatterImpl:()=>wl,sigmoidImpl:()=>nR,simpleAbsImpl:()=>Qk,sliceImpl:()=>Yc,sparseFillEmptyRowsImpl:()=>Xb,sparseReshapeImpl:()=>Yb,sparseSegmentReductionImpl:()=>ld,sqrtImpl:()=>iR,squaredDifferenceImpl:()=>wN,stridedSliceImpl:()=>Zb,stringNGramsImpl:()=>Jb,stringSplitImpl:()=>Qb,stringToHashBucketFastImpl:()=>tw,subImpl:()=>CN,tileImpl:()=>ew,topKImpl:()=>rw,transposeImpl:()=>ad,uniqueImpl:()=>nw});function Qk(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var LZ=r=>{let{x:t}=r.inputs,e=r.backend;ot(t,"abs");let n=new Float32Array(x.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return n=Qk(o),e.makeOutput(n,t.shape,t.dtype)},FF={kernelName:wi,backendName:"cpu",kernelFunc:LZ};function re(r){return(t,e,n,o,s)=>{let i=S.assertAndGetBroadcastShape(t,e),a=i.length,u=x.computeStrides(i),l=x.sizeFromShape(i),c=x.getTypedArrayFromDType(s,l),p=t.length,m=e.length,f=x.computeStrides(t),d=x.computeStrides(e),h=S.getBroadcastDims(t,i),g=S.getBroadcastDims(e,i);if(h.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(n[y%n.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let b=x.indexToLoc(y,a,u),w=b.slice(-p);h.forEach($=>w[$]=0);let v=x.locToIndex(w,p,f),k=b.slice(-m);g.forEach($=>k[$]=0);let E=x.locToIndex(k,m,d);c[y]=r(n[v],o[E])}return[c,i]}}function Ir(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(a.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var RF={kernelName:Rp,backendName:"cpu",kernelFunc:Ir};function od(r,t,e="float32"){if(e==="complex64"){let o=od(r,t,"float32"),s=od(r,t,"float32");return Ir({inputs:{real:o,imag:s},backend:r})}let n=x.makeZerosTypedArray(x.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function qr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var OF={kernelName:lo,backendName:"cpu",kernelFunc:qr};function Fo(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var MF={kernelName:Qp,backendName:"cpu",kernelFunc:Fo};function Ro(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return qr({inputs:{x:o},backend:e});let i=od(e,o.shape,o.dtype),a=Ro({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Ir({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Fo({inputs:{input:o},backend:e}),a=Ro({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!x.hasEncodingLoss(o.dtype,s)){let i=qr({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32"){let i=e.data.get(o.dataId).values,a=Int32Array.from(i);return e.makeTensorInfo(o.shape,"int32",a)}if(s==="bool"){let i=e.data.get(o.dataId).values,a=x.toTypedArray([0],o.dtype),[u,l]=re((c,p)=>c!==p?1:0)(o.shape,[],i,a,"bool");return e.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var PF={kernelName:io,backendName:"cpu",kernelFunc:Ro};function ie(r,t,e,n){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;ot([i,a],r);let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(l):l,m=i.dtype==="string"?S.fromUint8ToStringArray(c):c,f=n||i.dtype,[d,h]=t(i.shape,a.shape,p,m,f);return u.makeTensorInfo(h,f,d)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=Ro({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=u.data.get(p.dataId).values,d=u.data.get(m.dataId).values,h=Ro({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,w=u.data.get(y.dataId).values,v=u.data.get(b.dataId).values,[k,E,$]=e(i.shape,a.shape,f,d,w,v),D=u.makeTensorInfo($,"float32",k),F=u.makeTensorInfo($,"float32",E),P=Ir({inputs:{real:D,imag:F},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(D),u.disposeIntermediateTensorInfo(F),P}else{let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=n||i.dtype,[m,f]=t(i.shape,a.shape,l,c,p);return u.makeTensorInfo(f,p,m)}}}function sd(r){return(t,e,n,o,s,i)=>{let a=S.assertAndGetBroadcastShape(t,e),u=x.sizeFromShape(a),l=a.length,c=x.computeStrides(a),p=x.getTypedArrayFromDType("float32",u),m=x.getTypedArrayFromDType("float32",u),f=S.getBroadcastDims(t,a),d=S.getBroadcastDims(e,a),h=S.mergeRealAndImagArrays(n,o),g=S.mergeRealAndImagArrays(s,i),y=t.length,b=x.computeStrides(t),w=e.length,v=x.computeStrides(e);if(f.length+d.length===0)for(let k=0;k<p.length;k++){let E=k%h.length,$=k%g.length,D=r(h[E*2],h[E*2+1],g[$*2],g[$*2+1]);p[k]=D.real,m[k]=D.imag}else for(let k=0;k<p.length;k++){let E=x.indexToLoc(k,l,c),$=E.slice(-y);f.forEach(U=>$[U]=0);let D=x.locToIndex($,y,b),F=E.slice(-w);d.forEach(U=>F[U]=0);let P=x.locToIndex(F,w,v),W=r(h[D*2],h[D*2+1],g[P*2],g[P*2+1]);p[k]=W.real,m[k]=W.imag}return[p,m,a]}}var tN=re((r,t)=>r+t),zZ=sd((r,t,e,n)=>({real:r+e,imag:t+n})),Zi=ie(Xn,tN,zZ),LF={kernelName:Xn,backendName:"cpu",kernelFunc:Zi};function id(r,t,e,n,o){let s=x.sizeFromShape(n),i=x.makeZerosTypedArray(o,e);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=t[a]:i[u]+=1)}return i}function Ub(r,t,e,n=!1){let o=r.shape[0],s=r.shape[1],i=Ct([o,e],t.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(n?i.set(1,a,l):t.size>0?i.set(i.get(a,l)+t.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}function In(r){return(t,e,n)=>{let o=x.getTypedArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=r(t[s],n);return o}}function Et(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(ot(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=x.sizeFromShape(i.shape),c=e||i.dtype,p=x.getArrayFromDType(c,l);for(let m=0;m<l;++m)p[m]=t(u[m],o);return a.makeTensorInfo(i.shape,c,p)}}function Oo(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(ot(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=e||i.dtype,c=t(u,l,o);return a.makeTensorInfo(i.shape,l,c)}}var eN=In(r=>Math.ceil(r)),BZ=Oo(es,eN),zF={kernelName:es,backendName:"cpu",kernelFunc:BZ};function Kc(r,t,e,n){let o=x.getArrayFromDType(e,x.sizeFromShape(t));if(n&&e!=="string"){let s=0;r.forEach(i=>{let a=x.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=e==="string"?S.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let c=l*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[u++]}s+=i.shape[1]})}return o}var rN=re((r,t)=>r===t?1:0),nN=ie(ha,rN,null,"bool"),BF={kernelName:ha,backendName:"cpu",kernelFunc:nN};var oN=In(r=>Math.exp(r)),sN=Oo(cs,oN,"float32"),VF={kernelName:cs,backendName:"cpu",kernelFunc:sN};var iN=In(r=>Math.expm1(r)),VZ=Oo(ga,iN),GF={kernelName:ga,backendName:"cpu",kernelFunc:VZ};var aN=In(r=>Math.floor(r)),GZ=Oo(ps,aN),WF={kernelName:ps,backendName:"cpu",kernelFunc:GZ};function Hb(r,t,e,n,o,s,i,a,u){let l=Ct([n,s],e);for(let c=0;c<n;c++){let p=[],m=0;for(let f=0;f<o;f++){let d=r[c*o+f];m+=d*i[f],p.push(d)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[c*s+f]=t.get(...t.indexToLoc(m*s+f))}return l}function qb(r,t,e){let n=Ct(e,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=t.locToIndex([a,u]);i[2]=t.values[l];let c=r.locToIndex(i);0<=c&&c<r.values.length&&(n.values[o]=r.values[c])}return n}var lN=re((r,t)=>r>t?1:0),WZ=ie(ba,lN,null,"bool"),UF={kernelName:ba,backendName:"cpu",kernelFunc:WZ};var uN=re((r,t)=>r>=t?1:0),UZ=ie(ds,uN,null,"bool"),HF={kernelName:ds,backendName:"cpu",kernelFunc:UZ};var cN=re((r,t)=>r<t?1:0),HZ=ie(Ia,cN,null,"bool"),qF={kernelName:Ia,backendName:"cpu",kernelFunc:HZ};var pN=re((r,t)=>r<=t?1:0),qZ=ie(Sa,pN,null,"bool"),KF={kernelName:Sa,backendName:"cpu",kernelFunc:qZ};function Kb(r,t,e){let n=(t-r)/(e-1),o=x.makeZerosTypedArray(e,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var mN=In(r=>Math.log(r)),KZ=Oo(gs,mN),jF={kernelName:gs,backendName:"cpu",kernelFunc:KZ};function jb(r,t,e,n){let o=x.getTypedArrayFromDType(n,x.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*t,a=r[i];for(let u=0;u<t;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var fN=re((r,t)=>Math.max(r,t)),jZ=ie(ys,fN),XF={kernelName:ys,backendName:"cpu",kernelFunc:jZ};var dN=re((r,t)=>Math.min(r,t)),XZ=ie(Cs,dN),YF={kernelName:Cs,backendName:"cpu",kernelFunc:XZ};var dg=re((r,t)=>r*t),YZ=sd((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),jc=ie(Ss,dg,YZ),ZF={kernelName:Ss,backendName:"cpu",kernelFunc:jc};function hN(r,t,e){let n=x.createScalarValue(-1,e);return dg([],t,n,r,e)}function ZZ(r){let{inputs:t,backend:e}=r,{x:n}=t;ot(n,"neg");let o=e.data.get(n.dataId).values,[s,i]=hN(o,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,s)}var JF={kernelName:ki,backendName:"cpu",kernelFunc:ZZ};var gN=re((r,t)=>r!==t?1:0),JZ=ie(_a,gN,null,"bool"),QF={kernelName:_a,backendName:"cpu",kernelFunc:JZ};function ad(r,t,e,n,o){let s=t.length,i=x.sizeFromShape(t),a=x.computeStrides(t),u=x.computeStrides(o),l=x.getTypedArrayFromDType(e,x.sizeFromShape(o));for(let c=0;c<i;++c){let p=x.indexToLoc(c,s,a),m=new Array(p.length);for(let d=0;d<m.length;d++)m[d]=p[n[d]];let f=x.locToIndex(m,s,u);l[f]=r[c]}return l}function He(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{perm:s}=e;ot(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let u=n.data.get(o.dataId).values,l=ad(u,o.shape,o.dtype,s,a);return{dataId:n.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var tR={kernelName:Hs,backendName:"cpu",kernelFunc:He};function xN(r,t,e,n){let[o,s]=S.computeOutAndReduceShapes(r,n),i=ar(t,"int32"),a=x.makeZerosTypedArray(x.sizeFromShape(o),i),u=x.sizeFromShape(s);for(let l=0;l<a.length;++l){let c=l*u,p=1;for(let m=0;m<u;++m)p*=e[c+m];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function QZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;ot(o,"prod");let a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=S.getAxesPermutation(u,a),c=u,p=o,m=[];l!=null&&(p=He({inputs:{x:o},backend:e,attrs:{perm:l}}),m.push(p),c=S.getInnerMostAxes(c.length,a));let f=e.data.get(p.dataId).values,{outVals:d,outShape:h,outDtype:g}=xN(p.shape,p.dtype,f,c),y=h;return i&&(y=S.expandShapeToKeepDim(h,u)),m.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,d)}var eR={kernelName:Es,backendName:"cpu",kernelFunc:QZ};function Xc(r,t,e,n){let o=r===t,s=r<t&&e<0,i=t<r&&e>1;if(o||s||i)return x.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((t-r)/e)),u=x.makeZerosTypedArray(a,n);t<r&&e===1&&(e=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+e;return u}var yN=In(r=>1/Math.sqrt(r)),t9=Oo(Os,yN),rR={kernelName:Os,backendName:"cpu",kernelFunc:t9};function wl(r,t,e,n,o,s,i,a,u,l){let c=[n/o,o],p=r.values,m=t.values;if(n===0)return Ct(e,t.dtype);let f=Ct(c,t.dtype);typeof u=="string"||typeof u=="number"?f.values.fill(u):typeof u=="boolean"&&f.values.fill(+u);for(let d=0;d<s;d++){let h=[],g=0;for(let y=0;y<i;y++){let b=p[d*i+y];h.push(b),g+=b*a[y]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${e}`);for(let y=0;y<o;y++)l?f.values[g*o+y]+=m[d*o+y]:f.values[g*o+y]=t.rank===0?m[0]:m[d*o+y]}return f}var nR=In(r=>1/(1+Math.exp(-r))),bN=Et(Ps,r=>1/(1+Math.exp(-r))),oR={kernelName:Ps,backendName:"cpu",kernelFunc:bN};function Yc(r,t,e,n,o){let s=Ve.isSliceContinous(n,t,e),i=x.sizeFromShape(e),a=x.computeStrides(n);if(s){let p=Ve.computeFlatOffset(t,a);return o==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let u=o==="string"?S.fromUint8ToStringArray(r):r,l=Ct(n,o,u),c=Ct(e,o);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((d,h)=>d+t[h]);c.set(l.get(...f),...m)}return o==="string"?S.fromStringArrayToUint8(c.values):c.values}function Mo(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n;ot(o,"slice");let[a,u]=Ve.parseSliceParams(o,s,i);Ve.assertParamsValid(o,a,u);let l=e.data.get(o.dataId).values,c=Yc(l,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}var sR={kernelName:Ai,backendName:"cpu",kernelFunc:Mo};function Xb(r,t,e,n,o,s,i){let a=t[0],u=s[0],l=new Array(u),c=new Array(a),p=t[1];if(u===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=x.getArrayFromDType(e,0),y=x.getArrayFromDType(o,0);return[g,[0,p],y,l,c]}let m=!0,f=0,d=new Array(u).fill(0);for(let g=0;g<a;++g){let y=r[g*p];if(y<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=u)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,u));++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<u;++g){let y=d[g]===0;l[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=n;for(let b=0;b<a;++b)c[b]=b;return[g,[a,p],y,l,c]}else{let g=d[u-1],y=x.getArrayFromDType(e,g*p),b=x.getArrayFromDType(o,g),w=new Array(u).fill(0);for(let v=0;v<a;++v){let k=r[v*p],E=w[k],$=(k===0?0:d[k-1])+E;w[k]++;for(let D=0;D<p;++D)y[$*p+D]=r[v*p+D];b[$]=n[v],c[v]=$}for(let v=0;v<u;++v)if(w[v]===0){let E=v===0?0:d[v-1];y[E*p+0]=v;for(let $=1;$<p;++$)y[E*p+$]=0;b[E]=i}return[y,[g,p],b,l,c]}}function Yb(r,t,e,n,o){let s=x.sizeFromShape(n),i=t[0],a=o.length,u=[],l=1,c=-1;for(let g=0;g<a;++g){let y=o[g];if(y===-1){if(c!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,u.push(1)}else{if(y<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,y));l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[c]=g}if(x.sizeFromShape(u)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(a>0){d[a-1]=1;for(let g=a-2;g>=0;--g)d[g]=d[g+1]*u[g+1]}let h=x.getArrayFromDType(e,i*a);for(let g=0;g<i;++g){let y=0;for(let b=0;b<m;++b)y+=r[g*m+b]*f[b];for(let b=0;b<a;++b)h[g*a+b]=Math.trunc(y/d[b]),y%=d[b]}return[h,[i,a],u]}function ld(r,t,e,n,o,s=!1,i=0){let a=n.length,u=[t[0],r.length/t[0]],l=u[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=t.slice();m[0]=p;let f=m.reduce((w,v)=>w*v,1),d=x.getArrayFromDType(e,f);if(a===0)return p>0&&d.fill(i),[d,m];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,y=0,b=o[h];for(;;){let w=0;if(g<a){if(w=o[g],b===w){++g;continue}if(b>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>y&&d.fill(i,y*l,b*l);for(let v=h;v<g;++v){let k=n[v];if(k<0||k>=u[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v,n[v],u[0]));for(let E=0;E<l;E++)d[b*l+E]+=r[k*l+E]}if(s)for(let v=0;v<l;v++)d[b*l+v]/=g-h;if(h=g,++g,y=b+1,b=w,g>a)break}return y<p&&d.fill(i,y*l,p*l),[d,m]}var iR=In(r=>Math.sqrt(r)),e9=Et(Ls,r=>Math.sqrt(r)),aR={kernelName:Ls,backendName:"cpu",kernelFunc:e9};var wN=re((r,t)=>{let e=r-t;return e*e}),r9=ie(Vs,wN),lR={kernelName:Vs,backendName:"cpu",kernelFunc:r9};function Zb(r,t,e,n){let o=Ct(r,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*e[u]+n[u];o.set(t.get(...a),...i)}return o}var vN=class{constructor(t,e,n,o,s,i){this.separator=x.encodeString(t),this.nGramWidths=e,this.leftPad=x.encodeString(n),this.rightPad=x.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(s-(a+1))),p=i-(l+c),m=e+(l>0?0:a-u),f=0;f+=l*this.leftPad.length;for(let b=0;b<p;++b)f+=t[m+b].length;f+=c*this.rightPad.length,f+=(l+c+p-1)*this.separator.length,n[o+a]=new Uint8Array(f);let h=n[o+a],g=0,y=b=>b.forEach(w=>h[g++]=w);for(let b=0;b<l;++b)y(this.leftPad),y(this.separator);for(let b=0;b<p-1;++b)y(t[m+b]),y(this.separator);if(p>0){y(t[m+p-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){let n=t.length,o=e.length;if(o>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let c=e[l]>=u;if(c=c&&e[l]<=n,!c)throw new Error(`Invalid split value ${e[l]}, must be in [${u}, ${n}]`);u=e[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=x.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=e[u]-e[u-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=e[u],c=i[u];if(this.nGramWidths.forEach(p=>{let m=e[u+1]-e[u],f=this.getNumNGrams(m,p);this.createNGrams(t,l,a,c,f,p),c+=f}),this.preserveShort&&c===i[u]){let p=e[u+1]-e[u];if(p===0)continue;let m=p+2*this.padWidth,f=1;this.createNGrams(t,l,a,c,f,m)}}return[a,i]}};function Jb(r,t,e,n,o,s,i,a){return new vN(e,n,o,s,i,a).compute(r,t)}function n9(r,t,e,n){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!e||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!e||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!e||i.length!==0)&&n.push(i),o=s+1}}function Qb(r,t,e){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let m=0;m<n;++m){let f=o.length;n9(r[m],t,e,o);let d=o.length-f;a[m]=d,s+=d,i=Math.max(i,d)}let u=x.getArrayFromDType("int32",s*2),l=new Array(s),c=[n,i],p=0;for(let m=0;m<n;++m)for(let f=0;f<a[m];++f)u[p*2]=m,u[p*2+1]=f,l[p]=o[p],++p;return[u,l,c]}function tw(r,t){let e=x.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)e[n]=x.fingerPrint64(r[n]).modulo(t).getLowBitsUnsigned();return e}var CN=re((r,t)=>r-t),o9=sd((r,t,e,n)=>({real:r-e,imag:t-n})),hg=ie(Gs,CN,o9),uR={kernelName:Gs,backendName:"cpu",kernelFunc:hg};function ew(r,t){let e=new Array(r.rank);for(let o=0;o<e.length;o++)e[o]=r.shape[o]*t[o];let n=Ct(e,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var gg=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function cR(r,t,e=0,n=r.length-1){for(;n>e;){if(n-e>600){let a=n-e+1,u=t-e+1,l=Math.log(a),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),m=Math.max(e,Math.floor(t-u*c/a+p)),f=Math.min(n,Math.floor(t+(a-u)*c/a+p));cR(r,t,m,f)}let o=r[t],s=e,i=n;for(x.swap(r,e,t),gg(r[n],o)>0&&x.swap(r,e,n);s<i;){for(x.swap(r,s,i),s++,i--;gg(r[s],o)<0;)s=s+1;for(;gg(r[i],o)>0;)i=i-1}gg(r[e],o)===0?x.swap(r,e,i):(i=i+1,x.swap(r,i,n)),i<=t&&(e=i+1),t<=i&&(n=i-1)}}function rw(r,t,e,n,o){let s=t[t.length-1],[i,a]=[r.length/s,s],u=x.getTypedArrayFromDType(e,i*n),l=x.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let m=p*a,f=r.subarray(m,m+a),d=new Array(f.length);f.forEach((b,w)=>d[w]={value:b,index:w}),n<d.length&&(cR(d,n),d=d.slice(0,n)),o&&d.sort(gg);let h=p*n,g=u.subarray(h,h+n),y=l.subarray(h,h+n);for(let b=0;b<n;b++)g[b]=d[b].value,y[b]=d[b].index}let c=t.slice();return c[c.length-1]=n,[Ct(c,e,u),Ct(c,"int32",l)]}function nw(r,t,e,n){let o=x.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let d=0;d<o;d++)s[0]*=e[d];s[1]=e[o];for(let d=o+1;d<e.length;d++)s[2]*=e[d];let i={},a=new Int32Array(e[o]),u=new pe(s,n,r),l=[],c=s[0]===1&&s[2]===1;for(let d=0;d<e[o];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)g.push(u.get(y,d,b));h=g.join(",")}if(i[h]!==void 0)a[d]=i[h];else{let g=Object.keys(i).length;i[h]=g,a[d]=g,l.push(d)}}let p=s.slice();p[1]=Object.keys(i).length;let m=new pe(p,n);l.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(u.get(g,d,y),g,h,y)});let f=e.slice();return f[o]=p[1],{outputValues:m.values,outputShape:f,indices:a}}ym("cpu",()=>new yu,1);var IN=Et(us,r=>r>=0?r:Math.exp(r)-1),pR={kernelName:us,backendName:"cpu",kernelFunc:IN};function SN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n;ot([o],"leakyRelu");let i=x.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,u=x.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?s*a[l]:a[l];return e.makeTensorInfo(o.shape,"float32",u)}var mR={kernelName:hs,backendName:"cpu",kernelFunc:SN};var i9=re((r,t)=>r<0?t*r:r);function kN(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t;ot([n,o],"prelu");let s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[a,u]=i9(n.shape,o.shape,s,i,"float32");return e.makeTensorInfo(u,"float32",a)}var fR={kernelName:_s,backendName:"cpu",kernelFunc:kN};var NN=Et(As,r=>Math.max(0,r)),dR={kernelName:As,backendName:"cpu",kernelFunc:NN};var TN=Et(Ds,r=>Math.min(Math.max(0,r),6)),hR={kernelName:Ds,backendName:"cpu",kernelFunc:TN};function ud(r,t,e,n,o){if(e==="linear")return qr({inputs:{x:t},backend:r});if(e==="relu")return NN({inputs:{x:t},backend:r});if(e==="elu")return IN({inputs:{x:t},backend:r});if(e==="relu6")return TN({inputs:{x:t},backend:r});if(e==="prelu")return kN({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return SN({inputs:{x:t},backend:r,attrs:{alpha:o}});if(e==="sigmoid")return bN({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function te(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=x.sizeFromShape(o.shape),a=x.inferFromImplicitShape(s,i),u=x.sizeFromShape(a);x.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let l=e.data.get(o.dataId);if(l.complexTensorInfos!=null){let c=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var gR={kernelName:_i,backendName:"cpu",kernelFunc:te};function _N(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;ot([o,s],"matMul");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),w=Sr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[g,c,m]:[g,m,c],k=a?[y,f,p]:[y,p,f],E=te({inputs:{x:o},backend:e,attrs:{shape:v}}),$=te({inputs:{x:s},backend:e,attrs:{shape:k}}),D=i?E.shape[1]:E.shape[2],F=i?E.shape[2]:E.shape[1],P=a?$.shape[1]:$.shape[2],W=Math.max(g,y),U=e.data.get(E.dataId).values,q=e.data.get($.dataId).values,K=x.computeStrides(E.shape),j=x.computeStrides($.shape),[Q,rt,X]=i?[K[0],1,K[1]]:[K[0],K[1],1],[nt,st,it]=a?[1,j[1],j[0]]:[j[1],1,j[0]],ft=F*P,at=Ct([W,F,P],E.dtype),xt=at.values,dt=e.blockSize;for(let bt=0;bt<W;bt++)for(let kt=0;kt<F;kt+=dt)for(let At=0;At<P;At+=dt)for(let Dt=0;Dt<D;Dt+=dt){let qt=Math.min(kt+dt,F),Kt=Math.min(At+dt,P),ce=Math.min(Dt+dt,D);for(let Ot=kt;Ot<qt;Ot++)for(let $e=At;$e<Kt;$e++){let ke=0;for(let ae=Dt;ae<ce;ae++){let Ke=Math.min(bt,g-1)*Q,Re=Math.min(bt,y-1)*it,rn=U[Ke+Ot*rt+ae*X],ze=q[ae*nt+$e*st+Re];ke+=rn*ze}xt[bt*ft+(Ot*P+$e)]+=ke}}return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo($),e.makeTensorInfo(w,at.dtype,at.values)}var xR={kernelName:ts,backendName:"cpu",kernelFunc:_N};function a9(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m,f,d,h=[];m=_N({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:e}),i&&(f=Zi({inputs:{a:m,b:i},backend:e}),h.push(m),m=f),c&&(d=ud(e,m,c,a,p),h.push(m),m=d);for(let y of h)e.disposeIntermediateTensorInfo(y);return m}var yR={kernelName:Oi,backendName:"cpu",kernelFunc:a9};var l9=Et(ra,r=>Math.acos(r)),bR={kernelName:ra,backendName:"cpu",kernelFunc:l9};var u9=Et(na,r=>Math.acosh(r)),wR={kernelName:na,backendName:"cpu",kernelFunc:u9};function c9(r){let{inputs:t,backend:e}=r,n=t;ot(t,"addN");let o=n.map(a=>e.data.get(a.dataId).values),s=Ct(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let u=o[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var vR={kernelName:Zo,backendName:"cpu",kernelFunc:c9};function p9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;ot(o,"all");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];w=w&&k}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=te({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var CR={kernelName:oa,backendName:"cpu",kernelFunc:p9};function m9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;ot(o,"any");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];w=w||k}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=te({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var IR={kernelName:sa,backendName:"cpu",kernelFunc:m9};function f9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;ot(o,"argMax");let i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=He({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],w=0;for(let v=0;v<d;++v){let k=h[y+v];k>b&&(b=k,w=v)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var SR={kernelName:Jo,backendName:"cpu",kernelFunc:f9};function d9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;ot(o,"argMin");let i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=He({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],w=0;for(let v=0;v<d;++v){let k=h[y+v];k<b&&(b=k,w=v)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var kR={kernelName:Dl,backendName:"cpu",kernelFunc:d9};var h9=Et(ia,r=>Math.asin(r)),NR={kernelName:ia,backendName:"cpu",kernelFunc:h9};var g9=Et(aa,r=>Math.asinh(r)),TR={kernelName:aa,backendName:"cpu",kernelFunc:g9};var x9=Et(la,r=>Math.atan(r)),_R={kernelName:la,backendName:"cpu",kernelFunc:x9};var y9=re((r,t)=>Math.atan2(r,t)),b9=ie(ca,y9),ER={kernelName:ca,backendName:"cpu",kernelFunc:b9};var w9=Et(ua,r=>Math.atanh(r)),AR={kernelName:ua,backendName:"cpu",kernelFunc:w9};function cd(r,t,e,n,o,s){let i=o.strideHeight,a=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,m=o.padInfo.top,f=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ct(o.outShape,e),g=h.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],b=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let v=0;v<o.batchSize;++v){let k=v*y,E=v*n[0];for(let $=0;$<o.inChannels;++$)for(let D=0;D<o.outHeight;++D){let F=D*i-m,P=Math.max(0,F),W=Math.min(o.inHeight,c+F),U=k+D*b;for(let q=0;q<o.outWidth;++q){let K=q*a-f,j=Math.max(0,K),Q=Math.min(o.inWidth,p+K),rt=d,X=0,nt=0;for(let it=P;it<W;it+=u){let ft=E+it*n[1];for(let at=j;at<Q;at+=l){let xt=ft+at*n[2],dt=r[xt+$];s==="max"&&dt>rt?rt=dt:s==="avg"&&(X+=dt,nt++)}if(isNaN(rt))break}let st=U+q*w+$;g[st]=s==="avg"?X/nt:rt}}}return h}function sw(r,t,e,n,o=!1,s=!1){let i=Ct(n.outShape,"int32"),a=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,f=n.padInfo.top,d=n.padInfo.left,h=Ct(t,e,r);for(let g=0;g<n.batchSize;++g)for(let y=0;y<n.inChannels;++y)for(let b=0;b<n.outHeight;++b){let w=b*a-f,v=w;for(;v<0;)v+=l;let k=Math.min(n.inHeight,p+w);for(let E=0;E<n.outWidth;++E){let $=E*u-d,D=$;for(;D<0;)D+=c;let F=Math.min(n.inWidth,m+$),P=Number.NEGATIVE_INFINITY,W=-1;for(let U=v;U<k;U+=l){let q=U-w;for(let K=D;K<F;K+=c){let j=K-$,Q=h.get(g,U,K,y);Q>P&&(P=Q,o?W=s?((g*n.inHeight+U)*n.inWidth+K)*n.inChannels+y:(U*n.inWidth+K)*n.inChannels+y:W=q*m+j)}}i.set(W,g,b,E,y)}}return i}function iw(r,t,e,n,o,s){let i=o.strideDepth,a=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,m=o.effectiveFilterDepth,f=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,y=o.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Ct(o.outShape,e),v=w.values,k=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],E=o.outShape[2]*o.outShape[3]*o.outShape[4],$=o.outShape[3]*o.outShape[4],D=o.outShape[4];for(let F=0;F<o.batchSize;++F){let P=F*k,W=F*n[0];for(let U=0;U<o.inChannels;++U)for(let q=0;q<o.outDepth;++q){let K=q*i-h,j=K;for(;j<0;)j+=l;let Q=Math.min(o.inDepth,m+K),rt=P+q*E;for(let X=0;X<o.outHeight;++X){let nt=X*a-g,st=nt;for(;st<0;)st+=c;let it=Math.min(o.inHeight,f+nt),ft=rt+X*$;for(let at=0;at<o.outWidth;++at){let xt=at*u-y,dt=xt;for(;dt<0;)dt+=p;let bt=Math.min(o.inWidth,d+xt),kt=ft+at*D,At=b,Dt=0,qt=0;for(let ce=j;ce<Q;ce+=l){let Ot=W+ce*n[1];for(let $e=st;$e<it;$e+=c){let ke=Ot+$e*n[2];for(let ae=dt;ae<bt;ae+=p){let Ke=ke+ae*n[3],Re=r[Ke+U];if(s==="max"&&Re>At?At=Re:s==="avg"&&(Dt+=Re,qt++),isNaN(At))break}if(isNaN(At))break}if(isNaN(At))break}let Kt=kt+U;v[Kt]=s==="avg"?Dt/qt:At}}}}return w}function $R(r,t){let e=Ct(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,f=t.padInfo.top,d=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*n-m,w=b;for(;w<0;)w+=i;let v=Math.min(t.inDepth,l+b);for(let k=0;k<t.outHeight;++k){let E=k*o-f,$=E;for(;$<0;)$+=a;let D=Math.min(t.inHeight,c+E);for(let F=0;F<t.outWidth;++F){let P=F*s-d,W=P;for(;W<0;)W+=u;let U=Math.min(t.inWidth,p+P),q=Number.NEGATIVE_INFINITY,K=-1;for(let j=w;j<v;j+=i){let Q=j-b;for(let rt=$;rt<D;rt+=a){let X=rt-E;for(let nt=W;nt<U;nt+=u){let st=nt-P,it=r.get(h,j,rt,nt,g);it>=q&&(q=it,K=Q*c*p+X*c+st)}}}e.set(K,h,y,k,F,g)}}}return e}function v9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;ot(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))p=qr({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=x.computeStrides(o.shape),d=cd(m,o.shape,o.dtype,f,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var DR={kernelName:Qo,backendName:"cpu",kernelFunc:v9};function C9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;ot(o,"avgPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=iw(p,o.shape,o.dtype,x.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}var FR={kernelName:Fl,backendName:"cpu",kernelFunc:C9};function I9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;ot([o,s],"avgPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=c.strideDepth,m=c.strideHeight,f=c.strideWidth,d=c.filterDepth,h=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,v=c.effectiveFilterDepth,k=c.effectiveFilterHeight,E=c.effectiveFilterWidth,$=v-1-c.padInfo.front,D=E-1-c.padInfo.left,F=k-1-c.padInfo.top,P=Ct(s.shape,"float32"),W=1/(d*h*g),U=e.bufferSync(o);for(let q=0;q<c.batchSize;++q)for(let K=0;K<c.inChannels;++K)for(let j=0;j<c.inDepth;++j)for(let Q=0;Q<c.inHeight;++Q)for(let rt=0;rt<c.inWidth;++rt){let X=j-$,nt=Q-F,st=rt-D,it=0;for(let ft=0;ft<v;ft+=y){let at=(X+ft)/p;if(!(at<0||at>=c.outDepth||Math.floor(at)!==at))for(let xt=0;xt<k;xt+=b){let dt=(nt+xt)/m;if(!(dt<0||dt>=c.outHeight||Math.floor(dt)!==dt))for(let bt=0;bt<E;bt+=w){let kt=(st+bt)/f;if(kt<0||kt>=c.outWidth||Math.floor(kt)!==kt)continue;it+=U.get(q,at,dt,kt,K)}}}P.set(it*W,q,j,Q,rt,K)}return e.makeTensorInfo(P.shape,P.dtype,P.values)}var RR={kernelName:$p,backendName:"cpu",kernelFunc:I9};function S9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;ot([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=c.strideHeight,m=c.strideWidth,f=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,v=y-1-c.padInfo.top,k=Ct(i.shape,"float32"),E=1/(f*d),$=e.data.get(o.dataId).values,D=Ct(o.shape,"float32",$);for(let F=0;F<c.batchSize;++F)for(let P=0;P<c.inChannels;++P)for(let W=0;W<c.inHeight;++W)for(let U=0;U<c.inWidth;++U){let q=W-v,K=U-w,j=0;for(let Q=0;Q<y;Q+=h){let rt=(q+Q)/p;if(!(rt<0||rt>=c.outHeight||Math.floor(rt)!==rt))for(let X=0;X<b;X+=g){let nt=(K+X)/m;if(nt<0||nt>=c.outWidth||Math.floor(nt)!==nt)continue;j+=D.get(F,rt,nt,P)}}k.set(j*E,F,W,U,P)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}var OR={kernelName:Ap,backendName:"cpu",kernelFunc:S9};function k9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,scale:s,offset:i,mean:a,variance:u}=t;x.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ot([o,a,u,s,i],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,m=e.data.get(u.dataId).values,f=s?e.data.get(s.dataId).values:new Float32Array([1]),d=i?e.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),g=d.length,y=f.length,b=m.length,w=p.length,v=0,k=0,E=0,$=0;for(let D=0;D<c.length;++D)h[D]=d[v++]+(c[D]-p[k++])*f[E++]/Math.sqrt(m[$++]+l),v>=g&&(v=0),k>=w&&(k=0),E>=y&&(E=0),$>=b&&($=0);return e.makeTensorInfo(o.shape,o.dtype,h)}var MR={kernelName:fs,backendName:"cpu",kernelFunc:k9};function N9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;ot([o],"batchToSpaceND");let a=s.reduce((y,b)=>y*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=te({inputs:{x:o},backend:e,attrs:{shape:u}}),d=He({inputs:{x:f},backend:e,attrs:{perm:l}}),h=te({inputs:{x:d},backend:e,attrs:{shape:c}}),g=Mo({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var PR={kernelName:vi,backendName:"cpu",kernelFunc:N9};function T9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=id(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var LR={kernelName:Dp,backendName:"cpu",kernelFunc:T9};function _9(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var zR={kernelName:Fp,backendName:"cpu",kernelFunc:_9};var E9=Et(ao,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),BR={kernelName:ao,backendName:"cpu",kernelFunc:E9};var A9=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(x.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let c=a[l],p=u[l];n[l]=Math.hypot(c,p)}return e.makeOutput(n,t.shape,"float32")},VR={kernelName:Rl,backendName:"cpu",kernelFunc:A9};function Ji(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var GR={kernelName:qp,backendName:"cpu",kernelFunc:Ji};function bu(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=x.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(h=>h.shape),s);if(x.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(h=>x.sizeFromShape(h.shape)>0);if(a.length===1)return qr({inputs:{x:a[0]},backend:e});let u=a.map(h=>h.shape);if(S.assertParamsConsistent(u,s),a[0].dtype==="complex64"){let h=a.map(v=>Fo({inputs:{input:v},backend:e})),g=a.map(v=>Ji({inputs:{input:v},backend:e})),y=bu({inputs:h,backend:e,attrs:{axis:s}}),b=bu({inputs:g,backend:e,attrs:{axis:s}}),w=Ir({inputs:{real:y,imag:b},backend:e});return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),w}let l=a.map(h=>{let g=x.sizeFromShape(h.shape.slice(s));return te({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}})}),c=l.map(h=>({vals:e.data.get(h.dataId).values,shape:h.shape}));i=S.computeOutShape(l.map(h=>h.shape),1);let p=l[0].shape[0]===1,m=Kc(c,i,t[0].dtype,p),f=S.computeOutShape(a.map(h=>h.shape),s),d=e.makeTensorInfo(f,t[0].dtype,m);return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var WR={kernelName:Ci,backendName:"cpu",kernelFunc:bu};function EN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n;ot([o,s],"conv2d");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,y=m.padInfo.left,b=m.padInfo.top,w=m.dataFormat==="channelsLast",v=new pe(m.outShape,o.dtype),k=x.computeStrides(o.shape),E=x.computeStrides(s.shape),$=k[0],D=w?k[1]:k[2],F=w?k[2]:1,P=w?1:k[1],W=v.strides[0],U=w?v.strides[1]:v.strides[2],q=w?v.strides[2]:1,K=w?1:v.strides[1],j=e.data.get(o.dataId).values,Q=e.data.get(s.dataId).values,rt=v.values;for(let X=0;X<m.batchSize;++X){let nt=X*$,st=X*W;for(let it=0;it<m.outHeight;++it){let ft=st+it*U,at=it*m.strideHeight-b;for(let xt=0;xt<f;++xt){let dt=at+xt*h;if(dt<0||dt>=m.inHeight)continue;let bt=xt*E[0],kt=nt+dt*D;for(let At=0;At<m.outWidth;++At){let Dt=ft+At*q,qt=At*m.strideWidth-y;for(let Kt=0;Kt<d;++Kt){let ce=qt+Kt*g;if(ce<0||ce>=m.inWidth)continue;let Ot=bt+Kt*E[1],$e=kt+ce*F,ke=Ot;for(let ae=0;ae<m.inChannels;++ae){let Ke=j[$e+ae*P];for(let Re=0;Re<m.outChannels;++Re)rt[Dt+Re*K]+=Ke*Q[ke+Re];ke+=m.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,rt)}var UR={kernelName:rs,backendName:"cpu",kernelFunc:EN};function $9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n;ot([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,y=m.dataFormat==="channelsLast",b=new pe(m.filterShape,"float32"),w=m.padInfo.left,v=m.padInfo.top,k=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=new pe(o.shape,o.dtype,k),D=new pe(s.shape,s.dtype,E);for(let F=0;F<h;++F){let P=Math.max(0,Math.ceil((v-F)/f)),W=Math.min(m.outHeight,(m.inHeight+v-F)/f);for(let U=0;U<g;++U){let q=Math.max(0,Math.ceil((w-U)/d)),K=Math.min(m.outWidth,(m.inWidth+w-U)/d);for(let j=0;j<m.inChannels;++j)for(let Q=0;Q<m.outChannels;++Q){let rt=0;for(let X=0;X<m.batchSize;++X)for(let nt=P;nt<W;++nt){let st=F+nt*f-v;for(let it=q;it<K;++it){let ft=U+it*d-w;y?rt+=$.get(X,st,ft,j)*D.get(X,nt,it,Q):rt+=$.get(X,j,st,ft)*D.get(X,Q,nt,it)}}b.set(rt,F,U,j,Q)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var HR={kernelName:Op,backendName:"cpu",kernelFunc:$9};function D9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n;ot([o,s],"conv2dBackpropInput");let p=x.computeStrides(s.shape),m=x.computeStrides(o.shape),f=S.convertConv2DDataFormat(l),d=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,f),h=new pe(d.inShape,"float32"),g=h.values,y=e.data.get(o.dataId).values,b=e.data.get(s.dataId).values,[w,v,k]=p,{batchSize:E,filterHeight:$,filterWidth:D,inChannels:F,inHeight:P,inWidth:W,outChannels:U,outHeight:q,outWidth:K,strideHeight:j,strideWidth:Q}=d;f=d.dataFormat;let rt=$-1-d.padInfo.top,X=D-1-d.padInfo.left,nt=f==="channelsLast",st=h.strides[0],it=nt?h.strides[1]:h.strides[2],ft=nt?h.strides[2]:1,at=nt?1:h.strides[1],xt=m[0],dt=nt?m[1]:m[2],bt=nt?m[2]:1,kt=nt?1:m[1];for(let At=0;At<E;++At)for(let Dt=0;Dt<F;++Dt)for(let qt=0;qt<P;++qt){let Kt=qt-rt,ce=Math.max(0,Math.ceil(Kt/j)),Ot=Math.min(q,($+Kt)/j);for(let $e=0;$e<W;++$e){let ke=$e-X,ae=Math.max(0,Math.ceil(ke/Q)),Ke=Math.min(K,(D+ke)/Q),Re=0;for(let ze=ce;ze<Ot;++ze){let Bo=ze*j-Kt;for(let Or=ae;Or<Ke;++Or){let nn=Or*Q-ke,on=xt*At+dt*ze+bt*Or,jr=w*($-1-Bo)+v*(D-1-nn)+k*Dt;for(let oo=0;oo<U;++oo){let Rn=y[on+kt*oo],Vo=b[jr+oo];Re+=Rn*Vo}}}let rn=st*At+it*qt+ft*$e+at*Dt;g[rn]=Re}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var qR={kernelName:ns,backendName:"cpu",kernelFunc:D9};function F9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n;ot([o,s],"conv3d");let l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=l,y=g.front,b=g.left,w=g.top,v=new pe(l.outShape,o.dtype),k=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=v.values,D=x.computeStrides(o.shape),F=x.computeStrides(s.shape);for(let P=0;P<l.batchSize;++P){let W=P*D[0],U=P*v.strides[0];for(let q=0;q<l.outDepth;++q){let K=U+q*v.strides[1],j=q*l.strideDepth-y;for(let Q=0;Q<c;++Q){let rt=j+Q*f;if(rt<0||rt>=l.inDepth)continue;let X=Q*F[0],nt=W+rt*D[1];for(let st=0;st<l.outHeight;++st){let it=K+st*v.strides[2],ft=st*l.strideHeight-w;for(let at=0;at<p;++at){let xt=ft+at*d;if(xt<0||xt>=l.inHeight)continue;let dt=X+at*F[1],bt=nt+xt*D[2];for(let kt=0;kt<l.outWidth;++kt){let At=it+kt*l.outChannels,Dt=kt*l.strideWidth-b;for(let qt=0;qt<m;++qt){let Kt=Dt+qt*h;if(Kt<0||Kt>=l.inWidth)continue;let ce=dt+qt*F[2],Ot=bt+Kt*l.inChannels,$e=ce;for(let ke=0;ke<l.inChannels;++ke){let ae=k[Ot+ke];for(let Ke=0;Ke<l.outChannels;++Ke)$[At+Ke]+=ae*E[$e+Ke];$e+=l.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}var KR={kernelName:Ol,backendName:"cpu",kernelFunc:F9};function R9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n;ot([o,s],"conv3dBackpropFilterV2");let l=x.computeStrides(o.shape),c=x.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,u,i,1,a),m=p.strideDepth,f=p.strideHeight,d=p.strideWidth,h=p.filterDepth,g=p.filterHeight,y=p.filterWidth,b=new pe(p.filterShape,"float32"),w=b.values,[v,k,E,$]=b.strides,D=e.data.get(s.dataId).values,[F,P,W,U]=c,q=e.data.get(o.dataId).values,[K,j,Q,rt]=l,X=p.padInfo.front,nt=p.padInfo.left,st=p.padInfo.top;for(let it=0;it<h;++it){let ft=Math.max(0,Math.ceil((X-it)/m)),at=Math.min(p.outDepth,(p.inDepth+X-it)/m),xt=it*v;for(let dt=0;dt<g;++dt){let bt=Math.max(0,Math.ceil((st-dt)/f)),kt=Math.min(p.outHeight,(p.inHeight+st-dt)/f),At=dt*k+xt;for(let Dt=0;Dt<y;++Dt){let qt=Math.max(0,Math.ceil((nt-Dt)/d)),Kt=Math.min(p.outWidth,(p.inWidth+nt-Dt)/d),ce=Dt*E+At;for(let Ot=0;Ot<p.inChannels;++Ot){let $e=Ot*$+ce;for(let ke=0;ke<p.outChannels;++ke){let ae=0;for(let Ke=0;Ke<p.batchSize;++Ke){let Re=Ke*K,rn=Ke*F;for(let ze=ft;ze<at;++ze){let Or=(it+ze*m-X)*j+Re,nn=ze*P+rn;for(let on=bt;on<kt;++on){let oo=(dt+on*f-st)*Q+Or,Rn=on*W+nn;for(let Vo=qt;Vo<Kt;++Vo){let _l=(Dt+Vo*d-nt)*rt+oo,_u=Vo*U+Rn;ae+=q[_l+Ot]*D[_u+ke]}}}}w[$e+ke]=ae}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var jR={kernelName:Mp,backendName:"cpu",kernelFunc:R9};function O9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n;ot([o],"conv3dBackpropInputV2");let l=x.computeStrides(o.shape),c=x.computeStrides(s.shape),p=S.computeConv3DInfo(u,s.shape,a,1,i),m=new pe(p.inShape,"float32"),f=m.values,[d,h,g,y]=m.strides,b=e.data.get(o.dataId).values,[w,v,k,E]=l,$=e.data.get(s.dataId).values,[D,F,P,W]=c,{batchSize:U,filterDepth:q,filterHeight:K,filterWidth:j,inChannels:Q,inDepth:rt,inHeight:X,inWidth:nt,outChannels:st,outDepth:it,outHeight:ft,outWidth:at,strideDepth:xt,strideHeight:dt,strideWidth:bt}=p,kt=q-1-p.padInfo.front,At=K-1-p.padInfo.top,Dt=j-1-p.padInfo.left;for(let qt=0;qt<U;++qt)for(let Kt=0;Kt<Q;++Kt)for(let ce=0;ce<rt;++ce){let Ot=ce-kt,$e=Math.max(0,Math.ceil(Ot/xt)),ke=Math.min(it,(q+Ot)/xt);for(let ae=0;ae<X;++ae){let Ke=ae-At,Re=Math.max(0,Math.ceil(Ke/dt)),rn=Math.min(ft,(K+Ke)/dt);for(let ze=0;ze<nt;++ze){let Bo=ze-Dt,Or=Math.max(0,Math.ceil(Bo/bt)),nn=Math.min(at,(j+Bo)/bt),on=0;for(let jr=$e;jr<ke;++jr){let oo=jr*xt-Ot;for(let Rn=Re;Rn<rn;++Rn){let Vo=Rn*dt-Ke;for(let so=Or;so<nn;++so){let _l=so*bt-Bo,_u=w*qt+v*jr+k*Rn+E*so,pp=D*(q-1-oo)+F*(K-1-Vo)+P*(j-1-_l)+W*Kt;for(let gr=0;gr<st;++gr){let mp=b[_u+gr],fp=$[pp+gr];on+=mp*fp}}}}f[d*qt+h*ce+g*ae+y*ze+Kt]=on}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var XR={kernelName:Pp,backendName:"cpu",kernelFunc:O9};var M9=Et(os,r=>Math.cos(r)),YR={kernelName:os,backendName:"cpu",kernelFunc:M9};var P9=Et(ss,r=>Math.cosh(r)),ZR={kernelName:ss,backendName:"cpu",kernelFunc:P9};function L9(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,[c,p,m,f]=o.shape,d=s.shape[0],[h,g]=a,y=Ct([d,h,g,f],"float32"),b=e.data.get(s.dataId).values,w=e.data.get(i.dataId).values,v=e.data.get(o.dataId).values,k=x.computeStrides(o.shape),E=x.computeStrides(y.shape);for(let $=0;$<d;$++){let D=$*4,F=b[D],P=b[D+1],W=b[D+2],U=b[D+3],q=w[$];if(q>=c)continue;let K=h>1?(W-F)*(p-1)/(h-1):0,j=g>1?(U-P)*(m-1)/(g-1):0;for(let Q=0;Q<h;Q++){let rt=h>1?F*(p-1)+Q*K:.5*(F+W)*(p-1);if(rt<0||rt>p-1){for(let X=0;X<g;X++)for(let nt=0;nt<f;nt++){let st=nt+X*E[2]+Q*E[1]+$*E[0];y.values[st]=l}continue}if(u==="bilinear"){let X=Math.floor(rt),nt=Math.ceil(rt),st=rt-X;for(let it=0;it<g;it++){let ft=g>1?P*(m-1)+it*j:.5*(P+U)*(m-1);if(ft<0||ft>m-1){for(let bt=0;bt<f;bt++){let kt=bt+it*E[2]+Q*E[1]+$*E[0];y.values[kt]=l}continue}let at=Math.floor(ft),xt=Math.ceil(ft),dt=ft-at;for(let bt=0;bt<f;bt++){let kt=bt+at*k[2]+X*k[1]+q*k[0],At=v[kt];kt=bt+xt*k[2]+X*k[1]+q*k[0];let Dt=v[kt];kt=bt+at*k[2]+nt*k[1]+q*k[0];let qt=v[kt];kt=bt+xt*k[2]+nt*k[1]+q*k[0];let Kt=v[kt],ce=At+(Dt-At)*dt,Ot=qt+(Kt-qt)*dt;kt=bt+it*E[2]+Q*E[1]+$*E[0],y.values[kt]=ce+(Ot-ce)*st}}}else for(let X=0;X<g;++X){let nt=g>1?P*(m-1)+X*j:.5*(P+U)*(m-1);if(nt<0||nt>m-1){for(let ft=0;ft<f;ft++){let at=ft+X*E[2]+Q*E[1]+$*E[0];y.values[at]=l}continue}let st=Math.round(nt),it=Math.round(rt);for(let ft=0;ft<f;ft++){let at=ft+st*k[2]+it*k[1]+q*k[0],xt=ft+X*E[2]+Q*E[1]+$*E[0];y.values[xt]=v[at]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var JR={kernelName:ma,backendName:"cpu",kernelFunc:L9};function z9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;ot(o,"cumprod");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=He({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ar(l.dtype,"int32"),m=x.makeOnesTypedArray(x.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let w=h(y,b);if(b===0)m[w]=i?1:f[w];else{let v=h(y,b-1);m[w]=i?f[v]*m[v]:f[w]*m[v]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let y=S.getUndoAxesPermutation(u),b=He({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var QR={kernelName:pa,backendName:"cpu",kernelFunc:z9};function B9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;ot(o,"cumsum");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=He({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ar(l.dtype,"int32"),m=x.makeZerosTypedArray(x.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let w=h(y,b);if(b===0)m[w]=i?0:f[w];else{let v=h(y,b-1);m[w]=i?f[v]+m[v]:f[w]+m[v]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let y=S.getUndoAxesPermutation(u),b=He({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var tO={kernelName:is,backendName:"cpu",kernelFunc:B9};function V9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=id(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=Ub(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var eO={kernelName:Lp,backendName:"cpu",kernelFunc:V9};function G9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n;x.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],u=o.shape[1],l=o.shape[2],c=o.shape[3],p=u*s,m=l*s,f=c/(s*s),d=e.data.get(o.dataId).values,h=new Float32Array(a*p*m*f),g=0;for(let y=0;y<a;++y)for(let b=0;b<p;++b){let w=Math.floor(b/s),v=b%s;for(let k=0;k<m;++k){let E=Math.floor(k/s),$=k%s,D=(v*s+$)*f;for(let F=0;F<f;++F){let W=F+D+c*(E+l*(w+u*y));h[g++]=d[W]}}}return e.makeTensorInfo([a,p,m,f],o.dtype,h)}var rO={kernelName:fa,backendName:"cpu",kernelFunc:G9};function AN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n;ot([o,s],"depthwiseConv2DNative");let c=x.computeStrides(o.shape),p=x.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,m,a,l,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:y,padInfo:b}=f,w=b.left,v=b.top,k=f.outChannels/f.inChannels,E=new pe(f.outShape,o.dtype),$=e.data.get(o.dataId).values,D=e.data.get(s.dataId).values,F=E.values;for(let P=0;P<f.batchSize;++P){let W=P*c[0],U=P*E.strides[0];for(let q=0;q<f.outHeight;++q){let K=U+q*E.strides[1],j=q*f.strideHeight-v;for(let Q=0;Q<d;++Q){let rt=j+Q*g;if(rt<0||rt>=f.inHeight)continue;let X=Q*p[0],nt=W+rt*c[1];for(let st=0;st<f.outWidth;++st){let it=K+st*E.strides[2],ft=st*f.strideWidth-w;for(let at=0;at<h;++at){let xt=ft+at*y;if(xt<0||xt>=f.inWidth)continue;let dt=X+at*p[1],bt=nt+xt*f.inChannels,kt=it,At=dt;for(let Dt=0;Dt<f.inChannels;++Dt){let qt=$[bt+Dt];for(let Kt=0;Kt<k;++Kt)F[kt+Kt]+=qt*D[At+Kt];kt+=k,At+=k}}}}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}var nO={kernelName:as,backendName:"cpu",kernelFunc:AN};function W9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n;ot([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=p,g=new pe(p.filterShape,"float32"),y=p.padInfo.left,b=p.padInfo.top,w=p.outChannels/p.inChannels,v=e.data.get(o.dataId).values,k=new pe(o.shape,o.dtype,v),E=e.data.get(s.dataId).values,$=new pe(s.shape,s.dtype,E);for(let D=0;D<d;++D){let F=Math.max(0,Math.ceil((b-D)/m)),P=Math.min(p.outHeight,(p.inHeight+b-D)/m);for(let W=0;W<h;++W){let U=Math.max(0,Math.ceil((y-W)/f)),q=Math.min(p.outWidth,(p.inWidth+y-W)/f);for(let K=0;K<p.outChannels;++K){let j=Math.trunc(K/w),Q=K%w,rt=0;for(let X=0;X<p.batchSize;++X)for(let nt=F;nt<P;++nt){let st=D+nt*m-b;for(let it=U;it<q;++it){let ft=W+it*f-y;rt+=k.get(X,st,ft,j)*$.get(X,nt,it,K)}}g.set(rt,D,W,j,Q)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var oO={kernelName:zp,backendName:"cpu",kernelFunc:W9};function U9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n;ot([o,s],"depthwiseConv2DNativeBackpropInput");let p=x.computeStrides(o.shape),m=x.computeStrides(s.shape),f=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),d=new pe(f.inShape,"float32"),h=d.values,[g,y,b]=d.strides,w=e.data.get(o.dataId).values,[v,k,E]=p,$=e.data.get(s.dataId).values,[D,F,P]=m,{batchSize:W,filterHeight:U,filterWidth:q,inChannels:K,inHeight:j,inWidth:Q,outChannels:rt,outHeight:X,outWidth:nt,strideHeight:st,strideWidth:it}=f,ft=U-1-f.padInfo.top,at=q-1-f.padInfo.left,xt=rt/K;for(let dt=0;dt<W;++dt)for(let bt=0;bt<K;++bt)for(let kt=0;kt<j;++kt){let At=kt-ft,Dt=Math.max(0,Math.ceil(At/st)),qt=Math.min(X,(U+At)/st);for(let Kt=0;Kt<Q;++Kt){let ce=Kt-at,Ot=Math.max(0,Math.ceil(ce/it)),$e=Math.min(nt,(q+ce)/it),ke=0;for(let ae=Dt;ae<qt;++ae){let Ke=ae*st-At;for(let Re=Ot;Re<$e;++Re){let rn=Re*it-ce,ze=v*dt+k*ae+E*Re,Bo=D*(U-1-Ke)+F*(q-1-rn)+P*bt;for(let Or=0;Or<xt;++Or){let nn=bt*xt+Or,on=w[ze+nn],jr=$[Bo+Or];ke+=on*jr}}}h[g*dt+y*kt+b*Kt+bt]=ke}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var sO={kernelName:Bp,backendName:"cpu",kernelFunc:U9};function H9(r){let{inputs:t,backend:e}=r,{x:n}=t,o=x.sizeFromShape(n.shape),s=e.data.get(n.dataId).values,i=Ct([o,o],n.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,i.dtype,i.values)}var iO={kernelName:Vp,backendName:"cpu",kernelFunc:H9};var aO={kernelName:Ml,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o}=r,{strides:s,pad:i,dilations:a}=e,u=t,l=u.data.get(n.dataId).values,c=n.shape.length,p=u.data.get(o.dataId).values,m=o.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:v,strideWidth:k,filterHeight:E,filterWidth:$,dilationHeight:D,dilationWidth:F,outShape:P}=S.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),W=x.sizeFromShape(P),U=P.length,q=x.getArrayFromDType(n.dtype,W);for(let j=0;j<f;++j)for(let Q=0;Q<y;++Q){let rt=Q*v-w.top;for(let X=0;X<b;++X){let nt=X*k-w.left;for(let st=0;st<g;++st){let it=Number.MIN_SAFE_INTEGER;for(let at=0;at<E;++at){let xt=rt+at*D;if(xt>=0&&xt<d)for(let dt=0;dt<$;++dt){let bt=nt+dt*F;if(bt>=0&&bt<h){let kt=x.locToIndex([j,xt,bt,st],c,x.computeStrides(n.shape)),At=x.locToIndex([at,dt,st],m,x.computeStrides(o.shape)),Dt=l[kt]+p[At];Dt>it&&(it=Dt)}}}let ft=x.locToIndex([j,Q,X,st],U,x.computeStrides(P));q[ft]=it}}}return{dataId:u.write(x.toTypedArray(q,n.dtype),P,n.dtype),shape:P,dtype:n.dtype}}};var lO={kernelName:jd,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=x.toNestedArray(n.shape,l.data.get(n.dataId).values),p=x.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:F}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);x.assert(s.rank===F.length,()=>`Error in ${jd}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let P=x.toNestedArray(F,l.data.get(s.dataId).values),W=x.makeZerosNestedTypedArray(o.shape,o.dtype);for(let q=0;q<m;++q)for(let K=0;K<g;++K){let j=K*w-b.top;for(let Q=0;Q<y;++Q){let rt=Q*v-b.left;for(let X=0;X<h;++X){let nt=Number.MIN_SAFE_INTEGER,st=0,it=0;for(let ft=0;ft<k;++ft){let at=j+ft*$;if(at>=0&&at<f)for(let xt=0;xt<E;++xt){let dt=rt+xt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][X]+p[ft][xt][X];bt>nt&&(nt=bt,st=ft,it=xt)}}}W[st][it][X]+=P[q][K][Q][X]}}}return{dataId:l.write(x.toTypedArray(W,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var uO={kernelName:Kd,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=x.toNestedArray(n.shape,l.data.get(n.dataId).values),p=x.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:F}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);x.assert(s.rank===F.length,()=>`Error in ${Kd}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let P=x.toNestedArray(F,l.data.get(s.dataId).values),W=x.makeZerosNestedTypedArray(n.shape,n.dtype);for(let q=0;q<m;++q)for(let K=0;K<g;++K){let j=K*w-b.top;for(let Q=0;Q<y;++Q){let rt=Q*v-b.left;for(let X=0;X<h;++X){let nt=Number.MIN_SAFE_INTEGER,st=j<0?0:j,it=rt<0?0:rt;for(let ft=0;ft<k;++ft){let at=j+ft*$;if(at>=0&&at<f)for(let xt=0;xt<E;++xt){let dt=rt+xt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][X]+p[ft][xt][X];bt>nt&&(nt=bt,st=at,it=dt)}}}W[q][st][it][X]+=P[q][K][Q][X]}}}return{dataId:l.write(x.toTypedArray(W,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function vl(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;ot(o,"sum");let a;o.dtype==="bool"?a=Ro({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=qr({inputs:{x:o},backend:e});let u=a.shape.length,l=x.parseAxisParam(s,a.shape),c=S.getAxesPermutation(l,u),p=l,m=a;c!=null&&(m=He({inputs:{x:a},backend:e,attrs:{perm:c}}),p=S.getInnerMostAxes(p.length,u)),S.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[f,d]=S.computeOutAndReduceShapes(m.shape,p),h=S.upcastType(m.dtype,"int32"),g=od(e,f,h),y=x.sizeFromShape(d),b=e.data.get(g.dataId).values,w=e.data.get(m.dataId).values;for(let v=0;v<b.length;++v){let k=v*y,E=0;for(let $=0;$<y;++$)E+=w[k+$];b[v]=E}if(i){let v=S.expandShapeToKeepDim(g.shape,l),k=g;g=te({inputs:{x:g},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(k)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(m),g}var cO={kernelName:zs,backendName:"cpu",kernelFunc:vl};function q9(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(y)?w=s[g]:(w=He({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),d.push(w));let v=w.shape.slice();for(let k=0;k<b.length;++k)v.splice(b[k],0,1);x.arraysEqual(w.shape,v)||(w=te({inputs:{x:w},backend:e,attrs:{shape:v}}),d.push(w)),m===null?m=w:(m=jc({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=vl({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var pO={kernelName:Gp,backendName:"cpu",kernelFunc:q9};function K9(r){let{inputs:t,backend:e}=r,{dy:n,y:o}=t;ot([n,o],"eluGrad");let s=new Float32Array(x.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let l=i[u];l>=1?s[u]=a[u]:s[u]=a[u]*(l+1)}return e.makeTensorInfo(o.shape,"float32",s)}var mO={kernelName:Wp,backendName:"cpu",kernelFunc:K9};var j9=S.ERF_P,X9=S.ERF_A1,Y9=S.ERF_A2,Z9=S.ERF_A3,J9=S.ERF_A4,Q9=S.ERF_A5,tJ=Et(da,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+j9*e);return t*(1-((((Q9*n+J9)*n+Z9)*n+Y9)*n+X9)*n*Math.exp(-e*e))}),fO={kernelName:da,backendName:"cpu",kernelFunc:tJ};function pd(r){let{inputs:t,backend:e,attrs:n}=r,{input:o}=t,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(x.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),te({inputs:{x:o},backend:e,attrs:{shape:a}})}var dO={kernelName:Ii,backendName:"cpu",kernelFunc:pd};var eJ=re((r,t)=>r/t),xg=ie(ls,eJ),yg={kernelName:ls,backendName:"cpu",kernelFunc:xg};function aw(r,t,e){let n=r.shape,o=n[0],s=n[1],i=e.data.get(r.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[o,s],c=x.sizeFromShape(l),p=x.getTypedArrayFromDType("float32",c),m=x.getTypedArrayFromDType("float32",c);for(let g=0;g<o;g++){let y=Mo({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),b=Mo({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,s]}}),w=Ir({inputs:{real:y,imag:b},backend:e}),{real:v,imag:k}=rJ(w,t,e),E=S.mergeRealAndImagArrays(v,k);for(let $=0;$<s;$++){let D=S.getComplexWithIndex(E,$);p[g*s+$]=D.real,m[g*s+$]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w)}let f=e.makeTensorInfo(l,"float32",p),d=e.makeTensorInfo(l,"float32",m),h=Ir({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}function rJ(r,t,e){let n=x.sizeFromShape(r.shape),o=e.data.get(r.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(nJ(n)){let a=$N(s,i,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let l=e.makeTensorInfo(u,"float32",a.real),c=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",x.createScalarValue(n,"float32")),m=qr({inputs:{x:p},backend:e}),f=yg.kernelFunc({inputs:{a:l,b:p},backend:e}),d=yg.kernelFunc({inputs:{a:c,b:m},backend:e}),h=e.data.get(f.dataId).values,g=e.data.get(d.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),u=oJ(a,n,t);return S.splitRealAndImagArrays(u)}}function nJ(r){return(r&r-1)===0}function $N(r,t,e,n,o){if(e===1)return{real:r,imag:t};let s=S.mergeRealAndImagArrays(r,t),i=e/2,a=S.complexWithEvenIndex(s),u=a.real,l=a.imag,c=[u.length],p=o.makeTensorInfo(c,"float32",u),m=o.makeTensorInfo(c,"float32",l),f=Ir({inputs:{real:p,imag:m},backend:o}),d=S.complexWithOddIndex(s),h=d.real,g=d.imag,y=[h.length],b=o.makeTensorInfo(y,"float32",h),w=o.makeTensorInfo(y,"float32",g),v=Ir({inputs:{real:b,imag:w},backend:o}),k=$N(u,l,i,n,o),E=k.real,$=k.imag,D=[E.length],F=o.makeTensorInfo(D,"float32",E),P=o.makeTensorInfo(D,"float32",$),W=Ir({inputs:{real:F,imag:P},backend:o}),U=$N(h,g,i,n,o),q=U.real,K=U.imag,j=[q.length],Q=o.makeTensorInfo(j,"float32",q),rt=o.makeTensorInfo(j,"float32",K),X=Ir({inputs:{real:Q,imag:rt},backend:o}),nt=S.exponents(e,n),st=[nt.real.length],it=o.makeTensorInfo(st,"float32",nt.real),ft=o.makeTensorInfo(st,"float32",nt.imag),at=Ir({inputs:{real:it,imag:ft},backend:o}),xt=jc({inputs:{a:at,b:X},backend:o}),dt=Zi({inputs:{a:W,b:xt},backend:o}),bt=hg({inputs:{a:W,b:xt},backend:o}),kt=Fo({inputs:{input:dt},backend:o}),At=Fo({inputs:{input:bt},backend:o}),Dt=Ji({inputs:{input:dt},backend:o}),qt=Ji({inputs:{input:bt},backend:o}),Kt=bu({inputs:[kt,At],backend:o,attrs:{axis:0}}),ce=bu({inputs:[Dt,qt],backend:o,attrs:{axis:0}}),Ot=o.data.get(Kt.dataId).values,$e=o.data.get(ce.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(F),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(rt),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(it),o.disposeIntermediateTensorInfo(ft),o.disposeIntermediateTensorInfo(at),o.disposeIntermediateTensorInfo(xt),o.disposeIntermediateTensorInfo(dt),o.disposeIntermediateTensorInfo(bt),o.disposeIntermediateTensorInfo(kt),o.disposeIntermediateTensorInfo(Dt),o.disposeIntermediateTensorInfo(At),o.disposeIntermediateTensorInfo(qt),o.disposeIntermediateTensorInfo(Kt),o.disposeIntermediateTensorInfo(ce),{real:Ot,imag:$e}}function oJ(r,t,e){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let u=S.exponent(o*a,t,e),l=S.getComplexWithIndex(r,a);s+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}e&&(s/=t,i/=t),S.assignToTypedArray(n,s,i,o)}return n}function sJ(r){let{inputs:t,backend:e}=r,{input:n}=t,o=x.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=te({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=aw(a,!1,e),l=te({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var hO={kernelName:Up,backendName:"cpu",kernelFunc:sJ};function bg(r){let{backend:t,attrs:e}=r,{shape:n,value:o,dtype:s}=e,i=s||x.inferDtype(o),a=x.getArrayFromDType(i,x.sizeFromShape(n));return iJ(a,o,i),t.makeTensorInfo(n,i,a)}var gO={kernelName:Pl,backendName:"cpu",kernelFunc:bg};function iJ(r,t,e){r.fill(t)}var xO={kernelName:xa,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,o=e,s=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(n.shape)),[i,a,u,l]=n.shape,c=o.data.get(n.dataId).values;for(let m=0;m<i;m++){let f=m*u*a*l;for(let d=0;d<a;d++){let h=d*(u*l);for(let g=0;g<u;g++){let y=g*l;for(let b=0;b<l;b++){let w=Math.round(u-g-1),v=f+h+y+b,k=c[v];if(w>=0&&w<u){let E=w*l,$=f+h+E+b;k=c[$]}s[v]=k}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var aJ=re((r,t)=>Math.floor(r/t)),lJ=ie(ms,aJ,null,"int32"),yO={kernelName:ms,backendName:"cpu",kernelFunc:lJ};function uJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=EN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=te({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});h=Zi({inputs:{a:h,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else h=Zi({inputs:{a:h,b:i},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=ud(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var bO={kernelName:Mi,backendName:"cpu",kernelFunc:uJ};function cJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=AN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;h=Zi({inputs:{a:h,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=ud(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var wO={kernelName:Pi,backendName:"cpu",kernelFunc:cJ};function pJ(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=x.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[u,l,c,p]=S.prepareAndValidate(n,o);if(l===0)return e.makeTensorInfo(u,n.dtype,[]);let m=e.data.get(o.dataId).values,f=e.bufferSync(n),d=Hb(m,f,n.dtype,l,a,c,p,n.shape,s);return e.makeTensorInfo(u,n.dtype,d.values)}var vO={kernelName:ya,backendName:"cpu",kernelFunc:pJ};function mJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n;ot([o,s],"gatherV2");let u=x.parseAxisParam(i,o.shape)[0],l=e.data.get(s.dataId).values,c=o.shape[u];for(let v=0;v<l.length;++v){let k=l[v];x.assert(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let m=x.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,u,p),d=te({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=te({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],y=e.bufferSync(h),b=e.bufferSync(d),w=qb(b,y,g);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.makeTensorInfo(f.outputShape,w.dtype,w.values)}var CO={kernelName:Si,backendName:"cpu",kernelFunc:mJ};function fJ(r){let{inputs:t,backend:e}=r,{input:n}=t,o=x.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=te({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=aw(a,!0,e),l=te({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var IO={kernelName:Hp,backendName:"cpu",kernelFunc:fJ};var dJ=Et(wa,r=>Number.isFinite(r)?1:0,"bool"),SO={kernelName:wa,backendName:"cpu",kernelFunc:dJ};var hJ=Et(va,r=>Math.abs(r)===1/0?1:0,"bool"),kO={kernelName:va,backendName:"cpu",kernelFunc:hJ};var gJ=Et(Ca,r=>Number.isNaN(r)?1:0,"bool"),NO={kernelName:Ca,backendName:"cpu",kernelFunc:gJ};function xJ(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=Kb(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var TO={kernelName:Kp,backendName:"cpu",kernelFunc:xJ};var yJ=Et(ka,r=>Math.log1p(r)),_O={kernelName:ka,backendName:"cpu",kernelFunc:yJ};var bJ=re((r,t)=>r&&t),wJ=ie(Na,bJ,null,"bool"),EO={kernelName:Na,backendName:"cpu",kernelFunc:wJ};var vJ=Et(Lu,r=>r?0:1,"bool"),AO={kernelName:Lu,backendName:"cpu",kernelFunc:vJ};var CJ=re((r,t)=>r||t),IJ=ie(zu,CJ,null,"bool"),$O={kernelName:zu,backendName:"cpu",kernelFunc:IJ};function SJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n;ot(o,"LRN");let l=o.shape[3],c=l-1,p=e.data.get(o.dataId).values,m=x.sizeFromShape(o.shape),f=new Float32Array(m);function d(h){let g=h%l,y=h-g+Math.max(0,g-s),b=h-g+Math.min(g+s,c),w=0;for(;y<=b;y++){let v=p[y];w+=v*v}return w}for(let h=0;h<m;h++){let g=d(h),y=p[h]*Math.pow(i+a*g,-u);f[h]=y}return e.makeTensorInfo(o.shape,o.dtype,f)}var DO={kernelName:Ll,backendName:"cpu",kernelFunc:SJ};function kJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n;ot(i,"LRNGrad");let p=x.sizeFromShape(i.shape),m=i.shape[3],f=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=e.data.get(s.dataId).values,g=new Float32Array(p),y=p;for(let b=0;b<y;b++){let w=b%m,v=b-w+Math.max(0,w-a),k=b-w+Math.min(m,w+a+1),E=0;for(let $=v;$<k;$++)E+=Math.pow(d[$],2);E=l*E+u;for(let $=v;$<k;$++){let D=-2*l*c*d[$]*h[b]/E;b===$&&(D+=Math.pow(E,-c)),D*=f[b],g[$]+=D}}return e.makeTensorInfo(i.shape,o.dtype,g)}var FO={kernelName:jp,backendName:"cpu",kernelFunc:kJ};function DN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=e,u=o.shape,l=u.length,c=x.parseAxisParam(s,u),p=c,m=S.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(m!=null){let v=new Array(l);for(let k=0;k<v.length;k++)v[k]=u[m[k]];f=ad(f,u,o.dtype,m,v),p=S.getInnerMostAxes(p.length,l),u=v}ot(o,"max"),S.assertAxesAreInnerMostDims("max",p,l);let[d,h]=S.computeOutAndReduceShapes(u,p),g=x.sizeFromShape(h),y=jb(f,g,d,o.dtype),b=a.write(y,d,o.dtype),w=d;return i&&(w=S.expandShapeToKeepDim(d,c)),{dataId:b,shape:w,dtype:o.dtype}}var RO={kernelName:xs,backendName:"cpu",kernelFunc:DN};function NJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;ot(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))p=qr({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=x.computeStrides(o.shape),d=cd(m,o.shape,o.dtype,f,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var OO={kernelName:bs,backendName:"cpu",kernelFunc:NJ};function TJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;ot(o,"maxPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=iw(p,o.shape,o.dtype,x.computeStrides(o.shape),c,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}var MO={kernelName:zl,backendName:"cpu",kernelFunc:TJ};function _J(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;ot([o,s],"maxPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=e.bufferSync(s),m=$R(p,c),f=c.strideDepth,d=c.strideHeight,h=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,E=w-1-c.padInfo.front,$=k-1-c.padInfo.left,D=v-1-c.padInfo.top,F=Ct(s.shape,"float32"),P=e.bufferSync(o);for(let W=0;W<c.batchSize;++W)for(let U=0;U<c.inChannels;++U)for(let q=0;q<c.inDepth;++q)for(let K=0;K<c.inHeight;++K)for(let j=0;j<c.inWidth;++j){let Q=q-E,rt=K-D,X=j-$,nt=0;for(let st=0;st<w;st+=g){let it=(Q+st)/f;if(!(it<0||it>=c.outDepth||Math.floor(it)!==it))for(let ft=0;ft<v;ft+=y){let at=(rt+ft)/d;if(!(at<0||at>=c.outHeight||Math.floor(at)!==at))for(let xt=0;xt<k;xt+=b){let dt=(X+xt)/h;if(dt<0||dt>=c.outWidth||Math.floor(dt)!==dt)continue;let bt=w*v*k-1-m.get(W,it,at,dt,U),kt=st*v*k+ft*k+xt,At=bt===kt?1:0;if(At===0)continue;nt+=P.get(W,it,at,dt,U)*At}}}F.set(nt,W,q,K,j,U)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}var PO={kernelName:Yp,backendName:"cpu",kernelFunc:_J};function EJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;ot([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=e.data.get(a.dataId).values,d=Ct(m.outShape,a.dtype,sw(f,a.shape,a.dtype,m).values),h=m.strideHeight,g=m.strideWidth,y=m.dilationHeight,b=m.dilationWidth,w=m.effectiveFilterHeight,v=m.effectiveFilterWidth,k=v-1-m.padInfo.left,E=w-1-m.padInfo.top,$=Ct(a.shape,"float32"),D=e.data.get(o.dataId).values,F=Ct(o.shape,"float32",D);for(let P=0;P<m.batchSize;++P)for(let W=0;W<m.inChannels;++W)for(let U=0;U<m.inHeight;++U)for(let q=0;q<m.inWidth;++q){let K=U-E,j=q-k,Q=0;for(let rt=0;rt<w;rt+=y){let X=(K+rt)/h;if(!(X<0||X>=m.outHeight||Math.floor(X)!==X))for(let nt=0;nt<v;nt+=b){let st=(j+nt)/g;if(st<0||st>=m.outWidth||Math.floor(st)!==st)continue;let it=w*v-1-d.get(P,X,st,W),ft=rt*v+nt,at=it===ft?1:0;if(at===0)continue;Q+=F.get(P,X,st,W)*at}}$.set(Q,P,U,q,W)}return e.makeTensorInfo($.shape,$.dtype,$.values)}var LO={kernelName:Xp,backendName:"cpu",kernelFunc:EJ};function zO(r,t,e,n,o){let s=x.computeStrides(t),i=cd(r,t,e,s,o,"max"),a=sw(r,t,e,o,!0,n);return[i.values,a.values]}var BO={kernelName:Zp,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;ot(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,c=S.computePool2DInfo(n.shape,o,s,[1,1],i),[p,m]=zO(l,n.shape,n.dtype,a,c),f=u.write(p,c.outShape,n.dtype),d=u.write(m,c.outShape,n.dtype);return[{dataId:f,shape:c.outShape,dtype:n.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function AJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=x.parseAxisParam(s,o.shape),l=S.computeOutAndReduceShapes(o.shape,a)[1],c=x.sizeFromShape(l),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(m);let f=Ro({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(f);let d=xg({inputs:{a:f,b:m},backend:e});p.push(d);let h=vl({inputs:{x:d},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var VO={kernelName:ws,backendName:"cpu",kernelFunc:AJ};function $J(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;ot(o,"min");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];(Number.isNaN(k)||k<w)&&(w=k)}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=te({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var GO={kernelName:vs,backendName:"cpu",kernelFunc:$J};function DJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,mode:i}=n;ot(o,"mirrorPad");let a=s.map((w,v)=>w[0]+o.shape[v]+w[1]),u=s.map(w=>w[0]),l=s.map((w,v)=>w[0]+o.shape[v]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,m=o.shape.length,f=x.computeStrides(o.shape),d=x.sizeFromShape(a),h=a.length,g=x.computeStrides(a),y=x.getTypedArrayFromDType(o.dtype,d);for(let w=0;w<d;w++){let v=x.indexToLoc(w,h,g);for(let E=0;E<h;E++)v[E]<u[E]?v[E]=u[E]*2-v[E]-c:v[E]>=l[E]&&(v[E]=(l[E]-1)*2-v[E]+c);v=v.map((E,$)=>E-u[$]);let k=x.locToIndex(v,m,f);y[w]=p[k]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var WO={kernelName:Is,backendName:"cpu",kernelFunc:DJ};var FJ=re((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),RJ=ie(Ta,FJ),UO={kernelName:Ta,backendName:"cpu",kernelFunc:RJ};var qO=Ou(gS());function FN(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let u=x.parseAxisParam([a],o.shape),l=DN({inputs:{x:o},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),c=S.expandShapeToKeepDim(l.shape,u),p=te({inputs:{x:l},backend:e,attrs:{shape:c}}),m=hg({inputs:{a:o,b:p},backend:e}),f=sN({inputs:{x:m},backend:e}),d=vl({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),h=te({inputs:{x:d},backend:e,attrs:{shape:c}}),g=xg({inputs:{a:f,b:h},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var HO={kernelName:Bs,backendName:"cpu",kernelFunc:FN};function OJ(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n;ot(o,"multinomial");let u=a?o:FN({inputs:{logits:o},backend:e,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],p=e.data.get(u.dataId).values,m=[l,s],f=x.makeZerosTypedArray(x.sizeFromShape(m),"int32");for(let d=0;d<l;++d){let h=d*c,g=new Float32Array(c-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let y=qO.alea(i.toString()),b=d*s;for(let w=0;w<s;++w){let v=y();f[b+w]=g.length;for(let k=0;k<g.length;k++)if(v<g[k]){f[b+w]=k;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(m,"int32",f)}var KO={kernelName:Jp,backendName:"cpu",kernelFunc:OJ};var MJ=Gr.nonMaxSuppressionV3Impl;function PJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n;ot(o,"NonMaxSuppression");let l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=MJ(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var jO={kernelName:Ea,backendName:"cpu",kernelFunc:PJ};var LJ=Gr.nonMaxSuppressionV4Impl;function zJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n;ot(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=LJ(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var XO={kernelName:Aa,backendName:"cpu",kernelFunc:zJ};var BJ=Gr.nonMaxSuppressionV5Impl;function VJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n;ot(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=BJ(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var YO={kernelName:$a,backendName:"cpu",kernelFunc:VJ};function GJ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n;ot(o,"oneHot");let u=x.sizeFromShape(o.shape),l=new Float32Array(u*s);l.fill(a);let c=e.data.get(o.dataId).values;for(let p=0;p<u;++p)c[p]>=0&&c[p]<s&&(l[p*s+c[p]]=i);return e.makeTensorInfo([...o.shape,s],"int32",l)}var ZO={kernelName:ks,backendName:"cpu",kernelFunc:GJ};function wg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Fo({inputs:{input:n},backend:e}),s=wg({inputs:{x:o},backend:e}),i=Ji({inputs:{input:n},backend:e}),a=wg({inputs:{x:i},backend:e}),u=Ir({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return bg({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var JO={kernelName:Ri,backendName:"cpu",kernelFunc:wg};function QO(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Fo({inputs:{input:n},backend:e}),s=QO({inputs:{x:o},backend:e}),i=Ji({inputs:{input:n},backend:e}),a=wg({inputs:{x:i},backend:e}),u=Ir({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return bg({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var tM={kernelName:Ni,backendName:"cpu",kernelFunc:QO};function RN(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return pd({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=pd({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=bu({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var eM={kernelName:Ti,backendName:"cpu",kernelFunc:RN};function WJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;ot(o,"pad");let a=s.map((b,w)=>b[0]+o.shape[w]+b[1]),u=s.map(b=>b[0]),l=e.data.get(o.dataId).values,c=x.sizeFromShape(o.shape),p=o.shape.length,m=x.computeStrides(o.shape),f=x.sizeFromShape(a),d=a.length,h=x.computeStrides(a),g=x.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let b=0;b<c;b++){let v=x.indexToLoc(b,p,m).map((E,$)=>E+u[$]),k=x.locToIndex(v,d,h);g[k]=l[b]}return{dataId:e.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var lw={kernelName:Ns,backendName:"cpu",kernelFunc:WJ};var UJ=re((r,t)=>Math.pow(r,t)),HJ=ie(Ts,UJ),rM={kernelName:Ts,backendName:"cpu",kernelFunc:HJ};function qJ(r){let{backend:t,attrs:e}=r,{start:n,stop:o,dtype:s,step:i}=e,a=Xc(n,o,i,s);return t.makeTensorInfo([a.length],s,a)}var nM={kernelName:Bl,backendName:"cpu",kernelFunc:qJ};var KJ=Et(Da,r=>1/r),oM={kernelName:Da,backendName:"cpu",kernelFunc:KJ};function jJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;ot(o,"resizeBilinear");let u=x.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(x.sizeFromShape([p,l,c,d])),y=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=0,v=y[0]/b[0],k=y[1]/b[1];for(let E=0;E<p;E++)for(let $=0;$<l;$++){let D;i?D=v*($+.5)-.5:D=v*$;let F=Math.max(0,Math.floor(D)),P=D-F,W=Math.min(m-1,Math.ceil(D)),U=E*u[0]+F*u[1],q=E*u[0]+W*u[1];for(let K=0;K<c;K++){let j;i?j=k*(K+.5)-.5:j=k*K;let Q=Math.max(0,Math.floor(j)),rt=j-Q,X=Math.min(f-1,Math.ceil(j)),nt=U+Q*u[2],st=q+Q*u[2],it=U+X*u[2],ft=q+X*u[2];for(let at=0;at<d;at++){let xt=h[nt+at],dt=h[st+at],bt=h[it+at],kt=h[ft+at],At=xt+(bt-xt)*rt,Dt=dt+(kt-dt)*rt,qt=At+(Dt-At)*P;g[w++]=qt}}}return e.makeTensorInfo([p,l,c,d],"float32",g)}var sM={kernelName:$s,backendName:"cpu",kernelFunc:jJ};function XJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;ot([s,o],"resizeBilinearGrad");let a=x.computeStrides(o.shape),[u,l,c,p]=o.shape,[,m,f]=s.shape,d=new Float32Array(u*l*c*p),h=[i&&m>1?l-1:l,i&&f>1?c-1:c],g=[i&&m>1?m-1:m,i&&f>1?f-1:f],y=h[0]/g[0],b=h[1]/g[1],w=e.data.get(s.dataId).values,v=0;for(let k=0;k<u;k++){let E=k*a[0];for(let $=0;$<m;$++){let D=$*y,F=Math.floor(D),P=Math.min(Math.ceil(D),l-1),W=E+F*a[1],U=E+P*a[1],q=D-F,K=1-q;for(let j=0;j<f;j++){let Q=j*b,rt=Math.floor(Q),X=Math.min(Math.ceil(Q),c-1),nt=Q-rt,st=1-nt,it=W+rt*a[2],ft=W+X*a[2],at=U+rt*a[2],xt=U+X*a[2],dt=K*st,bt=K*nt,kt=q*st,At=q*nt;for(let Dt=0;Dt<p;Dt++){let qt=w[v++];d[it+Dt]+=qt*dt,d[ft+Dt]+=qt*bt,d[at+Dt]+=qt*kt,d[xt+Dt]+=qt*At}}}}return e.makeTensorInfo([u,c,l,p],"float32",d)}var iM={kernelName:em,backendName:"cpu",kernelFunc:XJ};function YJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;ot(o,"resizeNearestNeighbor");let u=x.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(p*l*c*d),y=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=y[0]/b[0],v=y[1]/b[1],k=0;for(let E=0;E<p;E++){let $=E*u[0];for(let D=0;D<l;D++){let F=i?w*(D+.5):w*D,P=Math.min(m-1,s?Math.round(F):Math.floor(F));i&&(P=Math.max(0,P));let W=$+P*u[1];for(let U=0;U<c;U++){let q=i?v*(U+.5):v*U,K=Math.min(f-1,s?Math.round(q):Math.floor(q));i&&(K=Math.max(0,K));let j=W+K*u[2];for(let Q=0;Q<d;Q++){let rt=h[j+Q];g[k++]=rt}}}}return e.makeTensorInfo([p,l,c,d],o.dtype,g)}var aM={kernelName:Vl,backendName:"cpu",kernelFunc:YJ};function ZJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;ot([s,o],"resizeNearestNeighborGrad");let a=x.computeStrides(o.shape),u=x.computeStrides(s.shape),[l,c,p,m]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*c*p*m),g=e.data.get(s.dataId).values,y=[i&&f>1?c-1:c,i&&d>1?p-1:p],b=[i&&f>1?f-1:f,i&&d>1?d-1:d],w=y[0]/b[0],v=y[1]/b[1],k=1/w,E=1/v,$=Math.ceil(k)*2+2,D=Math.ceil(E)*2+2;for(let F=0;F<l;F++){let P=F*a[0];for(let W=0;W<c;W++){let U=P+W*a[1],q=Math.floor(W*k),K=Math.floor(q-$/2);for(let j=0;j<p;j++){let Q=U+j*a[2],rt=Math.floor(j*E),X=Math.floor(rt-D/2);for(let nt=0;nt<m;nt++){let st=0;for(let it=0;it<$;it++){let ft=it+K;if(ft<0||ft>=f)continue;let at=P+ft*u[1],xt=ft*w,dt=Math.min(c-1,i?Math.round(xt):Math.floor(xt));if(W===dt)for(let bt=0;bt<D;bt++){let kt=bt+X;if(kt<0||kt>=d)continue;let At=at+kt*u[2],Dt=kt*v,qt=Math.min(p-1,i?Math.round(Dt):Math.floor(Dt));j===qt&&(st+=g[At+nt])}}h[Q+nt]=st}}}}return e.makeTensorInfo(o.shape,o.dtype,h)}var lM={kernelName:tm,backendName:"cpu",kernelFunc:ZJ};function JJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n;ot(o,"reverse");let i=o.shape.length,a=x.parseAxisParam(s,o.shape);if(i===0)return qr({inputs:{x:o},backend:e});let u=new pe(o.shape,o.dtype),l=e.bufferSync(o);for(let c=0;c<u.size;c++){let p=u.indexToLoc(c),m=p.slice();a.forEach(f=>m[f]=o.shape[f]-1-m[f]),u.set(l.get(...m),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var uM={kernelName:Fs,backendName:"cpu",kernelFunc:JJ};var cM={kernelName:Ga,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(n.shape)),[l,c,p,m]=n.shape,[f,d]=S.getImageCenter(i,c,p),h=255,g=Math.sin(o),y=Math.cos(o),b=a.data.get(n.dataId).values;for(let v=0;v<l;v++){let k=v*p*c*m;for(let E=0;E<c;E++){let $=E*(p*m);for(let D=0;D<p;D++){let F=D*m;for(let P=0;P<m;P++){let W=[l,E,D,P],U=W[2],q=W[1],K=(U-f)*y-(q-d)*g,j=(U-f)*g+(q-d)*y;K=Math.round(K+f),j=Math.round(j+d);let Q=s;if(typeof s!="number"&&(P===3?Q=h:Q=s[P]),K>=0&&K<p&&j>=0&&j<c){let X=j*(p*m),nt=K*m,st=k+X+nt+P;Q=b[st]}let rt=k+$+F+P;u[rt]=Q}}}}return{dataId:a.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var QJ=Et(Rs,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),pM={kernelName:Rs,backendName:"cpu",kernelFunc:QJ};function tQ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=!0,f=e.bufferSync(o),d=e.bufferSync(s),h=wl(f,d,i,p,l,u,a,c,0,m);return e.makeTensorInfo(i,h.dtype,h.values)}var mM={kernelName:Fa,backendName:"cpu",kernelFunc:tQ};function eQ(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<t?e=o+1:n=o;return n}function rQ(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<=t?e=o+1:n=o;return n}function fM(r,t,e,n,o,s){let i=x.getArrayFromDType("int32",e*o);for(let a=0;a<e;++a){let u=r.slice(a*n,(a+1)*n),l=a*o;for(let c=0;c<o;++c)i[l+c]=s==="left"?eQ(u,t[c+l]):rQ(u,t[c+l])}return i}function nQ(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=fM(a,u,o.shape[0],o.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",l)}var dM={kernelName:rm,backendName:"cpu",kernelFunc:nQ};function oQ(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t;ot([n,o,s],"select");let i=n.shape.length,a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=ar(o.dtype,s.dtype),p=x.makeZerosTypedArray(x.sizeFromShape(o.shape),c),m=0,f=i===0||i>1||o.shape.length===1?1:x.sizeFromShape(o.shape.slice(1));for(let d=0;d<a.length;d++)for(let h=0;h<f;h++)a[d]===1?p[m++]=u[d]:p[m++]=l[d];return e.makeTensorInfo(o.shape,c,p)}var hM={kernelName:Ei,backendName:"cpu",kernelFunc:oQ};var sQ=S.SELU_SCALEALPHA,iQ=S.SELU_SCALE,aQ=Et(Ra,r=>r>=0?iQ*r:sQ*(Math.exp(r)-1)),gM={kernelName:Ra,backendName:"cpu",kernelFunc:aQ};var lQ=Et(Ma,r=>r<0?-1:r>0?1:0),xM={kernelName:Ma,backendName:"cpu",kernelFunc:lQ};var uQ=Et(Ms,r=>Math.sin(r)),yM={kernelName:Ms,backendName:"cpu",kernelFunc:uQ};var cQ=Et(Oa,r=>Math.sinh(r)),bM={kernelName:Oa,backendName:"cpu",kernelFunc:cQ};var pQ=11920928955078125e-23,wM=Math.log(pQ)+2,mQ=Et(Pa,r=>{let t=r>-wM,e=r<wM,n=Math.exp(r),o;return e?o=n:t?o=r:o=Math.log(1+n),o}),vM={kernelName:Pa,backendName:"cpu",kernelFunc:mQ};function fQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;ot([o],"spaceToBatchND");let a=x.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=lw.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=te({inputs:{x:l},backend:e,attrs:{shape:c}}),b=He({inputs:{x:h},backend:e,attrs:{perm:p}}),k=te({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(b),k}var CM={kernelName:$i,backendName:"cpu",kernelFunc:fQ};function dQ(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,m,f,d,h]=Xb(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var IM={kernelName:Gl,backendName:"cpu",kernelFunc:dQ};function hQ(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(n.dataId).values,u=Array.from(e.data.get(s.dataId).values),[l,c,p]=Yb(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var SM={kernelName:La,backendName:"cpu",kernelFunc:hQ};function gQ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=ld(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var kM={kernelName:Wl,backendName:"cpu",kernelFunc:gQ};function xQ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=ld(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var NM={kernelName:Ul,backendName:"cpu",kernelFunc:xQ};function yQ(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,o,a),f=!1,d=e.bufferSync(o),h;switch(s.dtype){case"bool":{let g=e.bufferSync(s),y=Boolean(e.data.get(i.dataId).values[0]);h=wl(d,g,a,m,c,l,u,p,y,f);break}case"float32":{let g=e.bufferSync(s),y=e.data.get(i.dataId).values[0];h=wl(d,g,a,m,c,l,u,p,y,f);break}case"int32":{let g=e.bufferSync(s),y=e.data.get(i.dataId).values[0];h=wl(d,g,a,m,c,l,u,p,y,f);break}case"string":{let g=e.bufferSync(s),y=x.decodeString(e.data.get(i.dataId).values[0]);h=wl(d,g,a,m,c,l,u,p,y,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,h.dtype,h.values)}var TM={kernelName:nm,backendName:"cpu",kernelFunc:yQ};function bQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=Mo({inputs:{x:o},backend:e,attrs:{begin:l,size:m}});return l[a]+=p,f})}var _M={kernelName:Di,backendName:"cpu",kernelFunc:bQ};var EM={kernelName:Hl,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;ot(e,"square");let o=n.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let u=o[a];s[a]=u*u}return{dataId:n.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var wQ=Et(uo,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),AM={kernelName:uo,backendName:"cpu",kernelFunc:wQ};function vQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n;ot(o,"stridedSlice");let{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=te({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Ve.computeOutShape(b,w,v),$=Mo({inputs:{x:o},backend:e,attrs:{begin:b,size:E}});k=te({inputs:{x:$},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo($)}else{let E=e.bufferSync(o),$=Zb(f,E,v,b);k=e.makeTensorInfo(d,$.dtype,$.values)}return k}var $M={kernelName:za,backendName:"cpu",kernelFunc:vQ};function CQ(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.data.get(c.dataId).values,f=e.data.get(p.dataId).values,[d,h]=Jb(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var DM={kernelName:om,backendName:"cpu",kernelFunc:CQ};function IQ(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values[0],[l,c,p]=Qb(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var FM={kernelName:sm,backendName:"cpu",kernelFunc:IQ};function SQ(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=tw(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var RM={kernelName:im,backendName:"cpu",kernelFunc:SQ};var kQ=Et(Ws,r=>Math.tan(r)),OM={kernelName:Ws,backendName:"cpu",kernelFunc:kQ};var NQ=Et(Us,r=>Math.tanh(r)),MM={kernelName:Us,backendName:"cpu",kernelFunc:NQ};function TQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;ot(o,"tile");let i=ew(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var PM={kernelName:Yn,backendName:"cpu",kernelFunc:TQ};function _Q(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n;ot(o,"topk");let a=e.data.get(o.dataId).values,[u,l]=rw(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}var LM={kernelName:Ba,backendName:"cpu",kernelFunc:_Q};function EQ(r){let{inputs:t,attrs:e,backend:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=e,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=x.computeStrides(o.shape),b=y[0],w=y[1],v=y[2],k=x.getTypedArrayFromDType(o.dtype,x.sizeFromShape(g));k.fill(u);let E=n.data.get(o.dataId).values,$=n.data.get(s.dataId).values;for(let F=0;F<c;++F){let P=s.shape[0]===1?$:$.subarray(F*8,F*8+8);for(let W=0;W<d;++W)for(let U=0;U<h;++U)for(let q=0;q<f;++q){let K,j=P[6]*U+P[7]*W+1;if(j===0)continue;let Q=(P[0]*U+P[1]*W+P[2])/j,rt=(P[3]*U+P[4]*W+P[5])/j,X=zM(Q,m,a),nt=zM(rt,p,a);switch(i){case"nearest":K=RQ(E,p,m,b,w,v,F,nt,X,q,u);break;case"bilinear":K=OQ(E,p,m,b,w,v,F,nt,X,q,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let st=F*b+W*w+U*v+q;k[st]=K}return n.makeTensorInfo(g,o.dtype,k)}return{dataId:n.write(k,g,o.dtype),shape:o.shape,dtype:o.dtype}}var BM={kernelName:Va,backendName:"cpu",kernelFunc:EQ};function zM(r,t,e){switch(e){case"reflect":return AQ(r,t);case"wrap":return $Q(r,t);case"nearest":return FQ(r,t);case"constant":default:return DQ(r,t)}}function AQ(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{let n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return x.clamp(0,e,t-1)}function $Q(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{let n=t-1;e-=t*Math.trunc(e/n)}return x.clamp(0,e,t-1)}function DQ(r,t){return r}function FQ(r,t){return x.clamp(0,r,t-1)}function vg(r,t,e,n,o,s,i,a,u,l,c){let p=i*n+a*o+u*s+l;return 0<=a&&a<t&&0<=u&&u<e?r[p]:c}function RQ(r,t,e,n,o,s,i,a,u,l,c){let p=Math.round(a),m=Math.round(u);return vg(r,t,e,n,o,s,i,p,m,l,c)}function OQ(r,t,e,n,o,s,i,a,u,l,c){let p=Math.floor(a),m=Math.floor(u),f=p+1,d=m+1,h=(d-u)*vg(r,t,e,n,o,s,i,p,m,l,c)+(u-m)*vg(r,t,e,n,o,s,i,p,d,l,c),g=(d-u)*vg(r,t,e,n,o,s,i,f,m,l,c)+(u-m)*vg(r,t,e,n,o,s,i,f,d,l,c);return(f-a)*h+(a-p)*g}function MQ(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;ot(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:l}=nw(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var VM={kernelName:am,backendName:"cpu",kernelFunc:MQ};function PQ(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],u=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let m=new Array(a);for(let f=0;f<m.length;f++){c[s]=f;let d=Mo({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});m[f]=te({inputs:{x:d},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(d)}return m}var GM={kernelName:Fi,backendName:"cpu",kernelFunc:PQ};function LQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n;ot(o,"unsortedSegmentSum");let a=o.shape.length,u=s.shape.length,l=[],c=[],p=a-u,m=s;for(let d=0;d<p;++d){let h=pd({inputs:{input:m},backend:e,attrs:{dim:d+1}});m=h,c.push(h)}for(let d=0;d<i;++d){let h=x.createScalarValue(d,"int32"),g=e.makeTensorInfo([],"int32",h),y=nN({inputs:{a:g,b:m},backend:e}),b=Ro({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),w=jc({inputs:{a:b,b:o},backend:e}),v=vl({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});l.push(v),c.push(g),c.push(y),c.push(b),c.push(w),c.push(v)}let f=RN({inputs:l,backend:e,attrs:{axis:0}});return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var WM={kernelName:ql,backendName:"cpu",kernelFunc:LQ};var zQ=[yR,FF,bR,wR,LF,vR,CR,IR,SR,kR,NR,TR,_R,ER,AR,DR,FR,RR,OR,xR,MR,PR,LR,zR,PF,zF,BR,RF,VR,WR,UR,HR,qR,KR,jR,XR,YR,ZR,JR,QR,tO,eO,rO,nO,oO,sO,iO,aO,lO,uO,pO,pR,mO,BF,fO,VF,dO,GF,hO,gO,xO,WF,yO,bO,wO,vO,CO,UF,HF,OF,IO,GR,SO,kO,NO,mR,qF,KF,TO,jF,_O,EO,AO,$O,DO,FO,RO,XF,OO,MO,PO,LO,BO,VO,GO,YF,WO,UO,KO,ZF,JF,jO,XO,YO,QF,ZO,tM,eM,lw,rM,fR,eR,nM,MF,yg,oM,dR,hR,gR,sM,iM,aM,lM,uM,cM,pM,rR,mM,dM,hM,gM,oR,xM,yM,bM,sR,HO,vM,CM,IM,SM,kM,NM,TM,_M,aR,EM,lR,AM,$M,DM,FM,RM,uR,cO,OM,MM,PM,LM,BM,tR,VM,GM,WM,JO];for(let r of zQ)Bu(r);var dd={};Yt(dd,{assertNotComplex:()=>di,bindCanvasToFramebuffer:()=>jQ,bindColorTextureToFramebuffer:()=>kg,bindTextureToProgramUniformSampler:()=>ZN,bindTextureUnit:()=>KM,bindVertexBufferToProgramAttribute:()=>fw,callAndCheck:()=>vt,canBeRepresented:()=>zN,createFragmentShader:()=>VN,createFramebuffer:()=>jN,createProgram:()=>GN,createStaticIndexBuffer:()=>HN,createStaticVertexBuffer:()=>UN,createTexture:()=>qN,createVertexShader:()=>BN,getBatchDim:()=>Il,getExtensionOrThrow:()=>md,getFramebufferErrorMessage:()=>jM,getMaxTexturesInShader:()=>tT,getNumChannels:()=>qQ,getProgramUniformLocation:()=>YN,getProgramUniformLocationOrThrow:()=>XN,getRowsCols:()=>Sl,getShapeAs3D:()=>Ng,getTextureShapeFromLogicalShape:()=>JN,getWebGLDisjointQueryTimerVersion:()=>eT,getWebGLErrorMessage:()=>qM,getWebGLMaxTextureSize:()=>QN,hasExtension:()=>Un,isCapableOfRenderingToFloatTexture:()=>rT,isDownloadFloatTextureEnabled:()=>nT,isReshapeFree:()=>vu,isWebGLFenceEnabled:()=>oT,isWebGLVersionEnabled:()=>hw,linkProgram:()=>WN,logShaderSourceAndInfoLog:()=>mw,resetMaxTextureSize:()=>XQ,resetMaxTexturesInShader:()=>YQ,unbindColorTextureFromFramebuffer:()=>dw,unbindTextureUnit:()=>KQ,validateFramebuffer:()=>fd,validateProgram:()=>Sg,validateTextureSize:()=>KN});var Zc={},ON={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function MN(r,t){Zc[r]=t}function Wn(r,t){if(!(r in Zc)||t!=null){let n=VQ(r,t);if(n!==null)Zc[r]=n;else return console.log("Could not get context for WebGL version",r),null}let e=Zc[r];return e==null||e.isContextLost()?(delete Zc[r],Wn(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Zc[r])}function BQ(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function VQ(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t==null?BQ(r):t;return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Zc[r]},!1),r===1?e.getContext("webgl",ON)||e.getContext("experimental-webgl",ON):e.getContext("webgl2",ON)}var wu;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(wu||(wu={}));var Kr;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(Kr||(Kr={}));var Rr;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Rr||(Rr={}));function Jc(r,t){return[t,r]}function UM(r,t){return r*t}function Cg(r){let t=x.sizeFromShape(r),e=Math.ceil(t/4);return x.sizeToSquarishShape(e)}function Qi(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function HM(r,t){let[e,n]=Qi(r,t);return e*n*4}function Ig(r,t){let e=r,n,o,s,i,a,u,l,c,p,m;return V().getNumber("WEBGL_VERSION")===2?(n=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,l=4,c=1,p=e.HALF_FLOAT,m=e.FLOAT,u=e.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=e.RGBA,a=r.RGBA,l=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,m=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function vt(r,t){let e=t();return V().getBool("DEBUG")&&GQ(r),e}function GQ(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+qM(r,t))}var WQ=596e-10,UQ=65504;function zN(r){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||WQ<Math.abs(r)&&Math.abs(r)<UQ)}function qM(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function md(r,t){return Cl(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function BN(r,t){let e=Cl(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(vt(r,()=>r.shaderSource(e,t)),vt(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function VN(r,t){let e=Cl(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(vt(r,()=>r.shaderSource(e,t)),vt(r,()=>r.compileShader(e)),V().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw mw(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var HQ=/ERROR: [0-9]+:([0-9]+):/g;function mw(r,t){let e=HQ.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((p,m)=>x.rightPad((m+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${x.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function GN(r){return Cl(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function WN(r,t){if(vt(r,()=>r.linkProgram(t)),!V().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Sg(r,t){if(vt(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function UN(r,t){let e=Cl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),vt(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function HN(r,t){let e=Cl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return vt(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),vt(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function qQ(){return V().getNumber("WEBGL_VERSION")===2?1:4}function qN(r){return Cl(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function KN(r,t){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function jN(r){return Cl(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function fw(r,t,e,n,o,s,i){let a=r.getAttribLocation(t,e);return a===-1?!1:(vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),vt(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),vt(r,()=>r.enableVertexAttribArray(a)),!0)}function KM(r,t,e){XM(r,e),vt(r,()=>r.activeTexture(r.TEXTURE0+e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function KQ(r,t){XM(r,t),vt(r,()=>r.activeTexture(r.TEXTURE0+t)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function XN(r,t,e){return Cl(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function YN(r,t,e){return r.getUniformLocation(t,e)}function ZN(r,t,e,n){vt(r,()=>KM(r,t,n)),vt(r,()=>r.uniform1i(e,n))}function jQ(r){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),vt(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),vt(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function kg(r,t,e){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),vt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function dw(r,t){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),vt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function fd(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+jM(r,t))}function jM(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Cl(r,t,e){let n=vt(r,()=>t());if(n==null)throw new Error(e);return n}function XM(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Il(r,t=2){return x.sizeFromShape(r.slice(0,r.length-t))}function Sl(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Ng(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[Il(r),...Sl(r)]),t}function JN(r,t=!1){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,r=r.map((o,s)=>s>=r.length-2?x.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=x.squeezeShape(r).newShape);let n=x.sizeFromShape(r);if(r.length<=1&&n<=e)return[1,n];if(r.length===2&&r[0]<=e&&r[1]<=e)return r;if(r.length===3&&r[0]*r[1]<=e&&r[2]<=e)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=e&&r[1]*r[2]<=e)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e)return[r[0],r[1]*r[2]*r[3]];if(t){let o=Il(r),s=2,i=2;return r.length&&([s,i]=Sl(r)),n=o*(s/2)*(i/2),x.sizeToSquarishShape(n).map(a=>a*2)}return x.sizeToSquarishShape(n)}function uw(r){return r%2===0}function vu(r,t){if(r=r.slice(-2),t=t.slice(-2),x.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],n=t.slice(-1)[0];if(e===n||uw(e)&&uw(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&uw(r[0])&&uw(t[0])}var cw,pw;function QN(r){if(cw==null){let t=Wn(r);cw=t.getParameter(t.MAX_TEXTURE_SIZE)}return cw}function XQ(){cw=null}function YQ(){pw=null}function tT(r){if(pw==null){let t=Wn(r);pw=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,pw)}function eT(r){if(r===0)return 0;let t,e=Wn(r);return Un(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Un(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Un(r,t){return r.getExtension(t)!=null}function hw(r){try{if(Wn(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function rT(r){if(r===0)return!1;let t=Wn(r);if(r===1){if(!Un(t,"OES_texture_float"))return!1}else if(!Un(t,"EXT_color_buffer_float"))return!1;return LN(t)}function nT(r){if(r===0)return!1;let t=Wn(r);if(r===1){if(!Un(t,"OES_texture_float")||!Un(t,"WEBGL_color_buffer_float"))return!1}else{if(Un(t,"EXT_color_buffer_float"))return LN(t);let n="EXT_color_buffer_half_float";if(Un(t,n)){let o=t.getExtension(n);return ZQ(t,o)}return!1}return LN(t)}function LN(r){let t=Ig(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,n,o,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),i}function ZQ(r,t){let e=Ig(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,o,s,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function oT(r){return r!==2?!1:Wn(r).fenceSync!=null}function di(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&x.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Rt=V();Rt.registerFlag("HAS_WEBGL",()=>Rt.getNumber("WEBGL_VERSION")>0);Rt.registerFlag("WEBGL_VERSION",()=>hw(2)?2:hw(1)?1:0);Rt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Rt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Rt.get("WEBGL_VERSION")===2);Rt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Rt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Rt.registerFlag("WEBGL_PACK",()=>Rt.getBool("HAS_WEBGL"));Rt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_CLIP",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_PACK_REDUCE",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_CONV_IM2COL",()=>Rt.getBool("WEBGL_PACK"));Rt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>QN(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>tT(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Rt.getNumber("WEBGL_VERSION");return r===0?0:eT(r)});Rt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Rt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yl.isMobile());Rt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>rT(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Rt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Rt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Rt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>nT(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>oT(Rt.getNumber("WEBGL_VERSION")));Rt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Rt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Rt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Rt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Yl.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Rt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Rt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Rt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Rt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function qe(){let r,t,e,n,o,s,i,a,u,l;return V().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function hi(r,t,e="index"){let n=x.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Qc(r,t,e="index"){let n=x.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function JQ(r,t){let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function YM(r,t,e="index"){let n=r.map((s,i)=>i),o=JQ(n,t);return o.map((s,i)=>{let a=`int ${r[i]} = ${e} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${e} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function hd(r){let t=x.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function gd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var gw=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:ZM}=S;function JM(r,t,e){let n=[];if(r.forEach(f=>{let d=x.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){let{uniformShape:h}=xw(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>QQ(f,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=qe(),u=rtt(a),l,c,p=stt(a);return t.isPacked?(l=ttt(t.logicalShape,i,e.enableShapeUniforms),c=ott(a)):(l=ett(t.logicalShape,i,e.enableShapeUniforms),c=ntt(a)),e.packedInputs&&(p+=utt),[p,u,c,o,l,s,e.userCode].join(`
`)}function yd(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return vtt(r,t);case 1:return Itt(r,t);case 2:return ktt(r,t);case 3:return Ttt(r,t);case 4:return Ett(r,t);case 5:return Att(r);case 6:return $tt(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function QM(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return wtt(r);case 1:return Ctt(r,t);case 2:return Stt(r,t);case 3:return Ntt(r,t);default:return _tt(r,t)}}function QQ(r,t,e=!1,n){let o="";e?o+=QM(r,n):o+=yd(r,n);let s=r.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?o+=Dtt(r,t):o+=Ftt(r,t)),o}function ttt(r,t,e){switch(r.length){case 0:return tP();case 1:return ctt(r,t,e);case 2:return ytt(r,t,e);case 3:return mtt(r,t,e);default:return dtt(r,t,e)}}function ett(r,t,e){switch(r.length){case 0:return tP();case 1:return ptt(r,t,e);case 2:return btt(r,t,e);case 3:return ftt(r,t,e);case 4:return htt(r,t,e);case 5:return gtt(r,t);case 6:return xtt(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function rtt(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function ntt(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function ott(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function stt(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${itt}
    ${att}
    ${ltt}
  `}var itt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,att=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ltt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,utt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function tP(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function ctt(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function ptt(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function mtt(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function ftt(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Qc(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=hi(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function dtt(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function htt(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Qc(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=hi(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function gtt(r,t){let e=hi(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function xtt(r,t){let e=hi(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function ytt(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(x.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function btt(r,t,e){return x.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function tp(r){return`offset${r}`}function wtt(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=qe();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function vtt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=tp(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function Ctt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=r.shapeInfo.texShape,s=qe();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function Itt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${bd(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=tp(e);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function Stt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=qe();if(s!=null&&x.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function ktt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&x.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=x.squeezeShape(e),u=i;if(u.length<e.length){let m=wd(r,u),f=["row","col"];return`
      ${yd(m,t)}
      float ${o}(int row, int col) {
        return ${o}(${vd(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${bd(r)}
      }
    `;let l=s[0],c=s[1],p=tp(n);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function Ntt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let m=e.slice(1),f=[1,2],d=wd(r,m),h=["b","row","col"];return`
        ${QM(d,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${vd(h,f)});
        }
      `}let a=qe();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function Ttt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:u}=x.squeezeShape(e),l=a;if(l.length<e.length){let h=wd(r,l),g=["row","col","depth"];return`
        ${yd(h,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${vd(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${bd(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=tp(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${i} + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${d};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function _tt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=qe();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,m*=s[i-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${n}(${f}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${e}, uv);
    }
  `}function Ett(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=x.squeezeShape(e);if(u.length<e.length){let b=wd(r,u),w=["row","col","depth","depth2"];return`
      ${yd(b,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${vd(w,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${bd(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=tp(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function Att(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=x.squeezeShape(t);if(u.length<t.length){let h=wd(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${yd(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${vd(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${bd(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;let d=tp(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function $tt(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=x.squeezeShape(t);if(o.length<t.length){let g=wd(r,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${yd(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${vd(y,s)});
      }
    `}let i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${bd(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=tp(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function bd(r){let t=r.name,e=x.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Dtt(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=ZM(r.shapeInfo.logicalShape,t.logicalShape),u=Ht(i),l=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${p[b+l]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",h=x.sizeFromShape(r.shapeInfo.logicalShape)===1,y=x.sizeFromShape(t.logicalShape)===1;if(s===1&&!h&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!y)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let b=s-2,w=s-1;a.indexOf(b)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function Ftt(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&x.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let l=Ht(u),c=ZM(r.shapeInfo.logicalShape,t.logicalShape),p=u-a,m,f=["x","y","z","w","u","v"];a===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let d="";return u<2&&a>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function Ht(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function xw(r,t,e){let{newShape:n,keptDims:o}=x.squeezeShape(t),s=t.length,i=r&&s===3&&t[0]===1,a=i?t.slice(1):n,u=!r&&s>1&&!x.arraysEqual(t,e)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:t,keptDims:o}}function wd(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function vd(r,t){return t.map(e=>r[e]).join(", ")}function rP(r,t,e,n){let o=e.map((c,p)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),s=o.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=JM(o,i,t),u=VN(r.gl,a),l=r.createProgram(u);return V().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},sT(r,t,l))}function sT(r,t,e){let n={},o={},s={},i=[],a,u,l,c=null,p=null;p=r.getUniformLocation(e,"NAN",!1),V().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(e,"INFINITY",!1));let m=!1;for(let f=0;f<t.variableNames.length;f++){let d=t.variableNames[f];n[d]=r.getUniformLocation(e,d,m),n[`offset${d}`]=r.getUniformLocation(e,`offset${d}`,m),t.enableShapeUniforms&&(o[`${d}Shape`]=r.getUniformLocation(e,`${d}Shape`,m),s[`${d}TexShape`]=r.getUniformLocation(e,`${d}TexShape`,m))}return t.enableShapeUniforms&&(a=r.getUniformLocation(e,"outShape",m),l=r.getUniformLocation(e,"outShapeStrides",m),u=r.getUniformLocation(e,"outTexShape",m)),t.customUniforms&&t.customUniforms.forEach((f,d)=>{i[d]=r.getUniformLocation(e,f.name,m)}),{uniformLocations:n,customUniformLocations:i,infLoc:c,nanLoc:p,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}}function eP(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let o=e.logicalShape,s=t[n],i=s.shape;if(!x.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!x.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function nP(r,t,e,n,o){t.program.enableShapeUniforms||(eP(t.inShapeInfos,e),eP([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):r.setOutputMatrixTexture(s.texture,i[0],i[1]),r.setProgram(t.webGLProgram),V().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((u,l)=>{let c=t.program.variableNames[l],p=t.uniformLocations[c],m=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],d=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:h}=xw(t.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(x.sizeFromShape(u.shape)<2)r.gl.uniform1f(p,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(p,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,p,l)}});let a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let u=x.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o&&t.program.customUniforms.forEach((u,l)=>{let c=t.customUniformLocations[l],p=o[l];if(u.type==="float")r.gl.uniform1fv(c,p);else if(u.type==="vec2")r.gl.uniform2fv(c,p);else if(u.type==="vec3")r.gl.uniform3fv(c,p);else if(u.type==="vec4")r.gl.uniform4fv(c,p);else if(u.type==="int")r.gl.uniform1iv(c,p);else if(u.type==="ivec2")r.gl.uniform2iv(c,p);else if(u.type==="ivec3")r.gl.uniform3iv(c,p);else if(u.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function oP(r,t,e){let n="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=xw(r.packedInputs,i.shape,u),m="",f="",d="";if(c.length===1&&r.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${k[0]>1}_${k[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let k=x.computeStrides(c);d=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let h=i.shape.length,g=c.length===2&&x.arraysEqual(i.shape,u),y=x.sizeFromShape(i.shape)===1,b=S.getBroadcastDims(i.shape,e.shape),w=!r.packedInputs&&h===e.shape.length&&x.arraysEqual(u,e.texData.texShape),v=r.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${w}_${l?p:""}_${c.length}_${y}_${b}_${g}_${m}_${f}_${d}_${v}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${V().getNumber("WEBGL_VERSION")}`,s}function De(r){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var yw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=wu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Qc(["r","c","d"],t):hi(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var bw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=wu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Qc(["r","c","d"],t):hi(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var ww=class{constructor(t){this.variableNames=["A"],this.outTexUsage=Kr.DOWNLOAD;let e=qe();this.outputShape=t,this.userCode=`
      ${gw}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var vw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Kr.DOWNLOAD;let e=qe();this.outputShape=t,this.userCode=`
      ${gw}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var Cw=class{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?gd():hd(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var Iw=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?gd():hd(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var CT={};Yt(CT,{bindVertexProgramAttributeStreams:()=>dT,createBufferFromOutputTexture:()=>xT,createFloat16MatrixTexture:()=>cT,createFloat16PackedMatrixTexture:()=>fT,createFloat32MatrixTexture:()=>uT,createIndexBuffer:()=>lT,createPackedMatrixTexture:()=>mT,createUnsignedBytesMatrixTexture:()=>pT,createVertexBuffer:()=>aT,createVertexShader:()=>iT,downloadByteEncodedFloatMatrixFromOutputTexture:()=>bT,downloadFloat32MatrixFromBuffer:()=>yT,downloadMatrixFromPackedOutputTexture:()=>vT,downloadPackedMatrixFromBuffer:()=>wT,getInternalFormatForFloat16MatrixTexture:()=>kw,getInternalFormatForFloat16PackedMatrixTexture:()=>_w,getInternalFormatForFloat32MatrixTexture:()=>Sw,getInternalFormatForPackedMatrixTexture:()=>Tw,getInternalFormatForUnsignedBytesMatrixTexture:()=>Nw,uploadDenseMatrixToTexture:()=>hT,uploadPixelDataToTexture:()=>gT});function iT(r){let t=qe(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return BN(r,e)}function aT(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return UN(r,t)}function lT(r){let t=new Uint16Array([0,1,2,2,1,3]);return HN(r,t)}function Tg(r,t,e,n,o,s){KN(t,e);let i=qN(r),a=r.TEXTURE_2D;return vt(r,()=>r.bindTexture(a,i)),vt(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),vt(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),vt(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),vt(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),V().getNumber("WEBGL_VERSION")===1?vt(r,()=>r.texImage2D(a,0,n,t,e,0,o,s,null)):vt(r,()=>r.texStorage2D(a,1,n,t,e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function Sw(r){return r.internalFormatFloat}function uT(r,t,e,n){let[o,s]=Jc(t,e);return Tg(r,o,s,Sw(n),n.textureFormatFloat,r.FLOAT)}function kw(r){return r.internalFormatHalfFloat}function cT(r,t,e,n){let[o,s]=Jc(t,e);return Tg(r,o,s,kw(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function Nw(r){return r.downloadTextureFormat}function pT(r,t,e,n){let[o,s]=Jc(t,e);return Tg(r,o,s,Nw(n),r.RGBA,r.UNSIGNED_BYTE)}function Tw(r){return r.internalFormatPackedFloat}function mT(r,t,e,n){let[o,s]=Qi(t,e);return Tg(r,o,s,Tw(n),r.RGBA,r.FLOAT)}function _w(r){return r.internalFormatPackedHalfFloat}function fT(r,t,e,n){let[o,s]=Qi(t,e);return Tg(r,o,s,_w(n),r.RGBA,n.textureTypeHalfFloat)}function dT(r,t,e){return vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),fw(r,t,"clipSpacePos",e,3,20,0)&&fw(r,t,"uv",e,2,20,12)}function hT(r,t,e,n,o,s){vt(r,()=>r.bindTexture(r.TEXTURE_2D,t));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(e*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(e*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,n,r.RGBA,a,i)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,a,i)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function gT(r,t,e){vt(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function xT(r,t,e,n){let o=r.createBuffer();vt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*t*e;return vt(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),vt(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),vt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function yT(r,t,e){let n=r,o=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function bT(r,t,e,n){let[o,s]=Jc(t,e),i=4,a=new Uint8Array(UM(t*e,i));return vt(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function wT(r,t,e,n,o,s,i,a){let u=r,l=new Float32Array(HM(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function vT(r,t,e){let n=new Float32Array(t*e*4);return vt(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var ep=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=V().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,MN(e,t)):this.gl=Wn(e);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),V().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=md(this.gl,s),Un(this.gl,i))this.textureHalfFloatExtension=md(this.gl,i);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Un(this.gl,o))this.colorBufferHalfFloatExtension=md(this.gl,o);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Un(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Un(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=aT(this.gl),this.indexBuffer=lT(this.gl),this.framebuffer=jN(this.gl),this.textureConfig=Ig(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;vt(t,()=>t.finish()),vt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),vt(t,()=>t.deleteFramebuffer(this.framebuffer)),vt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),vt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),vt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),uT(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),cT(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),pT(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),gT(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,o){this.throwIfDisposed(),hT(this.gl,t,e,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),fT(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),mT(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(dw(this.gl,this.framebuffer),this.outputTexture=null),vt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>bT(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,o,s,i){return wT(this.gl,t,e,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return yT(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let o=xT(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(V().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>vT(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=iT(e));let n=GN(e);return vt(e,()=>e.attachShader(n,this.vertexShader)),vt(e,()=>e.attachShader(n,t)),WN(e,n),this.debug&&Sg(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=dT(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&vt(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Sg(this.gl,this.program),vt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?XN(this.gl,t,e):YN(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),vt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),ZN(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[o,s]=Qi(e,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Sg(this.gl,this.program),fd(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),vt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),vt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=md(this.gl,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await x.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=Mtt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&x.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),kg(this.gl,t,this.framebuffer),this.debug&&fd(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(kg(this.gl,this.outputTexture,this.framebuffer),this.debug&&fd(this.gl)):dw(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let o=this.gl;kg(o,t,this.framebuffer),this.debug&&fd(o),this.outputTexture=t,vt(o,()=>o.viewport(0,0,e,n)),vt(o,()=>o.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,o){this.throwIfDisposed(),vt(this.gl,()=>this.gl.scissor(t,e,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Mtt(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:sP,bincountImpl:Ew,bincountReduceImpl:iP,ceilImpl:aP,concatImpl:lP,equalImpl:uP,expImpl:cP,expm1Impl:pP,floorImpl:mP,gatherNdImpl:fP,gatherV2Impl:dP,greaterImpl:hP,greaterEqualImpl:gP,lessImpl:xP,lessEqualImpl:yP,linSpaceImpl:bP,logImpl:wP,maxImpl:vP,maximumImpl:CP,minimumImpl:IP,multiplyImpl:SP,negImpl:kP,notEqualImpl:NP,prodImpl:TP,rangeImpl:_P,rsqrtImpl:EP,scatterImpl:AP,sigmoidImpl:$P,simpleAbsImpl:Aw,sliceImpl:DP,sparseFillEmptyRowsImpl:FP,sparseReshapeImpl:RP,sparseSegmentReductionImpl:$w,sqrtImpl:OP,stridedSliceImpl:MP,stringNGramsImpl:PP,stringSplitImpl:LP,stringToHashBucketFastImpl:zP,subImpl:BP,tileImpl:VP,topKImpl:GP,transposeImpl:rp,uniqueImpl:WP}=ow;function IT(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function rr(r,t){return t===1?[r]:IT(r,t)}function UP(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var Dw=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=De(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=rr("rc",this.rank),n=Ht(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var Cd=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Ptt(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?gd():hd(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function Ptt(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?YM(["r","c","d"],"inputShape"):hi(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var Fw=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){let o=qP(e,n),s=KP(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=HP(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let a;return o===Rr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Rr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Rr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Rr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Rr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,o){if(this.freeTextures==null)return;let s=qP(n,o),i=KP(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=HP(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=V().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],c=l.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Ltt(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function HP(r,t,e,n,o){let s=ztt(t,n),i;if(o){let[u,l]=Qi(r[0],r[1]);i=u*l}else{let[u,l]=Jc(r[0],r[1]);i=u*l}let a=Ltt(e,s);return i*a}function ztt(r,t){switch(r){case Rr.PACKED_2X2_FLOAT32:return Tw(t);case Rr.PACKED_2X2_FLOAT16:return _w(t);case Rr.UNPACKED_FLOAT32:return Sw(t);case Rr.UNPACKED_FLOAT16:return kw(t);case Rr.PACKED_4X1_UNSIGNED_BYTE:return Nw(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function Btt(r){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Rr.PACKED_2X2_FLOAT32:Rr.UNPACKED_FLOAT32:r?Rr.PACKED_2X2_FLOAT16:Rr.UNPACKED_FLOAT16}function qP(r,t){if(r===Kr.UPLOAD)return Rr.PACKED_2X2_FLOAT32;if(r===Kr.RENDER||r==null)return Btt(t);if(r===Kr.DOWNLOAD||r===Kr.PIXELS)return Rr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function KP(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var en=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},hr="if (isnan(x)) return x;",jP="return x;",ST="return abs(x);";var XP="return (x >= 0.0) ? x : (exp(x) - 1.0);",YP=hr+`
  return (x < 0.0) ? 0.0 : x;
`,ZP=hr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,np="return x;",JP="return 1.0 / (1.0 + exp(-1.0 * x));";var tL="return x;",eL=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,rL=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nL=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,oL="return 1.0 / (1.0 + exp(-1.0 * x));",eo=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Rw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let e=t.length,n=rr("rc",e),o=Ht(e),s=UP(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Gtt=Gr.whereImpl,Wtt=1e-7,Utt=1e-4,Ow={};function Htt(r){return r in Ow||(Ow[r]={}),Ow[r]}var qtt=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Ktt=600;function jtt(){return V().global.screen==null?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*Ktt/1024/1024}var Cu=class extends jo{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof ep)e=t;else{let n=Wn(V().getNumber("WEBGL_VERSION"),t);e=new ep(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=Wn(V().getNumber("WEBGL_VERSION"));e=new ep(n),this.binaryCache=Htt(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Fw(this.gpgpu),this.numMBBeforeWarning=jtt(),this.texData=new ta(this,go())}nextDataId(){return Cu.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:e,dtype:n,values:t,usage:Kr.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,n,o,s){if(V().getBool("DEBUG")&&this.checkNumericalProblems(e),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:o,values:e,usage:Kr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let e=this.texData.get(t),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:u}=e;if(i!=null){let m;u?m=new eo(a,np):m=new en(a,np);let f=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(t);if(o==="string")return n;let l=this.activeTimers!=null,c;l&&(c=x.now());let p;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=S.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=x.now()-c),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){let d=this.pendingRead.get(t);return new Promise(h=>d.push(h))}let e=this.texData.get(t),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:u}=e;if(s!=null){let d;u?d=new eo(o,np):d=new en(o,np);let h=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:i}],i),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(t);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&V().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&V().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let d=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(d.texture.texture,...Cg(o))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){let d=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=d[0],g=d[1];p=S.mergeRealAndImagArrays(h,g)}else if(l==null)p=this.getValuesFromTexture(t);else{let d=x.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(l,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){let d=this.gpgpu.gl;vt(d,()=>d.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(t,p),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(d=>d(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&go().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){let n=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,isPacked:u,texture:l}=n;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;u?f=new eo(s,np):f=new en(s,np);let d=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:a}],a),h=this.readToGPU(d,e);return this.disposeIntermediateTensorInfo(d),h}if(l==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,e.customTexShape),p=go().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){let e=this.readSync(t.dataId);if(t.dtype==="string")try{let n=e.map(o=>x.decodeString(o));return Ct(t.shape,t.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ct(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let n=t[e];if(!zN(n))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:n,isPacked:o}=this.texData.get(t),s=x.sizeFromShape(e);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...Cg(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let i=V().getBool("WEBGL_PACK")&&o===!0,a=i?Ng(e):e,u=i?new vw(a):new ww(a),l=this.runWebGLProgram(u,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let e=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t();let s=x.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=x.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);a.kernelMs=x.sum(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:x.now(),endMs:null}}endTimer(t){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=x.now(),t)}async getQueryTime(t){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:e,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(t),u=a&&a.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(e,o,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=qtt){return V().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&x.sizeFromShape(n.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return Gtt(t.shape,e)}packedUnaryOp(t,e,n){let o=new eo(t.shape,e),s=this.compileAndRun(o,[t],n);return go().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let o=Aw(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,ST,t.dtype);let e=new en(t.shape,ST),n=this.compileAndRun(e,[t]);return go().makeTensorFromTensorInfo(n)}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&x.isString(n[0])){let s=n.map(i=>x.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:e}}makeOutput(t,e,n){return go().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,n),this)}unpackTensor(t){let e=new Rw(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new Dw(t.shape),n=!0;return this.runWebGLProgram(e,[t],t.dtype,null,n)}packedReshape(t,e){let n=[Il(t.shape),...Sl(t.shape)],o={dtype:t.dtype,shape:n,dataId:t.dataId},s=[Il(e),...Sl(e)],i=new Cd(s,n),a=!0,u=[n],l=this.runWebGLProgram(i,[o],t.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t,e){let n=this.texData.get(t),{isPacked:o,shape:s,dtype:i}=n;if(e!=null){let m=x.sizeFromShape(s),f=e[0]*e[1]*4;x.assert(m<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let a=Ng(s),u;o?u=new bw(a):u=new yw(a);let l=!0,c=[e!=null?e:Cg(a)],p=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:t}],i,c,l,e);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,e,n,o,s=!1,i){let a=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(a.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===wu.DENSE){let y=i!=null?i:Cg(t.outputShape);u.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),x.sizeFromShape(a.shape)===0)return u.values=x.getTypedArrayFromDType(a.dtype,0),a;let l=[],c=e.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&x.sizeFromShape(y.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),l.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!vu(b.shape,y.shape)){let w=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),l.push(y),b=this.texData.get(y.dataId),w.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:u,isUniform:!1},m=oP(t,c,p),f=this.getAndSaveBinary(m,()=>rP(this.gpgpu,t,c,p)),d=this.activeTimers!=null,h;d&&(h=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||nP(this.gpgpu,f,c,p,o),l.forEach(y=>this.disposeIntermediateTensorInfo(y)),d&&(h=this.endTimer(h),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(h)}));let g=V().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=x.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(t,e,n,o,s=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,o,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=V().getBool("DEBUG");V().set("DEBUG",!1);let e=this.abs(pt(1e-8)).dataSync()[0];if(V().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Wtt:Utt}uploadToGPU(t){let e=this.texData.get(t),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:u}=e;if(i!=null)return;let l=this.activeTimers!=null,c;l&&(c=x.now());let p=e.texShape;if(p==null&&(p=JN(n,u),e.texShape=p),s!=null){let m=Ng(n),f,d=p[1],h=p[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([d,h]=Qi(p[0],p[1])),u?f=new Iw(m,g):f=new Cw(m,g);let y=g?[h,d]:p,b=this.makeTensorInfo(y,o),w=this.texData.get(b.dataId);g?w.usage=Kr.PIXELS:w.usage=Kr.UPLOAD,w.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),d,h,s);let v=[[h,d]],k=!0,E=this.runWebGLProgram(f,[b],o,v,k),$=this.texData.get(E.dataId);e.texShape=$.texShape,e.isPacked=$.isPacked,e.usage=$.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(e.texture=$.texture,e.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(b),l&&(this.uploadWaitMs+=x.now()-c)}else{let m=this.acquireTexture(p,a,o,u);e.texture=m}}convertAndCacheOnCPU(t,e){let n=this.texData.get(t),{dtype:o}=n;return this.releaseGPUData(t),e!=null&&(n.values=Xtt(e,o)),n.values}acquireTexture(t,e,n,o){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,o)}computeBytes(t,e){return t[0]*t[1]*x.bytesPerElement(e)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(let[,e]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(e),o(!0)}catch(s){throw s}});t.push(n)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Hh(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(mw(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,t]of Object.entries(this.binaryCache)){let{uniformLocations:e,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:c}=sT(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=n,t.infLoc=o,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=u,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}};Cu.nextDataId=0;function Xtt(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}var sL="3.17.0";function iL(){V().set("WEBGL_FORCE_F16_TEXTURES",!0)}Yl.isBrowser()&&ym("webgl",()=>new Cu,2);var cNe={forceHalfFloat:iL};var Mw=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var ro=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Iu=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Po=class{constructor(t,e,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(e,n);let s=this.outputShape.length;this.enableShapeUniforms=De(s);let i="";if(o)if(s===0||x.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Ht(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=rr("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function nr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var aL={kernelName:lo,backendName:"webgl",kernelFunc:nr};function Fn(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),i=e.texData.get(s.dataId),a=nr({inputs:{x:n},backend:e}),u=nr({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:u},s}var lL={kernelName:Rp,backendName:"webgl",kernelFunc:Fn};var kT="return (a < 0.) ? b * a : a;",NT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ytt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,i=e.makeTensorInfo([],"float32",x.createScalarValue(s,"float32")),a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(NT,o.shape,i.shape):new ro(kT,o.shape,i.shape),u=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),u}var uL={kernelName:hs,backendName:"webgl",kernelFunc:Ytt};var TT="return (a < 0.) ? b * a : a;",_T=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ztt(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(_T,n.shape,o.shape):new ro(TT,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],"float32")}var cL={kernelName:_s,backendName:"webgl",kernelFunc:Ztt};var Lo="if (isnan(x)) return x;",pL=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,mL=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function It({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),m=e(p.values,u);return a.makeTensorInfo(i.shape,u,m)}let l=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return l?c=new eo(i.shape,t):c=new en(i.shape,r),a.runWebGLProgram(c,[i],u)}}function le({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,c=a;if(n&&u.dtype==="complex64"){let d=c.texData.get(u.dataId),h=c.texData.get(l.dataId),[g,y]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[v,k]=w,E={dataId:v.dataId,dtype:v.dtype,shape:u.shape},$={dataId:k.dataId,dtype:k.dtype,shape:l.shape},D=new ro(r,u.shape,l.shape);return c.runWebGLProgram(D,[E,$],ar(v.dtype,k.dtype))}),b=Fn({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}let p=s||ar(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&o!=null){let d=c.texData.get(u.dataId).values,h=c.texData.get(l.dataId).values,g=u.dtype==="string"?S.fromUint8ToStringArray(d):d,y=u.dtype==="string"?S.fromUint8ToStringArray(h):h,[b,w]=o(u.shape,l.shape,g,y,p),v=c.makeTensorInfo(w,p),k=c.texData.get(v.dataId);return k.values=b,v}let m=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return m?f=new Po(t,u.shape,l.shape,e):f=new ro(r,u.shape,l.shape),c.runWebGLProgram(f,[u,l],p)}}function Su(r,t=!1){if(r==="linear")return t?tL:jP;if(r==="relu")return t?rL:YP;if(r==="elu")return t?eL:XP;if(r==="relu6")return t?nL:ZP;if(r==="prelu")return t?_T:TT;if(r==="leakyrelu")return t?NT:kT;if(r==="sigmoid")return t?oL:JP;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Id=class{constructor(t,e,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=De(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",v="rc.x";t[0]<e[0]?w=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${w};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};var ET={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},_g=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var fL="return a * b;";function Eg(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=S.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),l=new _g(ET.REAL,n.shape,o.shape),c=new _g(ET.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=Fn({inputs:{real:m,imag:f},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}if(e.shouldExecuteOnCPU([n,o])){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),[l,c]=SP(n.shape,o.shape,a.values,u.values,s),p=e.makeTensorInfo(c,s),m=e.texData.get(p.dataId);return m.values=l,p}let i;return V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Po(fL,n.shape,o.shape):i=new ro(fL,n.shape,o.shape),e.runWebGLProgram(i,[n,o],s)}var dL={kernelName:Ss,backendName:"webgl",kernelFunc:Eg};function hL(r,t,e){let n=[Il(r.shape),...Sl(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[Il(t),...Sl(t)],i=new Cd(s,n),a=!0,u=[n],l=e.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function ut(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=e,a=x.sizeFromShape(o.shape),u=x.inferFromImplicitShape(s,a),l=x.sizeFromShape(u);x.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!vu(o.shape,u)&&!(c.texture!==null&&vu(c.shape,u))?hL(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var gL={kernelName:_i,backendName:"webgl",kernelFunc:ut};var Ag=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(e!=null){let p=1/e;l=`sumValue += dot(values * ${x.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var Pw=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",u="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",u="min"):e==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,p=n%4,m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";e==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):e==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Qtt(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=S.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Hn(r,t,e,n){let o=Qtt(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],c,p;e==="mean"?c=i===0?new Ag({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new Ag({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):c=new Pw({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},e),p=s,s=n.runWebGLProgram(c,[s],t),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var Lw=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;let o=Ht(this.rank),s=tet(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function tet(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<r.length;o++)n[r[o]]=e[o];return n.join()}var zw=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Ht(this.rank),s=IT("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function ku(r,t,e){let n=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zw(r.shape,t):new Lw(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function xL(r,t,e,n){let o=t,s=r.shape.length,i=x.parseAxisParam(o,r.shape),a=i,u=S.getAxesPermutation(a,s),l=u!=null,c=r;l&&(c=ku(r,u,n),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,m]=S.computeOutAndReduceShapes(c.shape,a),f=p;e&&(f=S.expandShapeToKeepDim(p,i));let d=x.sizeFromShape(m),g=x.sizeFromShape(r.shape)/d,y=ut({inputs:{x:c},attrs:{shape:[g,d]},backend:n}),b=qu(r.dtype),w=Hn(y,b,"sum",n),v=ut({inputs:{x:w},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),l&&n.disposeIntermediateTensorInfo(c),v}function op(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return xL(o,s,i,e)}var yL={kernelName:zs,backendName:"webgl",kernelFunc:op};function he(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,i=e,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,m=rp(p,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let f=i.texData.get(l.dataId);f.values=m}else l=ku(o,s,i);return l}var bL={kernelName:Hs,backendName:"webgl",kernelFunc:he};var AT=1e3;function sp({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=t.shape.length,p=e?r.shape[l-2]:r.shape[l-1],m=n?t.shape[c-1]:t.shape[c-2],f=e?r.shape[l-1]:r.shape[l-2],d=n?t.shape[c-2]:t.shape[c-1],h=r.shape.slice(0,-2),g=t.shape.slice(0,-2),y=x.sizeFromShape(h),b=x.sizeFromShape(g),v=Sr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,d]);x.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let k=e?[y,p,f]:[y,f,p],E=n?[b,d,m]:[b,m,d],$=ut({inputs:{x:r},backend:o,attrs:{shape:k}}),D=ut({inputs:{x:t},backend:o,attrs:{shape:E}}),F=[$,D],P=Math.max(y,b),W=e?$.shape[1]:$.shape[2],U=s!=null,q=i!=null,K=u==="leakyrelu",j=u!=null?Su(u,!0):null,Q=U||q||K||j!=null,rt;if((f===1||d===1)&&W>AT&&Q===!1){let nt=$,st=D;e&&(nt=he({inputs:{x:$},backend:o,attrs:{perm:[0,2,1]}}),F.push(nt)),n&&(st=he({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),F.push(st));let it=d!==1,ft=d===1,at=nt;it&&(at=ut({inputs:{x:nt},backend:o,attrs:{shape:[P,W,1]}}),F.push(at));let xt=d===1?2:1,dt=st;ft&&(dt=ut({inputs:{x:st},backend:o,attrs:{shape:[P,1,W]}}),F.push(dt));let bt=Eg({inputs:{a:at,b:dt},backend:o});rt=op({inputs:{x:bt},backend:o,attrs:{axis:xt,keepDims:!0}}),F.push(bt)}else{let nt=ar(r.dtype,t.dtype),st=new Id(k,E,[P,f,d],e,n,U,j,q,K),it=[$,D];if(s!=null&&it.push(s),q&&it.push(i),K){let ft=o.makeTensorInfo([],"float32",x.createScalarValue(a,"float32"));it.push(ft),F.push(ft)}rt=o.runWebGLProgram(st,it,nt)}let X=ut({inputs:{x:rt},backend:o,attrs:{shape:v}});F.push(rt);for(let nt of F)o.disposeIntermediateTensorInfo(nt);return X}function eet(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return sp({a:o,b:s,transposeA:u,transposeB:l,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var wL={kernelName:Oi,backendName:"webgl",kernelFunc:eet};var vL="return abs(x);";function ret(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=e.texData.get(n.dataId),i=Aw(s.values);return e.makeTensorInfo(n.shape,n.dtype,i)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new eo(n.shape,vL):o=new en(n.shape,vL),e.runWebGLProgram(o,[n],n.dtype)}var CL={kernelName:wi,backendName:"webgl",kernelFunc:ret};var net=hr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,oet=It({opSnippet:net}),IL={kernelName:ra,backendName:"webgl",kernelFunc:oet};var set=hr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,iet=It({opSnippet:set}),SL={kernelName:na,backendName:"webgl",kernelFunc:iet};var kL="return a + b;",aet=le({opSnippet:kL,packedOpSnippet:kL,supportsComplex:!0,cpuKernelImpl:sP}),NL={kernelName:Xn,backendName:"webgl",kernelFunc:aet};var Bw=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var Vw=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Gw(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return nr({inputs:{x:n[0]},backend:e});if(n.length>V().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=Gw({inputs:n.slice(0,u),backend:e}),c=Gw({inputs:n.slice(u),backend:e});return Gw({inputs:[l,c],backend:e})}let o=n.map(u=>u.dtype).reduce((u,l)=>ar(u,l)),s=n.map(u=>u.shape),a=V().getBool("WEBGL_PACK")?new Vw(n[0].shape,s):new Bw(n[0].shape,s);return e.runWebGLProgram(a,n,o)}var TL={kernelName:Zo,backendName:"webgl",kernelFunc:Gw};function uet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=he({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("all",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"all",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var _L={kernelName:oa,backendName:"webgl",kernelFunc:uet};function cet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=he({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("any",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"any",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var EL={kernelName:sa,backendName:"webgl",kernelFunc:cet};var Ww=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var Uw=class{constructor(t,e,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,x.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=Ht(u),c=rr("coords",u),p,m;if(i===1){m=u+1;let D=Ht(m);p=`
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[u-1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[u-2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[u-1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[u-2]};`}else m=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(D=>"int "+D),g=rr("sourceLocR",m-1).concat("inIdx.r"),y=rr("sourceLocG",m-1).concat("inIdx.g"),b=rr("sourceLocB",m-1).concat("inIdx.b"),w=rr("sourceLocA",m-1).concat("inIdx.a"),v=n==="max"?"greaterThan":"lessThan",k=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()})));`,E=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,$=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function AL(r,t,e,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new Ww(a,e,n==null),l=[t];n!=null&&l.push(n);let c=r.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let p=AL(r,t,e,c);return r.disposeIntermediateTensorInfo(c),p}function $L(r,t,e,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new Uw(o,i,e,n==null),u=n==null?[t]:[t,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===t.shape.length){let c=$L(r,t,e,l);return r.disposeIntermediateTensorInfo(l),c}return l}function Hw(r,t,e,n){let o=[e];if(S.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=r.texData.get(t.dataId),a=i!==null&&i.isPacked,u=t;a&&(u=r.unpackTensor(t),s.push(u));let[l,c]=S.computeOutAndReduceShapes(u.shape,o),p=x.sizeFromShape(c),m=ut({inputs:{x:u},backend:r,attrs:{shape:[-1,p]}});s.push(m);let f=AL(r,m,n);s.push(f);let d=ut({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return $L(r,t,n)}function pet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=he({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=Hw(e,u,i[0],"max");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var DL={kernelName:Jo,backendName:"webgl",kernelFunc:pet};function met(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=he({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=Hw(e,u,i[0],"min");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var FL={kernelName:Dl,backendName:"webgl",kernelFunc:met};var fet=hr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,det=It({opSnippet:fet}),RL={kernelName:ia,backendName:"webgl",kernelFunc:det};var het=hr+"return log(x + sqrt(x * x + 1.0));",get=It({opSnippet:het}),OL={kernelName:aa,backendName:"webgl",kernelFunc:get};var xet=hr+`
  return atan(x);
`,yet=It({opSnippet:xet}),ML={kernelName:la,backendName:"webgl",kernelFunc:yet};var bet=pL+`
  return atan(a, b);
`,wet=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+mL+`
  return result;
`,vet=le({opSnippet:bet,packedOpSnippet:wet}),PL={kernelName:ca,backendName:"webgl",kernelFunc:vet};var Cet=hr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Iet=It({opSnippet:Cet}),LL={kernelName:ua,backendName:"webgl",kernelFunc:Iet};var gi=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,f=t.padInfo.top,d=t.padInfo.left;this.outputShape=t.outShape;let h=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,b="0.0";if(h||(b="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:y:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(v="avgValue / count");let k=Math.floor(i/4)*4,E=i%4,$=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${k};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${v});
      }
    `}},Nu=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,u=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,f=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;let w=e==="avg",v="0.0";if(w||(v="-1.0 / 1e-20"),n){let P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",E=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(E="avgValue / count");let $=Math.floor(i/4)*4,D=i%4,F=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${$};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${F}
            }
          }
          setOutput(${E});
        }
      }
    `}};function ket(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;di(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return nr({inputs:{x:o},backend:e});let p=new gi(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var zL={kernelName:Qo,backendName:"webgl",kernelFunc:ket};function Net(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,u,l),m=new Nu(p,"avg",!1);return e.runWebGLProgram(m,[o],"float32")}var BL={kernelName:Fl,backendName:"webgl",kernelFunc:Net};var qw=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=u-1-t.padInfo.top,p=l-1-t.padInfo.left,m=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Kw=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=p-1-t.padInfo.front,h=m-1-t.padInfo.top,g=f-1-t.padInfo.left,y=1/(e*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Tet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Kw(m);return e.runWebGLProgram(f,[o],i.dtype)}var VL={kernelName:$p,backendName:"webgl",kernelFunc:Tet};function _et(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;di([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=new qw(c);return e.runWebGLProgram(p,[o],i.dtype)}var GL={kernelName:Ap,backendName:"webgl",kernelFunc:_et};function Eet(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return sp({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var WL={kernelName:ts,backendName:"webgl",kernelFunc:Eet};var jw=class{constructor(t,e,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var Xw=class{constructor(t,e,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Aet=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;x.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let l=[n,o,s],c=null;i!=null&&(c=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let m=V().getBool("WEBGL_PACK_NORMALIZATION")?new Xw(n.shape,o.shape,s.shape,c,p,u):new jw(n.shape,o.shape,s.shape,c,p,u);return t.runWebGLProgram(m,l,l[0].dtype)},UL={kernelName:fs,backendName:"webgl",kernelFunc:Aet};var Yw=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=Ht(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=$et(this.rank),o,s=t.map((i,a)=>`sourceLoc.${$T[a]} = start[${a}] + coords.${$T[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},$T=["x","y","z","w","u","v"];function $et(r){if(r===1)return"sourceLoc";if(r<=6)return $T.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var Zw=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Ht(this.rank),n=rr("coords",this.rank),o=rr("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function Det(r,t,e,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(e,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=r.dtype;let a=Ve.computeFlatOffset(t,x.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function xi(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n,[a,u]=Ve.parseSliceParams(o,s,i);if(Ve.assertParamsValid(o,a,u),x.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),m=DP(p.values,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=e.texData.get(o.dataId),c=Ve.isSliceContinous(o.shape,a,u);if(l||!c){let p=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zw(u):new Yw(u),m=[a];return e.runWebGLProgram(p,[o],o.dtype,m)}return e.uploadToGPU(o.dataId),Det(o,a,u,e)}var HL={kernelName:Ai,backendName:"webgl",kernelFunc:xi};var Fet=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;x.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((b,w)=>b*w),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=[],d=ut({inputs:{x:o},backend:e,attrs:{shape:u}}),h=he({inputs:{x:d},backend:e,attrs:{perm:l}}),g=ut({inputs:{x:h},backend:e,attrs:{shape:c}}),y=xi({inputs:{x:g},backend:e,attrs:{begin:p,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y},qL={kernelName:vi,backendName:"webgl",kernelFunc:Fet};function Ret(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.readSync(o.dataId),u=e.readSync(s.dataId),l=Ew(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var KL={kernelName:Dp,backendName:"webgl",kernelFunc:Ret};function Oet(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.readSync(n.dataId),i=e.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var jL={kernelName:Fp,backendName:"webgl",kernelFunc:Oet};var Met="return float(a != b);",DT=le({opSnippet:Met,cpuKernelImpl:NP,dtype:"bool"}),XL={kernelName:_a,backendName:"webgl",kernelFunc:DT};function kl(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return nr({inputs:{x:o.complexTensorInfos.real},backend:e})}var YL={kernelName:Qp,backendName:"webgl",kernelFunc:kl};var Pet="return float(int(x));";function ZL(r,t){let e=new en(r.shape,Pet),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function FT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return nr({inputs:{x:o},backend:e});let i=we(o.shape),a=FT({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Fn({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=kl({inputs:{input:o},backend:e}),a=FT({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!x.hasEncodingLoss(o.dtype,s)){let i=nr({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32")return ZL(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",x.getTypedArrayFromDType("bool",1)),u=DT({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var JL={kernelName:io,backendName:"webgl",kernelFunc:FT};var QL="return ceil(x);",Let=It({opSnippet:QL,packedOpSnippet:QL,cpuKernelImpl:aP}),t3={kernelName:es,backendName:"webgl",kernelFunc:Let};var Jw=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Qw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function zet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a;V().getBool("WEBGL_PACK_CLIP")?a=new Qw(o.shape):a=new Jw(o.shape);let u=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,u)}var e3={kernelName:ao,backendName:"webgl",kernelFunc:zet};var tv=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function r3(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function Bet(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.texData.get(n.dataId),s=new tv(n.shape),i=[r3(n,o.complexTensorInfos.real),r3(n,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var n3={kernelName:Rl,backendName:"webgl",kernelFunc:Bet};var ev=class{constructor(t){this.outputShape=[],this.outputShape=S.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var nv=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(t,e);let n=this.outputShape,o=n.length,s=Ht(o),i=rr("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((h,g)=>`T${g}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let h=1;h<u.length;h++)u[h]=u[h-1]+t[h][e];let l=a[e],c=a.slice(-2),p=a.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${rv(a,l,g)}),
            vec2(${rv(c,l,g)}));
        }`}let f=u.length,d=u[u.length-1];m+=`
        return getChannel(
          getT${f}(${rv(a,l,d)}),
          vec2(${rv(c,l,d)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function rv(r,t,e){let n=r.indexOf(t);return r.map((s,i)=>i===n?`${s} - ${e}`:s).join()}function ip(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return nr({inputs:{x:o.complexTensorInfos.imag},backend:e})}var o3={kernelName:qp,backendName:"webgl",kernelFunc:ip};function ap(r,t,e){let n=r[0].dtype;if(n==="complex64"){let c=r.map(h=>kl({inputs:{input:h},backend:e})),p=r.map(h=>ip({inputs:{input:h},backend:e})),m=ap(c,t,e),f=ap(p,t,e),d=Fn({inputs:{real:m,imag:f},backend:e});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),p.forEach(h=>e.disposeIntermediateTensorInfo(h)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let c=r.map(y=>{let b=x.sizeFromShape(y.shape.slice(t));return ut({inputs:{x:y},backend:e,attrs:{shape:[-1,b]}})}),p=c.map(y=>({vals:e.readSync(y.dataId),shape:y.shape})),m=S.computeOutShape(c.map(y=>y.shape),1),f=c[0].shape[0]===1,d=lP(p,m,n,f),h=S.computeOutShape(r.map(y=>y.shape),t),g=e.makeTensorInfo(h,n,d);return c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}if(r.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),p=ap(r.slice(0,c),t,e),m=ap(r.slice(c),t,e),f=ap([p,m],t,e);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),f}if(V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let c=new nv(r.map(p=>p.shape),t);return e.runWebGLProgram(c,r,n)}let{tensors2D:s,outShape:i}=Vet(r,t,e),a=new ev(s.map(c=>c.shape)),u=e.runWebGLProgram(a,s,n);s.forEach(c=>e.disposeIntermediateTensorInfo(c));let l=ut({inputs:{x:u},attrs:{shape:i},backend:e});return e.disposeIntermediateTensorInfo(u),l}function Vet(r,t,e){let n=S.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>ut({inputs:{x:s},attrs:{shape:[-1,x.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:n}}function RT(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=x.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(l=>l.shape),s);if(x.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(l=>x.sizeFromShape(l.shape)>0);if(a.length===1)return nr({inputs:{x:a[0]},backend:e});let u=a.map(l=>l.shape);return S.assertParamsConsistent(u,s),ap(a,s,e)}var s3={kernelName:Ci,backendName:"webgl",kernelFunc:RT};var Sd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,u=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,w=g?3:1,v="",k="";n&&(o?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:v=`
          float activation(float x) {
            ${n}
          }
        `,k="result = activation(result);");let E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${k}
        setOutput(result);
      }
    `}},ov=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var sv=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let{dataFormat:n}=e,o=qe(),s=n==="channelsLast",i=s?0:1,a=s?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`,l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.y + ${p};
          pos = rc.x + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function i3(r,t,e,n){let o=r.shape;if(x.assert(o.length<=1||o.length===3,()=>`WebGL conv2d only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${o.length}.`),o.length===1){let s=e?t[3]:t[1];x.assert(o[0]===1||o[0]===s,()=>`WebGL conv2d PReLU activation weights (${o}) is not compatible with the number of output channels (${s}).`)}else if(o.length===3){try{Sr.assertAndGetBroadcastShape(o,t)}catch(s){let i=`WebGL conv2d PReLU activation weights (${o}) is not compatible with the output shape of the conv2d (${t}).`;throw Error(i)}if(!e)return he({inputs:{x:r},backend:n,attrs:{perm:[1,2,0]}})}return r}function iv({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),c=e.inChannels,p=u[0]*u[1]*u[2],m=e.outChannels,f=e.dataFormat==="channelsLast",d=!1,h=!1,g,y=[];if(s!=null){let v=i3(s,e.outShape,f,n);v.dataId!==s.dataId&&(y.push(v),s=v)}if(!((p===1||m===1)&&c>AT)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!==0&&x.arraysEqual(l.shape.slice(-3),u.slice(-3))){let v=u[0]*u[1]*(u[2]+1),k={dataId:r.dataId,shape:[1,v,e.inChannels],dtype:r.dtype},E=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,x.assert(vu(l.shape,k.shape),()=>`packed reshape ${l.shape} to ${k.shape} isn't free`);let $=ut({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push($);let D=sp({a:k,b:$,backend:n,transposeA:d,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),F=n.texData.get(D.dataId);x.assert(F.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=E,F.shape=e.outShape,g=nr({inputs:{x:D},backend:n}),g.shape=e.outShape,y.push(D)}else{let v=f?r:he({inputs:{x:r},backend:n,attrs:{perm:[0,2,3,1]}}),k=v.shape,E=k[0]*k[1]*k[2],$=ut({inputs:{x:v},backend:n,attrs:{shape:[1,E,e.inChannels]}}),D=ut({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),F=sp({a:$,b:D,transposeA:d,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),P=[e.batchSize,e.outHeight,e.outWidth,e.outChannels],W=ut({inputs:{x:F},backend:n,attrs:{shape:P}});g=f?W:he({inputs:{x:W},backend:n,attrs:{perm:[0,3,1,2]}}),f||(y.push(v),y.push(W)),y.push($),y.push(D),y.push(F)}for(let v of y)n.disposeIntermediateTensorInfo(v);return g}function av({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=e,d=f==="channelsLast",h=u*l*c,g=m*p,y=[h,g],b=!0,w=!1,v=[];if(s!=null){let it=i3(s,e.outShape,d,n);it.dataId!==s.dataId&&(v.push(it),s=it)}let k=ut({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),E=ut({inputs:{x:t},backend:n,attrs:{shape:[1,h,x.sizeFromShape(t.shape)/h]}});v.push(k),v.push(E);let $=new sv(y,e),D=[k.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],F=n.runWebGLProgram($,[k],"float32",D),P=ut({inputs:{x:F},backend:n,attrs:{shape:[1,y[0],y[1]]}});v.push(F),v.push(P);let W=o!=null,U=s!=null,q=a==="leakyrelu",K=a?Su(a,!0):null,j=new Id(P.shape,E.shape,[1,g,e.outChannels],b,w,W,K,U,q),Q=[P,E];if(o&&Q.push(o),U&&Q.push(s),q){let it=n.makeTensorInfo([],"float32",x.createScalarValue(i,"float32"));Q.push(it),v.push(it)}let rt=n.runWebGLProgram(j,Q,"float32"),X=[1,m,p,e.outChannels],nt=ut({inputs:{x:rt},backend:n,attrs:{shape:X}}),st=d?nt:he({inputs:{x:nt},backend:n,attrs:{perm:[0,3,1,2]}});d||v.push(nt),v.push(rt);for(let it of v)n.disposeIntermediateTensorInfo(it);return st}function Get(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=iv({x:o,filter:s,convInfo:m,backend:e});else if(V().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)f=av({x:o,filter:s,convInfo:m,backend:e});else{let h=new Sd(m);f=e.runWebGLProgram(h,[o,s],"float32")}let d=ut({inputs:{x:f},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(f),d}var a3={kernelName:rs,backendName:"webgl",kernelFunc:Get};var lv=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},uv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,u=n-1-t.padInfo.left,l=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},cv=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},pv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Wet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new lv(m);return e.runWebGLProgram(f,[o,s],"float32")}var l3={kernelName:Op,backendName:"webgl",kernelFunc:Wet};function Uet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p),f=new uv(m);return e.runWebGLProgram(f,[o,s],"float32")}var u3={kernelName:ns,backendName:"webgl",kernelFunc:Uet};function Het(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),c=new ov(l);return e.runWebGLProgram(c,[o,s],"float32")}var c3={kernelName:Ol,backendName:"webgl",kernelFunc:Het};function qet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n,l=S.computeConv3DInfo(o.shape,u,i,1,a),c=new cv(l);return e.runWebGLProgram(c,[o,s],"float32")}var p3={kernelName:Mp,backendName:"webgl",kernelFunc:qet};function Ket(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n,l=S.computeConv3DInfo(u,s.shape,a,1,i),c=new pv(l);return e.runWebGLProgram(c,[o,s],"float32")}var m3={kernelName:Pp,backendName:"webgl",kernelFunc:Ket};var jet=Lo+`
  return cos(x);
`,Xet=It({opSnippet:jet}),f3={kernelName:os,backendName:"webgl",kernelFunc:Xet};var Yet=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Zet=It({opSnippet:Yet}),d3={kernelName:ss,backendName:"webgl",kernelFunc:Zet};var mv=class{constructor(t,e,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,u,l]=t,[c]=e,[p,m]=n;this.outputShape=[c,p,m,l];let f=o==="bilinear"?1:0,[d,h]=[`${a-1}.0`,`${u-1}.0`],[g,y,b]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[w,v,k]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${v};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Jet=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,c=new mv(o.shape,s.shape,a,u,l);return e.runWebGLProgram(c,[o,s,i],"float32")},h3={kernelName:ma,backendName:"webgl",kernelFunc:Jet};var lp;(function(r){r.Prod="*",r.Sum="+"})(lp||(lp={}));var $g=class{constructor(t,e,n,o){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.op=t,this.outputShape=e;let s=e.length,i=this.op===lp.Prod?"1.0":"0.0",a=n?i:`getX(${g3(s,"coords",this.op)})`,u=e[e.length-1],l="",c="";n?(l=o?`end != ${u-1}`:"end != 0",c=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${u}`:"end >= pow2",c=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ht(s)} coords = getOutputCoords();
        int end = ${x3(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${x3(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${g3(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function g3(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function x3(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function fv(r,t,e,n,o,s){let i=t.shape.length,a=S.getAxesPermutation([n],i),u=t;a!=null&&(u=he({inputs:{x:t},backend:e,attrs:{perm:a}}));let l=S.getInnerMostAxes(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let c=u.shape[l],p=nr({inputs:{x:u},backend:e});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let f=new $g(r,u.shape,!1,s),d=[[m]],h=p;p=e.runWebGLProgram(f,[p],p.dtype,d),e.disposeIntermediateTensorInfo(h)}if(o){let m=new $g(r,u.shape,o,s),f=p;p=e.runWebGLProgram(m,[p],p.dtype),e.disposeIntermediateTensorInfo(f)}if(a!=null){let m=S.getUndoAxesPermutation(a),f=he({inputs:{x:p},backend:e,attrs:{perm:m}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),f}return p}function Qet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return fv(lp.Prod,o,e,s,i,a)}var y3={kernelName:pa,backendName:"webgl",kernelFunc:Qet};function trt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;return fv(lp.Sum,o,e,s,i,a)}var b3={kernelName:is,backendName:"webgl",kernelFunc:trt};function ert(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=Ew(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=iP(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var w3={kernelName:Lp,backendName:"webgl",kernelFunc:ert};var dv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function rrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=new dv(d,s,i);return e.runWebGLProgram(h,[o],o.dtype)}var v3={kernelName:fa,backendName:"webgl",kernelFunc:rrt};var kd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=De(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,u=t.outChannels/t.inChannels,l="",c="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var Nd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=De(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,m=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(m+1)/2;y++){let b=y*2;if(f+=`
          xC = xCCorner + ${b*l};
          `,u===1){if(b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<p)){let w=a%2===0?x.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                      xTexelC${b} = getX(batch, xR, xCOffset, d1);
                      xTexelC${b}Ready = 1;
                    }
                    `),f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                  `):w===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<p&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<p&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<p&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function nrt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,c=u;c==null&&(c=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,c,a,l,!0),m;V().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new Nd(p):m=new kd(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[o,s],"float32",f)}var C3={kernelName:as,backendName:"webgl",kernelFunc:nrt};var hv=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},gv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ort(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),m=new hv(p);return e.runWebGLProgram(m,[o,s],"float32")}var I3={kernelName:zp,backendName:"webgl",kernelFunc:ort};function srt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),m=new gv(p);return e.runWebGLProgram(m,[o,s],"float32")}var S3={kernelName:Bp,backendName:"webgl",kernelFunc:srt};var xv=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function irt(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=x.sizeFromShape(n.shape),i=ut({inputs:{x:n},backend:e,attrs:{shape:[s]}}),a=new xv(s),u=e.runWebGLProgram(a,[i],i.dtype),l=ut({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}var k3={kernelName:Vp,backendName:"webgl",kernelFunc:irt};var yv=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=t,{top:p,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function art(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c,p=new yv(l);c=e.runWebGLProgram(p,[o,s],"float32");let m=ut({inputs:{x:c},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(c),m}var N3={kernelName:Ml,backendName:"webgl",kernelFunc:art};function lrt(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(y)?w=s[g]:(w=he({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),d.push(w));let v=w.shape.slice();for(let k=0;k<b.length;++k)v.splice(b[k],0,1);x.arraysEqual(w.shape,v)||(w=ut({inputs:{x:w},backend:e,attrs:{shape:v}}),d.push(w)),m===null?m=w:(m=Eg({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=op({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var T3={kernelName:Gp,backendName:"webgl",kernelFunc:lrt};var urt="return (x >= 0.0) ? x : (exp(x) - 1.0);",crt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,prt=It({opSnippet:urt,packedOpSnippet:crt}),_3={kernelName:us,backendName:"webgl",kernelFunc:prt};var mrt="return (b >= 1.0) ? a : a * (b + 1.0);",frt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,drt=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(frt,n.shape,o.shape):new ro(mrt,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],n.dtype)},E3={kernelName:Wp,backendName:"webgl",kernelFunc:drt};var hrt=`
  return vec4(equal(a, b));
`,grt="return float(a == b);",xrt=le({opSnippet:grt,packedOpSnippet:hrt,dtype:"bool",cpuKernelImpl:uP}),A3={kernelName:ha,backendName:"webgl",kernelFunc:xrt};var yrt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,brt=It({opSnippet:yrt}),$3={kernelName:da,backendName:"webgl",kernelFunc:brt};var wrt=Lo+`
  return exp(x);
`,vrt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,OT=It({opSnippet:wrt,packedOpSnippet:vrt,cpuKernelImpl:cP,dtype:"float32"}),D3={kernelName:cs,backendName:"webgl",kernelFunc:OT};function bv(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(x.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),ut({inputs:{x:s},backend:n,attrs:{shape:a}})}var F3={kernelName:Ii,backendName:"webgl",kernelFunc:bv};var R3="return exp(x) - 1.0;",Crt=It({opSnippet:R3,packedOpSnippet:R3,cpuKernelImpl:pP}),O3={kernelName:ga,backendName:"webgl",kernelFunc:Crt};var Dg=class{constructor(t,e,n){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function wv(r,t,e){let n=e.texData.get(r.dataId),o=x.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=ut({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),u=a.shape,l=new Dg("real",u,t),c=new Dg("imag",u,t),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=Fn({inputs:{real:m,imag:f},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f);let h=ut({inputs:{x:d},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(d),h}function Irt(r){let{inputs:t,backend:e}=r,{input:n}=t;return wv(n,!1,e)}var M3={kernelName:Up,backendName:"webgl",kernelFunc:Irt};var vv=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Nl(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||x.inferDtype(o),s==="string"){let i=x.getArrayFromDType(s,x.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new vv(n,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var P3={kernelName:Pl,backendName:"webgl",kernelFunc:Nl};var Cv=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var L3={kernelName:xa,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new Cv(e.shape);return n.runWebGLProgram(o,[e],e.dtype)}};var z3="return floor(x);",Srt=It({opSnippet:z3,packedOpSnippet:z3,cpuKernelImpl:mP}),B3={kernelName:ps,backendName:"webgl",kernelFunc:Srt};var krt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Nrt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Trt=le({opSnippet:krt,packedOpSnippet:Nrt,dtype:"int32"}),V3={kernelName:ms,backendName:"webgl",kernelFunc:Trt};var Iv=class{constructor(t){this.variableNames=["A"];let e=qe(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var Sv=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=qe(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var G3={kernelName:Xd,backendName:"webgl",kernelFunc:_rt},Td;function _rt(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[l,u],p=[l,u,s];(a||i)&&(Td==null&&(Td=document.createElement("canvas").getContext("2d")),Td.canvas.width=u,Td.canvas.height=l,Td.drawImage(o,0,0,u,l),o=Td.canvas);let m=e.makeTensorInfo(c,"int32");e.texData.get(m.dataId).usage=Kr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),o);let f=V().getBool("WEBGL_PACK")?new Sv(p):new Iv(p),d=e.runWebGLProgram(f,[m],"int32");return e.disposeData(m.dataId),d}function Ert(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=S.convertConv2DDataFormat(c),g=S.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!1,h),y,b=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=iv({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else if(V().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)y=av({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else{let v=i!=null,k=a!=null,E=f==="leakyrelu",$=f?Su(f,!1):null,D=new Sd(g,v,$,k,E),F=[o,s];if(i&&F.push(i),a&&F.push(a),E){let P=e.makeTensorInfo([],"float32",x.createScalarValue(d,"float32"));F.push(P),b.push(P)}y=e.runWebGLProgram(D,F,"float32")}let w=ut({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(v=>e.disposeIntermediateTensorInfo(v)),w}var W3={kernelName:Mi,backendName:"webgl",kernelFunc:Ert};function Art(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,d=[],h=c;h==null&&(h=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,u,h,l,p,!0),y=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=m?Su(m,y):null,w=[o,s],v=i!=null,k=a!=null,E=m==="leakyrelu";if(v&&w.push(i),k&&w.push(a),E){let P=e.makeTensorInfo([],"float32",x.createScalarValue(f,"float32"));w.push(P),d.push(P)}let $;y?$=new Nd(g,v,b,k,E):$=new kd(g,v,b,k,E);let D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=e.runWebGLProgram($,w,"float32",D);return d.forEach(P=>e.disposeIntermediateTensorInfo(P)),F}var U3={kernelName:Pi,backendName:"webgl",kernelFunc:Art};var kv=class{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;let o=Ht(e.length),s=Ht(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${i};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function $rt(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=x.sizeFromShape(n.shape),[u,l,c,p]=S.prepareAndValidate(n,o),m=ut({inputs:{x:o},backend:e,attrs:{shape:[l,i]}}),f=ut({inputs:{x:n},backend:e,attrs:{shape:[x.sizeFromShape(n.shape)/c,c]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=e.readSync(o.dataId),b=e.bufferSync(n),w=fP(y,b,n.dtype,l,i,c,p,n.shape,a);return e.makeTensorInfo(u,n.dtype,w.values)}let d=new kv(i,p,[l,c]),h=e.runWebGLProgram(d,[f,m],f.dtype),g=ut({inputs:{x:h},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),g}var H3={kernelName:ya,backendName:"webgl",kernelFunc:$rt};var Nv=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=Ht(this.rank),o=Drt(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function Drt(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${e[o]}`);return n.join()}function MT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=x.parseAxisParam(i,o.shape)[0];if(V().get("DEBUG")){let b=e.readSync(s.dataId),w=o.shape[u];for(let v=0;v<b.length;++v){let k=b[v];x.assert(k<=w-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${w-1}]`)}}let l=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=x.sizeFromShape(s.shape),p=[],m=ut({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=ut({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(m),p.push(f);let d=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let b=e.bufferSync(f),w=e.bufferSync(m),v=dP(w,b,d);return p.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.makeTensorInfo(l.outputShape,v.dtype,v.values)}let h=new Nv(m.shape,d),g=e.runWebGLProgram(h,[m,f],m.dtype);p.push(g);let y=ut({inputs:{x:g},backend:e,attrs:{shape:l.outputShape}});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}var q3={kernelName:Si,backendName:"webgl",kernelFunc:MT};var Frt="return float(a > b);",Rrt=`
  return vec4(greaterThan(a, b));
`,Ort=le({opSnippet:Frt,packedOpSnippet:Rrt,cpuKernelImpl:hP,dtype:"bool"}),K3={kernelName:ba,backendName:"webgl",kernelFunc:Ort};var Mrt="return float(a >= b);",Prt=`
  return vec4(greaterThanEqual(a, b));
`,Lrt=le({opSnippet:Mrt,packedOpSnippet:Prt,dtype:"bool",cpuKernelImpl:gP}),j3={kernelName:ds,backendName:"webgl",kernelFunc:Lrt};function zrt(r){let{inputs:t,backend:e}=r,{input:n}=t;return wv(n,!0,e)}var X3={kernelName:Hp,backendName:"webgl",kernelFunc:zrt};var Brt="return float(!isnan(x) && !isinf(x));",Vrt=It({opSnippet:Brt,dtype:"bool"}),Y3={kernelName:wa,backendName:"webgl",kernelFunc:Vrt};var Grt="return float(isinf(x));",Wrt=It({opSnippet:Grt,dtype:"bool"}),Z3={kernelName:va,backendName:"webgl",kernelFunc:Wrt};var Urt="return float(isnan(x));",Hrt=It({opSnippet:Urt,dtype:"bool"}),J3={kernelName:Ca,backendName:"webgl",kernelFunc:Hrt};var qrt="return float(a < b);",Krt=`
  return vec4(lessThan(a, b));
`,jrt=le({opSnippet:qrt,packedOpSnippet:Krt,cpuKernelImpl:xP,dtype:"bool"}),Q3={kernelName:Ia,backendName:"webgl",kernelFunc:jrt};var Xrt="return float(a <= b);",Yrt=`
  return vec4(lessThanEqual(a, b));
`,Zrt=le({opSnippet:Xrt,packedOpSnippet:Yrt,cpuKernelImpl:yP,dtype:"bool"}),tz={kernelName:Sa,backendName:"webgl",kernelFunc:Zrt};function Jrt(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=bP(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var ez={kernelName:Kp,backendName:"webgl",kernelFunc:Jrt};var Qrt=Lo+`
  return x < 0.0 ? 0./0. : log(x);
`,tnt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ent=It({opSnippet:Qrt,packedOpSnippet:tnt,cpuKernelImpl:wP}),rz={kernelName:gs,backendName:"webgl",kernelFunc:ent};var rnt=Lo+`
  return log(1.0 + x);
`,nnt=It({opSnippet:rnt}),nz={kernelName:ka,backendName:"webgl",kernelFunc:nnt};var ont="return float(a >= 1.0 && b >= 1.0);",snt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,int=le({opSnippet:ont,packedOpSnippet:snt,dtype:"bool"}),oz={kernelName:Na,backendName:"webgl",kernelFunc:int};var ant="return float(!(x >= 1.0));",lnt=It({opSnippet:ant}),sz={kernelName:Lu,backendName:"webgl",kernelFunc:lnt};var unt="return float(a >= 1.0 || b >= 1.0);",cnt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,pnt=le({opSnippet:unt,packedOpSnippet:cnt,dtype:"bool"}),iz={kernelName:zu,backendName:"webgl",kernelFunc:pnt};var Tv=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var _v=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var mnt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=V().getBool("WEBGL_PACK_NORMALIZATION")?new _v(o.shape,s,i,a,u):new Tv(o.shape,s,i,a,u);return e.runWebGLProgram(l,[o],o.dtype)},az={kernelName:Ll,backendName:"webgl",kernelFunc:mnt};var Ev=class{constructor(t,e,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var fnt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new Ev(o.shape,a,u,l,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},lz={kernelName:jp,backendName:"webgl",kernelFunc:fnt};function uz(r,t,e,n){let o=x.sizeFromShape(t),i=x.sizeFromShape(r.shape)/o,a=ut({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Hn(a,r.dtype,"max",n),l=ut({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function PT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=e.shouldExecuteOnCPU([o]),f=o;if(p){if(m){let w=e.texData.get(f.dataId).values,v=new Array(a);for(let $=0;$<v.length;$++)v[$]=o.shape[c[$]];let k=rp(w,o.shape,o.dtype,c,v);f=e.makeTensorInfo(v,o.dtype);let E=e.texData.get(f.dataId);E.values=k}else f=ku(o,c,e);l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("max",l,a);let[d,h]=S.computeOutAndReduceShapes(f.shape,l),g=d;i&&(g=S.expandShapeToKeepDim(d,u));let y;if(m){let w=e.texData.get(f.dataId).values,v=vP(w,x.sizeFromShape(h),g,o.dtype);y=e.makeTensorInfo(g,o.dtype);let k=e.texData.get(y.dataId);k.values=v}else y=uz(f,h,g,e);return p&&e.disposeIntermediateTensorInfo(f),y}var cz={kernelName:xs,backendName:"webgl",kernelFunc:PT};var dnt=Mw+`
  return max(a, b);
`,hnt=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Iu+`
  return result;
`,gnt=le({opSnippet:dnt,packedOpSnippet:hnt,cpuKernelImpl:CP}),pz={kernelName:ys,backendName:"webgl",kernelFunc:gnt};function xnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;di(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return nr({inputs:{x:o},backend:e});let p=new gi(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var mz={kernelName:bs,backendName:"webgl",kernelFunc:xnt};function ynt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,l,u),m=new Nu(p,"max",!1);return e.runWebGLProgram(m,[o],o.dtype)}var fz={kernelName:zl,backendName:"webgl",kernelFunc:ynt};var Av=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,u=i-1-t.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},$v=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=u-1-t.padInfo.front,m=l-1-t.padInfo.top,f=c-1-t.padInfo.left,d=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function bnt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Nu(m,"max",!0),d=e.runWebGLProgram(f,[i],i.dtype),h=new $v(m),g=e.runWebGLProgram(h,[o,d],i.dtype);return e.disposeIntermediateTensorInfo(d),g}var dz={kernelName:Yp,backendName:"webgl",kernelFunc:bnt};function wnt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;di([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=!0,d=new gi(m,"max",f),h=e.runWebGLProgram(d,[a],a.dtype),g=new Av(m),y=e.runWebGLProgram(g,[o,h],a.dtype);return e.disposeIntermediateTensorInfo(h),y}var hz={kernelName:Xp,backendName:"webgl",kernelFunc:wnt};function gz(r,t,e,n){let o=new gi(e,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new gi(e,"max",!0,!0,t);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var xz={kernelName:Zp,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;x.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];x.assert(S.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=S.computePool2DInfo(n.shape,o,s,l,i),[p,m]=gz(n,a,c,u);return[p,m]}};function yz(r,t,e,n){let o=x.sizeFromShape(t),i=x.sizeFromShape(r.shape)/o,a=ut({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Hn(a,"float32","mean",n),l=ut({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var bz={kernelName:ws,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:o,axis:s}=t,i=e,a=n.shape.length,u=x.parseAxisParam(s,n.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=i.shouldExecuteOnCPU([n]),f=[],d=n;if(p){if(m){let v=i.texData.get(d.dataId).values,k=new Array(a);for(let D=0;D<k.length;D++)k[D]=n.shape[c[D]];let E=rp(v,n.shape,n.dtype,c,k);d=i.makeTensorInfo(k,n.dtype);let $=i.texData.get(d.dataId);$.values=E}else d=ku(n,c,i);f.push(d),l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=S.computeOutAndReduceShapes(d.shape,l),y=h;o&&(y=S.expandShapeToKeepDim(h,u));let b=yz(d,g,y,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return b}};function vnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=he({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"min",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var wz={kernelName:vs,backendName:"webgl",kernelFunc:vnt};var Cnt=Mw+`
  return min(a, b);
`,Int=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Iu+`
  return result;
`,Snt=le({opSnippet:Cnt,packedOpSnippet:Int,cpuKernelImpl:IP}),vz={kernelName:Cs,backendName:"webgl",kernelFunc:Snt};var Dv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=Ht(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var Fv=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((d,h)=>d[0]+t[h]+d[1]);let o=t.length,s=Ht(o),i=e.map(d=>d[0]).join(","),a=e.map((d,h)=>d[0]+t[h]).join(","),u=rr("rc",o),l=rr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var knt=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:o,mode:s}=e,i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fv(n.shape,o,s):new Dv(n.shape,o,s);return t.runWebGLProgram(i,[n],n.dtype)},Cz={kernelName:Is,backendName:"webgl",kernelFunc:knt};var Nnt=`if (b == 0.0) return NAN;
  return mod(a, b);`,Tnt=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Iu+`
  return result;
`,_nt=le({opSnippet:Nnt,packedOpSnippet:Tnt}),Iz={kernelName:Ta,backendName:"webgl",kernelFunc:_nt};var Rv=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var Ent=`
if (a == b) {
  return 1.0;
};
return a / b;`,Ant=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,LT=le({opSnippet:Ent,packedOpSnippet:Ant,checkOutOfBounds:!0}),Sz={kernelName:ls,backendName:"webgl",kernelFunc:LT};var kz="return a - b;",zT=le({opSnippet:kz,packedOpSnippet:kz,supportsComplex:!0,cpuKernelImpl:BP}),Nz={kernelName:Gs,backendName:"webgl",kernelFunc:zT};function BT(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=x.parseAxisParam([s],o.shape),a=PT({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=S.expandShapeToKeepDim(a.shape,i),l=ut({inputs:{x:a},backend:e,attrs:{shape:u}}),c=zT({inputs:{a:o,b:l},backend:e}),p=OT({inputs:{x:c},backend:e}),m=op({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=ut({inputs:{x:m},backend:e,attrs:{shape:u}}),d=LT({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}var Tz={kernelName:Bs,backendName:"webgl",kernelFunc:BT};function $nt(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,u=a?o:BT({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new Rv(l,c,s),m=[[i]],f=e.runWebGLProgram(p,[u],"int32",m);return a||e.disposeIntermediateTensorInfo(u),f}var _z={kernelName:Jp,backendName:"webgl",kernelFunc:$nt};var Dnt=hr+`
  return -x;
`,Fnt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Rnt(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.texData.get(n.dataId),[i,a]=kP(s.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,i)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new eo(n.shape,Fnt):o=new en(n.shape,Dnt),e.runWebGLProgram(o,[n],n.dtype)}var Ez={kernelName:ki,backendName:"webgl",kernelFunc:Rnt};var Ont=Gr.nonMaxSuppressionV3Impl;function Mnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=Ont(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var Az={kernelName:Ea,backendName:"webgl",kernelFunc:Mnt};var Pnt=Gr.nonMaxSuppressionV4Impl;function Lnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=Pnt(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var $z={kernelName:Aa,backendName:"webgl",kernelFunc:Lnt};var znt=Gr.nonMaxSuppressionV5Impl;function Bnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=znt(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var Dz={kernelName:$a,backendName:"webgl",kernelFunc:Bnt};var Ov=class{constructor(t,e,n,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var Vnt=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n,u=x.sizeFromShape(o.shape),l=new Ov(u,s,i,a),c=ut({inputs:{x:o},backend:e,attrs:{shape:[u]}}),p=e.runWebGLProgram(l,[c],o.dtype);e.disposeIntermediateTensorInfo(c);let m=[...o.shape,s],f=ut({inputs:{x:p},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(p),f},Fz={kernelName:ks,backendName:"webgl",kernelFunc:Vnt};function Fg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=kl({inputs:{input:n},backend:e}),s=Fg({inputs:{x:o},backend:e}),i=ip({inputs:{input:n},backend:e}),a=Fg({inputs:{x:i},backend:e}),u=Fn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return Nl({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var Rz={kernelName:Ri,backendName:"webgl",kernelFunc:Fg};function Oz(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=kl({inputs:{input:n},backend:e}),s=Oz({inputs:{x:o},backend:e}),i=ip({inputs:{input:n},backend:e}),a=Fg({inputs:{x:i},backend:e}),u=Fn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return Nl({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var Mz={kernelName:Ni,backendName:"webgl",kernelFunc:Oz};function Gnt(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return bv({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=bv({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=RT({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var Pz={kernelName:Ti,backendName:"webgl",kernelFunc:Gnt};var Mv=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,c)=>l[0]+t[c]+l[1]);let o=t.length,s=Ht(o),i=e.map(l=>l[0]).join(","),a=e.map((l,c)=>l[0]+t[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var Pv=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,g)=>h[0]+t[g]+h[1]);let o=t.length,s=Ht(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+t[g]).join(","),u=rr("rc",o),l=rr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var VT=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;if(x.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return Nl({backend:e,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pv(o.shape,s,i):new Mv(o.shape,s,i),u=[[i]];return e.runWebGLProgram(a,[o],o.dtype,u)},Lz={kernelName:Ns,backendName:"webgl",kernelFunc:VT};var Wnt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Unt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Iu+`
  return result;
`,Hnt=le({opSnippet:Wnt,packedOpSnippet:Unt}),zz={kernelName:Ts,backendName:"webgl",kernelFunc:Hnt};function qnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=x.parseAxisParam(s,o.shape),c=l,p=S.getAxesPermutation(c,a),m=o;p!=null&&(m=he({inputs:{x:o},backend:e,attrs:{perm:p}}),c=S.getInnerMostAxes(c.length,a),u.push(m)),S.assertAxesAreInnerMostDims("prod",c,a);let f;if(e.shouldExecuteOnCPU([m])){let d=e.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:y}=TP(m.shape,m.dtype,d,c);f=e.makeTensorInfo(g,y,h)}else{let[d,h]=S.computeOutAndReduceShapes(m.shape,c),g=x.sizeFromShape(h),y=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}}),b=qu(o.dtype),w=Hn(y,b,"prod",e);f=ut({inputs:{x:w},backend:e,attrs:{shape:d}}),u.push(y),u.push(w)}if(i){u.push(f);let d=S.expandShapeToKeepDim(f.shape,l);f=ut({inputs:{x:f},backend:e,attrs:{shape:d}})}return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var Bz={kernelName:Es,backendName:"webgl",kernelFunc:qnt};var GT=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=_P(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},Vz={kernelName:Bl,backendName:"webgl",kernelFunc:GT};var Knt="return 1.0 / x;",jnt=It({opSnippet:Knt}),Gz={kernelName:Da,backendName:"webgl",kernelFunc:jnt};var Xnt=hr+`
  return (x < 0.0) ? 0.0 : x;
`,Ynt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Znt=It({opSnippet:Xnt,packedOpSnippet:Ynt}),Wz={kernelName:As,backendName:"webgl",kernelFunc:Znt};var Jnt=hr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Qnt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tot=It({opSnippet:Jnt,packedOpSnippet:Qnt}),Uz={kernelName:Ds,backendName:"webgl",kernelFunc:tot};var Lv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var zv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function eot(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zv(o.shape,u,l,s,i):new Lv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],"float32")}var Hz={kernelName:$s,backendName:"webgl",kernelFunc:eot};var Bv=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function rot(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new Bv(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var qz={kernelName:em,backendName:"webgl",kernelFunc:rot};var Vv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var Gv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function not(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Gv(o.shape,u,l,s,i):new Vv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var Kz={kernelName:Vl,backendName:"webgl",kernelFunc:not};var Wv=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function oot(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new Wv(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var jz={kernelName:tm,backendName:"webgl",kernelFunc:oot};var Uv=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,u)=>o(u)).join(","),i=Ht(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var Hv=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=rr("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Ht(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(d){return m(d)}function l(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=t.map((b,w)=>f(w,d)),g=h.join(","),y=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(d,h){return e.indexOf(d)!==-1&&t[d]!==1?`${t[d]} - ${h[d]} - 1`:`${h[d]}`}}};function sot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=o.shape.length,a=x.parseAxisParam(s,o.shape);if(i===0)return nr({inputs:{x:o},backend:e});let u=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hv(o.shape,a):new Uv(o.shape,a);return e.runWebGLProgram(u,[o],o.dtype)}var Xz={kernelName:Fs,backendName:"webgl",kernelFunc:sot};var qv=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Yz={kernelName:Ga,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=new qv(n.shape,s),[l,c]=S.getImageCenter(i,n.shape[1],n.shape[2]),p=[[l,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,p)}};var iot=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,aot=It({opSnippet:iot}),Zz={kernelName:Rs,backendName:"webgl",kernelFunc:aot};var lot="return inversesqrt(x);",uot=It({opSnippet:lot,cpuKernelImpl:EP}),Jz={kernelName:Os,backendName:"webgl",kernelFunc:uot};var _d=class{constructor(t,e,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=Ht(s.length),l=Ht(i.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function cot(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=[p/l,l];if(p===0)return e.makeTensorInfo(i,o.dtype);let f=ut({inputs:{x:o},backend:e,attrs:{shape:[u,a]}}),d=ut({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),h=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new _d(u,a,f.shape.length,d.shape.length,c,m),y=e.runWebGLProgram(g,[d,f,h],d.dtype),b=ut({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(h),b}var Qz={kernelName:Fa,backendName:"webgl",kernelFunc:cot};var Kv=class{constructor(t,e,n,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,n];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=V().getNumber("WEBGL_VERSION")===2?s:i,u=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function pot(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:i}=n,a=new Kv(o.shape[0],o.shape[1],s.shape[1],i),u=[[o.shape[1]]];return e.runWebGLProgram(a,[o,s],"int32",u)}var tB={kernelName:rm,backendName:"webgl",kernelFunc:pot};var jv=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<e.length;c++)l.push(`${a[c]}`),c<t&&u.push(`${a[c]}`);o=u.join(),s=l.join()}let i=Ht(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function mot(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=new jv(n.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[n,o,s],ar(o.dtype,s.dtype))}var eB={kernelName:Ei,backendName:"webgl",kernelFunc:mot};var fot=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,dot=It({opSnippet:fot}),rB={kernelName:Ra,backendName:"webgl",kernelFunc:dot};var hot=Lo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,got=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xot=It({opSnippet:hot,packedOpSnippet:got,cpuKernelImpl:$P}),nB={kernelName:Ps,backendName:"webgl",kernelFunc:xot};var yot=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,bot=It({opSnippet:yot}),oB={kernelName:Ma,backendName:"webgl",kernelFunc:bot};var wot=Lo+`
  return sin(x);
`,vot=It({opSnippet:wot}),sB={kernelName:Ms,backendName:"webgl",kernelFunc:vot};var Cot=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Iot=It({opSnippet:Cot}),iB={kernelName:Oa,backendName:"webgl",kernelFunc:Iot};var Sot=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,kot=It({opSnippet:Sot}),aB={kernelName:Pa,backendName:"webgl",kernelFunc:kot};var Not=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;x.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,b)=>y*b),u=[[0,0]];u.push(...i);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],c=VT({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),p=S.getReshaped(c.shape,s,a,!1),m=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(c.shape,s,a,!1),d=ut({inputs:{x:c},backend:e,attrs:{shape:p}}),h=he({inputs:{x:d},backend:e,attrs:{perm:m}}),g=ut({inputs:{x:h},backend:e,attrs:{shape:f}});return l.push(c),l.push(d),l.push(h),l.forEach(y=>e.disposeIntermediateTensorInfo(y)),g},lB={kernelName:$i,backendName:"webgl",kernelFunc:Not};function Tot(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(n.dataId),u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,m,f,d,h]=FP(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var uB={kernelName:Gl,backendName:"webgl",kernelFunc:Tot};function _ot(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(n.dataId),u=Array.from(e.readSync(s.dataId)),[l,c,p]=RP(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var cB={kernelName:La,backendName:"webgl",kernelFunc:_ot};function Eot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=$w(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var pB={kernelName:Wl,backendName:"webgl",kernelFunc:Eot};function Aot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=$w(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var mB={kernelName:Ul,backendName:"webgl",kernelFunc:Aot};function $ot(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,o,a),f=!1;if(s.dtype==="string"){let y=e.bufferSync(o),b=e.bufferSync(s),w=x.decodeString(e.readSync(i.dataId)[0]),v=AP(y,b,a,m,c,l,u,p,w,f);return e.makeTensorInfo(a,v.dtype,v.values)}let d=new _d(l,u,o.shape.length,s.shape.length,p,[m,1],f),h=e.runWebGLProgram(d,[s,o,i],s.dtype),g=ut({inputs:{x:h},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(h),g}var fB={kernelName:nm,backendName:"webgl",kernelFunc:$ot};function Dot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(m=>{let f=[...p];f[a]=m;let d=xi({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=m,d})}var dB={kernelName:Di,backendName:"webgl",kernelFunc:Dot};var hB="return sqrt(x);",Fot=It({opSnippet:hB,packedOpSnippet:hB,cpuKernelImpl:OP}),gB={kernelName:Ls,backendName:"webgl",kernelFunc:Fot};var Rot="return x * x;",Oot=It({opSnippet:Rot}),xB={kernelName:Hl,backendName:"webgl",kernelFunc:Oot};var yB="return (a - b) * (a - b);",Mot=le({opSnippet:yB,packedOpSnippet:yB}),bB={kernelName:Vs,backendName:"webgl",kernelFunc:Mot};function Pot({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=hr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new en(n.shape,o);return e.runWebGLProgram(s,[n],n.dtype)}var wB={kernelName:uo,backendName:"webgl",kernelFunc:Pot};var Xv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=Ht(n.length),i=Ht(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function Lot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=ut({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let $=Ve.computeOutShape(b,w,v),D=xi({inputs:{x:o},backend:e,attrs:{begin:b,size:$}});k=ut({inputs:{x:D},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([o])){let D=e.readSync(o.dataId),F=Ct(o.shape,o.dtype,D),P=MP(f,F,v,b);k=e.makeTensorInfo(d,o.dtype,P.values)}else{let D=new Xv(b,v,f);k=e.runWebGLProgram(D,[o],o.dtype)}let E=ut({inputs:{x:k},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(k),E}var vB={kernelName:za,backendName:"webgl",kernelFunc:Lot};function zot(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.readSync(c.dataId),f=e.readSync(p.dataId),[d,h]=PP(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var CB={kernelName:om,backendName:"webgl",kernelFunc:zot};function Bot(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),u=e.readSync(i.dataId)[0],[l,c,p]=LP(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var IB={kernelName:sm,backendName:"webgl",kernelFunc:Bot};function Vot(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=zP(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var SB={kernelName:im,backendName:"webgl",kernelFunc:Vot};var Got="return tan(x);",Wot=It({opSnippet:Got}),kB={kernelName:Ws,backendName:"webgl",kernelFunc:Wot};var Uot=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Hot=It({opSnippet:Uot}),NB={kernelName:Us,backendName:"webgl",kernelFunc:Hot};var Yv=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;let o=Ht(this.rank),s=qot(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function qot(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${e[o]}, ${r[o]})`);return n.join()}function WT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=e.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>x.decodeString(m)):u,c=Ct(o.shape,o.dtype,l),p=VP(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Yv(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var TB={kernelName:Yn,backendName:"webgl",kernelFunc:WT};var Zv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Jv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function up(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function _B(r){let t=1;for(;t<r;)t*=2;return t}function Kot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n,a=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,c=l[l.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>u){let P=e.readSync(o.dataId),[W,U]=GP(P,l,o.dtype,s,i);return[e.makeTensorInfo(W.shape,W.dtype,W.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(s===0)return l[l.length-1]=0,[e.makeTensorInfo(l,o.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(c===1)return[o,Nl({attrs:{shape:l,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),m=p!==null&&p.isPacked,f=m?e.unpackTensor(o):o,h=x.sizeFromShape(l)/c,g=ut({inputs:{x:f},attrs:{shape:[h,c]},backend:e});m&&up(e,f);let y=_B(s),b=_B(c),w=null,v=()=>w===null?[g,g]:[g,w],k=(P,W,U)=>{let q=v(),K=new Zv(U),Q=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[P],[W]],rt=w;w=e.runWebGLProgram(K,q,"int32",Q),up(e,rt)};for(let P=1;P<y;P*=2){let W=P*2;for(let U=P;U>=1;U/=2)k(W,U,[h,b])}for(let P=b;P>y;P/=2){let W=v(),U=new Jv([h,P/2]),K=[[c],[w===null?1:0],[y]],j=w;w=e.runWebGLProgram(U,W,"int32",K),up(e,j);let Q=y/2,rt=Q*2;for(let X=Q;X>=1;X/=2)k(rt,X,w.shape)}let E=w;w=xi({inputs:{x:w},backend:e,attrs:{begin:0,size:[h,s]}}),up(e,E);let $=MT({inputs:{x:g,indices:w},backend:e,attrs:{axis:1,batchDims:1}});up(e,g);let D=l.slice(0,-1);D.push(s),E=w,w=ut({inputs:{x:w},attrs:{shape:D},backend:e}),up(e,E);let F=$;return $=ut({inputs:{x:$},attrs:{shape:D},backend:e}),up(e,F),[$,w]}var EB={kernelName:Ba,backendName:"webgl",kernelFunc:Kot};var Qv=class{constructor(t,e,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function jot(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=new Qv(p,m,i,a,u,g);return e.runWebGLProgram(y,[o,s],"float32")}var AB={kernelName:Va,backendName:"webgl",kernelFunc:jot};function Xot(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;di(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=WP(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var $B={kernelName:am,backendName:"webgl",kernelFunc:Xot};function Yot(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let h=0;h<a;h++)h!==s&&(l[c++]=i.shape[h]);let p=[],m=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=xi({inputs:{x:i},backend:e,attrs:{begin:m,size:f}}),y=ut({inputs:{x:g},backend:e,attrs:{shape:l}});d[h]=y,p.push(g)}return p.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var DB={kernelName:Fi,backendName:"webgl",kernelFunc:Yot};var t0=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,p=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Zot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=S.getAxesPermutation([l],a),p=o;c!=null&&(p=he({inputs:{x:o},backend:e,attrs:{perm:c}}),u.push(p),l=S.getInnerMostAxes(1,a)[0]);let m=S.segment_util.computeOutShape(p.shape,l,i),f=x.sizeFromShape([p.shape[l]]),d=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(d);let h=qu(o.dtype),g=(v,k,E,$,D)=>{let F=v.shape[0],P=v.shape[1],W=S.segment_util.segOpComputeOptimalWindowSize(P,D),U={windowSize:W,inSize:P,batchSize:F,numSegments:D},q=new t0(U,k),K=e.compileAndRun(q,[v,E],$);if(u.push(K),K.shape[1]===D)return K;let j=GT({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),Q=WT({inputs:{x:j},backend:e,attrs:{reps:[P/W]}});return u.push(j),u.push(Q),g(K,k,Q,$,D)},y=g(d,"unsortedSegmentSum",s,h,i),b=ut({inputs:{x:y},backend:e,attrs:{shape:m}}),w=b;if(c!=null){u.push(b);let v=S.getUndoAxesPermutation(c);w=he({inputs:{x:w},backend:e,attrs:{perm:v}})}return u.forEach(v=>e.disposeIntermediateTensorInfo(v)),w}var FB={kernelName:ql,backendName:"webgl",kernelFunc:Zot};var Jot=[wL,CL,IL,SL,NL,TL,_L,EL,DL,FL,RL,OL,ML,PL,LL,zL,BL,VL,GL,WL,UL,qL,KL,jL,JL,t3,e3,lL,n3,s3,a3,l3,u3,c3,p3,m3,f3,d3,h3,y3,b3,w3,v3,C3,I3,S3,k3,N3,T3,_3,E3,A3,$3,D3,F3,O3,M3,P3,L3,B3,V3,G3,W3,U3,H3,q3,K3,j3,aL,X3,o3,Y3,Z3,J3,uL,Q3,tz,ez,rz,nz,oz,sz,iz,az,lz,cz,pz,mz,fz,dz,hz,xz,bz,wz,vz,Cz,Iz,_z,dL,Ez,Az,$z,Dz,XL,Fz,Mz,Pz,Lz,zz,cL,Bz,Vz,YL,Sz,Gz,Wz,Uz,gL,Hz,qz,Kz,jz,Xz,Yz,Zz,Jz,Qz,tB,eB,rB,nB,oB,sB,iB,HL,Tz,aB,lB,uB,cB,pB,mB,fB,dB,gB,xB,bB,wB,vB,CB,IB,SB,Nz,yL,kB,NB,TB,EB,AB,bL,$B,DB,FB,Rz];for(let r of Jot)Bu(r);var Xt;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Xt||(Xt={}));var Tu;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(Tu||(Tu={}));var RB;function Qot(r){RB=r.wasm.cwrap(Oi,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function tst(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=0;if(i!=null){let D=e.dataIdMap.get(i.dataId);if(D.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${D.shape.length}.`);d=D.id}let h=a==null?0:e.dataIdMap.get(a.dataId).id,g=Tu[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=u?o.shape[2]:o.shape[1],b=l?s.shape[1]:s.shape[2],w=Sr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),v=e.makeOutput([...w,y,b],o.dtype),k=e.dataIdMap.get(v.dataId).id,E=new Uint8Array(new Int32Array(o.shape).buffer),$=new Uint8Array(new Int32Array(s.shape).buffer);return RB(m,E,o.shape.length,f,$,s.shape.length,u,l,g,d,h,p||0,k),v}var OB={kernelName:Oi,backendName:"wasm",setupFunc:Qot,kernelFunc:tst};function ue(r,t){let e;function n(s){e=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:i,inputs:{x:a}}=s,u=i.dataIdMap.get(a.dataId).id,l=i.makeOutput(a.shape,t||a.dtype),c=i.dataIdMap.get(l.dataId).id;return x.sizeFromShape(l.shape)===0||e(u,Xt[a.dtype],c),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var MB=ue(wi);function Se(r,t,e){let n;function o(i){n=i.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:a,inputs:u}=i,{a:l,b:c}=u,p=a.dataIdMap.get(l.dataId).id,m=a.dataIdMap.get(c.dataId).id,f=e!=null?e:l.dtype,d=S.assertAndGetBroadcastShape(l.shape,c.shape),h=a.makeOutput(d,f);if(x.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),b=a.dataIdMap.get(h.dataId).id;return(()=>n(p,g,l.shape.length,m,y,c.shape.length,Xt[l.dtype],b))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var est=!0,PB=Se(Xn,est);var LB;function rst(r){LB=r.wasm.cwrap(Zo,null,["array","number","number","number"])}function nst(r){let{inputs:t,backend:e}=r,n=e.makeOutput(t[0].shape,t[0].dtype);if(x.sizeFromShape(n.shape)===0)return n;let o=t.map(a=>e.dataIdMap.get(a.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),i=e.dataIdMap.get(n.dataId).id;return LB(s,o.length,Xt[n.dtype],i),n}var zB={kernelName:Zo,backendName:"wasm",setupFunc:rst,kernelFunc:nst};function cp(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype),o=e.typedArrayFromHeap(t);return e.typedArrayFromHeap(n).set(o),n}var BB={kernelName:lo,backendName:"wasm",kernelFunc:cp};var VB;function ost(r){VB=r.wasm.cwrap(Hs,null,["number","array","number","number","number","array","number"])}function no(r){let{inputs:t,backend:e,attrs:n}=r,[o,s]=ist(t.x.shape,n.perm),i=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(i=!1);let a=sst(t.x.shape,n.perm),u={dataId:t.x.dataId,shape:o,dtype:t.x.dtype};if(i){let d=cp({inputs:t,backend:e});return d.shape=a,d}let l=e.makeOutput(a,u.dtype),c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(u.shape).buffer);return VB(c,f,u.shape.length,Xt[u.dtype],p,m,s.length),l}function sst(r,t){let e=new Array(r.length);for(let n=0;n<e.length;n++)e[n]=r[t[n]];return e}function ist(r,t){let e=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&e.push(r[o]),r[t[o]]!==1&&n.push(t[o]);for(let o=0;o<n.length;++o){let s=-1;for(let i=0;i<n.length;++i)n[i]>=o&&(s===-1||n[s]>n[i])&&(s=i);n[s]=o}return[e,n]}var GB={kernelName:Hs,backendName:"wasm",kernelFunc:no,setupFunc:ost};function Sn(r,t,e){let n=r.shape,o=r.shape.length,s=x.parseAxisParam(t,n),i=s,a=S.getAxesPermutation(i,o),u=null,l=!1;if(a!=null){let c=new Array(o);for(let f=0;f<c.length;f++)c[f]=n[a[f]];i=S.getInnerMostAxes(i.length,o),u=no({inputs:{x:r},attrs:{perm:a},backend:e});let p=e.dataIdMap.get(r.dataId).id;e.dataIdMap.get(u.dataId).id!==p&&(l=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:l}}var WB;function ast(r){WB=r.wasm.cwrap(oa,null,["number, number, number"])}function lst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("all",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;WB(u,y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var UB={kernelName:oa,backendName:"wasm",setupFunc:ast,kernelFunc:lst};var HB;function ust(r){HB=r.wasm.cwrap(sa,null,["number, number, number"])}function cst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("any",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;HB(u,y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var qB={kernelName:sa,backendName:"wasm",setupFunc:ust,kernelFunc:cst};var KB;function pst(r){KB=r.wasm.cwrap(Jo,null,["number","number","number","number","number"])}function mst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=i,u=s,{transposed:l,axes:c,inputWasTransposed:p}=Sn(s,o,t);if(p){let y=t.dataIdMap.get(l.dataId).id;y!==i&&(u=l,a=y)}let m=u.shape.slice(0,-1),f=t.makeOutput(m,"int32"),d=t.dataIdMap.get(f.dataId).id,h=x.sizeFromShape(f.shape),g=u.shape[c[0]];return KB(a,Xt[u.dtype],h,g,d),p&&t.disposeData(l.dataId),f}var jB={kernelName:Jo,backendName:"wasm",kernelFunc:mst,setupFunc:pst};var XB;function fst(r){XB=r.wasm.cwrap(Qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dst(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let v=n.makeOutput(c.outShape,"float32"),k=n.dataIdMap.get(v.dataId).id;return XB(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,b,w,k),v}var YB={kernelName:Qo,backendName:"wasm",setupFunc:fst,kernelFunc:dst};function pr(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=x.sizeFromShape(n.shape),i=x.inferFromImplicitShape(o,s);return x.assert(s===x.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var ZB={kernelName:_i,backendName:"wasm",kernelFunc:pr};var JB;function hst(r){JB=r.wasm.cwrap(ts,null,["number","array","number","number","array","number","number","number","number"])}function gst(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),w=Sr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[g,c,m]:[g,m,c],k=a?[y,f,p]:[y,p,f],E=pr({inputs:{x:o},backend:e,attrs:{shape:v}}),$=pr({inputs:{x:s},backend:e,attrs:{shape:k}}),D=e.dataIdMap.get(E.dataId).id,F=e.dataIdMap.get($.dataId).id,P=i?E.shape[2]:E.shape[1],W=a?$.shape[1]:$.shape[2],U=Math.max(g,y),q=e.makeOutput([U,P,W],E.dtype),K=e.dataIdMap.get(q.dataId).id,j=new Uint8Array(new Int32Array(E.shape).buffer),Q=new Uint8Array(new Int32Array($.shape).buffer);return JB(D,j,E.shape.length,F,Q,$.shape.length,i,a,K),e.disposeData(E.dataId),e.disposeData($.dataId),q.shape=w,q}var QB={kernelName:ts,backendName:"wasm",setupFunc:hst,kernelFunc:gst};function zo(r){let{inputs:{x:t},attrs:{begin:e,size:n},backend:o}=r,[s,i]=Ve.parseSliceParams(t,e,n),a=Ve.isSliceContinous(t.shape,s,i),u=o.readSync(t.dataId),l=o.makeOutput(i,t.dtype),c=x.computeStrides(t.shape),p=o.dataIdMap.get(l.dataId);if(a){let d=Ve.computeFlatOffset(s,c);return t.dtype==="string"?p.stringBytes=u.slice(d,d+x.sizeFromShape(i)):o.typedArrayFromHeap(l).set(u.subarray(d,d+x.sizeFromShape(i))),l}if(t.dtype==="string"){let d=Yc(u,s,i,t.shape,t.dtype);return p.stringBytes=d,l}let m=o.typedArrayFromHeap(l),f=t.shape.length;if(f===2)xst(u,c[0],m,s,i);else if(f===3)yst(u,c[0],c[1],m,s,i);else if(f===4)bst(u,c[0],c[1],c[2],m,s,i);else{let d=Yc(u,s,i,t.shape,t.dtype);m.set(d)}return l}function xst(r,t,e,n,o){let s=0,i=n[0],a=n[1],u=i+o[0];for(let l=i;l<u;l++){let c=l*t+a;e.set(r.subarray(c,c+o[1]),s),s+=o[1]}}function yst(r,t,e,n,o,s){let i=0,a=o[0],u=o[1],l=o[2],c=a+s[0],p=u+s[1];for(let m=a;m<c;m++)for(let f=u;f<p;f++){let d=m*t+f*e+l;n.set(r.subarray(d,d+s[2]),i),i+=s[2]}}function bst(r,t,e,n,o,s,i){let a=0,u=s[0],l=s[1],c=s[2],p=u+i[0],m=l+i[1],f=c+i[2],d=s[3];for(let h=u;h<p;h++)for(let g=l;g<m;g++)for(let y=c;y<f;y++){let b=h*t+g*e+y*n+d;o.set(r.subarray(b,b+i[3]),a),a+=i[3]}}var tV={kernelName:Ai,backendName:"wasm",kernelFunc:zo};function wst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n,a=s.reduce((y,b)=>y*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=pr({inputs:{x:o},backend:e,attrs:{shape:u}}),d=no({inputs:{x:f},backend:e,attrs:{perm:l}}),h=pr({inputs:{x:d},backend:e,attrs:{shape:c}}),g=zo({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeData(f.dataId),e.disposeData(d.dataId),e.disposeData(f.dataId),g}var eV={kernelName:vi,backendName:"wasm",kernelFunc:wst};function Tl(r){let{inputs:{x:t},attrs:{dtype:e},backend:n}=r,o=n.makeOutput(t.shape,e),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(o).set(s),o}var rV={kernelName:io,backendName:"wasm",kernelFunc:Tl};var nV=ue(es);var oV;function vst(r){oV=r.wasm.cwrap(ao,null,["number","number","number","number"])}function Cst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a=e.dataIdMap.get(o.dataId).id,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(u.dataId).id;return oV(a,s,i,l),u}var sV={kernelName:ao,backendName:"wasm",setupFunc:vst,kernelFunc:Cst};function UT(r){let{inputs:t,backend:e}=r,n=x.parseAxisParam(r.attrs.axis,t[0].shape)[0],o=S.computeOutShape(t.map(f=>f.shape),n),s=t.filter(f=>x.sizeFromShape(f.shape)>0);if(s.length===1)return cp({inputs:{x:s[0]},backend:e});let i=e.makeOutput(o,t[0].dtype);if(x.sizeFromShape(o)===0)return i;let a=s.map(f=>f.shape);if(S.assertParamsConsistent(a,n),s[0].dtype==="string"){let f=s.map(w=>{let v=x.sizeFromShape(w.shape.slice(n));return pr({inputs:{x:w},backend:e,attrs:{shape:[-1,v]}})}),d=f.map(w=>({vals:e.readSync(w.dataId),shape:w.shape}));o=S.computeOutShape(f.map(w=>w.shape),1);let h=f[0].shape[0]===1,g=Kc(d,o,t[0].dtype,h),y=S.computeOutShape(s.map(w=>w.shape),n);i.shape=y;let b=e.dataIdMap.get(i.dataId);return b.stringBytes=S.fromStringArrayToUint8(g),f.forEach(w=>e.disposeData(w.dataId)),i}let u=x.sizeFromShape(s[0].shape.slice(0,n)),l=0,c=s.map(f=>{let d=x.sizeFromShape(f.shape.slice(n));return l+=d,d}),p=s.map(f=>e.typedArrayFromHeap(f)),m=e.typedArrayFromHeap(i);for(let f=0;f<u;f++){let d=f*l;for(let h=0;h<p.length;h++){let g=c[h],y=f*g,b=p[h].subarray(y,y+g);m.set(b,d),d+=g}}return i}var iV={kernelName:Ci,backendName:"wasm",kernelFunc:UT};var aV;function Ist(r){aV=r.wasm.cwrap(rs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Sst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p,dataFormat:m}=e,f=S.convertConv2DDataFormat(m),d=S.computeConv2DInfo(o.shape,s.shape,u,l,c,p,!1,f),h=d.filterHeight,g=d.filterWidth,y=d.padInfo.top,b=d.padInfo.right,w=d.padInfo.bottom,v=d.padInfo.left,k=d.dilationHeight,E=d.dilationWidth,$=d.strideHeight,D=d.strideWidth,F=d.inChannels,P=d.outChannels,W=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let U=n.makeOutput(d.outShape,"float32"),q=n.dataIdMap.get(U.dataId).id;return aV(i,o.shape[0],o.shape[1],o.shape[2],a,h,g,y,b,w,v,W,k,E,$,D,F,P,q),U}var lV={kernelName:rs,backendName:"wasm",setupFunc:Ist,kernelFunc:Sst};var uV;function kst(r){uV=r.wasm.cwrap(ns,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Nst(r){let{backend:t,inputs:e,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,inputShape:c}=n,p=1,m=S.convertConv2DDataFormat(u),f=S.computeConv2DInfo(c,s.shape,i,p,a,l,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:y,inHeight:b,inWidth:w,outChannels:v,outHeight:k,outWidth:E,strideHeight:$,strideWidth:D}=f,F=h-1-f.padInfo.top,P=g-1-f.padInfo.left,W=f.dataFormat==="channelsLast",U=x.computeStrides(f.inShape),q=x.computeStrides(o.shape),[K,j,Q]=x.computeStrides(s.shape),rt=U[0],X=W?U[1]:U[2],nt=W?U[2]:1,st=W?1:U[1],it=q[0],ft=W?q[1]:q[2],at=W?q[2]:1,xt=W?1:q[1],dt=t.makeOutput(f.inShape,"float32"),bt=t.dataIdMap.get(dt.dataId).id,kt=t.dataIdMap.get(o.dataId).id,At=t.dataIdMap.get(s.dataId).id;return uV(kt,At,d,h,g,b,w,y,k,E,v,$,D,F,P,K,j,Q,rt,X,nt,st,it,ft,at,xt,bt),dt}var cV={kernelName:ns,backendName:"wasm",setupFunc:kst,kernelFunc:Nst};var pV=ue(os);var mV=ue(ss);var HT;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(HT||(HT={}));var fV;function Tst(r){fV=r.wasm.cwrap(ma,null,["number","number","number","number","array","number","number","number","number","number"])}function _st(r){let{backend:t,inputs:e,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:i}=n,{image:a,boxes:u,boxInd:l}=e,c=u.shape[0],[p,m]=i,f=[c,p,m,a.shape[3]],d=t.dataIdMap.get(a.dataId),h;a.dtype!=="float32"&&(h=Tl({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),d=t.dataIdMap.get(h.dataId));let g=d.id,y=t.dataIdMap.get(u.dataId).id,b=t.dataIdMap.get(l.dataId).id,w=t.makeOutput(f,"float32"),v=t.dataIdMap.get(w.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer);return fV(g,y,b,c,k,p,m,HT[o],s,v),h!=null&&t.disposeData(h.dataId),w}var dV={kernelName:ma,backendName:"wasm",setupFunc:Tst,kernelFunc:_st};var hV;function Est(r){hV=r.wasm.cwrap(pa,null,["number","number","number","number","number","number"])}function Ast(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;x.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=no({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumprod",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;hV(d,i?1:0,a?1:0,f,h,Xt[o.dtype]);let g=m;if(l!==null){let y=S.getUndoAxesPermutation(l);g=no({inputs:{x:m},attrs:{perm:y},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var gV={kernelName:pa,backendName:"wasm",setupFunc:Est,kernelFunc:Ast};var xV;function $st(r){xV=r.wasm.cwrap(is,null,["number","number","number","number","number","number"])}function Dst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;x.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=no({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumsum",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;xV(d,i?1:0,a?1:0,f,h,Xt[o.dtype]);let g=m;if(l!==null){let y=S.getUndoAxesPermutation(l);g=no({inputs:{x:m},attrs:{perm:y},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var yV={kernelName:is,backendName:"wasm",setupFunc:$st,kernelFunc:Dst};var bV;function Fst(r){bV=r.wasm.cwrap(fa,null,["number","number","number","array","number","array","array","number","number"])}function Rst(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=t.makeOutput(d,"float32"),y=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),w=new Uint8Array(new Int32Array(d).buffer),v=new Uint8Array(new Int32Array(x.computeStrides(d)).buffer),k=t.dataIdMap.get(h.dataId).id;return bV(y,s,i==="NHWC"?1:0,b,o.shape.length-1,w,v,d.length,k),h}var wV={kernelName:fa,backendName:"wasm",setupFunc:Fst,kernelFunc:Rst};var vV;function Ost(r){vV=r.wasm.cwrap(as,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Mst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p}=e,m=l==null?[1,1]:l,f=S.computeConv2DInfo(o.shape,s.shape,u,m,c,p,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,b=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,E=f.strideHeight,$=f.strideWidth,D=f.inChannels,F=f.outChannels,P=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),U=n.dataIdMap.get(W.dataId).id;return vV(i,o.shape[0],o.shape[1],o.shape[2],a,d,h,g,y,b,w,P,v,k,E,$,D,F,U),W}var CV={kernelName:as,backendName:"wasm",setupFunc:Ost,kernelFunc:Mst};var IV=ue(us);var Pst=!1,SV=Se(ha,Pst,"bool");var kV=ue(cs,"float32");function e0(r){let{inputs:t,attrs:e,backend:n}=r,{input:o}=t,{dim:s}=e,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(x.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),pr({inputs:{x:o},backend:n,attrs:{shape:a}})}var NV={kernelName:Ii,backendName:"wasm",kernelFunc:e0};function qT(r){let{attrs:{shape:t,value:e,dtype:n},backend:o}=r,s=o.makeOutput(t,n);return o.typedArrayFromHeap(s).fill(e),s}var TV={kernelName:Pl,backendName:"wasm",kernelFunc:qT};var _V;function Lst(r){_V=r.wasm.cwrap(xa,null,["number","number","number","number","number","number"])}function zst(r){let{inputs:t,backend:e}=r,{image:n}=t,o=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,[a,u,l,c]=n.shape;return _V(s,a,u,l,c,i),o}var EV={kernelName:xa,backendName:"wasm",kernelFunc:zst,setupFunc:Lst};var AV=ue(ps);var Bst=!1,$V=Se(ms,Bst);var DV;function Vst(r){DV=r.wasm.cwrap(fs,null,["number","number","number","number","number","number","number"])}function Gst(r){let{backend:t,inputs:e,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:i,variance:a,offset:u,scale:l}=e,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,f=u!=null?t.dataIdMap.get(u.dataId).id:0,d=l!=null?t.dataIdMap.get(l.dataId).id:0,h=t.makeOutput(s.shape,s.dtype);if(x.sizeFromShape(s.shape)===0)return h;let g=t.dataIdMap.get(h.dataId).id;return DV(c,p,m,f,d,o,g),h}var FV={kernelName:fs,backendName:"wasm",setupFunc:Vst,kernelFunc:Gst};var RV;function Wst(r){RV=r.wasm.cwrap(Mi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ust(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m),g=Tu[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,v=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);v=at.id}let k=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,F=h.padInfo.bottom,P=h.padInfo.left,W=h.dilationHeight,U=h.dilationWidth,q=h.strideHeight,K=h.strideWidth,j=h.inChannels,Q=h.padInfo.type==="SAME"?1:0,rt=h.batchSize,X=h.inHeight,nt=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,ft=a==null?0:n.dataIdMap.get(a.dataId).id;return RV(y,rt,X,nt,b,k,E,v,$,D,F,P,Q,W,U,q,K,j,w,g,ft,d||0,it),st}var OV={kernelName:Mi,backendName:"wasm",setupFunc:Wst,kernelFunc:Ust};var MV;function Hst(r){MV=r.wasm.cwrap(Pi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function qst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!0),g=Tu[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,v=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);v=at.id}let k=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,F=h.padInfo.bottom,P=h.padInfo.left,W=h.dilationHeight,U=h.dilationWidth,q=h.strideHeight,K=h.strideWidth,j=h.inChannels,Q=h.padInfo.type==="SAME"?1:0,rt=h.batchSize,X=h.inHeight,nt=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,ft=a==null?0:n.dataIdMap.get(a.dataId).id;return MV(y,rt,X,nt,b,k,E,v,$,D,F,P,Q,W,U,q,K,j,w,g,ft,d||0,it),st}var PV={kernelName:Pi,backendName:"wasm",setupFunc:Hst,kernelFunc:qst};var LV;function Kst(r){LV=r.wasm.cwrap(ya,null,["number","number","number","number","number","number","array","number"])}function jst(r){let{backend:t,inputs:e}=r,{params:n,indices:o}=e,[s,i,a,u]=Rx.prepareAndValidate(n,o),l=t.makeOutput(s,n.dtype);if(i===0)return l;let c=o.shape,p=c[c.length-1],f=t.dataIdMap.get(n.dataId).id,h=t.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),y=t.dataIdMap.get(l.dataId).id;return LV(f,Xt[n.dtype],h,i,p,a,g,y),l}var zV={kernelName:ya,backendName:"wasm",setupFunc:Kst,kernelFunc:jst};var BV;function Xst(r){BV=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Yst(r){let{backend:t,inputs:e,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=x.parseAxisParam(i,o.shape)[0],l=t.readSync(s.dataId),c=o.shape[u];for(let F=0;F<l.length;++F){let P=l[F];x.assert(P<=c-1&&P>=0,()=>`GatherV2: the index value ${P} is not in [0, ${c-1}]`)}let p=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),m=pr({inputs:{x:o},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),f=x.sizeFromShape(s.shape),d=pr({inputs:{x:s},attrs:{shape:[p.batchSize,f/p.batchSize]},backend:t}),h=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],g=t.makeOutput(h,o.dtype);if(x.sizeFromShape(o.shape)===0)return g;let y=m.shape.length-1,w=t.dataIdMap.get(m.dataId).id,k=t.dataIdMap.get(d.dataId).id,E=t.dataIdMap.get(g.dataId).id,$=new Uint8Array(new Int32Array(x.computeStrides(m.shape)).buffer),D=new Uint8Array(new Int32Array(x.computeStrides(h)).buffer);return BV(w,Xt[o.dtype],$,y,k,p.batchSize,D,E),t.disposeData(m.dataId),t.disposeData(d.dataId),g.shape=p.outputShape,g}var VV={kernelName:Si,backendName:"wasm",setupFunc:Xst,kernelFunc:Yst};var Zst=!1,GV=Se(ba,Zst,"bool");var Jst=!1,WV=Se(ds,Jst,"bool");var UV;function Qst(r){UV=r.wasm.cwrap(hs,null,["number","number","number","number"])}function tit(r){let{inputs:{x:t},attrs:{alpha:e},backend:n}=r,o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(t.shape,"float32");if(x.sizeFromShape(t.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;UV(o,Xt[t.dtype],e,i)}return s}var HV={kernelName:hs,backendName:"wasm",setupFunc:Qst,kernelFunc:tit};var eit=!1,qV=Se(Ia,eit,"bool");var rit=!1,KV=Se(Sa,rit,"bool");var jV=ue(gs);var nit=!1,XV=Se(Na,nit,"bool");var YV;function oit(r){YV=r.wasm.cwrap(xs,null,["number","number","number","number"])}function sit(r){let{backend:t,inputs:e,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("max",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;YV(u,Xt[i.dtype],y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var ZV={kernelName:xs,backendName:"wasm",setupFunc:oit,kernelFunc:sit};var iit=!1,JV=Se(ys,iit);var QV;function ait(r){QV=r.wasm.cwrap(bs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lit(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id;x.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,v=c.strideWidth,k=c.inChannels,E=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let $=n.makeOutput(c.outShape,"float32"),D=n.dataIdMap.get($.dataId).id;return QV(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,b,w,v,k,E,D),$}var tG={kernelName:bs,backendName:"wasm",setupFunc:ait,kernelFunc:lit};var eG;function uit(r){eG=r.wasm.cwrap(ws,null,["number, number, number"])}function cit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let v=t.dataIdMap.get(c.dataId).id;v!==a&&(l=c,u=v,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("mean",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=l;l.dtype!=="float32"&&(b=Tl({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(b.dataId).id);let w=t.makeOutput(h,"float32");if(x.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(w.dataId).id;eG(u,y,v)}if(f&&t.disposeData(c.dataId),s){let v=S.expandShapeToKeepDim(w.shape,m);w.shape=v}return l.dtype!=="float32"&&t.disposeData(b.dataId),w}var rG={kernelName:ws,backendName:"wasm",setupFunc:uit,kernelFunc:cit};var nG;function pit(r){nG=r.wasm.cwrap(vs,null,["number","number","number","number"])}function mit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w)}let d=l.shape.length;S.assertAxesAreInnerMostDims("min",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;nG(u,Xt[i.dtype],y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var oG={kernelName:vs,backendName:"wasm",setupFunc:pit,kernelFunc:mit};var fit=!1,sG=Se(Cs,fit);var KT;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(KT||(KT={}));var iG;function dit(r){iG=r.wasm.cwrap(Is,null,["number","array","number","number","array","array","number","number"])}function hit(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+t.shape[h]+d[1]),i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),u=e.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return iG(i,l,t.shape.length,Xt[t.dtype],m,f,KT[o],u),a}var aG={kernelName:Is,backendName:"wasm",kernelFunc:hit,setupFunc:dit};var git=!0,lG=Se(Ss,git);var uG=ue(ki);function Ed(r,t){let e=new Int32Array(r.wasm.HEAPU8.buffer,t,4),n=e[0],o=e[1],s=e[2],i=e[3];return r.wasm._free(t),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:i}}var cG;function xit(r){cG=r.wasm.cwrap(Ea,"number",["number","number","number","number","number"])}function yit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i}=n,{boxes:a,scores:u}=e,l=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=cG(l,c,s,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=Ed(t,p);return t.wasm._free(d),t.wasm._free(h),t.makeOutput([f],"int32",m)}var pG={kernelName:Ea,backendName:"wasm",setupFunc:xit,kernelFunc:yit};var mG;function bit(r){mG=r.wasm.cwrap(Aa,"number",["number","number","number","number","number","bool"])}function wit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=mG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=Ed(t,m);t.wasm._free(h);let y=t.makeOutput([d],"int32",f),b=t.makeOutput([],"int32",g);return[y,b]}var fG={kernelName:Aa,backendName:"wasm",setupFunc:bit,kernelFunc:wit};var dG;function vit(r){dG=r.wasm.cwrap($a,"number",["number","number","number","number","number","number"])}function Cit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,softNmsSigma:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=dG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=Ed(t,m);t.wasm._free(g);let y=t.makeOutput([d],"int32",f),b=t.makeOutput([d],"float32",h);return[y,b]}var hG={kernelName:$a,backendName:"wasm",setupFunc:vit,kernelFunc:Cit};var Iit=!1,gG=Se(_a,Iit,"bool");var xG;function Sit(r){xG=r.wasm.cwrap(ks,null,["number","number","number","number","number"])}function kit(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n,u=e.makeOutput([...o.shape,s],"int32"),l=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(o.dataId).id;return xG(p,s,i,a,l),u}var yG={kernelName:ks,backendName:"wasm",setupFunc:Sit,kernelFunc:kit};function Nit(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(1),n}var bG={kernelName:Ni,backendName:"wasm",kernelFunc:Nit};function Tit(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return e0({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=e0({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=UT({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeData(c.dataId)),l}var wG={kernelName:Ti,backendName:"wasm",kernelFunc:Tit};var vG;function _it(r){vG=r.wasm.cwrap(Ns,null,["number","array","number","number","array","array","number","number"])}function Eit(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+t.shape[g]+h[1]);if(x.sizeFromShape(t.shape)===0)return qT({backend:e,attrs:{shape:s,value:o,dtype:t.dtype}});let i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=n.map(h=>h[0]),m=n.map(h=>h[1]),f=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return vG(i,c,t.shape.length,Xt[t.dtype],f,d,o,l),a}var r0={kernelName:Ns,backendName:"wasm",kernelFunc:Eit,setupFunc:_it};var Ait=!1,CG=Se(Ts,Ait);var IG;function $it(r){IG=r.wasm.cwrap(_s,null,["number","number","number"])}function Dit(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,a=s,u=n,l=u;u.dtype!=="float32"&&(l=Tl({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),a=e.dataIdMap.get(l.dataId).id);let c=e.makeOutput(n.shape,"float32"),p=e.dataIdMap.get(c.dataId).id;return IG(a,i,p),u.dtype!=="float32"&&e.disposeData(l.dataId),c}var SG={kernelName:_s,backendName:"wasm",setupFunc:$it,kernelFunc:Dit};var kG;function Fit(r){kG=r.wasm.cwrap(Es,null,["number","number","number","number"])}function Rit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("prod",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;kG(u,y,Xt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var NG={kernelName:Es,backendName:"wasm",setupFunc:Fit,kernelFunc:Rit};var Oit=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=Xc(n,o,s,i),u=t.makeOutput([a.length],i);return t.typedArrayFromHeap(u).set(a),u},TG={kernelName:Bl,backendName:"wasm",kernelFunc:Oit};var Mit=!0,_G=Se(ls,Mit);var EG=ue(As);var AG=ue(Ds);var $G;function Pit(r){$G=r.wasm.cwrap($s,null,["number","number","number","number","number","number","number","number","number","number"])}function Lit(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[c,p,m,f]=o.shape,d=[c,u,l,f],h=t.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=Tl({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(g.dataId));let y=h.id,b=t.makeOutput(d,"float32");if(x.sizeFromShape(o.shape)===0)return b;let w=t.dataIdMap.get(b.dataId).id;return $G(y,c,p,m,f,u,l,s?1:0,i?1:0,w),g!=null&&t.disposeData(g.dataId),b}var DG={kernelName:$s,backendName:"wasm",setupFunc:Pit,kernelFunc:Lit};var FG;function zit(r){FG=r.wasm.cwrap(Fs,null,["number","array","number","array","number","number"])}function Bit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=x.parseAxisParam(s,o.shape);if(o.shape.length===0)return cp({inputs:{x:o},backend:e});let a=e.makeOutput(o.shape,o.dtype),u=e.dataIdMap.get(o.dataId).id,l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer);FG(u,c,i.length,p,o.shape.length,l);let m=pr({inputs:{x:a},attrs:{shape:o.shape},backend:e});return e.disposeData(a.dataId),m}var RG={kernelName:Fs,backendName:"wasm",kernelFunc:Bit,setupFunc:zit};var OG;function Vit(r){OG=r.wasm.cwrap(Ga,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Git(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{radians:s,fillValue:i,center:a}=n,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(o.dataId).id,c=e.dataIdMap.get(u.dataId).id,[p,m,f,d]=o.shape,[h,g]=S.getImageCenter(a,m,f),y=i===0,b=255,w=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(w).buffer);return OG(l,p,m,f,d,s,h,g,v,w.length,c),u}var MG={kernelName:Ga,backendName:"wasm",kernelFunc:Git,setupFunc:Vit};var PG=ue(Rs);var LG=ue(Os);var zG;function Wit(r){zG=r.wasm.cwrap(Fa,null,["number","number","number","number","number","number","array","number","number"])}function Uit(r){let{backend:t,inputs:e,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,a=t.makeOutput(i,s.dtype);if(x.sizeFromShape(i)===0)return a;let{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=ih.calculateShapes(s,o,i),d=t.dataIdMap.get(o.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),b=t.dataIdMap.get(a.dataId).id;return zG(d,g,Xt[s.dtype],u,l,c,y,m,b),a}var BG={kernelName:Fa,backendName:"wasm",setupFunc:Wit,kernelFunc:Uit};var VG;function Hit(r){VG=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function qit(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=e.makeOutput(o.shape,o.dtype),c=e.dataIdMap.get(l.dataId).id,p=n.shape.length,m=o.shape.length,f=p===0||p>1||m===1?1:x.sizeFromShape(o.shape.slice(1));return VG(i,a,u,f,c),l}var GG={kernelName:Ei,backendName:"wasm",kernelFunc:qit,setupFunc:Hit};var WG;function Kit(r){WG=r.wasm.cwrap(Ps,null,["number","number"])}function jit(r){let{backend:t,inputs:{x:e}}=r,n=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(e.shape,e.dtype),s=t.dataIdMap.get(o.dataId).id;return x.sizeFromShape(o.shape)===0||WG(n,s),o}var UG={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Kit,kernelFunc:jit};var HG=ue(Ms);var qG;function Xit(r){qG=r.wasm.cwrap(Bs,null,["number","number","number","number"])}function Yit(r){let{backend:t,inputs:{logits:e},attrs:{dim:n}}=r,o=t.dataIdMap.get(e.dataId).id,s=t.makeOutput(e.shape,e.dtype),i=t.dataIdMap.get(s.dataId).id,a=e.shape[n],u=x.sizeFromShape(e.shape)/a;return x.sizeFromShape(s.shape)===0||qG(o,i,a,u),s}var KG={kernelName:Bs,backendName:"wasm",setupFunc:Xit,kernelFunc:Yit};function Zit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n,a=x.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=r0.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=pr({inputs:{x:l},backend:e,attrs:{shape:c}}),b=no({inputs:{x:h},backend:e,attrs:{perm:p}}),k=pr({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeData(l.dataId),e.disposeData(h.dataId),e.disposeData(b.dataId),k}var jG={kernelName:$i,backendName:"wasm",kernelFunc:Zit};var XG;function Jit(r){XG=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Qit(r){let{backend:t,inputs:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e,a=n.shape[0],u=n.shape[1],l=t.readSync(s.dataId)[0],c=[a+l,u],p=t.dataIdMap.get(n.dataId).id,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(i.dataId).id,d=t.makeOutput(c,n.dtype),h=t.dataIdMap.get(d.dataId).id,g=t.makeOutput(c.slice(0,1),o.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([l],"bool"),w=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([a],n.dtype),k=t.dataIdMap.get(v.dataId).id,E=t.makeOutput([4],"int32"),$=t.dataIdMap.get(E.dataId).id,D=XG(p,m,Xt[o.dtype],a,l,u,f,h,y,w,k,$),F=t.readSync(E.dataId),P;switch(F[0]){case 1:{P=S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(F[1]);break}case 2:{P=S.getSparseFillEmptyRowsNegativeIndexErrorMessage(F[1],F[2]);break}case 3:P=S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F[1],F[2],F[3]);break;default:P=""}if(t.disposeData(E.dataId),P)throw t.disposeData(d.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(P);let W=d,U=g;return D!==c[0]&&(W=zo({inputs:{x:d},attrs:{begin:0,size:[D,u]},backend:t}),U=zo({inputs:{x:g},attrs:{begin:0,size:D},backend:t}),t.disposeData(d.dataId),t.disposeData(g.dataId)),[W,U,b,v]}var YG={kernelName:Gl,backendName:"wasm",setupFunc:Jit,kernelFunc:Qit};var ZG;function tat(r){ZG=r.wasm.cwrap(La,null,["number","number","number","number","number","number","number"])}function eat(r){let{backend:t,inputs:e}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=n.shape[0],c=x.sizeFromShape(s.shape),p=t.makeOutput([l,c],n.dtype),m=t.dataIdMap.get(p.dataId).id,f=t.makeOutput([c],s.dtype),d=t.dataIdMap.get(f.dataId).id,h=t.makeOutput([3],"int32"),g=t.dataIdMap.get(h.dataId).id;ZG(i,a,u,l,m,d,g);let y=t.readSync(h.dataId),b;switch(y[0]){case 0:{b=S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=S.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let w=Array.from(t.readSync(o.dataId)),v=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMultipleErrorMessage(w,v);break}case 4:{let w=Array.from(t.readSync(o.dataId)),v=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMismatchErrorMessage(w,v);break}default:b=""}if(t.disposeData(h.dataId),b)throw t.disposeData(p.dataId),t.disposeData(f.dataId),new Error(b);return[p,f]}var JG={kernelName:La,backendName:"wasm",setupFunc:tat,kernelFunc:eat};var QG;function n0(r){QG=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function o0(r,t){let{backend:e,inputs:n}=r,{data:o,indices:s,segmentIds:i}=n,a=s.shape[0],u=e.readSync(i.dataId,a-1,a)[0],c=a>0?u+1:0;if(c<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=o.shape.slice();p[0]=c;let m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=e.dataIdMap.get(i.dataId).id,h=e.makeOutput(p,o.dtype),g=e.dataIdMap.get(h.dataId).id,y=e.makeOutput([4],"int32"),b=e.dataIdMap.get(y.dataId).id;QG(m,Xt[o.dtype],o.shape[0],f,d,g,b,t,0);let w=e.readSync(y.dataId),v;switch(w[0]){case 0:{v=S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{v=S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:v=S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:v=S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:v=""}if(e.disposeData(y.dataId),v)throw e.disposeData(h.dataId),new Error(v);return h}function rat(r){return o0(r,!0)}var tW={kernelName:Wl,backendName:"wasm",setupFunc:n0,kernelFunc:rat};function nat(r){return o0(r,!1)}var eW={kernelName:Ul,backendName:"wasm",setupFunc:n0,kernelFunc:nat};function oat(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=e,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=zo({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[a]+=p,f})}var rW={kernelName:Di,backendName:"wasm",kernelFunc:oat};var nW=ue(Ls);var oW=ue(Hl);var sat=!0,sW=Se(Vs,sat);var iW;function iat(r){iW=r.wasm.cwrap(uo,null,["number","number","number","number"])}function aat(r){let{backend:t,inputs:e,attrs:n}=r,{alpha:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(a.dataId).id;return iW(i,o,Xt[s.dtype],u),a}var aW={kernelName:uo,backendName:"wasm",setupFunc:iat,kernelFunc:aat};var lW;function lat(r){lW=r.wasm.cwrap(za,null,["number","array","number","array","array","array","array","array","number","number"])}function uat(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=pr({inputs:{x:o},backend:t,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Ve.computeOutShape(b,w,v),$=zo({inputs:{x:o},backend:t,attrs:{begin:b,size:E}});k=pr({inputs:{x:$},backend:t,attrs:{shape:d}}),t.disposeData($.dataId)}else{let E=t.makeOutput(f,"float32"),$=t.dataIdMap.get(o.dataId).id,D=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),F=new Uint8Array(new Int32Array(b).buffer),P=new Uint8Array(new Int32Array(w).buffer),W=new Uint8Array(new Int32Array(v).buffer),U=new Uint8Array(new Int32Array(f).buffer),q=new Uint8Array(new Int32Array(x.computeStrides(f)).buffer),K=t.dataIdMap.get(E.dataId).id;lW($,D,o.shape.length,F,P,W,U,q,f.length,K),k=pr({inputs:{x:E},backend:t,attrs:{shape:d}}),t.disposeData(E.dataId)}return k}var uW={kernelName:za,backendName:"wasm",setupFunc:lat,kernelFunc:uat};var cat=!0,cW=Se(Gs,cat);var pW;function pat(r){pW=r.wasm.cwrap(zs,null,["number","number","number","number"])}function mat(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("sum",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;pW(u,y,Xt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var mW={kernelName:zs,backendName:"wasm",setupFunc:pat,kernelFunc:mat};var fW=ue(Ws);var dW=ue(Us);var hW;function fat(r){hW=r.wasm.cwrap(Yn,null,["number","array","number","array","number","number"])}function dat(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,s=e.dataIdMap.get(o.dataId).id,{reps:i}=n,a=new Array(o.shape.length);for(let m=0;m<a.length;m++)a[m]=o.shape[m]*i[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(a).buffer),c=e.makeOutput(a,o.dtype),p=e.dataIdMap.get(c.dataId).id;return hW(s,u,o.shape.length,l,a.length,Xt[c.dtype],p),c}var gW={kernelName:Yn,backendName:"wasm",setupFunc:fat,kernelFunc:dat};var xW;function hat(r){xW=r.wasm.cwrap(Ba,null,["number","array","number","number","number","bool","number","number"])}var gat=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{k:o,sorted:s}=e,i=t.dataIdMap.get(n.dataId).id,a=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=t.makeOutput(u,n.dtype),c=t.dataIdMap.get(l.dataId).id,p=t.makeOutput(u,"int32"),m=t.dataIdMap.get(p.dataId).id;return xW(i,a,n.shape.length,Xt[n.dtype],o,s,c,m),[l,p]},yW={kernelName:Ba,backendName:"wasm",setupFunc:hat,kernelFunc:gat};var bW;function xat(r){bW=r.wasm.cwrap(Va,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function yat(r){let{backend:t,inputs:e,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),b=t.makeOutput(g,o.dtype),w=t.dataIdMap.get(b.dataId).id,k=t.dataIdMap.get(o.dataId).id,$=t.dataIdMap.get(s.dataId).id,D=i==="nearest"?1:2,F;switch(a){case"constant":F=1;break;case"reflect":F=2;break;case"wrap":F=3;break;case"nearest":F=4;break;default:F=1;break}return bW(k,$,s.shape[0]>1,c,d,h,f,m,p,y,o.shape.length-1,D,F,u,w),b}var wW={kernelName:Va,backendName:"wasm",setupFunc:xat,kernelFunc:yat};function bat(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape[s],a=o.shape.length,u=new Array(a-1),l=0;for(let f=0;f<a;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i),p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)p[s]=f,c[f]=zo({inputs:{x:o},attrs:{begin:p,size:m},backend:e});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:u}))}var vW={kernelName:Fi,backendName:"wasm",kernelFunc:bat};function wat(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(0),n}var CW={kernelName:Ri,backendName:"wasm",kernelFunc:wat};var vat=[OB,MB,PB,zB,UB,qB,jB,YB,QB,eV,rV,nV,sV,iV,lV,cV,pV,mV,dV,gV,yV,wV,CV,IV,SV,kV,NV,TV,EV,AV,$V,FV,OV,PV,zV,VV,GV,WV,BB,HV,qV,KV,jV,XV,ZV,JV,tG,rG,oG,sG,aG,lG,uG,pG,fG,hG,gG,yG,bG,wG,r0,CG,SG,NG,TG,_G,EG,AG,ZB,DG,RG,MG,PG,LG,BG,GG,UG,HG,tV,KG,jG,YG,JG,tW,eW,rW,nW,oW,sW,aW,uW,cW,mW,fW,dW,gW,yW,wW,GB,vW,CW];for(let r of vat)Bu(r);var jT=V();jT.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));jT.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(jT.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var QT=Ou(NW());var TW=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`;var AW=Ou(_W());var Lg=class extends jo{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(DW),t1=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ta(this,go())}write(t,e,n){let o={id:this.dataIdNextNumber++};return this.move(o,t,e,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let e=x.now();return t(),{kernelMs:x.now()-e}}move(t,e,n,o,s){let i=this.dataIdNextNumber++;if(o==="string"){let c=e;this.dataIdMap.set(t,{id:i,stringBytes:c,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let a=x.sizeFromShape(n),u=a*x.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(t,{id:i,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(i,a,l),e!=null&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,u),l)}async read(t){return this.readSync(t)}readSync(t,e,n){let{memoryOffset:o,dtype:s,shape:i,stringBytes:a}=this.dataIdMap.get(t);if(s==="string")return(e==null||e===0)&&(n==null||n>=a.length)?a:a.slice(e,n);e=e||0,n=n||x.sizeFromShape(i);let u=x.bytesPerElement(s),l=this.wasm.HEAPU8.slice(o+e*u,o+n*u);return Iat(l.buffer,s)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){let n=this.dataIdMap.get(t);if(n.refCount--,!e&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let e=this.dataIdMap.get(t);e!=null&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,n){let o;if(n==null)o=this.write(null,t,e);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:t,dtype:e,refCount:1});let i=x.sizeFromShape(t);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:o,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),i=x.sizeFromShape(t);switch(e){case"float32":return new Float32Array(o,s,i);case"int32":return new Int32Array(o,s,i);case"bool":return new Uint8Array(o,s,i);default:throw new Error(`Unknown dtype ${e}`)}}};function Cat(r){return(t,e)=>(x.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||t.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,t).then(s=>{e(s.instance,s.module)})})}),{})}function EW(r,t,e){if(a0!=null)return a0;let n="tfjs-backend-wasm.wasm";return r&&t?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Mg!=null&&Mg[n]!=null?Mg[n]:e+n}async function $W(){let[r,t]=await Promise.all([V().getAsync("WASM_HAS_SIMD_SUPPORT"),V().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((e,n)=>{let o={};o.locateFile=(a,u)=>{if(a.endsWith(".worker.js")){let l=TW.replace(/\n/g,"\\n"),c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return a.endsWith(".wasm")?EW(r,t,Og!=null?Og:u):u+a},e1&&(o.instantiateWasm=Cat(EW(r,t,Og!=null?Og:"")));let s=!1;o.onAbort=()=>{if(s||Pg)return;Pg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;t&&r&&a0==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+QT.default.toString()],{type:"text/javascript"}),i=(0,QT.default)(o)):i=(0,AW.default)(o),i.then(a=>{s=!0,Pg=!1;let u=null;a.tfjs={init:a.cwrap("init",null,[]),initWithThreadsCount:a.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:a.cwrap("get_threads_count","number",[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",u,["number"]),dispose:a.cwrap("dispose",u,[])},e({wasm:a})})})}function Iat(r,t){switch(t){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${t}`)}}var Sat=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],a0=null,Og=null,Mg={},Pg=!1,e1=!1;function kat(r,t=!1){if(FI("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Pg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");a0=r,e1=t}function Nat(r,t=!1){if(Pg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")Og=r;else{Mg=r;let e=Sat.filter(n=>Mg[n]==null);if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}e1=t}var DW=-1,t1=-1;function Tat(r){DW=r}function _at(){if(t1===-1)throw new Error("WASM backend not initialized.");return t1}var Eat="3.17.0";var Aat=2;ym("wasm",async()=>{let{wasm:r}=await $W();return new Lg(r)},Aat);var $at="3.17.0",Dat="3.17.0",Fat="3.17.0",Rat="3.17.0",Oat="3.17.0",Mat="3.17.0",Pat="3.17.0",Lat="3.17.0",zat={tfjs:$at,"tfjs-core":Dat,"tfjs-data":Fat,"tfjs-layers":Rat,"tfjs-converter":Oat,"tfjs-backend-cpu":Mat,"tfjs-backend-webgl":Pat,"tfjs-backend-wasm":Lat};export{wi as Abs,ra as Acos,na as Acosh,nu as AdadeltaOptimizer,ou as AdagradOptimizer,su as AdamOptimizer,iu as AdamaxOptimizer,Xn as Add,Zo as AddN,oa as All,sa as Any,Jo as ArgMax,Dl as ArgMin,ia as Asin,aa as Asinh,la as Atan,ca as Atan2,ua as Atanh,Qo as AvgPool,Fl as AvgPool3D,$p as AvgPool3DGrad,Ap as AvgPoolGrad,Lg as BackendWasm,ts as BatchMatMul,vi as BatchToSpaceND,Dp as Bincount,Fp as BroadcastArgs,E1 as BroadcastTo,fb as Callback,Ny as CallbackList,io as Cast,es as Ceil,ao as ClipByValue,Rp as Complex,Rl as ComplexAbs,Ci as Concat,rs as Conv2D,Op as Conv2DBackpropFilter,ns as Conv2DBackpropInput,Ol as Conv3D,Mp as Conv3DBackpropFilterV2,Pp as Conv3DBackpropInputV2,os as Cos,ss as Cosh,ma as CropAndResize,pa as Cumprod,is as Cumsum,_y as CustomCallback,ta as DataStorage,Lp as DenseBincount,fa as DepthToSpace,as as DepthwiseConv2dNative,zp as DepthwiseConv2dNativeBackpropFilter,Bp as DepthwiseConv2dNativeBackpropInput,Vp as Diag,Ml as Dilation2D,jd as Dilation2DBackpropFilter,Kd as Dilation2DBackpropInput,qC as ENV,db as EarlyStopping,Gp as Einsum,us as Elu,Wp as EluGrad,Hd as Environment,ha as Equal,da as Erf,cs as Exp,Ii as ExpandDims,ga as Expm1,Up as FFT,Pl as Fill,xa as FlipLeftRight,ps as Floor,ms as FloorDiv,Xd as FromPixels,fs as FusedBatchNorm,Mi as FusedConv2D,Pi as FusedDepthwiseConv2D,ep as GPGPUContext,ya as GatherNd,Si as GatherV2,Db as GraphModel,ba as Greater,ds as GreaterEqual,Ty as History,Hp as IFFT,lo as Identity,qp as Imag,Ce as InputSpec,wa as IsFinite,va as IsInf,Ca as IsNan,jo as KernelBackend,Ll as LRN,jp as LRNGrad,Yh as LayerVariable,Vn as LayersModel,hs as LeakyRelu,Ia as Less,Sa as LessEqual,Kp as LinSpace,gs as Log,ka as Log1p,A1 as LogSoftmax,Na as LogicalAnd,Lu as LogicalNot,zu as LogicalOr,Hat as LowerBound,Cu as MathBackendWebGL,xs as Max,bs as MaxPool,zl as MaxPool3D,Yp as MaxPool3DGrad,Xp as MaxPoolGrad,Zp as MaxPoolWithArgmax,ys as Maximum,ws as Mean,vs as Min,Cs as Minimum,Is as MirrorPad,Ta as Mod,au as MomentumOptimizer,Jp as Multinomial,Ss as Multiply,ki as Neg,Ea as NonMaxSuppressionV3,Aa as NonMaxSuppressionV4,$a as NonMaxSuppressionV5,_a as NotEqual,o_ as OP_SCOPE_SUFFIX,ks as OneHot,Ni as OnesLike,Vr as Optimizer,oi as OptimizerConstructors,Ti as Pack,Ns as PadV2,qat as Pool,Ts as Pow,_s as Prelu,Es as Prod,lu as RMSPropOptimizer,$n as RNN,Bl as Range,nI as Rank,Qp as Real,ls as RealDiv,Da as Reciprocal,Je as Reduction,As as Relu,Ds as Relu6,_i as Reshape,$s as ResizeBilinear,em as ResizeBilinearGrad,Vl as ResizeNearestNeighbor,tm as ResizeNearestNeighborGrad,Fs as Reverse,Ga as RotateWithOffset,Rs as Round,Os as Rsqrt,Hi as SGDOptimizer,Fa as ScatterNd,rm as SearchSorted,Ei as Select,Ra as Selu,Yi as Sequential,Ps as Sigmoid,Ma as Sign,Ms as Sin,Oa as Sinh,Ai as Slice,Bs as Softmax,Pa as Softplus,$i as SpaceToBatchND,Gl as SparseFillEmptyRows,La as SparseReshape,Wl as SparseSegmentMean,Ul as SparseSegmentSum,nm as SparseToDense,Di as SplitV,Ls as Sqrt,Hl as Square,Vs as SquaredDifference,uo as Step,za as StridedSlice,om as StringNGrams,sm as StringSplit,im as StringToHashBucketFast,Gs as Sub,zs as Sum,Qr as SymbolicTensor,Ws as Tan,Us as Tanh,Lt as Tensor,pe as TensorBuffer,Yn as Tile,Ba as TopK,Va as Transform,Hs as Transpose,am as Unique,Fi as Unpack,ql as UnsortedSegmentSum,Kat as UpperBound,Wa as Variable,Ri as ZerosLike,Oi as _FusedMatMul,Te as abs,uh as acos,ch as acosh,J as add,RI as addN,Yu as all,Jl as any,Xs as argMax,ph as argMin,mh as asin,fh as asinh,dh as atan,hh as atan2,gh as atanh,Ka as avgPool,xh as avgPool3d,Q_ as backend,S as backend_util,YH as basicLSTMCell,xo as batchNorm,LI as batchNorm2d,zI as batchNorm3d,BI as batchNorm4d,ja as batchToSpaceND,yh as bincount,Z1t as booleanMaskAsync,VI as broadcastArgs,Xa as broadcastTo,Sr as broadcast_util,Fx as browser,Ct as buffer,_7 as callbacks,Z as cast,bh as ceil,br as clipByValue,kn as clone,zn as complex,se as concat,GI as concat1d,WI as concat2d,UI as concat3d,HI as concat4d,M$ as constraints,Qu as conv1d,pn as conv2d,tc as conv2dTranspose,wh as conv3d,qI as conv3dTranspose,tlt as copyRegisteredKernels,Ya as cos,ec as cosh,Zx as cosineWindow,Ql as cumprod,rc as cumsum,mn as customGrad,DF as data,KI as denseBincount,FI as deprecationWarn,vh as depthToSpace,Zs as depthwiseConv2d,D7 as deregisterOp,Yl as device_util,Nq as diag,Ch as dilation2d,Ipt as disableDeprecationWarnings,_t as dispose,Spt as disposeVariables,ct as div,Ih as divNoNan,jI as dot,IE as dropout,XI as einsum,Js as elu,Cpt as enableDebugMode,vpt as enableProdMode,SE as enclosingPowerOfTwo,go as engine,V as env,kr as equal,Sh as erf,Nh as euclideanNorm,Ye as exp,fr as expandDims,Th as expm1,vm as eye,sl as fft,Qs as fill,Apt as findBackend,$pt as findBackendFactory,ti as floor,Xu as floorDiv,iL as forceHalfFloat,Co as fused,bo as gather,vE as gatherND,Rx as gather_util,_pt as getBackend,XC as getGradient,Zd as getKernel,bx as getKernelsForBackend,_at as getThreadsCount,CT as gpgpu_util,pK as grad,mK as grads,Ge as greater,Tn as greaterEqual,Wi as ifft,nc as imag,dn as image,V_t as inTopKAsync,P$ as initializers,HS as input,Pr as io,gc as irfft,tS as isFinite,eS as isInf,_h as isNaN,Pe as keep,Gr as kernel_impls,hD as layers,Za as leakyRelu,oc as less,_n as lessEqual,uA as linalg,rS as linspace,kZ as loadGraphModel,z8 as loadLayersModel,Eh as localResponseNormalization,wr as log,Ja as log1p,nS as logSigmoid,sc as logSoftmax,Ah as logSumExp,Tr as logicalAnd,Qa as logicalNot,ic as logicalOr,oS as logicalXor,yOt as losses,sS as lowerBound,zt as matMul,R_ as math,Fr as max,tl as maxPool,$h as maxPool3d,iS as maxPoolWithArgmax,fn as maximum,be as mean,lh as memory,$K as meshgrid,gD as metrics,tu as min,ei as minimum,Dh as mirrorPad,Fh as mod,P8 as model,xD as models,Cm as moments,l_t as movingAverage,M as mul,PK as multiRNNCell,aS as multinomial,Zt as neg,Hh as nextFrame,eu as norm,vo as notEqual,js as oneHot,lr as ones,dr as onesLike,N as op,GK as outerProduct,Zr as pad,HK as pad1d,KK as pad2d,XK as pad3d,ZK as pad4d,lS as pool,Yr as pow,rl as prelu,vI as print,ac as prod,kpt as profile,sj as rand,fj as randomGamma,Kx as randomNormal,ri as randomUniform,nl as range,Tpt as ready,ru as real,Rh as reciprocal,ym as registerBackend,B8 as registerCallbackConstructor,D1 as registerGradient,Bu as registerKernel,$7 as registerOp,yD as regularizers,_r as relu,cc as relu6,Ept as removeBackend,R as reshape,ir as reverse,Cj as reverse1d,Sj as reverse2d,Nj as reverse3d,_j as reverse4d,il as rfft,pc as round,mc as rsqrt,pt as scalar,bE as scatterND,ih as scatter_util,Gx as searchSorted,fc as selu,Oh as separableConv2d,L8 as sequential,et as serialization,yH as setBackend,Dpt as setPlatform,Tat as setThreadsCount,kat as setWasmPath,Nat as setWasmPaths,MN as setWebGLContext,xS as setdiff1dAsync,Lr as sigmoid,Mh as sign,HRt as signal,dc as sin,hc as sinh,Ft as slice,Ph as slice1d,jx as slice2d,Lh as slice3d,Im as slice4d,Ve as slice_util,ol as softmax,wo as softplus,el as spaceToBatchND,Uh as sparse,Yx as sparseToDense,BRt as spectral,ur as split,ye as sqrt,Wt as square,xc as squaredDifference,zr as squeeze,Ze as stack,ni as step,zh as stridedSlice,ay as string,lt as sub,mt as sum,qu as sumOutType,Bh as tan,Ys as tanh,$r as tensor,Fe as tensor1d,Ui as tensor2d,TI as tensor3d,Qj as tensor4d,t6 as tensor5d,e6 as tensor6d,fo as tensor_util,Z_ as test_util,B as tidy,Nr as tile,Npt as time,Vh as topk,Ic as train,Mt as transpose,yc as truncatedNormal,Sm as unique,Qat as unregisterGradient,Jat as unregisterKernel,Gh as unsortedSegmentSum,vr as unstack,ar as upcastType,yS as upperBound,x as util,fK as valueAndGrad,dK as valueAndGrads,bS as variable,zx as variableGrads,zat as version,ZD as version_converter,J_ as version_core,jm as version_layers,Eat as version_wasm,sL as version_webgl,cNe as webgl,dd as webgl_util,Ee as where,Wh as whereAsync,we as zeros,St as zerosLike};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
