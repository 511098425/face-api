/*
  Face-API
  homepage: <https://github.com/vladmandic/face-api>
  author: <https://github.com/vladmandic>'
*/

var hU=Object.create;var RC=Object.defineProperty;var gU=Object.getOwnPropertyDescriptor;var xU=Object.getOwnPropertyNames;var yU=Object.getPrototypeOf,bU=Object.prototype.hasOwnProperty;var Oe=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),Yt=(r,t)=>{for(var e in t)RC(r,e,{get:t[e],enumerable:!0})},wU=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of xU(t))!bU.call(r,o)&&o!==e&&RC(r,o,{get:()=>t[o],enumerable:!(n=gU(t,o))||n.enumerable});return r};var Ru=(r,t,e)=>(e=r!=null?hU(yU(r)):{},wU(t||!r||!r.__esModule?RC(e,"default",{value:r,enumerable:!0}):e,r));var O1=Oe((Pat,F1)=>{F1.exports=Xe;var co=null;try{co=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function Xe(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}Xe.prototype.__isLong__;Object.defineProperty(Xe.prototype,"__isLong__",{value:!0});function Ln(r){return(r&&r.__isLong__)===!0}Xe.isLong=Ln;var k1={},N1={};function Bu(r,t){var e,n,o;return t?(r>>>=0,(o=0<=r&&r<256)&&(n=N1[r],n)?n:(e=Ye(r,(r|0)<0?-1:0,!0),o&&(N1[r]=e),e)):(r|=0,(o=-128<=r&&r<128)&&(n=k1[r],n)?n:(e=Ye(r,r<0?-1:0,!1),o&&(k1[r]=e),e))}Xe.fromInt=Bu;function po(r,t){if(isNaN(r))return t?zu:mo;if(t){if(r<0)return zu;if(r>=A1)return R1}else{if(r<=-_1)return Pn;if(r+1>=_1)return D1}return r<0?po(-r,t).neg():Ye(r%im|0,r/im|0,t)}Xe.fromNumber=po;function Ye(r,t,e){return new Xe(r,t,e)}Xe.fromBits=Ye;var xx=Math.pow;function qC(r,t,e){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return mo;if(typeof t=="number"?(e=t,t=!1):t=!!t,e=e||10,e<2||36<e)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return qC(r.substring(1),t,e).neg();for(var o=po(xx(e,8)),s=mo,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),e);if(a<8){var l=po(xx(e,a));s=s.mul(l).add(po(u))}else s=s.mul(o),s=s.add(po(u))}return s.unsigned=t,s}Xe.fromString=qC;function qs(r,t){return typeof r=="number"?po(r,t):typeof r=="string"?qC(r,t):Ye(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}Xe.fromValue=qs;var T1=1<<16,GU=1<<24,im=T1*T1,A1=im*im,_1=A1/2,E1=Bu(GU),mo=Bu(0);Xe.ZERO=mo;var zu=Bu(0,!0);Xe.UZERO=zu;var sm=Bu(1);Xe.ONE=sm;var $1=Bu(1,!0);Xe.UONE=$1;var HC=Bu(-1);Xe.NEG_ONE=HC;var D1=Ye(-1,2147483647,!1);Xe.MAX_VALUE=D1;var R1=Ye(-1,-1,!0);Xe.MAX_UNSIGNED_VALUE=R1;var Pn=Ye(0,-2147483648,!1);Xe.MIN_VALUE=Pn;var yt=Xe.prototype;yt.toInt=function(){return this.unsigned?this.low>>>0:this.low};yt.toNumber=function(){return this.unsigned?(this.high>>>0)*im+(this.low>>>0):this.high*im+(this.low>>>0)};yt.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Pn)){var e=po(t),n=this.div(e),o=n.mul(e).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=po(xx(t,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,c=l.toString(t);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};yt.getHighBits=function(){return this.high};yt.getHighBitsUnsigned=function(){return this.high>>>0};yt.getLowBits=function(){return this.low};yt.getLowBitsUnsigned=function(){return this.low>>>0};yt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Pn)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&(t&1<<e)==0;e--);return this.high!=0?e+33:e+1};yt.isZero=function(){return this.high===0&&this.low===0};yt.eqz=yt.isZero;yt.isNegative=function(){return!this.unsigned&&this.high<0};yt.isPositive=function(){return this.unsigned||this.high>=0};yt.isOdd=function(){return(this.low&1)===1};yt.isEven=function(){return(this.low&1)===0};yt.equals=function(t){return Ln(t)||(t=qs(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};yt.eq=yt.equals;yt.notEquals=function(t){return!this.eq(t)};yt.neq=yt.notEquals;yt.ne=yt.notEquals;yt.lessThan=function(t){return this.comp(t)<0};yt.lt=yt.lessThan;yt.lessThanOrEqual=function(t){return this.comp(t)<=0};yt.lte=yt.lessThanOrEqual;yt.le=yt.lessThanOrEqual;yt.greaterThan=function(t){return this.comp(t)>0};yt.gt=yt.greaterThan;yt.greaterThanOrEqual=function(t){return this.comp(t)>=0};yt.gte=yt.greaterThanOrEqual;yt.ge=yt.greaterThanOrEqual;yt.compare=function(t){if(Ln(t)||(t=qs(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};yt.comp=yt.compare;yt.negate=function(){return!this.unsigned&&this.eq(Pn)?Pn:this.not().add(sm)};yt.neg=yt.negate;yt.add=function(t){Ln(t)||(t=qs(t));var e=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=t.high>>>16,a=t.high&65535,u=t.low>>>16,l=t.low&65535,c=0,p=0,m=0,f=0;return f+=s+l,m+=f>>>16,f&=65535,m+=o+u,p+=m>>>16,m&=65535,p+=n+a,c+=p>>>16,p&=65535,c+=e+i,c&=65535,Ye(m<<16|f,c<<16|p,this.unsigned)};yt.subtract=function(t){return Ln(t)||(t=qs(t)),this.add(t.neg())};yt.sub=yt.subtract;yt.multiply=function(t){if(this.isZero())return mo;if(Ln(t)||(t=qs(t)),co){var e=co.mul(this.low,this.high,t.low,t.high);return Ye(e,co.get_high(),this.unsigned)}if(t.isZero())return mo;if(this.eq(Pn))return t.isOdd()?Pn:mo;if(t.eq(Pn))return this.isOdd()?Pn:mo;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(E1)&&t.lt(E1))return po(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=t.high>>>16,u=t.high&65535,l=t.low>>>16,c=t.low&65535,p=0,m=0,f=0,d=0;return d+=i*c,f+=d>>>16,d&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=i*l,m+=f>>>16,f&=65535,m+=o*c,p+=m>>>16,m&=65535,m+=s*l,p+=m>>>16,m&=65535,m+=i*u,p+=m>>>16,m&=65535,p+=n*c+o*l+s*u+i*a,p&=65535,Ye(f<<16|d,p<<16|m,this.unsigned)};yt.mul=yt.multiply;yt.divide=function(t){if(Ln(t)||(t=qs(t)),t.isZero())throw Error("division by zero");if(co){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?co.div_u:co.div_s)(this.low,this.high,t.low,t.high);return Ye(e,co.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?zu:mo;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return zu;if(t.gt(this.shru(1)))return $1;s=zu}else{if(this.eq(Pn)){if(t.eq(sm)||t.eq(HC))return Pn;if(t.eq(Pn))return sm;var i=this.shr(1);return n=i.div(t).shl(1),n.eq(mo)?t.isNegative()?sm:HC:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(Pn))return this.unsigned?zu:mo;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=mo}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:xx(2,a-48),l=po(n),c=l.mul(t);c.isNegative()||c.gt(o);)n-=u,l=po(n,this.unsigned),c=l.mul(t);l.isZero()&&(l=sm),s=s.add(l),o=o.sub(c)}return s};yt.div=yt.divide;yt.modulo=function(t){if(Ln(t)||(t=qs(t)),co){var e=(this.unsigned?co.rem_u:co.rem_s)(this.low,this.high,t.low,t.high);return Ye(e,co.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};yt.mod=yt.modulo;yt.rem=yt.modulo;yt.not=function(){return Ye(~this.low,~this.high,this.unsigned)};yt.and=function(t){return Ln(t)||(t=qs(t)),Ye(this.low&t.low,this.high&t.high,this.unsigned)};yt.or=function(t){return Ln(t)||(t=qs(t)),Ye(this.low|t.low,this.high|t.high,this.unsigned)};yt.xor=function(t){return Ln(t)||(t=qs(t)),Ye(this.low^t.low,this.high^t.high,this.unsigned)};yt.shiftLeft=function(t){return Ln(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Ye(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Ye(0,this.low<<t-32,this.unsigned)};yt.shl=yt.shiftLeft;yt.shiftRight=function(t){return Ln(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Ye(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Ye(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};yt.shr=yt.shiftRight;yt.shiftRightUnsigned=function(t){if(Ln(t)&&(t=t.toInt()),t&=63,t===0)return this;var e=this.high;if(t<32){var n=this.low;return Ye(n>>>t|e<<32-t,e>>>t,this.unsigned)}else return t===32?Ye(e,0,this.unsigned):Ye(e>>>t-32,0,this.unsigned)};yt.shru=yt.shiftRightUnsigned;yt.shr_u=yt.shiftRightUnsigned;yt.toSigned=function(){return this.unsigned?Ye(this.low,this.high,!1):this};yt.toUnsigned=function(){return this.unsigned?this:Ye(this.low,this.high,!0)};yt.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};yt.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};yt.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Xe.fromBytes=function(t,e,n){return n?Xe.fromBytesLE(t,e):Xe.fromBytesBE(t,e)};Xe.fromBytesLE=function(t,e){return new Xe(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};Xe.fromBytesBE=function(t,e){return new Xe(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}});var g_=Oe(()=>{});var x_=Oe(()=>{});var Z_=Oe((Y_,rS)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=l.toString();for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(Y_,typeof rS=="object"&&rS,typeof define=="function"&&define)});var Q_=Oe((J_,nS)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(J_,typeof nS=="object"&&nS,typeof define=="function"&&define)});var eE=Oe((tE,oS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(tE,typeof oS=="object"&&oS,typeof define=="function"&&define)});var nE=Oe((rE,sS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(rE,typeof sS=="object"&&sS,typeof define=="function"&&define)});var sE=Oe((oE,iS)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(oE,typeof iS=="object"&&iS,typeof define=="function"&&define)});var aE=Oe((iE,aS)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(iE,typeof aS=="object"&&aS,typeof define=="function"&&define)});var lS=Oe(()=>{});var lE=Oe((xIt,Lx)=>{(function(r,t){var e=this,n=256,o=6,s=52,i="random",a=t.pow(n,o),u=t.pow(2,s),l=u*2,c=n-1,p;function m(w,v,k){var E=[];v=v==!0?{entropy:!0}:v||{};var $=g(h(v.entropy?[w,b(r)]:w==null?y():w,3),E),D=new f(E),R=function(){for(var P=D.g(o),W=a,U=0;P<u;)P=(P+U)*n,W*=n,U=D.g(1);for(;P>=l;)P/=2,W/=2,U>>>=1;return(P+U)/W};return R.int32=function(){return D.g(4)|0},R.quick=function(){return D.g(4)/4294967296},R.double=R,g(b(D.S),r),(v.pass||k||function(P,W,U,q){return q&&(q.S&&d(q,D),P.state=function(){return d(D,{})}),U?(t[i]=P,W):P})(R,$,"global"in v?v.global:this==t,v.state)}t["seed"+i]=m;function f(w){var v,k=w.length,E=this,$=0,D=E.i=E.j=0,R=E.S=[];for(k||(w=[k++]);$<n;)R[$]=$++;for($=0;$<n;$++)R[$]=R[D=c&D+w[$%k]+(v=R[$])],R[D]=v;(E.g=function(P){for(var W,U=0,q=E.i,K=E.j,j=E.S;P--;)W=j[q=c&q+1],U=U*n+j[c&(j[q]=j[K=c&K+W])+(j[K]=W)];return E.i=q,E.j=K,U})(n)}function d(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function h(w,v){var k=[],E=typeof w,$;if(v&&E=="object")for($ in w)try{k.push(h(w[$],v-1))}catch(D){}return k.length?k:E=="string"?w:w+"\0"}function g(w,v){for(var k=w+"",E,$=0;$<k.length;)v[c&$]=c&(E^=v[c&$]*19)+k.charCodeAt($++);return b(v)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(e.crypto||e.msCrypto).getRandomValues(w)),b(w)}catch(E){var v=e.navigator,k=v&&v.plugins;return[+new Date,e,k,e.screen,b(r)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),r),typeof Lx=="object"&&Lx.exports){Lx.exports=m;try{p=lS()}catch(w){}}else typeof define=="function"&&define.amd&&define(function(){return m})})([],Math)});var uS=Oe((yIt,uE)=>{var HK=Z_(),qK=Q_(),KK=eE(),jK=nE(),XK=sE(),YK=aE(),ic=lE();ic.alea=HK;ic.xor128=qK;ic.xorwow=KK;ic.xorshift7=jK;ic.xor4096=XK;ic.tychei=YK;uE.exports=ic});var HD=Oe((UD,xk)=>{(function(r,t,e){function n(a){var u=this,l=i();u.next=function(){var c=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=c-(u.c=c|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),c=u&&u.state,p=l.next;return p.int32=function(){return l.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,c&&(typeof c=="object"&&o(c,l),p.state=function(){return o(l,{})}),p}function i(){var a=4022871197,u=function(l){l=String(l);for(var c=0;c<l.length;c++){a+=l.charCodeAt(c);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(UD,typeof xk=="object"&&xk,typeof define=="function"&&define)});var KD=Oe((qD,yk)=>{(function(r,t,e){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var c=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^c^c>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(qD,typeof yk=="object"&&yk,typeof define=="function"&&define)});var XD=Oe((jD,bk)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(c^c<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(jD,typeof bk=="object"&&bk,typeof define=="function"&&define)});var ZD=Oe((YD,wk)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.x,c=a.i,p,m,f;return p=l[c],p^=p>>>7,m=p^p<<24,p=l[c+1&7],m^=p^p>>>10,p=l[c+3&7],m^=p^p>>>3,p=l[c+4&7],m^=p^p<<7,p=l[c+7&7],p=p^p<<13,m^=p^p<<9,l[c]=m,a.i=c+1&7,m};function u(l,c){var p,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,p=0;p<c.length;++p)f[p&7]=f[p&7]<<15^c.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?m=f[7]=-1:m=f[p],l.x=f,l.i=0,p=256;p>0;--p)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.x&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(YD,typeof wk=="object"&&wk,typeof define=="function"&&define)});var QD=Oe((JD,vk)=>{(function(r,t,e){function n(i){var a=this;a.next=function(){var l=a.w,c=a.X,p=a.i,m,f;return a.w=l=l+1640531527|0,f=c[p+34&127],m=c[p=p+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[p]=f^m,a.i=p,f+(l^l>>>16)|0};function u(l,c){var p,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,p=g[d&127]^=m+h,f=p==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],p=g[f=f+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,g[f]=m^p;l.w=h,l.X=g,l.i=f}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(l.X&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(JD,typeof vk=="object"&&vk,typeof define=="function"&&define)});var eR=Oe((tR,Ck)=>{(function(r,t,e){function n(i){var a=this,u="";a.next=function(){var c=a.b,p=a.c,m=a.d,f=a.a;return c=c<<25^c>>>7^p,p=p-m|0,m=m<<24^m>>>8^f,f=f-c|0,a.b=c=c<<20^c>>>12^p,a.c=p=p-m|0,a.d=m<<16^p>>>16^f,a.a=f-c|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,c=function(){return(u.next()>>>0)/4294967296};return c.double=function(){do var p=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(p+m)/(1<<21);while(f===0);return f},c.int32=u.next,c.quick=c,l&&(typeof l=="object"&&o(l,u),c.state=function(){return o(u,{})}),c}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(tR,typeof Ck=="object"&&Ck,typeof define=="function"&&define)});var nR=Oe((rR,_b)=>{(function(r,t,e){var n=256,o=6,s=52,i="random",a=e.pow(n,o),u=e.pow(2,s),l=u*2,c=n-1,p;function m(w,v,k){var E=[];v=v==!0?{entropy:!0}:v||{};var $=g(h(v.entropy?[w,b(t)]:w==null?y():w,3),E),D=new f(E),R=function(){for(var P=D.g(o),W=a,U=0;P<u;)P=(P+U)*n,W*=n,U=D.g(1);for(;P>=l;)P/=2,W/=2,U>>>=1;return(P+U)/W};return R.int32=function(){return D.g(4)|0},R.quick=function(){return D.g(4)/4294967296},R.double=R,g(b(D.S),t),(v.pass||k||function(P,W,U,q){return q&&(q.S&&d(q,D),P.state=function(){return d(D,{})}),U?(e[i]=P,W):P})(R,$,"global"in v?v.global:this==e,v.state)}function f(w){var v,k=w.length,E=this,$=0,D=E.i=E.j=0,R=E.S=[];for(k||(w=[k++]);$<n;)R[$]=$++;for($=0;$<n;$++)R[$]=R[D=c&D+w[$%k]+(v=R[$])],R[D]=v;(E.g=function(P){for(var W,U=0,q=E.i,K=E.j,j=E.S;P--;)W=j[q=c&q+1],U=U*n+j[c&(j[q]=j[K=c&K+W])+(j[K]=W)];return E.i=q,E.j=K,U})(n)}function d(w,v){return v.i=w.i,v.j=w.j,v.S=w.S.slice(),v}function h(w,v){var k=[],E=typeof w,$;if(v&&E=="object")for($ in w)try{k.push(h(w[$],v-1))}catch(D){}return k.length?k:E=="string"?w:w+"\0"}function g(w,v){for(var k=w+"",E,$=0;$<k.length;)v[c&$]=c&(E^=v[c&$]*19)+k.charCodeAt($++);return b(v)}function y(){try{var w;return p&&(w=p.randomBytes)?w=w(n):(w=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(w)),b(w)}catch(E){var v=r.navigator,k=v&&v.plugins;return[+new Date,r,k,r.screen,b(t)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(e.random(),t),typeof _b=="object"&&_b.exports){_b.exports=m;try{p=lS()}catch(w){}}else typeof define=="function"&&define.amd?define(function(){return m}):e["seed"+i]=m})(typeof self!="undefined"?self:rR,[],Math)});var Ik=Oe((Wie,oR)=>{var fZ=HD(),dZ=KD(),hZ=XD(),gZ=ZD(),xZ=QD(),yZ=eR(),Gc=nR();Gc.alea=fZ;Gc.xor128=dZ;Gc.xorwow=hZ;Gc.xorshift7=gZ;Gc.xor4096=xZ;Gc.tychei=yZ;oR.exports=Gc});var Sk=Oe(()=>{});var Lb=Oe(()=>{});var $g=Oe(()=>{});var mW=Oe(()=>{});var fW=Oe(()=>{});var dW=Oe(()=>{});var hW=Oe((Qv,GT)=>{var VT=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};function e(){return Ot.buffer!=gr&&Go(Ot.buffer),up}function n(){return Ot.buffer!=gr&&Go(Ot.buffer),cp}function o(){return Ot.buffer!=gr&&Go(Ot.buffer),Td}function s(){return Ot.buffer!=gr&&Go(Ot.buffer),Mg}function i(){return Ot.buffer!=gr&&Go(Ot.buffer),Pg}function a(){return Ot.buffer!=gr&&Go(Ot.buffer),Lg}function u(){return Ot.buffer!=gr&&Go(Ot.buffer),zg}var l=typeof t!="undefined"?t:{},c,p;l.ready=new Promise(function(T,F){c=T,p=F});var m;typeof process!="undefined"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},l),d=[],h="./this.program",g=(T,F)=>{throw F},y=typeof window=="object",b=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=l.ENVIRONMENT_IS_PTHREAD||!1,k="";function E(T){return l.locateFile?l.locateFile(T,k):k+T}var $,D,R,P;function W(T){if(T instanceof Pd)return;X("exiting due to exception: "+T)}var U,q,K;if(w){b?k=$g().dirname(k)+"/":k=__dirname+"/",K=()=>{q||(U=Lb(),q=$g())},$=function(G,Y){return K(),G=q.normalize(G),U.readFileSync(G,Y?void 0:"utf8")},R=F=>{var G=$(F,!0);return G.buffer||(G=new Uint8Array(G)),G},D=(F,G,Y)=>{K(),F=q.normalize(F),U.readFile(F,function(ht,wt){ht?Y(ht):G(wt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(F){if(!(F instanceof Pd))throw F}),process.on("unhandledRejection",function(F){throw F}),g=(F,G)=>{if(_u())throw process.exitCode=F,G;W(G),process.exit(F)},l.inspect=function(){return"[Emscripten Module object]"};let T;try{T=mW()}catch(F){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),F}global.Worker=T.Worker}else(y||b)&&(b?k=self.location.href:typeof document!="undefined"&&document.currentScript&&(k=document.currentScript.src),typeof r!="undefined"&&r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",w||($=T=>{var F=new XMLHttpRequest;return F.open("GET",T,!1),F.send(null),F.responseText},b&&(R=T=>{var F=new XMLHttpRequest;return F.open("GET",T,!1),F.responseType="arraybuffer",F.send(null),new Uint8Array(F.response)}),D=(T,F,G)=>{var Y=new XMLHttpRequest;Y.open("GET",T,!0),Y.responseType="arraybuffer",Y.onload=()=>{if(Y.status==200||Y.status==0&&Y.response){F(Y.response);return}G()},Y.onerror=G,Y.send(null)}),P=T=>document.title=T);w&&typeof performance=="undefined"&&(global.performance=fW().performance);var j=console.log.bind(console),Q=console.warn.bind(console);w&&(K(),j=T=>U.writeSync(1,T+`
`),Q=T=>U.writeSync(2,T+`
`));var rt=l.print||j,X=l.printErr||Q;Object.assign(l,f),f=null,l.arguments&&(d=l.arguments),l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit);var ot=4;function st(T){st.shown||(st.shown={}),st.shown[T]||(st.shown[T]=1,X(T))}function it(T,F){if(typeof WebAssembly.Function=="function"){for(var G={i:"i32",j:"i64",f:"f32",d:"f64"},Y={parameters:[],results:F[0]=="v"?[]:[G[F[0]]]},ht=1;ht<F.length;++ht)Y.parameters.push(G[F[ht]]);return new WebAssembly.Function(Y,T)}var wt=[1,0,1,96],Tt=F.slice(0,1),Wt=F.slice(1),sr={i:127,j:126,f:125,d:124};wt.push(Wt.length);for(var ht=0;ht<Wt.length;++ht)wt.push(sr[Wt[ht]]);Tt=="v"?wt.push(0):wt=wt.concat([1,sr[Tt]]),wt[1]=wt.length-2;var qo=new Uint8Array([0,97,115,109,1,0,0,0].concat(wt,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Ko=new WebAssembly.Module(qo),fx=new WebAssembly.Instance(Ko,{e:{f:T}}),Ld=fx.exports.f;return Ld}var ft=[],at;function xt(){if(ft.length)return ft.pop();try{qn.grow(1)}catch(T){throw T instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":T}return qn.length-1}function dt(T,F){for(var G=T;G<T+F;G++){var Y=hp(G);Y&&at.set(Y,G)}}var bt=0,kt=T=>{bt=T},At=Atomics.load,Dt=Atomics.store,qt=Atomics.compareExchange,Kt;l.wasmBinary&&(Kt=l.wasmBinary);var ce=l.noExitRuntime||!0;typeof WebAssembly!="object"&&mp("no native wasm support detected");var Ot,$e,Se=!1,ae;function je(T,F){T||mp(F)}function Fe(T){var F=l["_"+T];return F}function rn(T,F,G,Y,ht){var wt={string:function(On){var Cp=0;if(On!=null&&On!==0){var d1=(On.length<<2)+1;Cp=vp(d1),Fn(On,Cp,d1)}return Cp},array:function(On){var Cp=vp(On.length);return Tl(On,Cp),Cp}};function Tt(On){return F==="string"?jr(On):F==="boolean"?Boolean(On):On}var Wt=Fe(T),sr=[],qo=0;if(Y)for(var Ko=0;Ko<Y.length;Ko++){var fx=wt[G[Ko]];fx?(qo===0&&(qo=$C()),sr[Ko]=fx(Y[Ko])):sr[Ko]=Y[Ko]}var Ld=Wt.apply(null,sr);function dU(On){return qo!==0&&ux(qo),Tt(On)}return Ld=dU(Ld),Ld}function ze(T,F,G,Y){G=G||[];var ht=G.every(function(Tt){return Tt==="number"}),wt=F!=="string";return wt&&ht&&!Y?Fe(T):function(){return rn(T,F,G,arguments,Y)}}var Bo=1;function Fr(T){var F=new TextDecoder(T);this.decode=G=>(G.buffer instanceof SharedArrayBuffer&&(G=new Uint8Array(G)),F.decode.call(F,G))}var nn=typeof TextDecoder!="undefined"?new Fr("utf8"):void 0;function on(T,F,G){for(var Y=F+G,ht=F;T[ht]&&!(ht>=Y);)++ht;if(ht-F>16&&T.subarray&&nn)return nn.decode(T.subarray(F,ht));for(var wt="";F<ht;){var Tt=T[F++];if(!(Tt&128)){wt+=String.fromCharCode(Tt);continue}var Wt=T[F++]&63;if((Tt&224)==192){wt+=String.fromCharCode((Tt&31)<<6|Wt);continue}var sr=T[F++]&63;if((Tt&240)==224?Tt=(Tt&15)<<12|Wt<<6|sr:Tt=(Tt&7)<<18|Wt<<12|sr<<6|T[F++]&63,Tt<65536)wt+=String.fromCharCode(Tt);else{var qo=Tt-65536;wt+=String.fromCharCode(55296|qo>>10,56320|qo&1023)}}return wt}function jr(T,F){return T?on(n(),T,F):""}function oo(T,F,G,Y){if(!(Y>0))return 0;for(var ht=G,wt=G+Y-1,Tt=0;Tt<T.length;++Tt){var Wt=T.charCodeAt(Tt);if(Wt>=55296&&Wt<=57343){var sr=T.charCodeAt(++Tt);Wt=65536+((Wt&1023)<<10)|sr&1023}if(Wt<=127){if(G>=wt)break;F[G++]=Wt}else if(Wt<=2047){if(G+1>=wt)break;F[G++]=192|Wt>>6,F[G++]=128|Wt&63}else if(Wt<=65535){if(G+2>=wt)break;F[G++]=224|Wt>>12,F[G++]=128|Wt>>6&63,F[G++]=128|Wt&63}else{if(G+3>=wt)break;F[G++]=240|Wt>>18,F[G++]=128|Wt>>12&63,F[G++]=128|Wt>>6&63,F[G++]=128|Wt&63}}return F[G]=0,G-ht}function Fn(T,F,G){return oo(T,n(),F,G)}function Vo(T){for(var F=0,G=0;G<T.length;++G){var Y=T.charCodeAt(G);Y>=55296&&Y<=57343&&(Y=65536+((Y&1023)<<10)|T.charCodeAt(++G)&1023),Y<=127?++F:Y<=2047?F+=2:Y<=65535?F+=3:F+=4}return F}var so=typeof TextDecoder!="undefined"?new Fr("utf-16le"):void 0;function Tl(T,F){e().set(T,F)}function Nu(T,F,G){for(var Y=0;Y<T.length;++Y)e()[F++>>0]=T.charCodeAt(Y);G||(e()[F>>0]=0)}function lp(T,F){return T%F>0&&(T+=F-T%F),T}var gr,up,cp,Td,Mg,Pg,jT,Lg,zg;v&&(gr=l.buffer);function Go(T){gr=T,l.HEAP8=up=new Int8Array(T),l.HEAP16=Td=new Int16Array(T),l.HEAP32=Pg=new Int32Array(T),l.HEAPU8=cp=new Uint8Array(T),l.HEAPU16=Mg=new Uint16Array(T),l.HEAPU32=jT=new Uint32Array(T),l.HEAPF32=Lg=new Float32Array(T),l.HEAPF64=zg=new Float64Array(T)}var Bg=l.INITIAL_MEMORY||16777216;if(v)Ot=l.wasmMemory,gr=l.buffer;else if(l.wasmMemory)Ot=l.wasmMemory;else if(Ot=new WebAssembly.Memory({initial:Bg/65536,maximum:32768,shared:!0}),!(Ot.buffer instanceof SharedArrayBuffer))throw X("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Ot&&(gr=Ot.buffer),Bg=gr.byteLength,Go(gr);var qn,pp=[],_l=[],r0=[],Vg=[],Tu=!1,n0=!1,Gg=0;function _u(){return ce||Gg>0}function sn(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)XT(l.preRun.shift());qg(pp)}function _d(){Tu=!0,!v&&qg(_l)}function o0(){v||(Ht.terminateAllThreads(),n0=!0)}function s0(){if(!v){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)Ed(l.postRun.shift());qg(Vg)}}function XT(T){pp.unshift(T)}function YT(T){_l.unshift(T)}function Ed(T){Vg.unshift(T)}var El=0,Wg=null,Wo=null;function Ad(T){El++,l.monitorRunDependencies&&l.monitorRunDependencies(El)}function ZT(T){if(El--,l.monitorRunDependencies&&l.monitorRunDependencies(El),El==0&&(Wg!==null&&(clearInterval(Wg),Wg=null),Wo)){var F=Wo;Wo=null,F()}}l.preloadedImages={},l.preloadedAudios={};function mp(T){v?postMessage({cmd:"onAbort",arg:T}):l.onAbort&&l.onAbort(T),T="Aborted("+T+")",X(T),Se=!0,ae=1,T+=". Build with -s ASSERTIONS=1 for more info.";var F=new WebAssembly.RuntimeError(T);throw p(F),F}var i0="data:application/octet-stream;base64,";function $d(T){return T.startsWith(i0)}function Ug(T){return T.startsWith("file://")}var an;an="tfjs-backend-wasm-threaded-simd.wasm",$d(an)||(an=E(an));function Hg(T){try{if(T==an&&Kt)return new Uint8Array(Kt);if(R)return R(T);throw"both async and sync fetching of the wasm failed"}catch(F){mp(F)}}function fp(){if(!Kt&&(y||b)){if(typeof fetch=="function"&&!Ug(an))return fetch(an,{credentials:"same-origin"}).then(function(T){if(!T.ok)throw"failed to load wasm binary file at '"+an+"'";return T.arrayBuffer()}).catch(function(){return Hg(an)});if(D)return new Promise(function(T,F){D(an,function(G){T(new Uint8Array(G))},F)})}return Promise.resolve().then(function(){return Hg(an)})}function a0(){var T={env:ox,wasi_snapshot_preview1:ox};function F(Tt,Wt){var sr=Tt.exports;if(l.asm=sr,d0(l.asm.emscripten_tls_init),qn=l.asm.__indirect_function_table,YT(l.asm.__wasm_call_ctors),$e=Wt,!v){var qo=Ht.unusedWorkers.length;Ht.unusedWorkers.forEach(function(Ko){Ht.loadWasmModuleToWorker(Ko,function(){--qo||ZT("wasm-instantiate")})})}}v||Ad("wasm-instantiate");function G(Tt){F(Tt.instance,Tt.module)}function Y(Tt){return fp().then(function(Wt){return WebAssembly.instantiate(Wt,T)}).then(function(Wt){return Wt}).then(Tt,function(Wt){X("failed to asynchronously prepare wasm: "+Wt),mp(Wt)})}function ht(){return!Kt&&typeof WebAssembly.instantiateStreaming=="function"&&!$d(an)&&!Ug(an)&&typeof fetch=="function"?fetch(an,{credentials:"same-origin"}).then(function(Tt){var Wt=WebAssembly.instantiateStreaming(Tt,T);return Wt.then(G,function(sr){return X("wasm streaming compile failed: "+sr),X("falling back to ArrayBuffer instantiation"),Y(G)})}):Y(G)}if(l.instantiateWasm)try{var wt=l.instantiateWasm(T,F);return wt}catch(Tt){return X("Module.instantiateWasm callback failed with error: "+Tt),!1}return ht().catch(p),{}}var JT,QT,l0={};function qg(T){for(;T.length>0;){var F=T.shift();if(typeof F=="function"){F(l);continue}var G=F.func;typeof G=="number"?F.arg===void 0?hp(G)():hp(G)(F.arg):G(F.arg===void 0?null:F.arg)}}function dp(T){var F=$C(),G=T();return ux(F),G}function CW(T){return T}function t1(T){var F=/\b_Z[\w\d_]+/g;return T.replace(F,function(G){var Y=G;return G===Y?G:Y+" ["+G+"]"})}function u0(T){i()[T>>2]=0;var F=Ht.pthreads[T];delete Ht.pthreads[T],F.worker.terminate(),AC(T),Ht.runningWorkers.splice(Ht.runningWorkers.indexOf(F.worker),1),F.worker.pthread=void 0}function c0(T){var F=Ht.pthreads[T];F.worker.postMessage({cmd:"cancel"})}function Kg(T){var F=Ht.pthreads[T];if(F){i()[T>>2]=0;var G=F.worker;Ht.returnWorkerToPool(G)}}function jg(T){pU(T)}function p0(T){if(T instanceof Pd||T=="unwind")return ae;g(1,T)}var Ht={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){v?Ht.initWorker():Ht.initMainThread()},initMainThread:function(){for(var T=8,F=0;F<T;++F)Ht.allocateUnusedWorker()},initWorker:function(){ce=!1},pthreads:{},setExitStatus:function(T){ae=T},terminateAllThreads:function(){for(var T in Ht.pthreads){var F=Ht.pthreads[T];F&&F.worker&&Ht.returnWorkerToPool(F.worker)}for(var G=0;G<Ht.unusedWorkers.length;++G){var Y=Ht.unusedWorkers[G];Y.terminate()}Ht.unusedWorkers=[]},returnWorkerToPool:function(T){Ht.runWithoutMainThreadQueuedCalls(function(){delete Ht.pthreads[T.pthread.threadInfoStruct],Ht.unusedWorkers.push(T),Ht.runningWorkers.splice(Ht.runningWorkers.indexOf(T),1),AC(T.pthread.threadInfoStruct),T.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(T){i()[f1>>2]=0;try{T()}finally{i()[f1>>2]=1}},receiveObjectTransfer:function(T){},threadInit:function(){for(var T in Ht.tlsInitFunctions)Ht.tlsInitFunctions[T]()},loadWasmModuleToWorker:function(T,F){T.onmessage=G=>{var Y=G.data,ht=Y.cmd;if(T.pthread&&(Ht.currentProxiedOperationCallerThread=T.pthread.threadInfoStruct),Y.targetThread&&Y.targetThread!=lx()){var wt=Ht.pthreads[Y.targetThread];wt?wt.worker.postMessage(Y,Y.transferList):X('Internal error! Worker sent a message "'+ht+'" to target pthread '+Y.targetThread+", but that thread no longer exists!"),Ht.currentProxiedOperationCallerThread=void 0;return}ht==="processQueuedMainThreadWork"?l1():ht==="spawnThread"?Yg(Y):ht==="cleanupThread"?Kg(Y.thread):ht==="killThread"?u0(Y.thread):ht==="cancelThread"?c0(Y.thread):ht==="loaded"?(T.loaded=!0,F&&F(T),T.runPthread&&(T.runPthread(),delete T.runPthread)):ht==="print"?rt("Thread "+Y.threadId+": "+Y.text):ht==="printErr"?X("Thread "+Y.threadId+": "+Y.text):ht==="alert"?alert("Thread "+Y.threadId+": "+Y.text):Y.target==="setimmediate"?T.postMessage(Y):ht==="onAbort"?l.onAbort&&l.onAbort(Y.arg):X("worker sent an unknown command "+ht),Ht.currentProxiedOperationCallerThread=void 0},T.onerror=G=>{var Y="worker sent an error!";throw X(Y+" "+G.filename+":"+G.lineno+": "+G.message),G},w&&(T.on("message",function(G){T.onmessage({data:G})}),T.on("error",function(G){T.onerror(G)}),T.on("detachedExit",function(){})),T.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:Ot,wasmModule:$e})},allocateUnusedWorker:function(){var T=E("tfjs-backend-wasm-threaded-simd.worker.js");Ht.unusedWorkers.push(new Worker(T))},getNewWorker:function(){return Ht.unusedWorkers.length==0&&(Ht.allocateUnusedWorker(),Ht.loadWasmModuleToWorker(Ht.unusedWorkers[0])),Ht.unusedWorkers.pop()}};function m0(){var T=lx(),F=i()[T+44>>2],G=i()[T+48>>2],Y=F-G;m1(F,Y),ux(F)}l.establishStackSpace=m0;function Xg(T){if(v)return $u(1,0,T);try{jg(T)}catch(F){p0(F)}}var Eu=[];function hp(T){var F=Eu[T];return F||(T>=Eu.length&&(Eu.length=T+1),Eu[T]=F=qn.get(T)),F}function f0(T,F){return hp(T)(F)}l.invokeEntryPoint=f0;function e1(){var T=new Error;if(!T.stack){try{throw new Error}catch(F){T=F}if(!T.stack)return"(no stack trace available)"}return T.stack.toString()}function d0(T,F,G){Ht.tlsInitFunctions.push(T)}function r1(T,F){qn.set(T,F),Eu[T]=F}var Au;w?Au=()=>{var T=process.hrtime();return T[0]*1e3+T[1]/1e6}:v?Au=()=>performance.now()-l.__performance_now_clock_drift:Au=()=>performance.now();var h0=!0;function g0(T){return i()[a1()>>2]=T,T}function x0(T,F){var G;if(T===0)G=Date.now();else if((T===1||T===4)&&h0)G=Au();else return g0(28),-1;return i()[F>>2]=G/1e3|0,i()[F+4>>2]=G%1e3*1e3*1e3|0,0}function y0(T,F){return x0(T,F)}function b0(T){u1(T,!b,1,!y),Ht.threadInit()}function w0(T){v?postMessage({cmd:"cleanupThread",thread:T}):Kg(T)}function Yg(T){var F=Ht.getNewWorker();if(!F)return 6;Ht.runningWorkers.push(F);var G=Ht.pthreads[T.pthread_ptr]={worker:F,threadInfoStruct:T.pthread_ptr};F.pthread=G;var Y={cmd:"run",start_routine:T.startRoutine,arg:T.arg,threadInfoStruct:T.pthread_ptr};return F.runPthread=()=>{Y.time=performance.now(),F.postMessage(Y,T.transferList)},F.loaded&&(F.runPthread(),delete F.runPthread),0}function v0(T,F,G,Y){if(typeof SharedArrayBuffer=="undefined")return X("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var ht=[],wt=0;if(v&&(ht.length===0||wt))return c1(687865856,T,F,G,Y);if(wt)return wt;var Tt={startRoutine:G,pthread_ptr:T,arg:Y,transferList:ht};return v?(Tt.cmd="spawnThread",postMessage(Tt,ht),0):Yg(Tt)}function C0(){return 2097152}function I0(T,F){if(T==F)postMessage({cmd:"processQueuedMainThreadWork"});else if(v)postMessage({targetThread:T,cmd:"processThreadQueue"});else{var G=Ht.pthreads[T],Y=G&&G.worker;if(!Y)return;Y.postMessage({cmd:"processThreadQueue"})}return 1}function S0(){mp("")}function k0(){w||b||st("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Zg(){return 2147483648}function N0(T,F,G){n().copyWithin(T,F,F+G)}function T0(){return w?dW().cpus().length:navigator.hardwareConcurrency}function $u(T,F){var G=arguments.length-2,Y=arguments;return dp(function(){for(var ht=G,wt=vp(ht*8),Tt=wt>>3,Wt=0;Wt<G;Wt++){var sr=Y[2+Wt];u()[Tt+Wt]=sr}return p1(T,ht,wt,F)})}var Dd=[];function _0(T,F,G){Dd.length=F;for(var Y=G>>3,ht=0;ht<F;ht++)Dd[ht]=u()[Y+ht];var wt=T<0,Tt=wt?l0[-T-1]:K0[T];return Tt.apply(null,Dd)}function E0(T){try{return Ot.grow(T-gr.byteLength+65535>>>16),Go(Ot.buffer),1}catch(F){}}function A0(T){var F=n().length;if(T=T>>>0,T<=F)return!1;var G=Zg();if(T>G)return!1;for(var Y=1;Y<=4;Y*=2){var ht=F*(1+.2/Y);ht=Math.min(ht,T+100663296);var wt=Math.min(G,lp(Math.max(T,ht),65536)),Tt=E0(wt);if(Tt)return!0}return!1}var ee={inEventHandler:0,removeAllEventListeners:function(){for(var T=ee.eventHandlers.length-1;T>=0;--T)ee._removeHandler(T);ee.eventHandlers=[],ee.deferredCalls=[]},registerRemoveEventListeners:function(){ee.removeEventListenersRegistered||(r0.push(ee.removeAllEventListeners),ee.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(T,F,G){function Y(Tt,Wt){if(Tt.length!=Wt.length)return!1;for(var sr in Tt)if(Tt[sr]!=Wt[sr])return!1;return!0}for(var ht in ee.deferredCalls){var wt=ee.deferredCalls[ht];if(wt.targetFunction==T&&Y(wt.argsList,G))return}ee.deferredCalls.push({targetFunction:T,precedence:F,argsList:G}),ee.deferredCalls.sort(function(Tt,Wt){return Tt.precedence<Wt.precedence})},removeDeferredCalls:function(T){for(var F=0;F<ee.deferredCalls.length;++F)ee.deferredCalls[F].targetFunction==T&&(ee.deferredCalls.splice(F,1),--F)},canPerformEventHandlerRequests:function(){return ee.inEventHandler&&ee.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!ee.canPerformEventHandlerRequests())for(var T=0;T<ee.deferredCalls.length;++T){var F=ee.deferredCalls[T];ee.deferredCalls.splice(T,1),--T,F.targetFunction.apply(null,F.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(T,F){for(var G=0;G<ee.eventHandlers.length;++G)ee.eventHandlers[G].target==T&&(!F||F==ee.eventHandlers[G].eventTypeString)&&ee._removeHandler(G--)},_removeHandler:function(T){var F=ee.eventHandlers[T];F.target.removeEventListener(F.eventTypeString,F.eventListenerFunc,F.useCapture),ee.eventHandlers.splice(T,1)},registerOrRemoveHandler:function(T){var F=function(ht){++ee.inEventHandler,ee.currentEventHandler=T,ee.runDeferredCalls(),T.handlerFunc(ht),ee.runDeferredCalls(),--ee.inEventHandler};if(T.callbackfunc)T.eventListenerFunc=F,T.target.addEventListener(T.eventTypeString,F,T.useCapture),ee.eventHandlers.push(T),ee.registerRemoveEventListeners();else for(var G=0;G<ee.eventHandlers.length;++G)ee.eventHandlers[G].target==T.target&&ee.eventHandlers[G].eventTypeString==T.eventTypeString&&ee._removeHandler(G--)},queueEventHandlerOnThread_iiii:function(T,F,G,Y,ht){dp(function(){var wt=vp(12);i()[wt>>2]=G,i()[wt+4>>2]=Y,i()[wt+8>>2]=ht,EC(T,637534208,F,Y,wt)})},getTargetThreadForEventCallback:function(T){switch(T){case 1:return 0;case 2:return Ht.currentProxiedOperationCallerThread;default:return T}},getNodeNameForTarget:function(T){return T?T==window?"#window":T==screen?"#screen":T&&T.nodeName?T.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function $0(T){var F=Vo(T)+1,G=_C(F);return Fn(T,G,F),G}function D0(T,F,G,Y){dp(function(){var ht=vp(12),wt=0;F&&(wt=$0(F)),i()[ht>>2]=wt,i()[ht+4>>2]=G,i()[ht+8>>2]=Y,EC(T,657457152,0,wt,ht)})}function R0(T,F,G,Y){F=F?jr(F):"",D0(T,F,G,Y)}function F0(T){return T>2?jr(T):T}var O0=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function M0(T){T=F0(T);var F=O0[T]||(typeof document!="undefined"?document.querySelector(T):void 0);return F}function Rd(T){return M0(T)}function Jg(T,F,G){var Y=Rd(T);if(!Y)return-4;if(Y.canvasSharedPtr&&(i()[Y.canvasSharedPtr>>2]=F,i()[Y.canvasSharedPtr+4>>2]=G),Y.offscreenCanvas||!Y.controlTransferredOffscreen){Y.offscreenCanvas&&(Y=Y.offscreenCanvas);var ht=!1;if(Y.GLctxObject&&Y.GLctxObject.GLctx){var wt=Y.GLctxObject.GLctx.getParameter(2978);ht=wt[0]===0&&wt[1]===0&&wt[2]===Y.width&&wt[3]===Y.height}Y.width=F,Y.height=G,ht&&Y.GLctxObject.GLctx.viewport(0,0,F,G)}else if(Y.canvasSharedPtr){var Tt=i()[Y.canvasSharedPtr+8>>2];return R0(Tt,T,F,G),1}else return-4;return 0}function Qg(T,F,G){return v?$u(2,1,T,F,G):Jg(T,F,G)}function P0(T,F,G){var Y=Rd(T);return Y?Jg(T,F,G):Qg(T,F,G)}function L0(){throw"unwind"}function z0(T){var F=T.getExtension("ANGLE_instanced_arrays");if(F)return T.vertexAttribDivisor=function(G,Y){F.vertexAttribDivisorANGLE(G,Y)},T.drawArraysInstanced=function(G,Y,ht,wt){F.drawArraysInstancedANGLE(G,Y,ht,wt)},T.drawElementsInstanced=function(G,Y,ht,wt,Tt){F.drawElementsInstancedANGLE(G,Y,ht,wt,Tt)},1}function B0(T){var F=T.getExtension("OES_vertex_array_object");if(F)return T.createVertexArray=function(){return F.createVertexArrayOES()},T.deleteVertexArray=function(G){F.deleteVertexArrayOES(G)},T.bindVertexArray=function(G){F.bindVertexArrayOES(G)},T.isVertexArray=function(G){return F.isVertexArrayOES(G)},1}function V0(T){var F=T.getExtension("WEBGL_draw_buffers");if(F)return T.drawBuffers=function(G,Y){F.drawBuffersWEBGL(G,Y)},1}function G0(T){return!!(T.multiDrawWebgl=T.getExtension("WEBGL_multi_draw"))}var or={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(F){or.lastError||(or.lastError=F)},getNewId:function(T){for(var F=or.counter++,G=T.length;G<F;G++)T[G]=null;return F},getSource:function(T,F,G,Y){for(var ht="",wt=0;wt<F;++wt){var Tt=Y?i()[Y+wt*4>>2]:-1;ht+=jr(i()[G+wt*4>>2],Tt<0?void 0:Tt)}return ht},createContext:function(T,F){T.getContextSafariWebGL2Fixed||(T.getContextSafariWebGL2Fixed=T.getContext,T.getContext=function(ht,wt){var Tt=T.getContextSafariWebGL2Fixed(ht,wt);return ht=="webgl"==Tt instanceof WebGLRenderingContext?Tt:null});var G=T.getContext("webgl",F);if(!G)return 0;var Y=or.registerContext(G,F);return Y},registerContext:function(T,F){var G=_C(8);i()[G+4>>2]=lx();var Y={handle:G,attributes:F,version:F.majorVersion,GLctx:T};return T.canvas&&(T.canvas.GLctxObject=Y),or.contexts[G]=Y,(typeof F.enableExtensionsByDefault=="undefined"||F.enableExtensionsByDefault)&&or.initExtensions(Y),G},makeContextCurrent:function(T){return or.currentContext=or.contexts[T],l.ctx=nx=or.currentContext&&or.currentContext.GLctx,!(T&&!nx)},getContext:function(T){return or.contexts[T]},deleteContext:function(T){or.currentContext===or.contexts[T]&&(or.currentContext=null),typeof ee=="object"&&ee.removeAllHandlersOnTarget(or.contexts[T].GLctx.canvas),or.contexts[T]&&or.contexts[T].GLctx.canvas&&(or.contexts[T].GLctx.canvas.GLctxObject=void 0),i1(or.contexts[T].handle),or.contexts[T]=null},initExtensions:function(T){if(T||(T=or.currentContext),!T.initExtensionsDone){T.initExtensionsDone=!0;var F=T.GLctx;z0(F),B0(F),V0(F),F.disjointTimerQueryExt=F.getExtension("EXT_disjoint_timer_query"),G0(F);var G=F.getSupportedExtensions()||[];G.forEach(function(Y){!Y.includes("lose_context")&&!Y.includes("debug")&&F.getExtension(Y)})}}},W0=["default","low-power","high-performance"];function U0(T,F){var G=F>>2,Y=i()[G+6],ht={alpha:!!i()[G+0],depth:!!i()[G+1],stencil:!!i()[G+2],antialias:!!i()[G+3],premultipliedAlpha:!!i()[G+4],preserveDrawingBuffer:!!i()[G+5],powerPreference:W0[Y],failIfMajorPerformanceCaveat:!!i()[G+7],majorVersion:i()[G+8],minorVersion:i()[G+9],enableExtensionsByDefault:i()[G+10],explicitSwapControl:i()[G+11],proxyContextToMainThread:i()[G+12],renderViaOffscreenBackBuffer:i()[G+13]},wt=Rd(T);if(!wt||ht.explicitSwapControl)return 0;var Tt=or.createContext(wt,ht);return Tt}function H0(T,F){return U0(T,F)}var gp={mappings:{},buffers:[null,[],[]],printChar:function(T,F){var G=gp.buffers[T];F===0||F===10?((T===1?rt:X)(on(G,0)),G.length=0):G.push(F)},varargs:void 0,get:function(){gp.varargs+=4;var T=i()[gp.varargs-4>>2];return T},getStr:function(T){var F=jr(T);return F},get64:function(T,F){return T}};function tx(T){return v?$u(3,1,T):0}function ex(T,F,G,Y,ht){if(v)return $u(4,1,T,F,G,Y,ht)}function rx(T,F,G,Y){if(v)return $u(5,1,T,F,G,Y);for(var ht=0,wt=0;wt<G;wt++){var Tt=i()[F>>2],Wt=i()[F+4>>2];F+=8;for(var sr=0;sr<Wt;sr++)gp.printChar(T,n()[Tt+sr]);ht+=Wt}return i()[Y>>2]=ht,0}function q0(T){kt(T)}Ht.init();var nx,K0=[null,Xg,Qg,tx,ex,rx],n1=!1,ox={__clock_gettime:y0,__emscripten_init_main_thread_js:b0,__emscripten_thread_cleanup:w0,__pthread_create_js:v0,_emscripten_default_pthread_stack_size:C0,_emscripten_notify_thread_queue:I0,abort:S0,emscripten_check_blocking_allowed:k0,emscripten_get_heap_max:Zg,emscripten_get_now:Au,emscripten_memcpy_big:N0,emscripten_num_logical_cores:T0,emscripten_receive_on_main_thread_js:_0,emscripten_resize_heap:A0,emscripten_set_canvas_element_size:P0,emscripten_unwind_to_js_event_loop:L0,emscripten_webgl_create_context:H0,exit:jg,fd_close:tx,fd_seek:ex,fd_write:rx,memory:Ot||l.wasmMemory,setTempRet0:q0},o1=a0(),j0=l.___wasm_call_ctors=function(){return(j0=l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},X0=l._init=function(){return(X0=l._init=l.asm.init).apply(null,arguments)},Y0=l._init_with_threads_count=function(){return(Y0=l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},Z0=l._get_threads_count=function(){return(Z0=l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},J0=l._register_tensor=function(){return(J0=l._register_tensor=l.asm.register_tensor).apply(null,arguments)},Q0=l._dispose_data=function(){return(Q0=l._dispose_data=l.asm.dispose_data).apply(null,arguments)},tC=l._dispose=function(){return(tC=l._dispose=l.asm.dispose).apply(null,arguments)},eC=l._Abs=function(){return(eC=l._Abs=l.asm.Abs).apply(null,arguments)},rC=l._Add=function(){return(rC=l._Add=l.asm.Add).apply(null,arguments)},nC=l._AddN=function(){return(nC=l._AddN=l.asm.AddN).apply(null,arguments)},oC=l._All=function(){return(oC=l._All=l.asm.All).apply(null,arguments)},sC=l._Any=function(){return(sC=l._Any=l.asm.Any).apply(null,arguments)},iC=l._ArgMax=function(){return(iC=l._ArgMax=l.asm.ArgMax).apply(null,arguments)},aC=l._AvgPool=function(){return(aC=l._AvgPool=l.asm.AvgPool).apply(null,arguments)},lC=l._BatchMatMul=function(){return(lC=l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},uC=l._Ceil=function(){return(uC=l._Ceil=l.asm.Ceil).apply(null,arguments)},cC=l._ClipByValue=function(){return(cC=l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},pC=l._Conv2D=function(){return(pC=l._Conv2D=l.asm.Conv2D).apply(null,arguments)},mC=l._Conv2DBackpropInput=function(){return(mC=l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},fC=l._Cos=function(){return(fC=l._Cos=l.asm.Cos).apply(null,arguments)},dC=l._Cosh=function(){return(dC=l._Cosh=l.asm.Cosh).apply(null,arguments)},hC=l._CropAndResize=function(){return(hC=l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},gC=l._Cumprod=function(){return(gC=l._Cumprod=l.asm.Cumprod).apply(null,arguments)},xC=l._Cumsum=function(){return(xC=l._Cumsum=l.asm.Cumsum).apply(null,arguments)},yC=l._DepthToSpace=function(){return(yC=l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},bC=l._DepthwiseConv2dNative=function(){return(bC=l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},wC=l._Elu=function(){return(wC=l._Elu=l.asm.Elu).apply(null,arguments)},vC=l._Equal=function(){return(vC=l._Equal=l.asm.Equal).apply(null,arguments)},CC=l._Exp=function(){return(CC=l._Exp=l.asm.Exp).apply(null,arguments)},IC=l._FlipLeftRight=function(){return(IC=l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},sx=l._Floor=function(){return(sx=l._Floor=l.asm.Floor).apply(null,arguments)},ix=l._FloorDiv=function(){return(ix=l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},Fd=l._FusedBatchNorm=function(){return(Fd=l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},SC=l._FusedConv2D=function(){return(SC=l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},kC=l._FusedDepthwiseConv2D=function(){return(kC=l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},xp=l._Gather=function(){return(xp=l._Gather=l.asm.Gather).apply(null,arguments)},Od=l._GatherNd=function(){return(Od=l._GatherNd=l.asm.GatherNd).apply(null,arguments)},Md=l._Greater=function(){return(Md=l._Greater=l.asm.Greater).apply(null,arguments)},s1=l._GreaterEqual=function(){return(s1=l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},yp=l._LeakyRelu=function(){return(yp=l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},bp=l._Less=function(){return(bp=l._Less=l.asm.Less).apply(null,arguments)},NC=l._LessEqual=function(){return(NC=l._LessEqual=l.asm.LessEqual).apply(null,arguments)},H=l._Log=function(){return(H=l._Log=l.asm.Log).apply(null,arguments)},tt=l._LogicalAnd=function(){return(tt=l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},gt=l._Max=function(){return(gt=l._Max=l.asm.Max).apply(null,arguments)},$t=l._MaxPool=function(){return($t=l._MaxPool=l.asm.MaxPool).apply(null,arguments)},fe=l._Maximum=function(){return(fe=l._Maximum=l.asm.Maximum).apply(null,arguments)},he=l._Mean=function(){return(he=l._Mean=l.asm.Mean).apply(null,arguments)},oe=l._Min=function(){return(oe=l._Min=l.asm.Min).apply(null,arguments)},Qt=l._Minimum=function(){return(Qt=l._Minimum=l.asm.Minimum).apply(null,arguments)},xr=l._MirrorPad=function(){return(xr=l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},Uo=l._Multiply=function(){return(Uo=l._Multiply=l.asm.Multiply).apply(null,arguments)},Ho=l._Neg=function(){return(Ho=l._Neg=l.asm.Neg).apply(null,arguments)},wp=l._NonMaxSuppressionV3=function(){return(wp=l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},Du=l._NonMaxSuppressionV4=function(){return(Du=l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},TC=l._NonMaxSuppressionV5=function(){return(TC=l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},ln=l._NotEqual=function(){return(ln=l._NotEqual=l.asm.NotEqual).apply(null,arguments)},Al=l._OneHot=function(){return(Al=l._OneHot=l.asm.OneHot).apply(null,arguments)},ax=l._PadV2=function(){return(ax=l._PadV2=l.asm.PadV2).apply(null,arguments)},IW=l._Pow=function(){return(IW=l._Pow=l.asm.Pow).apply(null,arguments)},SW=l._Prelu=function(){return(SW=l._Prelu=l.asm.Prelu).apply(null,arguments)},kW=l._Prod=function(){return(kW=l._Prod=l.asm.Prod).apply(null,arguments)},NW=l._RealDiv=function(){return(NW=l._RealDiv=l.asm.RealDiv).apply(null,arguments)},TW=l._Relu=function(){return(TW=l._Relu=l.asm.Relu).apply(null,arguments)},_W=l._Relu6=function(){return(_W=l._Relu6=l.asm.Relu6).apply(null,arguments)},EW=l._ResizeBilinear=function(){return(EW=l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},AW=l._Reverse=function(){return(AW=l._Reverse=l.asm.Reverse).apply(null,arguments)},$W=l._RotateWithOffset=function(){return($W=l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},DW=l._Round=function(){return(DW=l._Round=l.asm.Round).apply(null,arguments)},RW=l._Rsqrt=function(){return(RW=l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},FW=l._ScatterNd=function(){return(FW=l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},OW=l._SelectV2=function(){return(OW=l._SelectV2=l.asm.SelectV2).apply(null,arguments)},MW=l._Sigmoid=function(){return(MW=l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},PW=l._Sin=function(){return(PW=l._Sin=l.asm.Sin).apply(null,arguments)},LW=l._Softmax=function(){return(LW=l._Softmax=l.asm.Softmax).apply(null,arguments)},zW=l._SparseFillEmptyRows=function(){return(zW=l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},BW=l._SparseReshape=function(){return(BW=l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},VW=l._SparseSegmentReduction=function(){return(VW=l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},GW=l._Sqrt=function(){return(GW=l._Sqrt=l.asm.Sqrt).apply(null,arguments)},WW=l._Square=function(){return(WW=l._Square=l.asm.Square).apply(null,arguments)},UW=l._SquaredDifference=function(){return(UW=l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},HW=l._Step=function(){return(HW=l._Step=l.asm.Step).apply(null,arguments)},qW=l._StridedSlice=function(){return(qW=l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},KW=l._Sub=function(){return(KW=l._Sub=l.asm.Sub).apply(null,arguments)},jW=l._Sum=function(){return(jW=l._Sum=l.asm.Sum).apply(null,arguments)},XW=l._Tan=function(){return(XW=l._Tan=l.asm.Tan).apply(null,arguments)},YW=l._Tanh=function(){return(YW=l._Tanh=l.asm.Tanh).apply(null,arguments)},ZW=l._Tile=function(){return(ZW=l._Tile=l.asm.Tile).apply(null,arguments)},JW=l._TopK=function(){return(JW=l._TopK=l.asm.TopK).apply(null,arguments)},QW=l._Transform=function(){return(QW=l._Transform=l.asm.Transform).apply(null,arguments)},tU=l._Transpose=function(){return(tU=l._Transpose=l.asm.Transpose).apply(null,arguments)},eU=l.__FusedMatMul=function(){return(eU=l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},_C=l._malloc=function(){return(_C=l._malloc=l.asm.malloc).apply(null,arguments)},i1=l._free=function(){return(i1=l._free=l.asm.free).apply(null,arguments)},rU=l._emscripten_tls_init=function(){return(rU=l._emscripten_tls_init=l.asm.emscripten_tls_init).apply(null,arguments)},a1=l.___errno_location=function(){return(a1=l.___errno_location=l.asm.__errno_location).apply(null,arguments)},lx=l._pthread_self=function(){return(lx=l._pthread_self=l.asm.pthread_self).apply(null,arguments)},l1=l._emscripten_main_thread_process_queued_calls=function(){return(l1=l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},nU=l.__emscripten_thread_crashed=function(){return(nU=l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},u1=l.__emscripten_thread_init=function(){return(u1=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)},oU=l._emscripten_current_thread_process_queued_calls=function(){return(oU=l._emscripten_current_thread_process_queued_calls=l.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},sU=l._emscripten_main_browser_thread_id=function(){return(sU=l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)},iU=l._emscripten_sync_run_in_main_thread_2=function(){return(iU=l._emscripten_sync_run_in_main_thread_2=l.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},c1=l._emscripten_sync_run_in_main_thread_4=function(){return(c1=l._emscripten_sync_run_in_main_thread_4=l.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)},p1=l._emscripten_run_in_main_runtime_thread_js=function(){return(p1=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},EC=l._emscripten_dispatch_to_thread_=function(){return(EC=l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},AC=l.__emscripten_thread_free_data=function(){return(AC=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},aU=l.__emscripten_thread_exit=function(){return(aU=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},lU=l._memalign=function(){return(lU=l._memalign=l.asm.memalign).apply(null,arguments)},m1=l._emscripten_stack_set_limits=function(){return(m1=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},$C=l.stackSave=function(){return($C=l.stackSave=l.asm.stackSave).apply(null,arguments)},ux=l.stackRestore=function(){return(ux=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},vp=l.stackAlloc=function(){return(vp=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)},uU=l.dynCall_iijjiiii=function(){return(uU=l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},cU=l.dynCall_jiji=function(){return(cU=l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)},f1=l.__emscripten_allow_main_runtime_queued_calls=21464;l.cwrap=ze,l.keepRuntimeAlive=_u,l.PThread=Ht,l.PThread=Ht,l.wasmMemory=Ot,l.ExitStatus=Pd;var cx;function Pd(T){this.name="ExitStatus",this.message="Program terminated with exit("+T+")",this.status=T}Wo=function T(){cx||DC(),cx||(Wo=T)};function DC(T){if(T=T||d,El>0)return;if(v){c(l),_d(),postMessage({cmd:"loaded"});return}if(sn(),El>0)return;function F(){cx||(cx=!0,l.calledRun=!0,!Se&&(_d(),c(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),s0()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),F()},1)):F()}l.run=DC;function pU(T,F){if(ae=T,!F&&v)throw Xg(T),"unwind";_u()||o0(),mU(T)}function mU(T){ae=T,_u()||(Ht.terminateAllThreads(),l.onExit&&l.onExit(T),Se=!0),g(T,new Pd(T))}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();DC();var px;m&&(px={uncaughtException:process.listeners("uncaughtException").filter(function(T){return!m.uncaughtException.indexOf(T)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(T){return!m.unhandledRejection.indexOf(T)>-1})});var mx;if(typeof WasmBackendModule!="undefined")mx=WasmBackendModule;else if(typeof t!="undefined")mx=t;else throw new Error("Could not find wasm module in post.js");if(px){var fU=mx._dispose;mx._dispose=function(){fU(),px.uncaughtException.forEach(function(T){process.removeListener("uncaughtException",T)}),px.unhandledRejection.forEach(function(T){process.removeListener("unhandledRejection",T)})}}return t.ready}})();typeof Qv=="object"&&typeof GT=="object"?GT.exports=VT:typeof define=="function"&&define.amd?define([],function(){return VT}):typeof Qv=="object"&&(Qv.WasmBackendModuleThreadedSimd=VT)});var xW=Oe((t0,UT)=>{var WT=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(t){t=t||{};var e=typeof t!="undefined"?t:{},n,o;e.ready=new Promise(function(H,tt){n=H,o=tt});var s;typeof process!="undefined"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i=Object.assign({},e),a=[],u="./this.program",l=(H,tt)=>{throw tt},c=typeof window=="object",p=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function d(H){return e.locateFile?e.locateFile(H,f):f+H}var h,g,y,b;function w(H){if(H instanceof Od)return;D("exiting due to exception: "+H)}var v,k,E;m?(p?f=$g().dirname(f)+"/":f=__dirname+"/",E=()=>{k||(v=Lb(),k=$g())},h=function(tt,gt){return E(),tt=k.normalize(tt),v.readFileSync(tt,gt?void 0:"utf8")},y=H=>{var tt=h(H,!0);return tt.buffer||(tt=new Uint8Array(tt)),tt},g=(H,tt,gt)=>{E(),H=k.normalize(H),v.readFile(H,function($t,fe){$t?gt($t):tt(fe.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(H){if(!(H instanceof Od))throw H}),process.on("unhandledRejection",function(H){throw H}),l=(H,tt)=>{if(Td())throw process.exitCode=H,tt;w(tt),process.exit(H)},e.inspect=function(){return"[Emscripten Module object]"}):(c||p)&&(p?f=self.location.href:typeof document!="undefined"&&document.currentScript&&(f=document.currentScript.src),r&&(f=r),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",h=H=>{var tt=new XMLHttpRequest;return tt.open("GET",H,!1),tt.send(null),tt.responseText},p&&(y=H=>{var tt=new XMLHttpRequest;return tt.open("GET",H,!1),tt.responseType="arraybuffer",tt.send(null),new Uint8Array(tt.response)}),g=(H,tt,gt)=>{var $t=new XMLHttpRequest;$t.open("GET",H,!0),$t.responseType="arraybuffer",$t.onload=()=>{if($t.status==200||$t.status==0&&$t.response){tt($t.response);return}gt()},$t.onerror=gt,$t.send(null)},b=H=>document.title=H);var $=e.print||console.log.bind(console),D=e.printErr||console.warn.bind(console);Object.assign(e,i),i=null,e.arguments&&(a=e.arguments),e.thisProgram&&(u=e.thisProgram),e.quit&&(l=e.quit);var R=4;function P(H){P.shown||(P.shown={}),P.shown[H]||(P.shown[H]=1,D(H))}function W(H,tt){if(typeof WebAssembly.Function=="function"){for(var gt={i:"i32",j:"i64",f:"f32",d:"f64"},$t={parameters:[],results:tt[0]=="v"?[]:[gt[tt[0]]]},fe=1;fe<tt.length;++fe)$t.parameters.push(gt[tt[fe]]);return new WebAssembly.Function($t,H)}var he=[1,0,1,96],oe=tt.slice(0,1),Qt=tt.slice(1),xr={i:127,j:126,f:125,d:124};he.push(Qt.length);for(var fe=0;fe<Qt.length;++fe)he.push(xr[Qt[fe]]);oe=="v"?he.push(0):he=he.concat([1,xr[oe]]),he[1]=he.length-2;var Uo=new Uint8Array([0,97,115,109,1,0,0,0].concat(he,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),Ho=new WebAssembly.Module(Uo),wp=new WebAssembly.Instance(Ho,{e:{f:H}}),Du=wp.exports.f;return Du}var U=[],q;function K(){if(U.length)return U.pop();try{so.grow(1)}catch(H){throw H instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":H}return so.length-1}function j(H,tt){for(var gt=H;gt<H+tt;gt++){var $t=Ad(gt);$t&&q.set($t,gt)}}var Q=0,rt=H=>{Q=H},X;e.wasmBinary&&(X=e.wasmBinary);var ot=e.noExitRuntime||!0;typeof WebAssembly!="object"&&Tu("no native wasm support detected");var st,it=!1,ft;function at(H,tt){H||Tu(tt)}function xt(H){var tt=e["_"+H];return tt}function dt(H,tt,gt,$t,fe){var he={string:function(ln){var Al=0;if(ln!=null&&ln!==0){var ax=(ln.length<<2)+1;Al=Fd(ax),ce(ln,Al,ax)}return Al},array:function(ln){var Al=Fd(ln.length);return Se(ln,Al),Al}};function oe(ln){return tt==="string"?qt(ln):tt==="boolean"?Boolean(ln):ln}var Qt=xt(H),xr=[],Uo=0;if($t)for(var Ho=0;Ho<$t.length;Ho++){var wp=he[gt[Ho]];wp?(Uo===0&&(Uo=sx()),xr[Ho]=wp($t[Ho])):xr[Ho]=$t[Ho]}var Du=Qt.apply(null,xr);function TC(ln){return Uo!==0&&ix(Uo),oe(ln)}return Du=TC(Du),Du}function bt(H,tt,gt,$t){gt=gt||[];var fe=gt.every(function(oe){return oe==="number"}),he=tt!=="string";return he&&fe&&!$t?xt(H):function(){return dt(H,tt,gt,arguments,$t)}}var kt=1,At=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Dt(H,tt,gt){for(var $t=tt+gt,fe=tt;H[fe]&&!(fe>=$t);)++fe;if(fe-tt>16&&H.subarray&&At)return At.decode(H.subarray(tt,fe));for(var he="";tt<fe;){var oe=H[tt++];if(!(oe&128)){he+=String.fromCharCode(oe);continue}var Qt=H[tt++]&63;if((oe&224)==192){he+=String.fromCharCode((oe&31)<<6|Qt);continue}var xr=H[tt++]&63;if((oe&240)==224?oe=(oe&15)<<12|Qt<<6|xr:oe=(oe&7)<<18|Qt<<12|xr<<6|H[tt++]&63,oe<65536)he+=String.fromCharCode(oe);else{var Uo=oe-65536;he+=String.fromCharCode(55296|Uo>>10,56320|Uo&1023)}}return he}function qt(H,tt){return H?Dt(ze,H,tt):""}function Kt(H,tt,gt,$t){if(!($t>0))return 0;for(var fe=gt,he=gt+$t-1,oe=0;oe<H.length;++oe){var Qt=H.charCodeAt(oe);if(Qt>=55296&&Qt<=57343){var xr=H.charCodeAt(++oe);Qt=65536+((Qt&1023)<<10)|xr&1023}if(Qt<=127){if(gt>=he)break;tt[gt++]=Qt}else if(Qt<=2047){if(gt+1>=he)break;tt[gt++]=192|Qt>>6,tt[gt++]=128|Qt&63}else if(Qt<=65535){if(gt+2>=he)break;tt[gt++]=224|Qt>>12,tt[gt++]=128|Qt>>6&63,tt[gt++]=128|Qt&63}else{if(gt+3>=he)break;tt[gt++]=240|Qt>>18,tt[gt++]=128|Qt>>12&63,tt[gt++]=128|Qt>>6&63,tt[gt++]=128|Qt&63}}return tt[gt]=0,gt-fe}function ce(H,tt,gt){return Kt(H,ze,tt,gt)}function Ot(H){for(var tt=0,gt=0;gt<H.length;++gt){var $t=H.charCodeAt(gt);$t>=55296&&$t<=57343&&($t=65536+(($t&1023)<<10)|H.charCodeAt(++gt)&1023),$t<=127?++tt:$t<=2047?tt+=2:$t<=65535?tt+=3:tt+=4}return tt}var $e=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):void 0;function Se(H,tt){rn.set(H,tt)}function ae(H,tt,gt){for(var $t=0;$t<H.length;++$t)rn[tt++>>0]=H.charCodeAt($t);gt||(rn[tt>>0]=0)}function je(H,tt){return H%tt>0&&(H+=tt-H%tt),H}var Fe,rn,ze,Bo,Fr,nn,on,jr,oo;function Fn(H){Fe=H,e.HEAP8=rn=new Int8Array(H),e.HEAP16=Bo=new Int16Array(H),e.HEAP32=nn=new Int32Array(H),e.HEAPU8=ze=new Uint8Array(H),e.HEAPU16=Fr=new Uint16Array(H),e.HEAPU32=on=new Uint32Array(H),e.HEAPF32=jr=new Float32Array(H),e.HEAPF64=oo=new Float64Array(H)}var Vo=e.INITIAL_MEMORY||16777216,so,Tl=[],Nu=[],lp=[],gr=!1,up=!1,cp=0;function Td(){return ot||cp>0}function Mg(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)zg(e.preRun.shift());Ed(Tl)}function Pg(){gr=!0,Ed(Nu)}function jT(){up=!0}function Lg(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)Bg(e.postRun.shift());Ed(lp)}function zg(H){Tl.unshift(H)}function Go(H){Nu.unshift(H)}function Bg(H){lp.unshift(H)}var qn=0,pp=null,_l=null;function r0(H){qn++,e.monitorRunDependencies&&e.monitorRunDependencies(qn)}function Vg(H){if(qn--,e.monitorRunDependencies&&e.monitorRunDependencies(qn),qn==0&&(pp!==null&&(clearInterval(pp),pp=null),_l)){var tt=_l;_l=null,tt()}}e.preloadedImages={},e.preloadedAudios={};function Tu(H){e.onAbort&&e.onAbort(H),H="Aborted("+H+")",D(H),it=!0,ft=1,H+=". Build with -s ASSERTIONS=1 for more info.";var tt=new WebAssembly.RuntimeError(H);throw o(tt),tt}var n0="data:application/octet-stream;base64,";function Gg(H){return H.startsWith(n0)}function _u(H){return H.startsWith("file://")}var sn;sn="tfjs-backend-wasm.wasm",Gg(sn)||(sn=d(sn));function _d(H){try{if(H==sn&&X)return new Uint8Array(X);if(y)return y(H);throw"both async and sync fetching of the wasm failed"}catch(tt){Tu(tt)}}function o0(){if(!X&&(c||p)){if(typeof fetch=="function"&&!_u(sn))return fetch(sn,{credentials:"same-origin"}).then(function(H){if(!H.ok)throw"failed to load wasm binary file at '"+sn+"'";return H.arrayBuffer()}).catch(function(){return _d(sn)});if(g)return new Promise(function(H,tt){g(sn,function(gt){H(new Uint8Array(gt))},tt)})}return Promise.resolve().then(function(){return _d(sn)})}function s0(){var H={env:dp,wasi_snapshot_preview1:dp};function tt(oe,Qt){var xr=oe.exports;e.asm=xr,st=e.asm.memory,Fn(st.buffer),so=e.asm.__indirect_function_table,Go(e.asm.__wasm_call_ctors),Vg("wasm-instantiate")}r0("wasm-instantiate");function gt(oe){tt(oe.instance)}function $t(oe){return o0().then(function(Qt){return WebAssembly.instantiate(Qt,H)}).then(function(Qt){return Qt}).then(oe,function(Qt){D("failed to asynchronously prepare wasm: "+Qt),Tu(Qt)})}function fe(){return!X&&typeof WebAssembly.instantiateStreaming=="function"&&!Gg(sn)&&!_u(sn)&&typeof fetch=="function"?fetch(sn,{credentials:"same-origin"}).then(function(oe){var Qt=WebAssembly.instantiateStreaming(oe,H);return Qt.then(gt,function(xr){return D("wasm streaming compile failed: "+xr),D("falling back to ArrayBuffer instantiation"),$t(gt)})}):$t(gt)}if(e.instantiateWasm)try{var he=e.instantiateWasm(H,tt);return he}catch(oe){return D("Module.instantiateWasm callback failed with error: "+oe),!1}return fe().catch(o),{}}var XT,YT;function Ed(H){for(;H.length>0;){var tt=H.shift();if(typeof tt=="function"){tt(e);continue}var gt=tt.func;typeof gt=="number"?tt.arg===void 0?Ad(gt)():Ad(gt)(tt.arg):gt(tt.arg===void 0?null:tt.arg)}}function El(H){return H}function Wg(H){var tt=/\b_Z[\w\d_]+/g;return H.replace(tt,function(gt){var $t=gt;return gt===$t?gt:$t+" ["+gt+"]"})}var Wo=[];function Ad(H){var tt=Wo[H];return tt||(H>=Wo.length&&(Wo.length=H+1),Wo[H]=tt=so.get(H)),tt}function ZT(){var H=new Error;if(!H.stack){try{throw new Error}catch(tt){H=tt}if(!H.stack)return"(no stack trace available)"}return H.stack.toString()}function mp(H,tt){so.set(H,tt),Wo[H]=tt}function i0(){Tu("")}function $d(){return 2147483648}function Ug(H,tt,gt){ze.copyWithin(H,tt,tt+gt)}function an(H){try{return st.grow(H-Fe.byteLength+65535>>>16),Fn(st.buffer),1}catch(tt){}}function Hg(H){var tt=ze.length;H=H>>>0;var gt=$d();if(H>gt)return!1;for(var $t=1;$t<=4;$t*=2){var fe=tt*(1+.2/$t);fe=Math.min(fe,H+100663296);var he=Math.min(gt,je(Math.max(H,fe),65536)),oe=an(he);if(oe)return!0}return!1}var fp={mappings:{},buffers:[null,[],[]],printChar:function(H,tt){var gt=fp.buffers[H];tt===0||tt===10?((H===1?$:D)(Dt(gt,0)),gt.length=0):gt.push(tt)},varargs:void 0,get:function(){fp.varargs+=4;var H=nn[fp.varargs-4>>2];return H},getStr:function(H){var tt=qt(H);return tt},get64:function(H,tt){return H}};function a0(H){return 0}function JT(H,tt,gt,$t,fe){}function QT(H,tt,gt,$t){for(var fe=0,he=0;he<gt;he++){var oe=nn[tt>>2],Qt=nn[tt+4>>2];tt+=8;for(var xr=0;xr<Qt;xr++)fp.printChar(H,ze[oe+xr]);fe+=Qt}return nn[$t>>2]=fe,0}function l0(H){rt(H)}var qg=!1,dp={abort:i0,emscripten_get_heap_max:$d,emscripten_memcpy_big:Ug,emscripten_resize_heap:Hg,fd_close:a0,fd_seek:JT,fd_write:QT,setTempRet0:l0},CW=s0(),t1=e.___wasm_call_ctors=function(){return(t1=e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)},u0=e._init=function(){return(u0=e._init=e.asm.init).apply(null,arguments)},c0=e._init_with_threads_count=function(){return(c0=e._init_with_threads_count=e.asm.init_with_threads_count).apply(null,arguments)},Kg=e._get_threads_count=function(){return(Kg=e._get_threads_count=e.asm.get_threads_count).apply(null,arguments)},jg=e._register_tensor=function(){return(jg=e._register_tensor=e.asm.register_tensor).apply(null,arguments)},p0=e._dispose_data=function(){return(p0=e._dispose_data=e.asm.dispose_data).apply(null,arguments)},Ht=e._dispose=function(){return(Ht=e._dispose=e.asm.dispose).apply(null,arguments)},m0=e._Abs=function(){return(m0=e._Abs=e.asm.Abs).apply(null,arguments)},Xg=e._Add=function(){return(Xg=e._Add=e.asm.Add).apply(null,arguments)},Eu=e._AddN=function(){return(Eu=e._AddN=e.asm.AddN).apply(null,arguments)},hp=e._All=function(){return(hp=e._All=e.asm.All).apply(null,arguments)},f0=e._Any=function(){return(f0=e._Any=e.asm.Any).apply(null,arguments)},e1=e._ArgMax=function(){return(e1=e._ArgMax=e.asm.ArgMax).apply(null,arguments)},d0=e._AvgPool=function(){return(d0=e._AvgPool=e.asm.AvgPool).apply(null,arguments)},r1=e._BatchMatMul=function(){return(r1=e._BatchMatMul=e.asm.BatchMatMul).apply(null,arguments)},Au=e._Ceil=function(){return(Au=e._Ceil=e.asm.Ceil).apply(null,arguments)},h0=e._ClipByValue=function(){return(h0=e._ClipByValue=e.asm.ClipByValue).apply(null,arguments)},g0=e._Conv2D=function(){return(g0=e._Conv2D=e.asm.Conv2D).apply(null,arguments)},x0=e._Conv2DBackpropInput=function(){return(x0=e._Conv2DBackpropInput=e.asm.Conv2DBackpropInput).apply(null,arguments)},y0=e._Cos=function(){return(y0=e._Cos=e.asm.Cos).apply(null,arguments)},b0=e._Cosh=function(){return(b0=e._Cosh=e.asm.Cosh).apply(null,arguments)},w0=e._CropAndResize=function(){return(w0=e._CropAndResize=e.asm.CropAndResize).apply(null,arguments)},Yg=e._Cumprod=function(){return(Yg=e._Cumprod=e.asm.Cumprod).apply(null,arguments)},v0=e._Cumsum=function(){return(v0=e._Cumsum=e.asm.Cumsum).apply(null,arguments)},C0=e._DepthToSpace=function(){return(C0=e._DepthToSpace=e.asm.DepthToSpace).apply(null,arguments)},I0=e._DepthwiseConv2dNative=function(){return(I0=e._DepthwiseConv2dNative=e.asm.DepthwiseConv2dNative).apply(null,arguments)},S0=e._Elu=function(){return(S0=e._Elu=e.asm.Elu).apply(null,arguments)},k0=e._Equal=function(){return(k0=e._Equal=e.asm.Equal).apply(null,arguments)},Zg=e._Exp=function(){return(Zg=e._Exp=e.asm.Exp).apply(null,arguments)},N0=e._FlipLeftRight=function(){return(N0=e._FlipLeftRight=e.asm.FlipLeftRight).apply(null,arguments)},T0=e._Floor=function(){return(T0=e._Floor=e.asm.Floor).apply(null,arguments)},$u=e._FloorDiv=function(){return($u=e._FloorDiv=e.asm.FloorDiv).apply(null,arguments)},Dd=e._FusedBatchNorm=function(){return(Dd=e._FusedBatchNorm=e.asm.FusedBatchNorm).apply(null,arguments)},_0=e._FusedConv2D=function(){return(_0=e._FusedConv2D=e.asm.FusedConv2D).apply(null,arguments)},E0=e._FusedDepthwiseConv2D=function(){return(E0=e._FusedDepthwiseConv2D=e.asm.FusedDepthwiseConv2D).apply(null,arguments)},A0=e._Gather=function(){return(A0=e._Gather=e.asm.Gather).apply(null,arguments)},ee=e._GatherNd=function(){return(ee=e._GatherNd=e.asm.GatherNd).apply(null,arguments)},$0=e._Greater=function(){return($0=e._Greater=e.asm.Greater).apply(null,arguments)},D0=e._GreaterEqual=function(){return(D0=e._GreaterEqual=e.asm.GreaterEqual).apply(null,arguments)},R0=e._LeakyRelu=function(){return(R0=e._LeakyRelu=e.asm.LeakyRelu).apply(null,arguments)},F0=e._Less=function(){return(F0=e._Less=e.asm.Less).apply(null,arguments)},O0=e._LessEqual=function(){return(O0=e._LessEqual=e.asm.LessEqual).apply(null,arguments)},M0=e._Log=function(){return(M0=e._Log=e.asm.Log).apply(null,arguments)},Rd=e._LogicalAnd=function(){return(Rd=e._LogicalAnd=e.asm.LogicalAnd).apply(null,arguments)},Jg=e._Max=function(){return(Jg=e._Max=e.asm.Max).apply(null,arguments)},Qg=e._MaxPool=function(){return(Qg=e._MaxPool=e.asm.MaxPool).apply(null,arguments)},P0=e._Maximum=function(){return(P0=e._Maximum=e.asm.Maximum).apply(null,arguments)},L0=e._Mean=function(){return(L0=e._Mean=e.asm.Mean).apply(null,arguments)},z0=e._Min=function(){return(z0=e._Min=e.asm.Min).apply(null,arguments)},B0=e._Minimum=function(){return(B0=e._Minimum=e.asm.Minimum).apply(null,arguments)},V0=e._MirrorPad=function(){return(V0=e._MirrorPad=e.asm.MirrorPad).apply(null,arguments)},G0=e._Multiply=function(){return(G0=e._Multiply=e.asm.Multiply).apply(null,arguments)},or=e._Neg=function(){return(or=e._Neg=e.asm.Neg).apply(null,arguments)},W0=e._NonMaxSuppressionV3=function(){return(W0=e._NonMaxSuppressionV3=e.asm.NonMaxSuppressionV3).apply(null,arguments)},U0=e._NonMaxSuppressionV4=function(){return(U0=e._NonMaxSuppressionV4=e.asm.NonMaxSuppressionV4).apply(null,arguments)},H0=e._NonMaxSuppressionV5=function(){return(H0=e._NonMaxSuppressionV5=e.asm.NonMaxSuppressionV5).apply(null,arguments)},gp=e._NotEqual=function(){return(gp=e._NotEqual=e.asm.NotEqual).apply(null,arguments)},tx=e._OneHot=function(){return(tx=e._OneHot=e.asm.OneHot).apply(null,arguments)},ex=e._PadV2=function(){return(ex=e._PadV2=e.asm.PadV2).apply(null,arguments)},rx=e._Pow=function(){return(rx=e._Pow=e.asm.Pow).apply(null,arguments)},q0=e._Prelu=function(){return(q0=e._Prelu=e.asm.Prelu).apply(null,arguments)},nx=e._Prod=function(){return(nx=e._Prod=e.asm.Prod).apply(null,arguments)},K0=e._RealDiv=function(){return(K0=e._RealDiv=e.asm.RealDiv).apply(null,arguments)},n1=e._Relu=function(){return(n1=e._Relu=e.asm.Relu).apply(null,arguments)},ox=e._Relu6=function(){return(ox=e._Relu6=e.asm.Relu6).apply(null,arguments)},o1=e._ResizeBilinear=function(){return(o1=e._ResizeBilinear=e.asm.ResizeBilinear).apply(null,arguments)},j0=e._Reverse=function(){return(j0=e._Reverse=e.asm.Reverse).apply(null,arguments)},X0=e._RotateWithOffset=function(){return(X0=e._RotateWithOffset=e.asm.RotateWithOffset).apply(null,arguments)},Y0=e._Round=function(){return(Y0=e._Round=e.asm.Round).apply(null,arguments)},Z0=e._Rsqrt=function(){return(Z0=e._Rsqrt=e.asm.Rsqrt).apply(null,arguments)},J0=e._ScatterNd=function(){return(J0=e._ScatterNd=e.asm.ScatterNd).apply(null,arguments)},Q0=e._SelectV2=function(){return(Q0=e._SelectV2=e.asm.SelectV2).apply(null,arguments)},tC=e._Sigmoid=function(){return(tC=e._Sigmoid=e.asm.Sigmoid).apply(null,arguments)},eC=e._Sin=function(){return(eC=e._Sin=e.asm.Sin).apply(null,arguments)},rC=e._Softmax=function(){return(rC=e._Softmax=e.asm.Softmax).apply(null,arguments)},nC=e._SparseFillEmptyRows=function(){return(nC=e._SparseFillEmptyRows=e.asm.SparseFillEmptyRows).apply(null,arguments)},oC=e._SparseReshape=function(){return(oC=e._SparseReshape=e.asm.SparseReshape).apply(null,arguments)},sC=e._SparseSegmentReduction=function(){return(sC=e._SparseSegmentReduction=e.asm.SparseSegmentReduction).apply(null,arguments)},iC=e._Sqrt=function(){return(iC=e._Sqrt=e.asm.Sqrt).apply(null,arguments)},aC=e._Square=function(){return(aC=e._Square=e.asm.Square).apply(null,arguments)},lC=e._SquaredDifference=function(){return(lC=e._SquaredDifference=e.asm.SquaredDifference).apply(null,arguments)},uC=e._Step=function(){return(uC=e._Step=e.asm.Step).apply(null,arguments)},cC=e._StridedSlice=function(){return(cC=e._StridedSlice=e.asm.StridedSlice).apply(null,arguments)},pC=e._Sub=function(){return(pC=e._Sub=e.asm.Sub).apply(null,arguments)},mC=e._Sum=function(){return(mC=e._Sum=e.asm.Sum).apply(null,arguments)},fC=e._Tan=function(){return(fC=e._Tan=e.asm.Tan).apply(null,arguments)},dC=e._Tanh=function(){return(dC=e._Tanh=e.asm.Tanh).apply(null,arguments)},hC=e._Tile=function(){return(hC=e._Tile=e.asm.Tile).apply(null,arguments)},gC=e._TopK=function(){return(gC=e._TopK=e.asm.TopK).apply(null,arguments)},xC=e._Transform=function(){return(xC=e._Transform=e.asm.Transform).apply(null,arguments)},yC=e._Transpose=function(){return(yC=e._Transpose=e.asm.Transpose).apply(null,arguments)},bC=e.__FusedMatMul=function(){return(bC=e.__FusedMatMul=e.asm._FusedMatMul).apply(null,arguments)},wC=e._malloc=function(){return(wC=e._malloc=e.asm.malloc).apply(null,arguments)},vC=e._free=function(){return(vC=e._free=e.asm.free).apply(null,arguments)},CC=e.___errno_location=function(){return(CC=e.___errno_location=e.asm.__errno_location).apply(null,arguments)},IC=e._emscripten_main_thread_process_queued_calls=function(){return(IC=e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},sx=e.stackSave=function(){return(sx=e.stackSave=e.asm.stackSave).apply(null,arguments)},ix=e.stackRestore=function(){return(ix=e.stackRestore=e.asm.stackRestore).apply(null,arguments)},Fd=e.stackAlloc=function(){return(Fd=e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)},SC=e.dynCall_iijjiiii=function(){return(SC=e.dynCall_iijjiiii=e.asm.dynCall_iijjiiii).apply(null,arguments)},kC=e.dynCall_jiji=function(){return(kC=e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)};e.cwrap=bt;var xp;function Od(H){this.name="ExitStatus",this.message="Program terminated with exit("+H+")",this.status=H}_l=function H(){xp||Md(),xp||(_l=H)};function Md(H){if(H=H||a,qn>0||(Mg(),qn>0))return;function tt(){xp||(xp=!0,e.calledRun=!0,!it&&(Pg(),n(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),Lg()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),tt()},1)):tt()}e.run=Md;function s1(H){ft=H,Td()||(e.onExit&&e.onExit(H),it=!0),l(H,new Od(H))}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();Md();var yp;s&&(yp={uncaughtException:process.listeners("uncaughtException").filter(function(H){return!s.uncaughtException.indexOf(H)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(H){return!s.unhandledRejection.indexOf(H)>-1})});var bp;if(typeof t!="undefined")bp=t;else if(typeof WasmBackendModuleThreadedSimd!="undefined")bp=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(yp){var NC=bp._dispose;bp._dispose=function(){NC(),yp.uncaughtException.forEach(function(H){process.removeListener("uncaughtException",H)}),yp.unhandledRejection.forEach(function(H){process.removeListener("unhandledRejection",H)})}}return t.ready}})();typeof t0=="object"&&typeof UT=="object"?UT.exports=WT:typeof define=="function"&&define.amd?define([],function(){return WT}):typeof t0=="object"&&(t0.WasmBackendModule=WT)});var Qi=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},jo=class{refCount(t){return Kn("refCount")}incRef(t){return Kn("incRef")}timerAvailable(){return!0}time(t){return Kn("time")}read(t){return Kn("read")}readSync(t){return Kn("readSync")}readToGPU(t,e){return Kn("readToGPU")}numDataIds(){return Kn("numDataIds")}disposeData(t,e){return Kn("disposeData")}write(t,e,n){return Kn("write")}move(t,e,n,o,s){return Kn("move")}memory(){return Kn("memory")}floatPrecision(){return Kn("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Kn("dispose")}};function Kn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function h1(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,dx(r,t,e)}function vU(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,dx(r,e,n),dx(t,e,n)}function Ip(r,t,e){return Math.max(r,Math.min(t,e))}function CU(r){return r%2===0?r:r+1}function dx(r,t,e){let n=r[t];r[t]=r[e],r[e]=n}function IU(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function SU(r,t){let e=Math.random();return t*e+(1-e)*r}function kU(r,t){let e=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(t[n]);e+=o*o}return e}function A(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Me(r,t,e=""){A(Mn(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function jn(r){A(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Xo(r,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(r)||yr(r)&&!e)for(let n=0;n<r.length;++n)Xo(r[n],t,e);else t.push(r);return t}function re(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function NU(r){return r.length===0}function Mn(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function ta(r){return r%1===0}function TU(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function _U(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function EU(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return h1(t),t}function Ou(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function AU(r,t=n=>0,e){return new Promise((n,o)=>{let s=0,i=()=>{if(r()){n();return}s++;let a=t(s);if(e!=null&&s>=e){o();return}setTimeout(i,a)};i()})}function $U(r,t){let e=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=r.slice();return o[n]=t/e,o}function mr(r,t){let e=t.length;return r=r==null?t.map((n,o)=>o):[].concat(r),A(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),A(r.every(n=>ta(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function FC(r,t){let e=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:mr(t,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(e.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(e.push(r[a]),n.push(a))}return{newShape:e,keptDims:n}}function OC(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function MC(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function PC(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function LC(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function DU(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function yr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function hx(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function zC(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function Yo(r){return typeof r=="string"||r instanceof String}function g1(r){return typeof r=="boolean"}function x1(r){return typeof r=="number"}function Sp(r){return Array.isArray(r)?Sp(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":x1(r)?"float32":Yo(r)?"string":g1(r)?"bool":"float32"}function yi(r){return!!(r&&r.constructor&&r.call&&r.apply)}function kp(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function bi(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function y1(r,t,e,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=e[r+i]}else{let s=t[0],i=t.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=y1(r+u*a,i,e,n)}return o}function Fu(r,t,e=!1){if(r.length===0)return t[0];let n=r.reduce((o,s)=>o*s)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return y1(0,r,t,e)}function zd(r,t){let e=Np(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function Np(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function RU(r,t){let e=r.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Fu(r,new Float32Array(e));if(t==="int32")return Fu(r,new Int32Array(e));if(t==="bool")return Fu(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Bd(r){r.forEach(t=>{A(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function FU(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function OU(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function Vd(r){return r&&r.then&&typeof r.then=="function"}var b1="tfjsflags",Gd=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=PU,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(Vd(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=this.getQueryParams(this.global.location.search);b1 in t&&t[b1].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=zU(o,s)})}};function PU(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(LU(t,n[0],n[1]),n.join("="))),t}function LU(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function zU(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function V(){return BC}var BC=null;function w1(r){BC=r}var VC;function GC(){if(VC==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");VC=r}return VC}function BU(){let r=GC();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Wd(r,t){let e=BU();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var wi="Abs",ea="Acos",ra="Acosh",Xn="Add",Zo="AddN",na="All",oa="Any",Jo="ArgMax",$l="ArgMin",sa="Asin",ia="Asinh",aa="Atan",la="Atanh",ua="Atan2",Qo="AvgPool",Tp="AvgPoolGrad",Dl="AvgPool3D",_p="AvgPool3DGrad",ts="BatchMatMul",vi="BatchToSpaceND",Ep="Bincount",v1="BroadcastTo",Ap="BroadcastArgs",io="Cast",es="Ceil",ao="ClipByValue",$p="Complex",Rl="ComplexAbs",Ci="Concat",rs="Conv2D",Dp="Conv2DBackpropFilter",ns="Conv2DBackpropInput",Fl="Conv3D",Rp="Conv3DBackpropFilterV2",Fp="Conv3DBackpropInputV2",os="Cos",ss="Cosh",ca="Cumprod",is="Cumsum",pa="CropAndResize",Op="DenseBincount",ma="DepthToSpace",as="DepthwiseConv2dNative",Mp="DepthwiseConv2dNativeBackpropFilter",Pp="DepthwiseConv2dNativeBackpropInput",Lp="Diag",Ol="Dilation2D",Ud="Dilation2DBackpropInput",Hd="Dilation2DBackpropFilter",ls="RealDiv",zp="Einsum",us="Elu",Bp="EluGrad",fa="Erf",da="Equal",cs="Exp",Ii="ExpandDims",ha="Expm1",Vp="FFT",Ml="Fill",ga="FlipLeftRight",ps="Floor",ms="FloorDiv",fs="FusedBatchNorm",Si="GatherV2",xa="GatherNd",ya="Greater",ds="GreaterEqual",lo="Identity",Gp="IFFT",Wp="Imag",ba="IsFinite",wa="IsInf",va="IsNan",hs="LeakyRelu",Ca="Less",Ia="LessEqual",Up="LinSpace",gs="Log",Sa="Log1p",ka="LogicalAnd",Mu="LogicalNot",Pu="LogicalOr",C1="LogSoftmax",Pl="LRN",Hp="LRNGrad",xs="Max",ys="Maximum",bs="MaxPool",qp="MaxPoolGrad",Ll="MaxPool3D",Kp="MaxPool3DGrad",jp="MaxPoolWithArgmax",ws="Mean",vs="Min",Cs="Minimum",Is="MirrorPad",Na="Mod",Xp="Multinomial",Ss="Multiply",ki="Neg",Ta="NotEqual",_a="NonMaxSuppressionV3",Ea="NonMaxSuppressionV4",Aa="NonMaxSuppressionV5",Ni="OnesLike",ks="OneHot",Ti="Pack",Ns="PadV2",_at="Pool",Ts="Pow",_s="Prelu",Es="Prod",zl="Range",Yp="Real",$a="Reciprocal",As="Relu",_i="Reshape",Bl="ResizeNearestNeighbor",Zp="ResizeNearestNeighborGrad",$s="ResizeBilinear",Jp="ResizeBilinearGrad",Ds="Relu6",Rs="Reverse",Fs="Round",Os="Rsqrt",Da="ScatterNd",Ei="Select",Ra="Selu",Ai="Slice",Ms="Sin",Fa="Sinh",Oa="Sign",Ps="Sigmoid",Ma="Softplus",Ls="Sqrt",zs="Sum",$i="SpaceToBatchND",Di="SplitV",Bs="Softmax",Vl="SparseFillEmptyRows",Pa="SparseReshape",Gl="SparseSegmentMean",Wl="SparseSegmentSum",Qp="SparseToDense",Vs="SquaredDifference",Ul="Square",La="StridedSlice",tm="StringNGrams",em="StringSplit",rm="StringToHashBucketFast",Gs="Sub",Ws="Tan",Us="Tanh",Yn="Tile",za="TopK",Ba="Transform",Hs="Transpose",nm="Unique",Ri="Unpack",Hl="UnsortedSegmentSum",Fi="ZerosLike",uo="Step",qd="FromPixels",Va="RotateWithOffset",Oi="_FusedMatMul",Mi="FusedConv2D",Pi="FusedDepthwiseConv2D";function Li(...r){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...r)}function VU(...r){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...r)}var om=Wd("kernelRegistry",()=>new Map),Kd=Wd("gradRegistry",()=>new Map);function jd(r,t){let e=UC(r,t);return om.get(e)}function WC(r){return Kd.get(r)}function gx(r){let t=om.entries(),e=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&e.push(i)}return e}function Lu(r){let{kernelName:t,backendName:e}=r,n=UC(t,e);om.has(n)&&Li(`The kernel '${t}' for backend '${e}' is already registered`),om.set(n,r)}function S1(r){let{kernelName:t}=r;Kd.has(t)&&V().getBool("DEBUG")&&Li(`Overriding the gradient for '${t}'`),Kd.set(t,r)}function Rat(r,t){let e=UC(r,t);if(!om.has(e))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);om.delete(e)}function Fat(r){if(!Kd.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);Kd.delete(r)}function Oat(r,t){gx(r).forEach(n=>{let o=Object.assign({},n,{backendName:t});Lu(o)})}function UC(r,t){return`${t}_${r}`}var x={};Yt(x,{arraysEqual:()=>Mn,assert:()=>A,assertNonNegativeIntegerDimensions:()=>Bd,assertNonNull:()=>jn,assertShapesMatch:()=>Me,bytesFromStringArray:()=>zC,bytesPerElement:()=>hx,checkConversionForErrors:()=>PC,clamp:()=>Ip,computeStrides:()=>bi,createScalarValue:()=>jU,createShuffledIndices:()=>EU,decodeString:()=>lm,distSquared:()=>kU,encodeString:()=>Kl,fetch:()=>YU,fingerPrint64:()=>KU,flatten:()=>Xo,getArrayFromDType:()=>MC,getTypedArrayFromDType:()=>OC,hasEncodingLoss:()=>DU,hexToLong:()=>Xd,indexToLoc:()=>OU,inferDtype:()=>Sp,inferFromImplicitShape:()=>$U,isBoolean:()=>g1,isFunction:()=>yi,isInt:()=>ta,isNumber:()=>x1,isPromise:()=>Vd,isScalarShape:()=>NU,isString:()=>Yo,isTypedArray:()=>yr,isValidDtype:()=>LC,locToIndex:()=>FU,makeOnesTypedArray:()=>zd,makeZerosNestedTypedArray:()=>RU,makeZerosTypedArray:()=>Np,nearestDivisor:()=>kp,nearestLargerEven:()=>CU,now:()=>Wu,parseAxisParam:()=>mr,randUniform:()=>SU,repeatedTry:()=>AU,rightPad:()=>Ou,shuffle:()=>h1,shuffleCombo:()=>vU,sizeFromShape:()=>re,sizeToSquarishShape:()=>_U,squeezeShape:()=>FC,sum:()=>IU,swap:()=>dx,tanh:()=>TU,toNestedArray:()=>Fu,toTypedArray:()=>am});var jC=Ru(O1());var Gu=jC.default||jC;function Xd(r){return Gu.fromString(r,!0,16)}var P1=Xd("c3a5c85c97cb3127"),Vu=Xd("b492b66fbe98f273"),un=Xd("9ae16a3b2f90404f");function KC(r){return r.xor(r.shru(47))}function L1(r,t,e){let n=r.slice(t,t+e);return Gu.fromBytes(Array.from(n),!0,!0)}function Be(r,t){return L1(r,t,8)}function M1(r,t){return L1(r,t,4)}function Er(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function ql(r,t,e=Xd("9ddfea08eb382d69")){let n=r.xor(t).mul(e);n=n.xor(n.shru(47));let o=t.xor(n).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function WU(r,t,e,n,o,s){o=o.add(r),s=Er(s.add(o).add(n),21);let i=o;return o=o.add(t),o=o.add(e),s=s.add(Er(o,44)),[o.add(n),s.add(i)]}function yx(r,t,e,n){return WU(Be(r,t),Be(r,t+8),Be(r,t+16),Be(r,t+24),e,n)}function UU(r,t=r.length){if(t>=8){let e=un.add(t*2),n=Be(r,0).add(un),o=Be(r,t-8),s=Er(o,37).mul(e).add(n),i=Er(n,25).add(o).mul(e);return ql(s,i,e)}if(t>=4){let e=un.add(t*2),n=M1(r,0);return ql(n.shl(3).add(t),M1(r,t-4),e)}if(t>0){let e=r[0],n=r[t>>1],o=r[t-1],s=e+(n<<8),i=t+(o<<2);return KC(un.mul(s).xor(P1.mul(i))).mul(un)}return un}function HU(r,t=r.length){let e=un.add(t*2),n=Be(r,0).mul(Vu),o=Be(r,8),s=Be(r,t-8).mul(e),i=Be(r,t-16).mul(un);return ql(Er(n.add(o),43).add(Er(s,30)).add(i),n.add(Er(o.add(un),18)).add(s),e)}function qU(r,t=r.length){let e=un.add(t*2),n=Be(r,0).mul(un),o=Be(r,8),s=Be(r,t-8).mul(e),i=Be(r,t-16).mul(un),a=Er(n.add(o),43).add(Er(s,30)).add(i),u=ql(a,n.add(Er(o.add(un),18)).add(s),e),l=Be(r,16).mul(e),c=Be(r,24),p=a.add(Be(r,t-32)).mul(e),m=u.add(Be(r,t-24)).mul(e);return ql(Er(l.add(c),43).add(Er(p,30)).add(m),l.add(Er(c.add(n),18)).add(p),e)}function KU(r,t=r.length){let e=Gu.fromNumber(81,!0);if(t<=32)return t<=16?UU(r,t):HU(r,t);if(t<=64)return qU(r,t);let n=e,o=e.mul(Vu).add(113),s=KC(o.mul(un).add(113)).mul(un),i=[Gu.UZERO,Gu.UZERO],a=[Gu.UZERO,Gu.UZERO];n=n.mul(un).add(Be(r,0));let u=0,l=(t-1>>6)*64,c=l+(t-1&63)-63;do n=Er(n.add(o).add(i[0]).add(Be(r,u+8)),37).mul(Vu),o=Er(o.add(i[1]).add(Be(r,u+48)),42).mul(Vu),n=n.xor(a[1]),o=o.add(i[0]).add(Be(r,u+40)),s=Er(s.add(a[0]),33).mul(Vu),i=yx(r,u,i[1].mul(Vu),n.add(a[0])),a=yx(r,u+32,s.add(a[1]),o.add(Be(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let p=Vu.add(s.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=Er(n.add(o).add(i[0]).add(Be(r,u+8)),37).mul(p),o=Er(o.add(i[1]).add(Be(r,u+48)),42).mul(p),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Be(r,u+40))),s=Er(s.add(a[0]),33).mul(p),i=yx(r,u,i[1].mul(p),n.add(a[0])),a=yx(r,u+32,s.add(a[1]),o.add(Be(r,u+16))),[s,n]=[n,s],ql(ql(i[0],a[0],p).add(KC(o).mul(P1)).add(s),ql(i[1],a[1],p).add(n),p)}function jU(r,t){return t==="string"?Kl(r):am([r],t)}function XU(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function am(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Xo(r)),V().getBool("DEBUG")&&PC(r,t),XU(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Wu(){return V().platform.now()}function YU(r,t){return V().platform.fetch(r,t)}function Kl(r,t="utf-8"){return t=t||"utf-8",V().platform.encode(r,t)}function lm(r,t="utf-8"){return t=t||"utf-8",V().platform.decode(r,t)}var bx=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new XC)}profileKernel(t,e,n){let o,s=()=>{o=n()},i,a=Wu();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:Wu()-a})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let c=o[l];c.data().then(p=>{ZU(p,c.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:o,inputs:s,extraInfo:i}=t;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(e,a,u[0],u[1],s,u[2])})})}};function ZU(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var XC=class{logKernelProfile(t,e,n,o,s,i){let a=typeof o=="number"?Ou(`${o}ms`,9):o.error,u=Ou(t,25),l=e.rank,c=e.size,p=Ou(e.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||e.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${p}	%c${c}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function z1(r,t,e){let n={},o={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],c=l.inputs;for(let p in c){let m=c[p],f=!1;for(let d=0;d<t.length;d++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[e.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],c=l.inputs;for(let p=0;p<l.outputs.length;p++)if(s[l.outputs[p].id]){for(let m in c)s[c[m].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let c={};for(let m in l.inputs){let f=l.inputs[m];n[f.id]&&(c[m]=f)}let p=Object.assign({},l);p.inputs=c,p.outputs=l.outputs,a.push(p)}}return a}function B1(r,t,e,n){for(let o=t.length-1;o>=0;o--){let s=t[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=e(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let c=s.inputs[u];if(!Mn(l.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=l;else{let p=r[c.id];r[c.id]=n(p,l),p.dispose()}}}}var V1=20,Yd=3,YC=7;function G1(r,t,e,n){let o=bi(t),s=JU(r,t,e,o),i=t.length,a=wx(r,t,e,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function JU(r,t,e,n){let o=re(t),s=n[n.length-1],i=new Array(s).fill(0),a=t.length,u=e==="complex64"?Jd(r):r;if(a>1)for(let l=0;l<o/s;l++){let c=l*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],Zd(u[c+p],0,e).length)}return i}function Zd(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(YC))} + ${parseFloat(r[1].toFixed(YC))}j`:Yo(r)?n=`'${r}'`:e==="bool"?n=W1(r):n=parseFloat(r.toFixed(YC)).toString(),Ou(n,t)}function W1(r){return r===0?"false":"true"}function wx(r,t,e,n,o,s=!0){let i=e==="complex64"?2:1,a=t[0],u=t.length;if(u===0){if(e==="complex64"){let h=Jd(r);return[Zd(h[0],0,e)]}return e==="bool"?[W1(r[0])]:[r[0].toString()]}if(u===1){if(a>V1){let g=Yd*i,y=Array.from(r.slice(0,g)),b=Array.from(r.slice((a-Yd)*i,a*i));return e==="complex64"&&(y=Jd(y),b=Jd(b)),["["+y.map((w,v)=>Zd(w,o[v],e)).join(", ")+", ..., "+b.map((w,v)=>Zd(w,o[a-Yd+v],e)).join(", ")+"]"]}let h=e==="complex64"?Jd(r):Array.from(r);return["["+h.map((g,y)=>Zd(g,o[y],e)).join(", ")+"]"]}let l=t.slice(1),c=n.slice(1),p=n[0]*i,m=[];if(a>V1){for(let h=0;h<Yd;h++){let g=h*p,y=g+p;m.push(...wx(r.slice(g,y),l,e,c,o,!1))}m.push("...");for(let h=a-Yd;h<a;h++){let g=h*p,y=g+p;m.push(...wx(r.slice(g,y),l,e,c,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*p,y=g+p;m.push(...wx(r.slice(g,y),l,e,c,o,h===a-1))}let f=u===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<u;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function Jd(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var pe=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=re(t),n!=null){let o=n.length;A(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||MC(e,this.size),this.strides=bi(t)}set(t,...e){e.length===0&&(e=[0]),A(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ks().makeTensor(this.values,this.shape,this.dtype)}},Ks=null,um=null,QU=null;function U1(r){Ks=r}function H1(r){um=r}function q1(r){QU=r}var Lt=class{constructor(t,e,n,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=re(t),this.strides=bi(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return um.buffer(this.shape,this.dtype,t)}bufferSync(){return um.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Fu(this.shape,t,this.dtype==="complex64")}arraySync(){return Fu(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=Ks().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>lm(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ks().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=Ks().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>lm(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await Ks().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ks().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return um.print(this,t)}clone(){return this.throwIfDisposed(),um.clone(this)}toString(t=!1){let e=this.dataSync();return G1(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),um.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Ks().makeVariable(this,t,e,n)}};Object.defineProperty(Lt,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function L(){return Wd("Tensor",()=>Lt)}L();var Ga=class extends Lt{constructor(t,e,n,o){super(t.shape,t.dtype,t.dataId,o),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Mn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ks().disposeTensor(this),this.dataId=t.dataId,Ks().incRef(this,null)}dispose(){Ks().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ga,Symbol.hasInstance,{value:r=>r instanceof Lt&&r.assign!=null&&r.assign instanceof Function});var fo={};Yt(fo,{assertTypesMatch:()=>rI,getTensorsInContainer:()=>Qd,isTensorInList:()=>e4,makeTypesMatch:()=>jt});var ZC;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(ZC||(ZC={}));var JC;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(JC||(JC={}));var QC;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(QC||(QC={}));var tI;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(tI||(tI={}));var eI;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(eI||(eI={}));var t4={float32:tI,int32:JC,bool:QC,complex64:eI};function ar(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return t4[r][t]}function Uu(r){return ar(r,"int32")}function jt(r,t){if(r.dtype===t.dtype)return[r,t];let e=ar(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function rI(r,t){A(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function e4(r,t){return t.some(e=>e.id===r.id)}function Qd(r){let t=[];return K1(r,t,new Set),t}function K1(r,t,e){if(r==null)return;if(r instanceof Lt){t.push(r);return}if(!r4(r))return;let n=r;for(let o in n){let s=n[o];e.has(s)||(e.add(s),K1(s,t,e))}}function r4(r){return Array.isArray(r)||typeof r=="object"}function nI(r){return r.kernelName!=null}var vx=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},jl=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new vx}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(Li(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new bx(this.backendInstance),!0}setupRegisteredKernels(){gx(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){gx(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=e.factory();if(n&&!(n instanceof jo)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Li(`Initialization of backend ${t} failed`),Li(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return Li(`Initialization of backend ${t} failed`),Li(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let n=this.state.tensorInfo.get(e),o=n.backend,s=this.readSync(e),i=o.refCount(e);o.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=e(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,e,n){t();try{let o=n();return e(),o}catch(o){throw e(),o}}nextTensorId(){return jl.nextTensorId++}nextVariableId(){return jl.nextVariableId++}clone(t){let e=_.runKernel(lo,{x:t}),n={x:t},o=i=>({x:()=>{let a="float32",u={x:i},l={dtype:a};return _.runKernel(io,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[e],o,s,{}),e}runKernel(t,e,n){if(this.backendName==null&&this.backend,!(jd(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-e-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u,l=nI(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(nI(t)){let{kernelName:d,inputs:h,attrs:g}=t;this.backendName==null&&this.backend;let y=jd(d,this.backendName);A(y!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),a=()=>{let b=this.backend.numDataIds();u=y.kernelFunc({inputs:h,attrs:g,backend:this.backend});let w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,b,w);let v=w.map(k=>{if(k.rank!=null)return k;let{dataId:E,shape:$,dtype:D}=k;return this.makeTensorFromDataId(E,$,D)});if(o){let k=this.getTensorsForGradient(d,h,v);n=this.saveTensorsForBackwardMode(k)}return v}}else{let{forwardFunc:d}=t,h=g=>{!o||(n=g.map(y=>this.keep(this.clone(y))))};a=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>d(this.backend,h));let y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}let{inputs:c,attrs:p}=t,m=nI(t)?null:t.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=a():(f=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs)}),o&&this.addTapeNode(l,c,e,m,n,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:e.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){let o=WC(t);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(A(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(e).map(l=>e[l])):a=s.map(l=>e[l]);let u=n.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(t,e,n,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=t;n==="string"&&Yo(t[0])&&(s=t.map(u=>Kl(u)));let i=o.write(s,e,n),a=new Lt(e,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let u=this.state.tensorInfo.get(i),l=zC(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(t,e,n,o){n=n||"float32";let s=new Lt(e,n,t,this.nextTensorId());return this.trackTensor(s,o),s}makeVariable(t,e=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));let s=new Ga(t,e,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*hx(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Ga||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*hx(t.dtype);this.state.numBytes-=n}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},u=WC(t);u!=null&&(o=u.gradFunc),o!=null&&(a.gradient=l=>(l=l.map((c,p)=>{if(c==null){let m=n[p],f=Np(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),o(l.length>1?l:l[0],s,i))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=Qd(t),n=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(t,e,n,o=!1){if(A(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));A(s instanceof Lt,()=>"The result y returned by f() must be a tensor.");let i=z1(this.state.activeTape,e,s);if(!o&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n==null?n4(s.shape):n,B1(a,i,l=>this.tidy(l),o4);let u=e.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let c of l.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return A(yi(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{A(e.every(a=>a instanceof Lt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};e.forEach((a,u)=>{o[u]=a});let s=(a,u)=>(n=t(...e,u),A(n.value instanceof Lt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(yi(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,u)=>{let l=n.gradFunc(a,u),c=Array.isArray(l)?l:[l];A(c.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A(c.every(m=>m instanceof Lt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let p={};return c.forEach((m,f)=>{p[f]=()=>m}),p};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){let e=Wu(),n=await this.backend.time(t);return n.wallMs=Wu()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new vx;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};jl.nextTensorId=0;jl.nextVariableId=0;function n4(r){let t=zd(re(r),"float32");return _.makeTensor(t,r,"float32")}function oI(){let r=GC();if(r._tfengine==null){let t=new Gd(r);r._tfengine=new jl(t)}return w1(r._tfengine.ENV),U1(()=>r._tfengine),r._tfengine}var _=oI();function o4(r,t){let e={a:r,b:t};return _.runKernel(Xn,e)}var Xl={};Yt(Xl,{isBrowser:()=>iI,isMobile:()=>a4,mockIsMobile:()=>i4});function s4(){return typeof navigator!="undefined"&&navigator!=null}var sI;function i4(r){sI=r}function a4(r){if(sI!==void 0)return sI;if(r||s4()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function iI(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var ho=V();ho.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ho.registerFlag("IS_BROWSER",()=>iI());ho.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");ho.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ho.registerFlag("PROD",()=>!1);ho.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ho.getBool("DEBUG"));ho.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ho.registerFlag("IS_TEST",()=>!1);ho.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ho.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ho.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Or(r,t){let e=r;if(yr(r))return t==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||yr(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&X1(r,n,[]),n}function X1(r,t,e){if(e=e||[],!Array.isArray(r)&&!yr(r)){A(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}A(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),A(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let o=0;o<r.length;++o)X1(r[o],n,e.concat(o))}function j1(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function C(r,t,e,n="numeric"){if(r instanceof Lt)return j1(n,r.dtype,t,e),r;let o=Sp(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),j1(n,o,t,e),r==null||!yr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Or(r,o);!yr(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?am(r,o):Xo(r,[],!0);return _.makeTensor(a,s,o)}function Wa(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>C(s,`${t}[${i}]`,e,n))}var Y1="__op";function N(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+Y1;let o=(...s)=>{_.startScope(e);try{let i=n(...s);return Vd(i)&&console.error("Cannot return a Promise inside of tidy."),_.endScope(i),i}catch(i){throw _.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function l4(r,t){let e=C(r,"real","complex"),n=C(t,"imag","complex");Me(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:e,imag:n};return _.runKernel($p,o)}var zn=N({complex_:l4});function cn(r,t,e,n){if(n==null&&(n=Sp(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!yr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Bd(t);let o=re(t),s=re(e);A(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],u=i===e.length-1?a!==re(t.slice(i)):!0;A(e[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!yr(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?am(r,n):Xo(r,[],!0),_.makeTensor(r,t,n)}function Ar(r,t,e){let n=Or(r,e);return cn(r,t,n,e)}var th={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Cx=4;async function J1(r,t){let e=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async p=>{let m=await u.bytes(),f=m.reduce((g,y)=>g+y.length,0)+Cx*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let y=m[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);d.set(b,h),h+=Cx,d.set(y,h),h+=y.length}p(d)});n.push(c)}else n.push(u.data());t!=null&&(l.group=t),e.push(l)}let s=await Promise.all(n);return{data:u4(s),specs:e}}function Ix(r,t){let e={},n,o=0;for(let s of t){let i=s.name,a=s.dtype,u=s.shape,l=re(u),c;if("quantization"in s){let p=s.quantization;if(p.dtype==="uint8"||p.dtype==="uint16"){if(!("min"in p&&"scale"in p))throw new Error(`Weight ${s.name} with quantization ${p.dtype} doesn't have corresponding metadata min and scale.`)}else if(p.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${p.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${p.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=th[p.dtype],f=r.slice(o,o+l*m),d=p.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(a==="float32")if(p.dtype==="uint8"||p.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*p.scale+p.min}}else if(p.dtype==="float16")n===void 0&&(n=f4()),c=n(d);else throw new Error(`Unsupported quantization type ${p.dtype} for weight type float32.`);else if(a==="int32"){if(p.dtype!=="uint8"&&p.dtype!=="uint16")throw new Error(`Unsupported quantization type ${p.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*p.scale+p.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*m}else if(a==="string"){let p=re(s.shape);c=[];for(let m=0;m<p;m++){let f=new Uint32Array(r.slice(o,o+Cx))[0];o+=Cx;let d=new Uint8Array(r.slice(o,o+f));c.push(d),o+=f}}else{let p=th[a],m=r.slice(o,o+l*p);if(a==="float32")c=new Float32Array(m);else if(a==="int32")c=new Int32Array(m);else if(a==="bool")c=new Uint8Array(m);else if(a==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[y*2],d[y]=c[y*2+1];let h=Ar(f,u,"float32"),g=Ar(d,u,"float32");e[i]=zn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*p}a!=="complex64"&&(e[i]=Ar(c,u,a))}return e}function u4(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return e.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var aI=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function Z1(r){return aI?Buffer.byteLength(r):new Blob([r]).size}function Q1(r){if(aI)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function t_(r){if(aI){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function cm(r){if(r.length===1)return r[0];let t=0;r.forEach(o=>{t+=o.byteLength});let e=new Uint8Array(t),n=0;return r.forEach(o=>{e.set(new Uint8Array(o),n),n+=o.byteLength}),e.buffer}function lI(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function Sx(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}async function pm(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await t(r.weightsManifest);e.weightSpecs=n,e.weightData=o}return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),e}function zi(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:Z1(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:Z1(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function c4(){let r=e=>{let n=e<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function p4(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function m4(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function f4(){let r=c4(),t=p4(),e=m4();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[e[a>>10]+(a&1023)]+t[a>>10];s[i]=u}return new Float32Array(o)}}var ke=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ke.instance==null&&(ke.instance=new ke),ke.instance}static registerSaveRouter(t){ke.getInstance().saveRouters.push(t)}static registerLoadRouter(t){ke.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return ke.getHandlers(t,"save")}static getLoadHandlers(t,e){return ke.getHandlers(t,"load",e)}static getHandlers(t,e,n){let o=[];return(e==="load"?ke.getInstance().loadRouters:ke.getInstance().saveRouters).forEach(i=>{let a=i(t,n);a!==null&&o.push(a)}),o}},e_=r=>ke.registerSaveRouter(r),r_=r=>ke.registerLoadRouter(r),n_=r=>ke.getSaveHandlers(r),o_=(r,t)=>ke.getLoadHandlers(r,t);var uI="tensorflowjs",cI=1,Hu="models_store",Yl="model_info_store";function s_(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function pI(r){let t=r.result;t.createObjectStore(Hu,{keyPath:"modelPath"}),t.createObjectStore(Yl,{keyPath:"modelPath"})}var Bi=class{constructor(t){if(this.indexedDB=s_(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,o)=>{let s=this.indexedDB.open(uI,cI);s.onupgradeneeded=()=>pI(s),s.onsuccess=()=>{let i=s.result;if(e==null){let a=i.transaction(Hu,"readonly"),l=a.objectStore(Hu).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=c=>(i.close(),o(l.error)),a.oncomplete=()=>i.close()}else{let a=zi(e),u=i.transaction(Yl,"readwrite"),l=u.objectStore(Yl),c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),p;c.onsuccess=()=>{p=i.transaction(Hu,"readwrite");let f=p.objectStore(Hu).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:a});f.onsuccess=()=>n({modelArtifactsInfo:a}),f.onerror=d=>{l=u.objectStore(Yl);let h=l.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(f.error)),h.onerror=g=>(i.close(),o(f.error))}},c.onerror=m=>(i.close(),o(c.error)),u.oncomplete=()=>{p==null?i.close():p.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};Bi.URL_SCHEME="indexeddb://";var i_=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Bi.URL_SCHEME)?d4(r.slice(Bi.URL_SCHEME.length)):null;ke.registerSaveRouter(i_);ke.registerLoadRouter(i_);function d4(r){return new Bi(r)}function h4(r){return r.startsWith(Bi.URL_SCHEME)?r.slice(Bi.URL_SCHEME.length):r}var kx=class{constructor(){this.indexedDB=s_()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(uI,cI);n.onupgradeneeded=()=>pI(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Yl,"readonly"),a=s.objectStore(Yl).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;t(u)},a.onerror=u=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>e(n.error)})}async removeModel(t){return t=h4(t),new Promise((e,n)=>{let o=this.indexedDB.open(uI,cI);o.onupgradeneeded=()=>pI(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Yl,"readwrite"),a=i.objectStore(Yl),u=a.get(t),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let c=a.delete(t),p=()=>{l=s.transaction(Hu,"readwrite");let f=l.objectStore(Hu).delete(t);f.onsuccess=()=>e(u.result.modelArtifactsInfo),f.onerror=d=>n(u.error)};c.onsuccess=p,c.onerror=m=>(p(),s.close(),n(u.error))}},u.onerror=c=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var Ua="/",mm="tensorflowjs_models",a_="info",g4="model_topology",x4="weight_specs",y4="weight_data",b4="model_metadata";function l_(r){return{info:[mm,r,a_].join(Ua),topology:[mm,r,g4].join(Ua),weightSpecs:[mm,r,x4].join(Ua),weightData:[mm,r,y4].join(Ua),modelMetadata:[mm,r,b4].join(Ua)}}function u_(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function w4(r){let t=r.split(Ua);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(Ua)}function v4(r){return r.startsWith(Vi.URL_SCHEME)?r.slice(Vi.URL_SCHEME.length):r}var Vi=class{constructor(t){if(!V().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=l_(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=zi(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Q1(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw u_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);e.format=a.format,e.generatedBy=a.generatedBy,e.convertedBy=a.convertedBy,a.signature!=null&&(e.signature=a.signature),a.userDefinedMetadata!=null&&(e.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(e.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(e.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=t_(i),e}};Vi.URL_SCHEME="localstorage://";var c_=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Vi.URL_SCHEME)?C4(r.slice(Vi.URL_SCHEME.length)):null;ke.registerSaveRouter(c_);ke.registerLoadRouter(c_);function C4(r){return new Vi(r)}var Nx=class{constructor(){A(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=mm+Ua,n=Ua+a_;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(n)){let i=w4(s);t[i]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=v4(t);let e=l_(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return u_(e),n}};var fm="://",Xr=class{constructor(){this.managers={}}static getInstance(){return Xr.instance==null&&(Xr.instance=new Xr),Xr.instance}static registerManager(t,e){A(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(fm)&&(t=t.slice(0,t.indexOf(fm))),A(t.length>0,()=>"scheme must not be an empty string.");let n=Xr.getInstance();A(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=this.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Tx(r){if(r.indexOf(fm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Xr.getSchemes().join(",")}`);return{scheme:r.split(fm)[0],path:r.split(fm)[1]}}async function p_(r,t,e=!1){A(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=ke.getLoadHandlers(r);A(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),A(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=ke.getSaveHandlers(t);A(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),A(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],a=Tx(r).scheme,u=Tx(r).path,l=a===Tx(r).scheme,c=await o.load();e&&l&&await Xr.getManager(a).removeModel(u);let p=await i.save(c);return e&&!l&&await Xr.getManager(a).removeModel(u),p.modelArtifactsInfo}async function m_(){let r=Xr.getSchemes(),t={};for(let e of r){let n=await Xr.getManager(e).listModels();for(let o in n){let s=e+fm+o;t[s]=n[o]}}return t}async function f_(r){let t=Tx(r);return Xr.getManager(t.scheme).removeModel(t.path)}async function d_(r,t){return p_(r,t,!1)}async function h_(r,t){return p_(r,t,!0)}var mI=class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}};if(V().get("IS_BROWSER")){V().setPlatform("browser",new mI);try{Xr.registerManager(Vi.URL_SCHEME,new Nx)}catch(r){}try{Xr.registerManager(Bi.URL_SCHEME,new kx)}catch(r){}}var I4={importFetch:()=>g_()},fI;var dI=class{constructor(){this.util=x_(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return V().global.fetch!=null?V().global.fetch(t,e):(fI==null&&(fI=I4.importFetch()),fI(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}};V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new dI);function It(r,t="float32",e){return t=t||"float32",Bd(r),new pe(r,t,e)}function S4(r,t){let e=C(r,"x","cast");if(!LC(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},o={dtype:t};return _.runKernel(io,n,o)}var Z=N({cast_:S4});function k4(r){let e={x:C(r,"x","clone","string_or_numeric")};return _.runKernel(lo,e)}var kn=N({clone_:k4});function hI(r,t=!1){console.log(r.toString(t))}oI();var N4={buffer:It,cast:Z,clone:kn,print:hI};H1(N4);var Mr={};Yt(Mr,{browserFiles:()=>b_,browserHTTPRequest:()=>C_,concatenateArrayBuffers:()=>cm,copyModel:()=>d_,decodeWeights:()=>Ix,encodeWeights:()=>J1,fromMemory:()=>I_,getLoadHandlers:()=>o_,getModelArtifactsForJSON:()=>pm,getModelArtifactsInfoForJSON:()=>zi,getSaveHandlers:()=>n_,http:()=>Ex,isHTTPScheme:()=>_x,listModels:()=>m_,loadWeights:()=>w_,moveModel:()=>h_,registerLoadRouter:()=>r_,registerSaveRouter:()=>e_,removeModel:()=>f_,weightsLoaderFactory:()=>bI,withSaveHandler:()=>S_});var T4="model",_4=".json",E4=".weights.bin";function y_(r){return new Promise(t=>setTimeout(t)).then(r)}var Ha=class{constructor(t){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ha.URL_SCHEME)&&(t=t.slice(Ha.URL_SCHEME.length)),(t==null||t.length===0)&&(t=T4),this.modelJsonFileName=t+_4,this.weightDataFileName=t+E4}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=Sx(t,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,await y_(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=e,await y_(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:zi(t)}}}};Ha.URL_SCHEME="downloads://";var gI=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}let u=pm(s,l=>this.loadWeights(l));t(u)},n.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){let e=[],n=[];for(let i of t)e.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,cm(i)])}loadWeightsFile(t,e){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(s=>lI(s.name)),o={};for(let s of t)s.paths.forEach(i=>{let a=lI(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},A4=r=>V().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ha.URL_SCHEME)?$4(r.slice(Ha.URL_SCHEME.length)):null;ke.registerSaveRouter(A4);function $4(r="model"){return new Ha(r)}function b_(r){return new gI(r)}function xI(r,t,e,n){i(r),e=e==null?0:e,n=n==null?1:n,a(e,n);let o=0,s=u=>(u.then(l=>{let c=e+ ++o/r.length*(n-e);return t(c),l}),u);function i(u){A(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){A(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),A(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),A(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function yI(r,t){t==null&&(t={});let e=t.fetchFunc==null?V().platform.fetch:t.fetchFunc,n=r.map(p=>e(p,t.requestInit,{isBinary:!0})),o=0,s=.5,a=(t.onProgress==null?await Promise.all(n):await xI(n,t.onProgress,o,s)).map(p=>p.arrayBuffer()),u=.5,l=1;return t.onProgress==null?await Promise.all(a):await xI(a,t.onProgress,u,l)}async function w_(r,t="",e,n){return bI(i=>yI(i,{requestInit:n}))(r,t,e)}function bI(r){return async(t,e="",n)=>{let o=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(t.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=th[y]*re(g.shape),w=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:b})};n!=null?n.forEach((v,k)=>{v===g.name&&(w(),i[k]=!0)}):w(),a.push(g.name),h+=b})}),!i.every(f=>f)){let f=n.filter((d,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),l=[];u.forEach(f=>{t[f].paths.forEach(d=>{let h=e+(e.endsWith("/")?"":"/")+d;l.push(h)})});let c=await r(l),p={},m=0;return u.forEach(f=>{let d=t[f].paths.length,h=0;for(let v=0;v<d;v++)h+=c[m+v].byteLength;let g=new ArrayBuffer(h),y=new Uint8Array(g),b=0;for(let v=0;v<d;v++){let k=new Uint8Array(c[m+v]);y.set(k,b),b+=k.byteLength}s[f].forEach(v=>{let k=g.slice(v.groupOffset,v.groupOffset+v.sizeBytes),E=Ix(k,[v.manifestEntry]);for(let $ in E)p[$]=E[$]}),m+=d}),p}}var D4="application/octet-stream",R4="application/json",eh=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(A(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=V().platform.fetch,A(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&A(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=Sx(t,n);e.body.append("model.json",new Blob([JSON.stringify(o)],{type:R4}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:D4}),"model.weights.bin");let s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:zi(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(s){let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=e.modelTopology,o=e.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return pm(e,s=>this.loadWeights(s))}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=F4(e),s=this.weightPathPrefix||n,i=[];for(let c of t)i.push(...c.weights);let a=[],u=[];for(let c of t)for(let p of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(p)):a.push(s+p+o);this.weightUrlConverter&&a.push(...await Promise.all(u));let l=await yI(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,cm(l)]}};eh.URL_SCHEME_REGEX=/^https?:\/\//;function F4(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),o=e>t?r.substring(e):"";return[n+"/",o]}function _x(r){return r.match(eh.URL_SCHEME_REGEX)!=null}var v_=(r,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>_x(n)):e=_x(r),e)return Ex(r,t)}return null};ke.registerSaveRouter(v_);ke.registerLoadRouter(v_);function Ex(r,t){return new eh(r,t)}function C_(r,t){return Ex(r,t)}var rh=class{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}},wI=class{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}};function I_(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new rh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new rh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new rh({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function S_(r){return new wI(r)}var N_={};Yt(N_,{confusionMatrix:()=>k_});function O4(r,t,e=!1,n=!1){let o=C(r,"a","matMul"),s=C(t,"b","matMul");[o,s]=jt(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:n};return _.runKernel(ts,i,a)}var zt=N({matMul_:O4});function M4(r,t,e=1,n=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:C(r,"indices","oneHot","int32")},i={depth:t,onValue:e,offValue:n};return _.runKernel(ks,s,i)}var js=N({oneHot_:M4});function P4(r,t){let e=C(r,"x","transpose");if(t==null&&(t=e.shape.map((s,i)=>i).reverse()),A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(s=>{A(s>=0&&s<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1)return e.clone();let n={x:e},o={perm:t};return _.runKernel(Hs,n,o)}var Mt=N({transpose_:P4});function L4(r,t,e){let n=C(r,"labels","confusionMatrix"),o=C(t,"predictions","confusionMatrix");A(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),A(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),A(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),A(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),A(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let s=js(Z(n,"int32"),e),i=js(Z(o,"int32"),e),a=Mt(s),u=zt(a,i);return Z(u,"int32")}var k_=N({confusionMatrix_:L4});var Pr={};Yt(Pr,{assertAndGetBroadcastShape:()=>Bt,getBroadcastDims:()=>T_,getReductionAxes:()=>ge});function T_(r,t){let e=r.length,n=[];for(let o=0;o<e;o++){let s=e-1-o,i=r[s]||1;(t[t.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function ge(r,t){let e=[];for(let n=0;n<t.length;n++){let o=r[r.length-n-1],s=t.length-n-1,i=t[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function Bt(r,t){let e=[],n=Math.max(r.length,t.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=t[t.length-o-1];if(i==null&&(i=1),s===1)e.unshift(i);else if(i===1)e.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(a)}else e.unshift(s)}return e}var Ax={};Yt(Ax,{fromPixels:()=>H4,fromPixelsAsync:()=>W4,toPixels:()=>U4});function vI(r,t,e){if(jn(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Or(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}var qu;function __(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o&&o&&r.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(jd(qd,_.backendName)!=null){let d={pixels:r},h={numChannels:t};return _.runKernel(qd,d,h)}let[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],p;if(i)p=r.getContext("2d").getImageData(0,0,l,c).data;else if(n||e)p=r.data;else if(s||o||a){if(qu==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")qu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else qu=document.createElement("canvas").getContext("2d");qu.canvas.width=l,qu.canvas.height=c,qu.drawImage(r,0,0,l,c),p=qu.getImageData(0,0,l,c).data}let m;if(t===4)m=new Int32Array(p);else{let d=l*c;m=new Int32Array(d*t);for(let h=0;h<d;h++)for(let g=0;g<t;++g)m[h*t+g]=p[h*4+g]}return vI(m,[c,l,t],"int32")}function z4(r){return r!=null&&r.data instanceof Uint8Array}function B4(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function V4(r){return r!=null&&r.width!==0&&r.height!==0}function G4(r){return B4()&&!(r instanceof ImageBitmap)&&V4(r)&&!z4(r)}async function W4(r,t=3){let e=null;if(V().getBool("WRAP_TO_IMAGEBITMAP")&&G4(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?e=n:e=r}else e=r;return __(e,t)}async function U4(r,t){let e=C(r,"img","toPixels");if(!(r instanceof Lt)){let l=e;e=Z(l,"int32"),l.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[n,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let i=await e.data(),a=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=i[l*s+m];if(e.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(e.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[m]=f*a}let p=l*4;u[p+0]=Math.round(c[0]),u[p+1]=Math.round(c[1]),u[p+2]=Math.round(c[2]),u[p+3]=Math.round(c[3])}if(t!=null){t.width=o,t.height=n;let l=t.getContext("2d"),c=new ImageData(u,o,n);l.putImageData(c,0,0)}return e!==r&&e.dispose(),u}var H4=N({fromPixels_:__});var $x={};Yt($x,{prepareAndValidate:()=>E_});function E_(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(re(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=t.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=r.shape,u=o.slice();u.pop();let l=1;for(let p=s;p<e;++p)l*=a[p],u.push(a[p]);let c=[...bi(r.shape).map(p=>p/l),1].slice(0,s);return[u,i,l,c]}var nh={};Yt(nh,{calculateShapes:()=>A_,validateInput:()=>Dx,validateUpdateShape:()=>CI});function CI(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(e.rank-o))throw new Error(s+` Output shape length < ${n+(e.rank-o)}`);if(e.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(e.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function Dx(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}CI(e,t,r)}function A_(r,t,e){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,u=re(t.shape)/a,l=[...bi(e.slice(0,o)),1],c=re(e);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}var Ve={};Yt(Ve,{assertParamsValid:()=>K4,computeFlatOffset:()=>J4,computeOutShape:()=>X4,getNormalizedAxes:()=>Y4,isSliceContinous:()=>Z4,maskToAxes:()=>j4,parseSliceParams:()=>SI,sliceInfo:()=>Q4,startForAxis:()=>L_,startIndicesWithElidedDims:()=>O_,stopForAxis:()=>z_,stopIndicesWithElidedDims:()=>M_,stridesForAxis:()=>P_,stridesWithElidedDims:()=>D_});var II=-2,q4=-1;function K4(r,t,e){let n=r.shape.length;A(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),A(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)A(t[o]+e[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function j4(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function X4(r,t,e){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((t[o]-r[o])/e[o]);return n}function D_(r,t,e,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function R_(r,t,e){return e<=r?e:e-(t-1)}function F_(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function Y4(r,t,e,n,o,s,i,a,u){let l=r.length,c=new Array(l),p=new Array(l),m=new Array(l);if(t.length&&e>0){let f=t[0],d=e+1;c=O_(i,f,d,n,r),p=M_(a,f,d,o,r),m=D_(s,f,d,r)}else for(let f=0;f<l;f++)c[f]=L_(i,n,s,r,f,u),p[f]=z_(a,o,s,r,f,u),m[f]=P_(s,f,u);return{begin:c,end:p,strides:m}}function O_(r,t,e,n,o){let s=[...o],i=F_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=R_(t,e,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function M_(r,t,e,n,o){let s=[...o],i=F_(e,t);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=R_(t,e,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=Ip(0,s[a],o[a])}return s}function P_(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function L_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=Ip(0,i,u-1),i}function z_(r,t,e,n,o,s){let i=t[o],a=e[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=Ip(0,i,u):i=Ip(-1,i,u-1),i}function Z4(r,t,e){let n=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){n=o;break}for(let o=n+1;o<e.length;o++)if(t[o]>0||e[o]!==r[o])return!1;return!0}function J4(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function SI(r,t,e){let n,o=r.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(i=>{A(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:(A(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function Q4(r,t,e,n,o,s,i,a,u){let l;if(n==null?(l=new Array(t.length),l.fill(1)):l=n,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let w=0;w<p.dims;w++)c&&(1<<w&a)!==0&&p.numAddAxisAfterEllipsis++,1<<w&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};tH(p,m);let f=!0,d=!0,h=!0,g=[],y=[];for(let w=0;w<r.length;++w){if(m.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);let v=!!(m.shrinkAxisMask&1<<w),k=r[w];if(k===-1){g.push(v?1:-1);continue}let E=[m.beginMask&1<<w,m.endMask&1<<w],$=[m.strides[w]>0?0:-1,m.strides[w]>0?k:k-1];if(v&&m.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&m.strides[w]===1;let D=!!(m.beginMask&1<<w&&m.endMask&1<<w);if(m.beginValid&&m.endValid){if(v){let U=m.begin[w]<0?k+m.begin[w]:m.begin[w];if(m.begin[w]=U,m.end[w]=m.begin[w]+1,U<0||U>=k)throw Error(`slice index ${m.begin[w]} of dimension ${w} out of bounds.`)}else m.begin[w]=$_(m.begin[w],0,m.strides[w],k,E,$),m.end[w]=$_(m.end[w],1,m.strides[w],k,E,$);let W=m.strides[w]===1&&m.begin[w]===0&&m.end[w]===k;f=f&&W,d=d&&(w===0&&m.strides[w]===1||W)}else f=f&&m.strides[w]===1&&D,d=d&&(w===0&&m.strides[w]===1||D);let R,P=!1;if(m.beginValid&&m.endValid?(R=m.end[w]-m.begin[w],P=!0):v?(R=1,P=!0):D&&k>=0&&(m.strides[w]<0?R=-k:R=k,P=!0),P){let W;R===0||R<0!=m.strides[w]<0?W=0:W=Math.trunc(R/m.strides[w])+(R%m.strides[w]!==0?1:0),g.push(W)}else g.push(-1)}for(let w=0;w<m.finalShapeGatherIndices.length;++w){let v=m.finalShapeGatherIndices[w];v>=0?y.push(g[v]):v===II&&y.push(1)}return{finalShapeSparse:y.filter((w,v)=>m.finalShapeGatherIndices[v]!==II),finalShape:y,isIdentity:f,sliceDim0:d,isSimpleSlice:h,begin:m.begin,end:m.end,strides:m.strides}}function tH(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(t.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&r.newAxisMask)t.finalShapeGatherIndices.push(II),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[n]),r.end!=null&&(t.end[e]=r.end[n]),t.strides[e]=r.strides[n],r.beginMask&1<<n&&(t.beginMask|=1<<e),r.endMask&1<<n&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(q4),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function $_(r,t,e,n,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let i=r<0?n+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var et={};Yt(et,{Serializable:()=>oh,SerializationMap:()=>Gi,registerClass:()=>Nn});var oh=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Gi=class{constructor(){this.classNameMap={}}static getMap(){return Gi.instance==null&&(Gi.instance=new Gi),Gi.instance}static register(t){Gi.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function Nn(r){A(r.className!=null,()=>"Class being registered does not have the static className property defined."),A(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),A(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Gi.register(r)}var W_={};Yt(W_,{TEST_EPSILON_FLOAT16:()=>B_,encodeStrings:()=>G_,expectArrayBuffersEqual:()=>iH,expectArraysClose:()=>rH,expectArraysEqual:()=>oH,expectNumbersClose:()=>V_,expectPromiseToFail:()=>nH,expectValuesInRange:()=>sH,testEpsilon:()=>Rx});var eH=.001,B_=.1;function rH(r,t,e){return e==null&&(e=Rx()),kI(r,t,(n,o)=>NI(n,o,e))}function Rx(){return _.backend.floatPrecision()===32?eH:B_}function kI(r,t,e){let n=!0;if((yr(r)||yr(t))&&(n=!1),yr(r)&&yr(t)&&(n=!0),n){let i=r.constructor.name,a=t.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(r)&&Array.isArray(t)){let i=Or(r),a=Or(t);if(!Mn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=yr(r)?r:Xo(r),s=yr(t)?t:Xo(t);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],u=s[i];if(!e(a,u))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}}function nH(r,t){r().then(()=>t.fail(),()=>t())}function oH(r,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Yo(r)||Yo(r[0])||Yo(t)||Yo(t[0])?kI(r,e,(n,o)=>n==o):kI(r,t,(n,o)=>NI(n,o,0))}function V_(r,t,e){if(e==null&&(e=Rx()),!NI(r,t,e))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`)}function NI(r,t,e){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>e)}function sH(r,t,e){for(let n=0;n<r.length;n++)if(r[n]<t||r[n]>e)throw new Error(`Value out of range:${r[n]} low: ${t}, high: ${e}`)}function iH(r,t){let e=new Float32Array(r),n=new Float32Array(t);if(e.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${e.length}`);for(let o=0;o<n.length;o++)if(e[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${e[o]} instead`)}function G_(r){for(let t=0;t<r.length;t++){let e=r[t];Array.isArray(e)?G_(e):r[t]=Kl(e)}return r}var U_="3.16.0";function rpt(){V().set("PROD",!0)}function npt(){V().set("DEBUG",!0)}function opt(){V().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function TI(r){V().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}q1(TI);function spt(){_.disposeVariables()}function go(){return _}function sh(){return _.memory()}function ipt(r){return _.profile(r)}function B(r,t){return _.tidy(r,t)}function _t(r){Qd(r).forEach(e=>e.dispose())}function Pe(r){return _.keep(r)}function apt(r){return _.time(r)}function aH(r){return _.setBackend(r)}function lpt(){return _.ready()}function upt(){return _.backendName}function cpt(r){_.removeBackend(r)}function ppt(r){return _.findBackend(r)}function mpt(r){return _.findBackendFactory(r)}function dm(r,t,e=1){return _.registerBackend(r,t,e)}function H_(){return _.backend}function fpt(r,t){V().setPlatform(r,t)}function lH(r,t){let e=C(r,"a","add"),n=C(t,"b","add");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Xn,o)}var J=N({add_:lH});function uH(r,t){let e=C(r,"a","floorDiv"),n=C(t,"b","floorDiv");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(ms,o)}var Ku=N({floorDiv_:uH});function cH(r,t){let e=C(r,"a","div"),n=C(t,"b","div");if([e,n]=jt(e,n),e.dtype==="int32"&&n.dtype==="int32")return Ku(e,n);let o={a:e,b:n},s={};return _.runKernel(ls,o,s)}var ct=N({div_:cH});function pH(r,t){let e=C(r,"a","mul"),n=C(t,"b","mul");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ss,o)}var O=N({mul_:pH});function mH(r){let t=C(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return _.runKernel(Rl,e)}else{let e={x:t};return _.runKernel(wi,e)}}var Ne=N({abs_:mH});function fH(r){let e={x:C(r,"x","acos")};return _.runKernel(ea,e)}var ih=N({acos_:fH});function dH(r){let e={x:C(r,"x","acosh")};return _.runKernel(ra,e)}var ah=N({acosh_:dH});function hH(r){A(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),A(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((o,s)=>C(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!Mn(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return _.runKernel(Zo,n)}var _I=N({addN_:hH});function gH(r,t=null,e=!1){let o={x:C(r,"x","all","bool")},s={axis:t,keepDims:e};return _.runKernel(na,o,s)}var ju=N({all_:gH});function xH(r,t=null,e=!1){let o={x:C(r,"x","any","bool")},s={axis:t,keepDims:e};return _.runKernel(oa,o,s)}var Zl=N({any_:xH});function yH(r,t=0){let n={x:C(r,"x","argMax")},o={axis:t};return _.runKernel(Jo,n,o)}var Xs=N({argMax_:yH});function bH(r,t=0){let n={x:C(r,"x","argMin")},o={axis:t};return _.runKernel($l,n,o)}var lh=N({argMin_:bH});function wH(r){let e={x:C(r,"x","asin")};return _.runKernel(sa,e)}var uh=N({asin_:wH});function vH(r){let e={x:C(r,"x","asinh")};return _.runKernel(ia,e)}var ch=N({asinh_:vH});function CH(r){let e={x:C(r,"x","atan")};return _.runKernel(aa,e)}var ph=N({atan_:CH});function IH(r,t){let e=C(r,"a","atan2"),n=C(t,"b","atan2");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(ua,o)}var mh=N({atan2_:IH});function SH(r){let e={x:C(r,"x","atanh")};return _.runKernel(la,e)}var fh=N({atanh_:SH});function kH(r,t,e,n,o="NHWC",s){let i=r[3],a=[...t,i],u=K_(o);return Yu(r,a,e,s,n,null,null,u)}function AI(r,t,e,n,o,s,i="channelsLast"){let[a,u]=Fx(t),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return Yu(r,l,e,n,o,s,!1,i)}function NH(r,t,e,n,o,s,i="NDHWC"){let[a,u,l]=EI(t),c,p;if(i==="NDHWC")p="channelsLast",c=[a,u,l,r[4],r[4]];else if(i==="NCDHW")p="channelsFirst",c=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return q_(r,c,e,n,o,!1,p,s)}function Yu(r,t,e,n,o,s,i=!1,a="channelsLast"){let[u,l,c,p]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,p]=r;else if(a==="channelsFirst")[u,p,l,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,f,,d]=t,[h,g]=Fx(e),[y,b]=Fx(n),w=hm(m,y),v=hm(f,b),{padInfo:k,outHeight:E,outWidth:$}=EH(o,l,c,h,g,w,v,s,a),D=i?d*p:d,R;return a==="channelsFirst"?R=[u,D,E,$]:a==="channelsLast"&&(R=[u,E,$,D]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:p,outHeight:E,outWidth:$,outChannels:D,padInfo:k,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:w,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:r,outShape:R,filterShape:t}}function q_(r,t,e,n,o,s=!1,i="channelsLast",a){let[u,l,c,p,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,p,m]=r;else if(i==="channelsFirst")[u,m,l,c,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[f,d,h,,g]=t,[y,b,w]=EI(e),[v,k,E]=EI(n),$=hm(f,v),D=hm(d,k),R=hm(h,E),{padInfo:P,outDepth:W,outHeight:U,outWidth:q}=AH(o,l,c,p,y,b,w,$,D,R,a),K=s?g*m:g,j;return i==="channelsFirst"?j=[u,K,W,U,q]:i==="channelsLast"&&(j=[u,W,U,q,K]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:p,inChannels:m,outDepth:W,outHeight:U,outWidth:q,outChannels:K,padInfo:P,strideDepth:y,strideHeight:b,strideWidth:w,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:$,effectiveFilterHeight:D,effectiveFilterWidth:R,dilationDepth:v,dilationHeight:k,dilationWidth:E,inShape:r,outShape:j,filterShape:t}}function TH(r,t,e,n,o){n==null&&(n=$I(r,t,e));let s=r[0],i=r[1],a=Xu((s-t+2*n)/e+1,o),u=Xu((i-t+2*n)/e+1,o);return[a,u]}function _H(r,t,e,n,o,s){o==null&&(o=$I(r,t,n));let i=r[0],a=r[1],u=r[2],l=Xu((i-t+2*o)/n+1,s),c=Xu((a-t+2*o)/n+1,s),p=Xu((u-t+2*o)/n+1,s);return[l,c,p,e]}function $I(r,t,e,n=1){let o=hm(t,n);return Math.floor((r[0]*(e-1)-e+o)/2)}function Fx(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function EI(r){return typeof r=="number"?[r,r,r]:r}function hm(r,t){return t<=1?r:r+(r-1)*(t-1)}function EH(r,t,e,n,o,s,i,a,u){let l,c,p;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=TH([t,e],s,n,r,a);c=f[0],p=f[1]}else if(r==="same"){c=Math.ceil(t/n),p=Math.ceil(e/o);let m=Math.max(0,(c-1)*n+s-t),f=Math.max(0,(p-1)*o+i-e),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),y=f-g;l={top:d,bottom:h,left:g,right:y,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),p=Math.ceil((e-i+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],d=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=Xu((t-s+m+f)/n+1,a),p=Xu((e-i+d+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:c,outWidth:p}}function AH(r,t,e,n,o,s,i,a,u,l,c){let p,m,f,d;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=_H([t,e,n,1],a,1,o,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(t/o),f=Math.ceil(e/s),d=Math.ceil(n/i);let h=(m-1)*o+a-t,g=(f-1)*s+u-e,y=(d-1)*i+l-n,b=Math.floor(h/2),w=h-b,v=Math.floor(g/2),k=g-v,E=Math.floor(y/2),$=y-E;p={top:v,bottom:k,left:E,right:$,front:b,back:w,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((t-a+1)/o),f=Math.ceil((e-u+1)/s),d=Math.ceil((n-l+1)/i);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outDepth:m,outHeight:f,outWidth:d}}function Xu(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Zn(r){let[t,e,n]=Fx(r);return t===1&&e===1&&n===1}function $r(r,t){return Zn(r)||Zn(t)}function K_(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Te(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")A(ta(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{A(ta(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function $H(r,t){let n={x:C(r,"x","reshape","string_or_numeric")},o={shape:t};return _.runKernel(_i,n,o)}var M=N({reshape_:$H});function DH(r,t,e,n,o){let s=C(r,"x","avgPool","float32"),i=1;A($r(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=M(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Te("avgPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(Qo,l,c);return p=Z(p,s.dtype),u?M(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var qa=N({avgPool_:DH});function RH(r,t,e,n,o,s="NDHWC"){let i=C(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Te("avgPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(Dl,l,c);return p=Z(p,a.dtype),u?M(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var dh=N({avgPool3d_:RH});function FH(r,t=0){A(r.length>=1,()=>"Pass at least one tensor to concat");let e=Wa(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return kn(e[0]);let n=e,o={axis:t};return _.runKernel(Ci,n,o)}var se=N({concat_:FH});function OH(r){let e={x:C(r,"x","sigmoid","float32")};return _.runKernel(Ps,e)}var Lr=N({sigmoid_:OH});function MH(r,t,e){let n=C(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:e};return _.runKernel(Ai,o,s)}var Rt=N({slice_:MH});function PH(r){let e={x:C(r,"x","tanh","float32")};return _.runKernel(Us,e)}var Ys=N({tanh_:PH});function LH(r,t,e,n,o,s){let i=C(r,"forgetBias","basicLSTMCell"),a=C(t,"lstmKernel","basicLSTMCell"),u=C(e,"lstmBias","basicLSTMCell"),l=C(n,"data","basicLSTMCell"),c=C(o,"c","basicLSTMCell"),p=C(s,"h","basicLSTMCell"),m=se([l,p],1),f=zt(m,a),d=J(f,u),h=d.shape[0],g=d.shape[1]/4,y=[h,g],b=Rt(d,[0,0],y),w=Rt(d,[0,g],y),v=Rt(d,[0,g*2],y),k=Rt(d,[0,g*3],y),E=J(O(Lr(b),Ys(w)),O(c,Lr(J(i,v)))),$=O(Ys(E),Lr(k));return[E,$]}var zH=N({basicLSTMCell_:LH});function BH(r,t,e){let n=C(r,"x","batchToSpaceND"),o=t.reduce((a,u)=>a*u);A(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),A(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),A(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},i={blockShape:t,crops:e};return _.runKernel(vi,s,i)}var Ka=N({batchToSpaceND_:BH});function j_(r){let t;return r.rank===0||r.rank===1?t=M(r,[1,1,1,r.size]):r.rank===2?t=M(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=M(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function VH(r,t,e,n,o,s){s==null&&(s=.001);let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;n!=null&&(c=C(n,"offset","batchNorm")),A(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),A(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),A(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:j_(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:s},d=_.runKernel(fs,m,f);return M(d,i.shape)}var xo=N({batchNorm_:VH});function GH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),A(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),A(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var DI=N({batchNorm2d_:GH});function WH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),A(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),A(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var RI=N({batchNorm3d_:WH});function UH(r,t,e,n,o,s){let i=C(r,"x","batchNorm"),a=C(t,"mean","batchNorm"),u=C(e,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let c;return n!=null&&(c=C(n,"offset","batchNorm")),A(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),A(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),A(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&A(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&A(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),xo(i,a,u,c,l,s)}var FI=N({batchNorm4d_:UH});function HH(r,t,e){let n=C(r,"x","bincount"),o=C(t,"weights","bincount");A(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:e};return _.runKernel(Ep,s,i)}var hh=N({bincount_:HH});function qH(r,t){let e=C(r,"s0","broadcastArgs","int32"),n=C(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:e,s1:n};return _.runKernel(Ap,o)}var OI=N({broadcastArgs_:qH});function KH(r,t){let e=C(r,"broadcastTo","x"),n=e.shape;if(t.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let l=e.shape.slice();for(;l.length<t.length;)l.unshift(1);e=M(e,l)}let o=e.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(o[l]===t[l])s[l]=1;else if(e.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return kn(e);let a={x:e},u={reps:s};return _.runKernel(Yn,a,u)}var ja=N({broadcastTo_:KH});function jH(r){let e={x:C(r,"x","ceil","float32")};return _.runKernel(es,e)}var gh=N({ceil_:jH});function XH(r,t,e){let n=C(r,"x","clipByValue");A(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let o={x:n},s={clipValueMin:t,clipValueMax:e};return _.runKernel(ao,o,s)}var br=N({clipByValue_:XH});function YH(r){return se(r,0)}var MI=N({concat1d_:YH});function ZH(r,t){return se(r,t)}var PI=N({concat2d_:ZH});function JH(r,t){return se(r,t)}var LI=N({concat3d_:JH});function QH(r,t){return se(r,t)}var zI=N({concat4d_:QH});function tq(r,t,e,n,o="NHWC",s=[1,1],i){let a=C(r,"x","conv2d","float32"),u=C(t,"filter","conv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Te("conv2d",n,i);let p=o==="NHWC"?l.shape[3]:l.shape[1];A(p===u.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${u.shape[2]}.`),A($r(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m={x:l,filter:u},f={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=_.runKernel(rs,m,f);return c?M(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var pn=N({conv2d_:tq});function eq(r,t,e,n,o="NWC",s=1,i){let a=C(r,"x","conv1d"),u=C(t,"filter","conv1d"),l=a,c=!1;a.rank===2&&(c=!0,l=M(a,[1,a.shape[0],a.shape[1]])),A(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),A(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Te("conv1d",n,i),A(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),A($r(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),A(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=M(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=M(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=pn(m,p,[1,e],n,"NHWC",[1,s],i);return c?M(g,[g.shape[2],g.shape[3]]):M(g,[g.shape[0],g.shape[2],g.shape[3]])}var Zu=N({conv1d_:eq});function rq(r,t,e,n,o,s="NHWC",i){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let a=r,u=t,l=!1;t.rank===3&&(l=!0,u=M(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,r[0],r[1],r[2]]),A(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),A(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),A(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let c=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?u.shape[3]:u.shape[1];A(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),A(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),Te("conv2dDerInput",o,i);let m={dy:u,filter:e},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},d=_.runKernel(ns,m,f);return l?M(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var gm=N({conv2DBackpropInput_:rq});function nq(r,t,e,n,o,s){let i=C(r,"x","conv2dTranspose"),a=C(t,"filter","conv2dTranspose");return gm(e,i,a,n,o,"NHWC",s)}var Ju=N({conv2dTranspose_:nq});function oq(r,t,e,n,o="NDHWC",s=[1,1,1]){let i=C(r,"x","conv3d"),a=C(t,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),A(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),A(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),A($r(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let c={x:u,filter:a},p={strides:e,pad:n,dataFormat:o,dilations:s},m=_.runKernel(Fl,c,p);return l?M(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var xh=N({conv3d_:oq});function sq(r,t,e,n,o){A(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,i=t,a=!1;t.rank===4&&(a=!0,i=M(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=i.shape[4];A(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),A(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),A(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),A(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),A(l===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`);let c={dy:i,filter:e},p={pad:o,strides:n,inputShape:s},m=_.runKernel(Fp,c,p);return a?M(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Ox=N({conv3DBackpropInput_:sq});function iq(r,t,e,n,o){let s=C(r,"x","conv3dTranspose"),i=C(t,"filter","conv3dTranspose");return Ox(e,s,i,n,o)}var BI=N({conv3dTranspose_:iq});function aq(r){let e={x:C(r,"x","cos","float32")};return _.runKernel(os,e)}var Xa=N({cos_:aq});function lq(r){let e={x:C(r,"x","cosh","float32")};return _.runKernel(ss,e)}var Qu=N({cosh_:lq});function uq(r,t=0,e=!1,n=!1){let s={x:C(r,"x","cumprod")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(ca,s,i)}var Jl=N({cumprod_:uq});function cq(r,t=0,e=!1,n=!1){let s={x:C(r,"x","cumsum")},i={axis:t,exclusive:e,reverse:n};return _.runKernel(is,s,i)}var tc=N({cumsum_:cq});function pq(r,t,e,n=!1){let o=C(r,"x","denseBincount"),s=C(t,"weights","denseBincount");A(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),A(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),A(e>=0,()=>`size must be non-negative, but got ${e}.`),A(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:n};return _.runKernel(Op,i,a)}var VI=N({denseBincount_:pq});function mq(r,t,e="NHWC"){let n=C(r,"x","depthToSpace","float32"),o=e==="NHWC"?n.shape[1]:n.shape[2],s=e==="NHWC"?n.shape[2]:n.shape[3],i=e==="NHWC"?n.shape[3]:n.shape[1];A(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),A(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),A(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),A(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:t,dataFormat:e};return _.runKernel(ma,a,u)}var yh=N({depthToSpace_:mq});function fq(r,t,e,n,o="NHWC",s=[1,1],i){let a=C(r,"x","depthwiseConv2d","float32"),u=C(t,"filter","depthwiseConv2d","float32"),l=a,c=!1;a.rank===3&&(c=!0,l=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),A(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Te("depthwiseConv2d",n,i);let p={x:l,filter:u},m={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},f=_.runKernel(as,p,m);return c?M(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Zs=N({depthwiseConv2d_:fq});function dq(r){let e={x:C(r,"x","diag")};return _.runKernel(Lp,e)}var hq=N({diag_:dq});function gq(r,t,e,n,o=[1,1],s="NHWC"){let i=C(r,"x","dilation2d"),a=C(t,"filter","dilation2d");A(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),A(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),A(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=M(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);let c={x:u,filter:a},p={strides:e,pad:n,dilations:o},m=_.runKernel(Ol,c,p);return l?M(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var bh=N({dilation2d_:gq});function xq(r,t){let e=C(r,"a","equal","string_or_numeric"),n=C(t,"b","equal","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(da,o)}var Sr=N({equal_:xq});function yq(r,t,e){let n=C(t,"a","where"),o=C(e,"b","where"),s=C(r,"condition","where","bool"),i=Bt(Bt(s.shape,n.shape),o.shape),a=ja(s,i),u=ja(n,i),l=ja(o,i),c={condition:a,t:u,e:l};return _.runKernel(Ei,c)}var _e=N({where_:yq});function bq(r){let e={x:C(r,"x","zerosLike")};return _.runKernel(Fi,e)}var St=N({zerosLike_:bq});function wq(r,t){let e=C(r,"a","div"),n=C(t,"b","div");[e,n]=jt(e,n);let o=ct(e,n),s=St(o),i=Sr(n,s);return _e(i,s,o)}var wh=N({divNoNan_:wq});function vq(r,t){let e=C(r,"t1","dot"),n=C(t,"t2","dot");A((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=n.rank===1?n.size:n.shape[0];if(A(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&n.rank===1){let i=M(e,[1,-1]),a=M(n,[-1,1]),u=zt(i,a);return M(u,[])}else if(e.rank===1&&n.rank===2){let i=M(e,[1,-1]),a=M(n,[n.shape[0],n.shape[1]]),u=zt(i,a);return M(u,[u.size])}else if(e.rank===2&&n.rank===1){let i=M(n,[-1,1]),a=zt(e,i);return M(a,[a.size])}else{let i=M(n,[n.shape[0],n.shape[1]]);return zt(e,i)}}var GI=N({dot_:vq});function Cq(r,...t){let e=t.map((o,s)=>C(o,`tensors${s}`,"einsum")),n={equation:r};return _.runKernel(zp,e,n)}var WI=N({einsum_:Cq});function Iq(r){let e={x:C(r,"x","elu","float32")};return _.runKernel(us,e)}var Js=N({elu_:Iq});function Sq(r){let t=C(r,"x","erf");A(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Z(t,"float32"));let e={x:t};return _.runKernel(fa,e)}var vh=N({erf_:Sq});function kq(r){let e={x:C(r,"x","exp")};return _.runKernel(cs,e)}var Ze=N({exp_:kq});function Nq(r,t=0){let e=C(r,"x","expandDims","string_or_numeric");A(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},o={dim:t};return _.runKernel(Ii,n,o)}var fr=N({expandDims_:Nq});function Tq(r){let e={x:C(r,"x","expm1")};return _.runKernel(ha,e)}var Ch=N({expm1_:Tq});function _q(r,t){let e=C(r,"x","tile","string_or_numeric");A(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},o={reps:t};return _.runKernel(Yn,n,o)}var kr=N({tile_:_q});function Eq(r,t,e,n="float32"){t==null&&(t=r);let o=It([r,t],n),s=r<=t?r:t;for(let a=0;a<s;++a)o.set(1,a,a);let i=M(o.toTensor(),[r,t]);if(e==null)return i;if(e.length===1)return kr(fr(i,0),[e[0],1,1]);if(e.length===2)return kr(fr(fr(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return kr(fr(fr(fr(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var xm=N({eye_:Eq});function Qs(r,t,e){let n={shape:r,value:t,dtype:e};return _.runKernel(Ml,{},n)}function Aq(r){let e={x:C(r,"x","floor","float32")};return _.runKernel(ps,e)}var ti=N({floor_:Aq});function $q(r,t,e=0,n=0){let o=C(r,"x","gather"),s=C(t,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:n};return _.runKernel(Si,i,a)}var yo=N({gather_:$q});function Dq(r,t){let e=C(r,"a","greater","string_or_numeric"),n=C(t,"b","greater","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ya,o)}var Ge=N({greater_:Dq});function Rq(r,t){let e=C(r,"a","greaterEqual","string_or_numeric"),n=C(t,"b","greaterEqual","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ds,o)}var Tn=N({greaterEqual_:Rq});function Fq(r){let e={input:C(r,"input","imag")};return _.runKernel(Wp,e)}var ec=N({imag_:Fq});function Oq(r){let e={x:C(r,"x","isFinite")};return _.runKernel(ba,e)}var UI=N({isFinite_:Oq});function Mq(r){let e={x:C(r,"x","isInf")};return _.runKernel(wa,e)}var HI=N({isInf_:Mq});function Pq(r){let e={x:C(r,"x","isNaN")};return _.runKernel(va,e)}var Ih=N({isNaN_:Pq});function Lq(r,t=.2){let n={x:C(r,"x","leakyRelu")},o={alpha:t};return _.runKernel(hs,n,o)}var Ya=N({leakyRelu_:Lq});function zq(r,t){let e=C(r,"a","less","string_or_numeric"),n=C(t,"b","less","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ca,o)}var rc=N({less_:zq});function Bq(r,t){let e=C(r,"a","lessEqual","string_or_numeric"),n=C(t,"b","lessEqual","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ia,o)}var _n=N({lessEqual_:Bq});function qI(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:t,num:e};return _.runKernel(Up,{},n)}function Vq(r,t=5,e=1,n=1,o=.5){let s=C(r,"x","localResponseNormalization");A(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),A(ta(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=M(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:t,bias:e,alpha:n,beta:o},c=_.runKernel(Pl,u,l);return a?M(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Sh=N({localResponseNormalization_:Vq});function Gq(r){let e={x:C(r,"x","log","float32")};return _.runKernel(gs,e)}var wr=N({log_:Gq});function Wq(r){let e={x:C(r,"x","log1p")};return _.runKernel(Sa,e)}var Za=N({log1p_:Wq});function Uq(r){return A(yi(r),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let n=C(t,"x","tf.grad","string_or_numeric"),o=e!=null?C(e,"dy","tf.grad"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(n),[n],o);return o!=null&&Me(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Px(i),i[0]})}}function Hq(r){return A(yi(r),()=>"The f passed in grads(f) must be a function"),(t,e)=>{A(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=Wa(t,"args","tf.grads","string_or_numeric"),o=e!=null?C(e,"dy","tf.grads"):null;return _.tidy(()=>{let{value:s,grads:i}=_.gradients(()=>r(...n),n,o);return o!=null&&Me(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Px(i),i})}}function qq(r){return A(yi(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{A(t instanceof Lt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),A(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=_.gradients(()=>r(t),[t],e);return Px(n),{grad:n[0],value:o}}}function Kq(r){return A(yi(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{A(Array.isArray(t)&&t.every(o=>o instanceof Lt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),A(e==null||e instanceof Lt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=_.gradients(()=>r(...t),t,e);return e!=null&&Me(n.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Px(n.grads),n}}function Mx(r,t){A(yi(r),()=>"The f passed in variableGrads(f) must be a function"),A(t==null||Array.isArray(t)&&t.every(l=>l instanceof Ga),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let l in _.registeredVariables)t.push(_.registeredVariables[l])}let n=e?t.filter(l=>!l.trainable):null,o=t.length;t=t.filter(l=>l.trainable),A(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=_.gradients(r,t,null,s);A(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),A(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),n!=null&&n.forEach(l=>u[l.name]=null),{value:i,grads:u}}function mn(r){return _.customGrad(r)}function Px(r){if(r.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function jq(r){let e={x:C(r,"x","neg")};return _.runKernel(ki,e)}var Zt=N({neg_:jq});function Xq(r){let e={x:C(r,"x","softplus")};return _.runKernel(Ma,e)}var bo=N({softplus_:Xq});function Yq(r){let t=C(r,"x","logSigmoid");return mn(n=>({value:Zt(bo(Zt(n))),gradFunc:i=>O(i,Lr(Zt(n)))}))(t)}var KI=N({logSigmoid_:Yq});function Zq(r,t=null,e=!1){let o={x:C(r,"x","max")},s={reductionIndices:t,keepDims:e};return _.runKernel(xs,o,s)}var Dr=N({max_:Zq});function Jq(r,t){let e=C(r,"a","sub"),n=C(t,"b","sub");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Gs,o)}var lt=N({sub_:Jq});function Qq(r,t=null,e=!1){let n=C(r,"x","sum");n.dtype==="bool"&&(n=Z(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(zs,o,s)}var mt=N({sum_:Qq});function tK(r,t=-1){let e=C(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return mn((o,s)=>{let a=Dr(o,t,!0),u=lt(o,a),l=lt(Z(u,"float32"),wr(mt(Ze(u),t,!0)));return s([l]),{value:l,gradFunc:(p,m)=>{let[f]=m,d=!0,h=Ze(f);return lt(p,O(mt(p,t,d),h))}}})(e)}var nc=N({logSoftmax_:tK});function jI(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function X_(r,t,e){let n=r.length+t.length,o=[],s=0,i=0;for(let a=0;a<n;a++)e.indexOf(a)===-1?o.push(r[s++]):o.push(t[i++]);return o}function XI(r,t){let e=[],n=r.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&e.push(r[s]);let o=t.map(s=>r[s]);return[e,o]}function wo(r,t){let e=t.map(n=>1);return X_(r,e,t)}function eK(r,t,e){A(jI(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function YI(r,t){if(jI(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function kh(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function rK(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function nK(r,t=null,e=!1){let n=C(r,"x","logSumExp"),o=mr(t,n.shape),s=Dr(n,o,!0),i=lt(n,s),a=Ze(i),u=mt(a,o),l=wr(u),c=J(M(s,l.shape),l);if(e){let p=wo(c.shape,o);return M(c,p)}return c}var Nh=N({logSumExp_:nK});function oK(r,t){let e=C(r,"a","logicalAnd","bool"),n=C(t,"b","logicalAnd","bool");Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ka,o)}var Nr=N({logicalAnd_:oK});function sK(r){let e={x:C(r,"x","logicalNot","bool")};return _.runKernel(Mu,e)}var Ja=N({logicalNot_:sK});function iK(r,t){let e=C(r,"a","logicalOr","bool"),n=C(t,"b","logicalOr","bool");Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Pu,o)}var oc=N({logicalOr_:iK});function aK(r,t){let e=C(r,"a","logicalXor","bool"),n=C(t,"b","logicalXor","bool");return Bt(e.shape,n.shape),Nr(oc(r,t),Ja(Nr(r,t)))}var JI=N({logicalXor_:aK});function lK(r,t,e,n,o){let s=C(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=M(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),A($r(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Te("maxPool",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o},p=_.runKernel(bs,l,c);return u?M(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Qa=N({maxPool_:lK});function uK(r,t=[1,1,1],e,n,o,s="NDHWC"){let i=C(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),A(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Te("maxPool3d",n,o);let l={x:a},c={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},p=_.runKernel(Ll,l,c);return u?M(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Th=N({maxPool3d_:uK});function cK(r,t,e,n,o=!1){let i={x:C(r,"x","maxPoolWithArgmax")},a={filterSize:t,strides:e,pad:n,includeBatchInIndex:o},u=_.runKernel(jp,i,a);return{result:u[0],indexes:u[1]}}var QI=N({maxPoolWithArgmax_:cK});function pK(r,t){let e=C(r,"a","maximum"),n=C(t,"b","maximum");[e,n]=jt(e,n),e.dtype==="bool"&&(e=Z(e,"int32"),n=Z(n,"int32")),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(ys,o)}var fn=N({maximum_:pK});function mK(r,t=null,e=!1){let o={x:C(r,"x","mean")},s={axis:t,keepDims:e};return _.runKernel(ws,o,s)}var xe=N({mean_:mK});function ye(r,t="float32"){if(t==="complex64"){let n=ye(r,"float32"),o=ye(r,"float32");return zn(n,o)}let e=Np(re(r),t);return _.makeTensor(e,r,t)}function lr(r,t="float32"){if(t==="complex64"){let n=lr(r,"float32"),o=ye(r,"float32");return zn(n,o)}let e=zd(re(r),t);return _.makeTensor(e,r,t)}function fK(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=C(r,"x","meshgrid",r instanceof Lt?r.dtype:"float32");if(t===void 0)return[n];let o=C(t,"y","meshgrid",t instanceof Lt?t.dtype:"float32"),s=re(n.shape),i=re(o.shape);return e==="xy"?(n=M(n,[1,-1]),o=M(o,[-1,1]),[zt(lr([i,1],n.dtype),n),zt(o,lr([1,s],o.dtype))]):(n=M(n,[-1,1]),o=M(o,[1,-1]),[zt(n,lr([1,i],n.dtype)),zt(lr([s,1],o.dtype),o)])}function dK(r,t=null,e=!1){let o={x:C(r,"x","min")},s={axis:t,keepDims:e};return _.runKernel(vs,o,s)}var Ql=N({min_:dK});function hK(r,t){let e=C(r,"a","minimum"),n=C(t,"b","minimum");[e,n]=jt(e,n),e.dtype==="bool"&&(e=Z(e,"int32"),n=Z(n,"int32")),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Cs,o)}var ei=N({minimum_:hK});function gK(r,t,e){A(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=C(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<n.rank;a++)A(t[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),A(t[a][0]>=0&&t[a][0]<=n.shape[a]-o&&t[a][1]>=0&&t[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:e},i={x:n};return _.runKernel(Is,i,s)}var _h=N({mirrorPad_:gK});function xK(r,t){let e=C(r,"a","mod"),n=C(t,"b","mod");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Na,o)}var Eh=N({mod_:xK});function yK(r){let t=C(r,"x","square"),e={};return _.runKernel("Square",{x:t},e)}var Ut=N({square_:yK});function bK(r,t=null,e=!1){r=C(r,"x","moments");let n=mr(t,r.shape),o=xe(r,n,e),s=o.shape;e||(s=wo(o.shape,n));let i=Ut(lt(Z(r,"float32"),M(o,s))),a=xe(i,n,e);return{mean:o,variance:a}}var ym=N({moments_:bK});function wK(r,t,e,n){let o=C(t,"data","multiRNNCell"),s=Wa(e,"c","multiRNNCell"),i=Wa(n,"h","multiRNNCell"),a=o,u=[];for(let p=0;p<r.length;p++){let m=r[p](a,s[p],i[p]);u.push(m[0]),u.push(m[1]),a=m[1]}let l=[],c=[];for(let p=0;p<u.length;p+=2)l.push(u[p]),c.push(u[p+1]);return[l,c]}var vK=N({multiRNNCell_:wK});function CK(r,t,e,n=!1){let o=C(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let u={logits:i===1?M(o,[1,-1]):o},l={numSamples:t,seed:e,normalized:n},c=_.runKernel(Xp,u,l);return i===1?M(c,[c.size]):c}var tS=N({multinomial_:CK});function IK(r,t){let e=C(r,"a","notEqual","string_or_numeric"),n=C(t,"b","notEqual","string_or_numeric");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n};return _.runKernel(Ta,o)}var vo=N({notEqual_:IK});function SK(r){let e={x:C(r,"x","onesLike")};return _.runKernel(Ni,e)}var dr=N({onesLike_:SK});function kK(r,t){let e=C(r,"v1","outerProduct"),n=C(t,"v2","outerProduct");A(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);let o=M(e,[-1,1]),s=M(n,[1,-1]);return zt(o,s)}var NK=N({outerProduct_:kK});function TK(r,t,e=0){let n=C(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:n};return _.runKernel(Ns,s,o)}var Yr=N({pad_:TK});function _K(r,t,e=0){return A(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Yr(r,[t],e)}var EK=N({pad1d_:_K});function AK(r,t,e=0){return A(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yr(r,t,e)}var $K=N({pad2d_:AK});function DK(r,t,e=0){return A(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yr(r,t,e)}var RK=N({pad3d_:DK});function FK(r,t,e=0){return A(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yr(r,t,e)}var OK=N({pad4d_:FK});function MK(r,t,e){let n=C(r,"x","spaceToBatchND");A(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),A(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),A(n.shape.reduce((i,a,u)=>u>0&&u<=t.length?i&&(a+e[u-1][0]+e[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:e};return _.runKernel($i,o,s)}var tl=N({spaceToBatchND_:MK});function PK(r,t,e,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=C(r,"x","maxPool"),u=a,l=!1;a.rank===3&&(l=!0,u=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A($r(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let c=AI(u.shape,t,s,o,n),p=[c.dilationHeight,c.dilationWidth],m;n==="same"?m=zK([c.filterHeight,c.filterWidth],p):m=[[0,0],[0,0]];let f=p[0]===1&&p[1]===1,[d,h]=LK([c.inHeight,c.inWidth],p,m),g=f?n:"valid",y=f?u:tl(u,p,d),w=(e==="avg"?()=>qa(y,t,s,g,i):()=>Qa(y,t,s,g,i))(),v=f?w:Ka(w,p,h);return l?M(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function LK(r,t,e){let n=e.map(c=>c[0]),o=e.map(c=>c[1]),s=r.concat(n,o),i=t.map((c,p)=>(c-s[p]%c)%c),a=o.map((c,p)=>c+i[p]),u=t.map((c,p)=>[n[p],a[p]]),l=t.map((c,p)=>[0,i[p]]);return[u,l]}function zK(r,t){let n=r.map((i,a)=>i+(i-1)*(t[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var eS=N({pool_:PK});function BK(r,t){let e=C(r,"base","pow"),n=C(t,"exp","pow");[e,n]=jt(e,n);let o={a:e,b:n};return _.runKernel(Ts,o)}var Zr=N({pow_:BK});function VK(r,t){let e=C(r,"x","prelu"),n=C(t,"alpha","prelu"),o={x:e,alpha:n};return _.runKernel(_s,o)}var el=N({prelu_:VK});function GK(r,t=null,e=!1){let n=C(r,"x","prod");n.dtype==="bool"&&(n=Z(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return _.runKernel(Es,o,s)}var sc=N({prod_:GK});function WK(r,t,e){let n=re(r),o=null;if(e==null||e==="float32")o=new Float32Array(n);else if(e==="int32")o=new Int32Array(n);else if(e==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<n;s++)o[s]=t();return _.makeTensor(o,r,e)}var UK=N({rand_:WK});var Vx=Ru(uS());var ac=class{constructor(t,e,n,o,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=Vx.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},zx=class{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;let s=o||Math.random();this.randu=Vx.alea(s.toString()),this.randn=new ac(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,t=o*o,e=1-.331*t*t,n=.5*t+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},Bx=class{constructor(t=0,e=1,n,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Vx.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function ZK(r,t,e=1,n="float32",o){if(e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new zx(t,e,n,o),i=It(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var JK=N({randomGamma_:ZK});function QK(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new ac(t,e,n,!1,o),i=It(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Gx=N({randomNormal_:QK});function tj(r,t=0,e=1,n="float32",o){let s=It(r,n),i=new Bx(t,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var ri=N({randomUniform_:tj});function rl(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:t,step:e,dtype:n};return _.runKernel(zl,{},o)}function ej(r){let e={input:C(r,"input","real")};return _.runKernel(Yp,e)}var tu=N({real_:ej});function rj(r){let e={x:C(r,"x","reciprocal")};return _.runKernel($a,e)}var Ah=N({reciprocal_:rj});function nj(r){let e={x:C(r,"x","relu")};return _.runKernel(As,e)}var Tr=N({relu_:nj});function oj(r){let e={x:C(r,"x","relu6")};return _.runKernel(Ds,e)}var lc=N({relu6_:oj});function sj(r,t){let n={x:C(r,"x","reverse")},o={dims:t};return _.runKernel(Rs,n,o)}var ir=N({reverse_:sj});function ij(r){let t=C(r,"x","reverse");return A(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ir(t,0)}var aj=N({reverse1d_:ij});function lj(r,t){let e=C(r,"x","reverse");return A(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),ir(e,t)}var uj=N({reverse2d_:lj});function cj(r,t){let e=C(r,"x","reverse");return A(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),ir(e,t)}var pj=N({reverse3d_:cj});function mj(r,t){let e=C(r,"x","reverse");return A(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),ir(e,t)}var fj=N({reverse4d_:mj});function dj(r){let e={x:C(r,"x","round")};return _.runKernel(Fs,e)}var uc=N({round_:dj});function hj(r){let e={x:C(r,"x","rsqrt","float32")};return _.runKernel(Os,e)}var cc=N({rsqrt_:hj});function pt(r,t){if((yr(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&yr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return cn(r,[],[],t)}function gj(r){let e={x:C(r,"x","selu")};return _.runKernel(Ra,e)}var pc=N({selu_:gj});function xj(r,t,e,n,o,s=[1,1],i="NHWC"){let a=C(r,"x","separableConv2d"),u=C(t,"depthwiseFilter","separableConv2d"),l=C(e,"pointwiseFilter","separableConv2d"),c=a,p=!1;if(a.rank===3&&(p=!0,c=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),A(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),A(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),A(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let m=u.shape[2],f=u.shape[3];A(l.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${l.shape[2]}.`);let d=Zs(c,u,n,o,i,s),g=pn(d,l,1,"valid",i);return p?M(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var $h=N({separableConv2d_:xj});async function yj(r,t){let e=C(r,"x","setdiff1d"),n=C(t,"y","setdiff1d");A(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),A(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),A(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await e.data(),s=await n.data(),i=new Set(s),a=0;for(let c=0;c<o.length;c++)i.has(o[c])||a++;let u=new pe([a],e.dtype),l=new pe([a],"int32");for(let c=0,p=0;c<o.length;c++)i.has(o[c])||(u.values[p]=o[c],l.values[p]=c,p++);return[u.toTensor(),l.toTensor()]}var cS=yj;function bj(r){let e={x:C(r,"x","sign")};return _.runKernel(Oa,e)}var Dh=N({sign_:bj});function wj(r){let e={x:C(r,"x","sin","float32")};return _.runKernel(Ms,e)}var mc=N({sin_:wj});function vj(r){let e={x:C(r,"x","sinh")};return _.runKernel(Fa,e)}var fc=N({sinh_:vj});function Cj(r,t,e){let n=C(r,"x","slice1d");return A(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Rt(n,[t],[e])}var Rh=N({slice1d_:Cj});function Ij(r,t,e){let n=C(r,"x","slice2d");return A(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Rt(n,t,e)}var Wx=N({slice2d_:Ij});function Sj(r,t,e){let n=C(r,"x","slice3d");return A(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Rt(n,t,e)}var Fh=N({slice3d_:Sj});function kj(r,t,e){let n=C(r,"x","slice4d");return A(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Rt(n,t,e)}var bm=N({slice4d_:kj});function Nj(r,t=-1){let e=C(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},o={dim:t};return _.runKernel(Bs,n,o)}var nl=N({softmax_:Nj});function Tj(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Vp,t)}var ol=N({fft_:Tj});function _j(r){A(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return _.runKernel(Gp,t)}var Wi=N({ifft_:_j});function Ej(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let o=M(r,[e,t]);n=Wi(o)}else{let o=[e,2*(t-1)],s=M(tu(r),[e,t]),i=M(ec(r),[e,t]),a=ir(Rt(s,[0,1],[e,t-2]),1),u=O(ir(Rt(i,[0,1],[e,t-2]),1),pt(-1)),l=se([s,a],1),c=se([i,u],1),p=M(zn(l,c),[o[0],o[1]]);n=Wi(p)}if(n=tu(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=M(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var dc=N({irfft_:Ej});function Aj(r,t,e=0){let o={x:C(r,"x","split")},s={numOrSizeSplits:t,axis:e};return _.runKernel(Di,o,s)}var ur=N({split_:Aj});function $j(r,t){A(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,o;if(t!=null&&t<e){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=t,o=Rt(r,d,h),e=t}else if(t!=null&&t>e){let d=r.shape.map(h=>h);d[r.shape.length-1]=t-e,o=se([r,ye(d)],r.shape.length-1),e=t}else o=r;let s=St(o),i=M(zn(o,s),[n,e]),a=ol(i),u=Math.floor(e/2)+1,l=tu(a),c=ec(a),p=ur(l,[u,e-u],l.shape.length-1),m=ur(c,[u,e-u],c.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,M(zn(p[0],m[0]),f)}var sl=N({rfft_:$j});function Dj(r){let e={x:C(r,"x","sqrt","float32")};return _.runKernel(Ls,e)}var be=N({sqrt_:Dj});function Rj(r,t){let e=C(r,"a","squaredDifference"),n=C(t,"b","squaredDifference");[e,n]=jt(e,n),Bt(e.shape,n.shape);let o={a:e,b:n},s={};return _.runKernel(Vs,o,s)}var hc=N({squaredDifference_:Rj});function Fj(r,t){let e=C(r,"x","squeeze");return M(e,FC(e.shape,t).newShape)}var zr=N({squeeze_:Fj});function Oj(r,t=0){let e=Wa(r,"tensors","stack","string_or_numeric");A(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&A(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,o={axis:t};return _.runKernel(Ti,n,o)}var Je=N({stack_:Oj});function Mj(r,t=0){let n={x:C(r,"x","step")},o={alpha:t};return _.runKernel(uo,n,o)}var ni=N({step_:Mj});function Pj(r,t,e,n,o=0,s=0,i=0,a=0,u=0){let c={x:C(r,"x","stridedSlice","string_or_numeric")},p={begin:t,end:e,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return _.runKernel(La,c,p)}var Oh=N({stridedSlice_:Pj});function Lj(r){let e={x:C(r,"x","tan","float32")};return _.runKernel(Ws,e)}var Mh=N({tan_:Lj});function Re(r,t){jn(r);let e=Or(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return cn(r,null,e,t)}function Ui(r,t,e){if(jn(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Or(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return cn(r,t,n,e)}function zj(r,t,e){if(jn(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Or(r,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}function Bj(r,t,e){if(jn(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Or(r,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return cn(r,t,n,e)}function Vj(r,t,e){if(jn(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Or(r,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,cn(r,t,n,e)}function Gj(r,t=1,e=!0){let n=C(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},i={k:t,sorted:e},[a,u]=_.runKernel(za,s,i);return{values:a,indices:u}}var Ph=N({topk_:Gj});function Wj(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new ac(t,e,n,!0,o),i=It(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var gc=N({truncatedNormal_:Wj});function Uj(r,t=0){let e=C(r,"x","unique","string_or_numeric");A(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},o={axis:t},[s,i]=_.runKernel(nm,n,o);return{values:s,indices:i}}var wm=N({unique_:Uj});function Hj(r,t,e){let n=C(r,"x","unsortedSegmentSum"),o=C(t,"segmentIds","unsortedSegmentSum","int32");A(ta(e),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:e};return _.runKernel(Hl,s,i)}var Lh=N({unsortedSegmentSum_:Hj});function qj(r,t=0){let e=C(r,"x","unstack","string_or_numeric");A(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},o={axis:t};return _.runKernel(Ri,n,o)}var vr=N({unstack_:qj});function pS(r,t=!0,e,n){return _.makeVariable(r,t,e,n)}function Ux(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let n=It(r,"int32"),o=It([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let i=n.indexToLoc(e[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}async function Kj(r){let t=C(r,"condition","whereAsync","bool"),e=await t.data(),n=Ux(t.shape,e);return r!==t&&t.dispose(),n}var zh=Kj;async function jj(r,t,e){let n=C(r,"tensor","boolMask"),o=C(t,"mask","boolMask","bool"),s=e==null?0:e,i=o.rank,a=n.shape;A(i>0,()=>"mask cannot be scalar"),Me(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+i;h++)u*=a[h];let l=a.slice(0,s).concat([u],a.slice(s+i)),c=M(n,l),p=M(o,[-1]),m=await zh(p),f=zr(m,[1]),d=yo(c,f,s);return r!==n&&n.dispose(),t!==o&&o.dispose(),f.dispose(),c.dispose(),p.dispose(),m.dispose(),d}var s1t=jj;function Xj(r,t="euclidean",e=null,n=!1){r=C(r,"x","norm");let o=cE(r,t,e),s=o.shape;if(n){let i=mr(e,r.shape);s=wo(o.shape,i)}return M(o,s)}function cE(r,t,e=null){if(r.rank===0)return Ne(r);if(r.rank!==1&&e===null)return cE(M(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return mt(Ne(r),e);if(t===1/0)return Dr(Ne(r),e);if(t===-1/0)return Ql(Ne(r),e);if(t==="euclidean"||t===2)return be(mt(Zr(Ne(r),pt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Dr(mt(Ne(r),e[0]),e[1]-1);if(t===1/0)return Dr(mt(Ne(r),e[1]),e[0]);if(t===-1/0)return Ql(mt(Ne(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return be(mt(Ut(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var vm=N({norm_:Xj});function Yj(r,t,e,n,o=!0){let s=C(r,"v","movingAverage"),i=C(t,"x","movingAverage"),a=C(e,"decay","movingAverage");rI(s,i),A(Mn(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=pt(1),l=lt(u,a),c=O(lt(i,s),l);if(o){A(n!=null,()=>"When using zeroDebias: true, step is required.");let p=C(n,"step","movingAverage");c=ct(c,lt(u,Zr(a,p)))}return J(s,c)}var E1t=N({movingAverage_:Yj});function Zj(r,t,e){let n=C(r,"indices","scatterND","int32"),o=C(t,"updates","scatterND");Dx(o,n,e);let s={indices:n,updates:o},i={shape:e};return _.runKernel(Da,s,i)}var pE=N({scatterND_:Zj});function mE(r,t,e,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Qj(r,t,e,n=0){let o=C(r,"sparseIndices","sparseToDense","int32"),s=C(t,"sparseValues","sparseToDense"),i=C(n,"defaultValue","sparseToDense",s.dtype);mE(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:e};return _.runKernel(Qp,a,u)}var Hx=N({sparseToDense_:Qj});function t6(r,t){let e=C(t,"indices","gatherND","int32"),o={params:C(r,"x","gatherND","string_or_numeric"),indices:e};return _.runKernel(xa,o)}var fE=N({gatherND_:t6});function dE(r,t){if(t==null)return r.shape.slice();if(Mn(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function e6(r,t,e,n){let o=C(r,"x","dropout");if(A(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),A(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof Lt?o.clone():o;let s=dE(o,e),i=1-t,a=ct(ti(J(ri(s,0,1,"float32",n),i)),i);return O(o,a)}var hE=N({dropout_:e6});function gE(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function qx(r,t,e){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let i=2*Math.PI*s/(r+n-1);o[s]=t-e*Math.cos(i)}return Re(o,"float32")}async function r6(r,t,e=1){let n=C(r,"predictions","inTopK"),o=C(t,"targets","inTopK");A(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),A(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Me(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];A(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=await n.data(),a=await o.data(),[u,l]=[i.length/s,s],c=OC("bool",u);for(let p=0;p<u;p++){let m=p*l,f=i.subarray(m,m+l),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),c[p]=0;for(let h=0;h<e;h++)if(d[h].index===a[p]){c[p]=1;break}}return r!==n&&n.dispose(),t!==o&&o.dispose(),Ar(c,o.shape,"bool")}var l_t=r6;var Co={};Yt(Co,{conv2d:()=>xE,depthwiseConv2d:()=>yE,matMul:()=>bE});function n6(r,t,e,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=M(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=M(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),A(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),A(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];A(l===e[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`),A(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),Te("conv2dDerFilter",o,i);let p={x:a,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return _.runKernel(Dp,p,m)}var Cm=N({conv2DBackpropFilter_:n6});function xc(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return O(r,ni(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function yc(r,t){let e=t,n=ge(r.shape,t.shape);return n.length>0&&(e=mt(e,n)),M(e,r.shape)}function bc(r,t,e,n){if(t==="linear")return r;if(t==="relu")return Tr(r);if(t==="elu")return Js(r);if(t==="relu6")return lc(r);if(t==="prelu")return el(r,e);if(t==="leakyrelu")return Ya(r,n);if(t==="sigmoid")return Lr(r);throw new Error(`Unknown fused activation ${t}.`)}var wc=(r,t)=>!(r>0)||t==="linear";function o6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",wc(_.state.gradientDepth,u)===!1){let k=pn(r,t,e,n,o,s,i);return a!=null&&(k=J(k,a)),bc(k,u,l,c)}let p=C(r,"x","conv2d","float32"),m=C(t,"filter","conv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=M(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Te("fused conv2d",n,i),A(f.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${m.shape[2]}.`),A($r(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),A(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=Yu(f.shape,m.shape,e,s,n,i),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=jt(g,p),Bt(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused conv2d"));let b=(k,E)=>{let[$,D,R,P]=E,W=xc(k,R,u);A(Zn(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let U=gm(D.shape,W,$,e,n),q=Cm(D,W,$.shape,e,n),K=[U,q];if(P!=null){let j=yc(P,W);K.push(j)}return K},w={x:f,filter:m,bias:g,preluActivationWeights:y},v={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?mn((E,$,D)=>{let R=_.runKernel(Mi,w,v);return D([$,E,R]),d&&(R=M(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,m):mn((E,$,D,R)=>{let P=_.runKernel(Mi,w,v);return R([$,E,P,D]),d&&(P=M(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m,g)}var xE=N({fusedConv2d_:o6});function s6(r,t,e,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=M(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=M(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={x:a,dy:u},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return _.runKernel(Mp,l,c)}var Kx=N({depthwiseConv2dNativeBackpropFilter_:s6});function i6(r,t,e,n,o,s=[1,1],i){let a=t,u=!1;t.rank===3&&(u=!0,a=M(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l={dy:a,filter:e},c={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},p=_.runKernel(Pp,l,c);return u?M(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var jx=N({depthwiseConv2dNativeBackpropInput_:i6});function a6({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(wc(_.state.gradientDepth,u)===!1){let k=Zs(r,t,e,n,o,s,i);return a!=null&&(k=J(k,a)),bc(k,u,l,c)}let p=C(r,"x","depthwiseConv2d","float32"),m=C(t,"filter","depthwiseConv2d","float32"),f=p,d=!1;p.rank===3&&(d=!0,f=M(p,[1,p.shape[0],p.shape[1],p.shape[2]])),A(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),A(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),A(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),A($r(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),Te("fused depthwiseConv2d",n,i);let h=Yu(f.shape,m.shape,e,s,n,i,!0),g;a!=null&&(g=C(a,"bias","fused conv2d"),[g]=jt(g,p),Bt(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused depthwiseConv2d"));let b=(k,E)=>{A(Zn(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[$,D,R,P]=E,W=xc(k,R,u),U=jx(D.shape,W,$,e,n,s,i),q=Kx(D,W,$.shape,e,n,s,i);if(P!=null){let K=yc(g,W);return[U,q,K]}return[U,q]},w={x:f,filter:m,bias:g,preluActivationWeights:y},v={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?mn((E,$,D)=>{let R=_.runKernel(Pi,w,v);return D([$,E,R]),d&&(R=M(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:b}})(f,m):mn((E,$,D,R)=>{let P=_.runKernel(Pi,w,v);return R([$,E,P,D]),d&&(P=M(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,m,g)}var yE=N({fusedDepthwiseConv2d_:a6});function l6({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(wc(_.state.gradientDepth,s)===!1){let W=zt(r,t,e,n);return o!=null&&(W=J(W,o)),bc(W,s,i,a)}let u=C(r,"a","fused matMul"),l=C(t,"b","fused matMul");[u,l]=jt(u,l);let c=e?u.shape[u.rank-2]:u.shape[u.rank-1],p=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=e?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=re(d),y=re(h);A(c===p,()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${e} and transposeB=${n} must match.`);let w=Bt(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([m,f]),v=e?M(u,[g,c,m]):M(u,[g,m,c]),k=n?M(l,[y,f,p]):M(l,[y,p,f]),E;o!=null&&(E=C(o,"bias","fused matMul"),[E]=jt(E,u),Bt(w,E.shape));let $;i!=null&&($=C(i,"prelu weights","fused matMul"));let D=(W,U)=>{let[q,K,j,Q]=U,rt=xc(M(W,j.shape),j,s),X,ot;if(!e&&!n?(X=zt(rt,K,!1,!0),ot=zt(q,rt,!0,!1)):!e&&n?(X=zt(rt,K,!1,!1),ot=zt(rt,q,!0,!1)):e&&!n?(X=zt(K,rt,!1,!0),ot=zt(q,rt,!1,!1)):(X=zt(K,rt,!0,!0),ot=zt(rt,q,!0,!0)),o!=null){let st=yc(Q,rt);return[X,ot,st]}else return[X,ot]},R={a:v,b:k,bias:E,preluActivationWeights:$},P={transposeA:e,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?mn((U,q,K)=>{let j=_.runKernel(Oi,R,P);return K([U,q,j]),{value:M(j,w),gradFunc:D}})(v,k):mn((U,q,K,j)=>{let Q=_.runKernel(Oi,R,P);return j([U,q,Q,K]),{value:M(Q,w),gradFunc:D}})(v,k,E)}var bE=N({fusedMatMul_:l6});function u6(r){return qx(r,.54,.46)}var wE=N({hammingWindow_:u6});function c6(r){return qx(r,.5,.5)}var Xx=N({hannWindow_:c6});function p6(r,t,e,n=!1,o=0){let s=0,i=[];for(;s+t<=r.size;)i.push(Rt(r,s,t)),s+=e;if(n)for(;s<r.size;){let a=s+t-r.size,u=se([Rt(r,s,t-a),Qs([a],o)]);i.push(u),s+=e}return i.length===0?Ui([],[0,t]):M(se(i),[i.length,t])}var Yx=N({frame_:p6});function m6(r,t,e,n,o=Xx){n==null&&(n=gE(t));let s=Yx(r,t,e),i=O(s,o(t));return sl(i,n)}var vE=N({stft_:m6});function f6(r,t,e,n,o="bilinear",s=0){let i=C(r,"image","cropAndResize"),a=C(t,"boxes","cropAndResize","float32"),u=C(e,"boxInd","cropAndResize","int32"),l=a.shape[0];A(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),A(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),A(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),A(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),A(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let c={image:i,boxes:a,boxInd:u},p={method:o,extrapolationValue:s,cropSize:n};return _.runKernel(pa,c,p)}var CE=N({cropAndResize_:f6});function d6(r){let t=C(r,"image","flipLeftRight","float32");A(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return _.runKernel(ga,e,{})}var IE=N({flipLeftRight_:d6});function h6(r){let t=C(r,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];A(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),A(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,kr(t,o)}var SE=N({grayscaleToRGB_:h6});function g6(r,t,e=0,n=.5){let o=C(r,"image","rotateWithOffset","float32");A(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:t,fillValue:e,center:n};return _.runKernel(Va,s,i)}var kE=N({rotateWithOffset_:g6});function Io(r,t,e,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return e=Math.min(e,i),A(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),A(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),A(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),A(t.rank===1,()=>"scores must be a 1D tensor"),A(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),A(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function x6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppression","float32"),i=C(t,"scores","nonMaxSuppression","float32"),a=Io(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:e,iouThreshold:n,scoreThreshold:o};return _.runKernel(_a,{boxes:s,scores:i},u)}var NE=N({nonMaxSuppression_:x6});function TE(r,t,e){let n=y6(r,t,e),o=n<0?-(n+1):n;r.splice(o,0,t)}function y6(r,t,e){return w6(r,t,e||b6)}function b6(r,t){return r>t?1:r<t?-1:0}function w6(r,t,e){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=e(t,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function Zx(r,t,e,n,o){return mS(r,t,e,n,o,0)}function Jx(r,t,e,n,o,s){return mS(r,t,e,n,o,0,!1,s,!0)}function Qx(r,t,e,n,o,s){return mS(r,t,e,n,o,s,!0)}function mS(r,t,e,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<t.length;g++)t[g]>o&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(_E);let c=s>0?-.5/s:0,p=[],m=[];for(;p.length<e&&l.length>0;){let g=l.pop(),{score:y,boxIndex:b,suppressBeginIndex:w}=g;if(y<o)break;let v=!1;for(let k=p.length-1;k>=w;--k){let E=v6(r,b,p[k]);if(E>=n){v=!0;break}if(g.score=g.score*C6(n,c,E),g.score<=o)break}g.suppressBeginIndex=p.length,v||(g.score===y?(p.push(b),m.push(g.score)):g.score>o&&TE(l,g,_E))}let f=p.length,d=e-f;a&&d>0&&(p.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:p};return i&&(h.selectedScores=m),u&&(h.validOutputs=f),h}function v6(r,t,e){let n=r.subarray(t*4,t*4+4),o=r.subarray(e*4,e*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),c=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(a-s)*(u-i),d=(p-l)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,l),g=Math.max(i,c),y=Math.min(a,p),b=Math.min(u,m),w=Math.max(y-h,0)*Math.max(b-g,0);return w/(f+d-w)}function C6(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function _E(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}async function I6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppressionAsync"),i=C(t,"scores","nonMaxSuppressionAsync"),a=Io(s,i,e,n,o);e=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:p}=Zx(l,c,e,n,o);return s!==r&&s.dispose(),i!==t&&i.dispose(),Re(p,"int32")}var EE=I6;function S6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(r,"boxes","nonMaxSuppression"),a=C(t,"scores","nonMaxSuppression"),u=Io(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},c={maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},p=_.runKernel(Aa,l,c);return{selectedIndices:p[0],selectedScores:p[1]}}var AE=N({nonMaxSuppressionWithScore_:S6});async function k6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(t,"scores","nonMaxSuppressionAsync"),u=Io(i,a,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),c=l[0],p=l[1],{selectedIndices:m,selectedScores:f}=Qx(c,p,e,n,o,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Re(m,"int32"),selectedScores:Re(f)}}var $E=k6;function N6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(r,"boxes","nonMaxSuppression"),a=C(t,"scores","nonMaxSuppression"),u=Io(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,m={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},d=_.runKernel(Ea,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var DE=N({nonMaxSuppressionPadded_:N6});async function T6(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(t,"scores","nonMaxSuppressionAsync"),u=Io(i,a,e,n,o,null),l=u.maxOutputSize,c=u.iouThreshold,p=u.scoreThreshold,[m,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:d,validOutputs:h}=Jx(m,f,l,c,p,s);return i!==r&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Re(d,"int32"),validOutputs:pt(h,"int32")}}var RE=T6;function _6(r,t,e=!1,n=!1){let o=C(r,"images","resizeBilinear");A(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),A(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=M(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel($s,a,u);return i?M(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var ty=N({resizeBilinear_:_6});function E6(r,t,e=!1,n=!1){let o=C(r,"images","resizeNearestNeighbor");A(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),A(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),A(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=M(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,a={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},l=_.runKernel(Bl,a,u);return i?M(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var ey=N({resizeNearestNeighbor_:E6});function A6(r,t="binary",e=!1,n=.5){let o=C(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=O(Re([n]),255),c,p,m,f;if(A(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),A(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),A(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),A(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[c,p,m]=ur(o,[1,1,1],-1);let g=O(c,s),y=O(p,i),b=O(m,a);f=J(J(g,y),b)}else f=r;if(t==="otsu"){let g=hh(Z(uc(f),"int32"),Ar([]),256);l=$6(g,u)}let d=e?_n(f,l):Ge(f,l);return Z(O(d,255),"int32")}function $6(r,t){let e=Re([-1]),n=Re([0]),o=Re([0]),s,i,a,u,l,c;for(let p=0;p<r.size-1;p++){s=Rt(r,0,p+1),i=Rt(r,p+1),l=ct(mt(s),t),c=ct(mt(i),t);let m=mt(O(s,rl(0,s.size)));a=ct(m,mt(s));let f=Qs(i.shape,s.size),d=J(rl(0,i.size),f),h=O(i,d);u=ct(mt(h),mt(i));let g=lt(a,u),y=lt(a,u),b=O(l,c);o=O(O(b,g),y);let w=Ge(o,n);n=_e(w,o,n),e=_e(w,Re([p]),e)}return e}var FE=N({threshold_:A6});function D6(r,t,e="nearest",n="constant",o=0,s){let i=C(r,"image","transform","float32"),a=C(t,"transforms","transform","float32");A(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),A(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:e,fillMode:n,fillValue:o,outputShape:s};return _.runKernel(Ba,u,l)}var OE=N({transform_:D6});function R6(r,t,e){A(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),A(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let n=C(r,"a","bandPart");A(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=i))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),e<0&&(e=i);let a=M(rl(0,s,1,"int32"),[-1,1]),u=rl(0,i,1,"int32"),l=lt(a,u),c=Nr(_n(l,pt(+t,"int32")),Tn(l,pt(-e,"int32"))),p=ye([s,i],n.dtype);return M(Je(vr(M(n,[-1,s,i])).map(m=>_e(c,m,p))),o)}var ME=N({bandPart_:R6});function F6(r){let t;if(Array.isArray(r)){t=!1,A(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)A(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else t=!0,r=ur(r,r.shape[0],0).map(o=>zr(o,[0]));A(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let o=0;o<r.length;++o)e.push(_.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=O(mt(O(e[i],s)),e[i]);s=lt(s,a)}return ct(s,vm(s,"euclidean"))}));return t?Je(e,0):e}var PE=N({gramSchmidt_:F6});function O6(r,t=!1){if(A(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return LE(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=vr(M(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,c]=LE(u,t);o.push(l),s.push(c)});let i=M(Je(o,0),r.shape),a=M(Je(s,0),r.shape);return[i,a]}}function LE(r,t=!1){return _.tidy(()=>{A(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],o=xm(e),s=kn(r),i=Ui([[1]],[1,1]),a=kn(i),u=e>=n?n:e;for(let l=0;l<u;++l){let c=s,p=a,m=o;[a,s,o]=_.tidy(()=>{let f=Rt(s,[l,l],[e-l,1]),d=vm(f),h=Rt(s,[l,l],[1,1]),g=_e(Ge(h,0),Ui([[-1]]),Ui([[1]])),y=lt(h,O(g,d)),b=ct(f,y);b.shape[0]===1?a=kn(i):a=se([i,Rt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let w=Zt(ct(zt(g,y),d)),v=Rt(s,[l,0],[e-l,n]),k=O(w,a),E=Mt(a);if(l===0)s=lt(v,zt(k,zt(E,v)));else{let R=lt(v,zt(k,zt(E,v)));s=se([Rt(s,[0,0],[l,n]),R],0)}let $=Mt(k),D=Rt(o,[0,l],[e,o.shape[1]-l]);if(l===0)o=lt(D,zt(zt(D,a),$));else{let R=lt(D,zt(zt(D,a),$));o=se([Rt(o,[0,0],[e,l]),R],1)}return[a,s,o]}),_t([c,p,m])}return!t&&e>n&&(o=Rt(o,[0,0],[e,n]),s=Rt(s,[0,0],[n,n])),[o,s]})}var zE=N({qr_:O6});var Qe;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Qe||(Qe={}));function M6(r,t,e=Qe.SUM_BY_NONZERO_WEIGHTS){let n=C(r,"losses","computeWeightedLoss"),o=null;t!=null&&(o=C(t,"weights","computeWeightedLoss"));let s=o==null?n:O(n,o);if(e===Qe.NONE)return s;if(e===Qe.SUM)return mt(s);if(e===Qe.MEAN){if(o==null)return xe(s);{let i=n.size/o.size,a=ct(mt(s),mt(o));return i>1?ct(a,pt(i)):a}}if(e===Qe.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ct(mt(s),pt(n.size));{let i=O(o,lr(n.shape)),a=Z(mt(vo(i,pt(0))),"float32");return ct(mt(s),a)}}throw Error(`Unknown reduction: ${e}`)}var Br=N({computeWeightedLoss_:M6});function P6(r,t,e,n=Qe.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","absoluteDifference"),s=C(t,"predictions","absoluteDifference"),i=null;e!=null&&(i=C(e,"weights","absoluteDifference")),Me(o.shape,s.shape,"Error in absoluteDifference: ");let a=Ne(lt(o,s));return Br(a,i,n)}var BE=N({absoluteDifference_:P6});function L6(r,t,e,n,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","cosineDistance"),i=C(t,"predictions","cosineDistance"),a=null;n!=null&&(a=C(n,"weights","cosineDistance")),Me(s.shape,i.shape,"Error in cosineDistance: ");let u=pt(1),l=lt(u,mt(O(s,i),e,!0));return Br(l,a,o)}var VE=N({cosineDistance_:L6});function z6(r,t,e,n=Qe.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","hingeLoss"),s=C(t,"predictions","hingeLoss"),i=null;e!=null&&(i=C(e,"weights","hingeLoss")),Me(o.shape,s.shape,"Error in hingeLoss: ");let a=pt(1);o=lt(O(pt(2),o),a);let u=Tr(lt(a,O(o,s)));return Br(u,i,n)}var GE=N({hingeLoss_:z6});function B6(r,t,e,n=1,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","huberLoss"),i=C(t,"predictions","huberLoss"),a=null;e!=null&&(a=C(e,"weights","huberLoss")),Me(s.shape,i.shape,"Error in huberLoss: ");let u=pt(n),l=Ne(lt(i,s)),c=ei(l,u),p=lt(l,c),m=J(O(pt(.5),Ut(c)),O(u,p));return Br(m,a,o)}var WE=N({huberLoss_:B6});function V6(r,t,e,n=1e-7,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","logLoss"),i=C(t,"predictions","logLoss"),a=null;e!=null&&(a=C(e,"weights","logLoss")),Me(s.shape,i.shape,"Error in logLoss: ");let u=pt(1),l=pt(n),c=Zt(O(s,wr(J(i,l)))),p=O(lt(u,s),wr(J(lt(u,i),l))),m=lt(c,p);return Br(m,a,o)}var UE=N({logLoss_:V6});function G6(r,t,e,n=Qe.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","meanSquaredError"),s=C(t,"predictions","meanSquaredError"),i=null;e!=null&&(i=C(e,"weights","meanSquaredError")),Me(o.shape,s.shape,"Error in meanSquaredError: ");let a=hc(o,s);return Br(a,i,n)}var HE=N({meanSquaredError_:G6});function W6(r,t){let e=C(r,"labels","sigmoidCrossEntropyWithLogits"),n=C(t,"logits","sigmoidCrossEntropyWithLogits");Me(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Tr(n),s=O(n,e),i=Za(Ze(Zt(Ne(n))));return J(lt(o,s),i)}function U6(r,t,e,n=0,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"multiClassLabels","sigmoidCrossEntropy"),i=C(t,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=C(e,"weights","sigmoidCrossEntropy")),Me(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=pt(n),c=pt(1),p=pt(.5);s=J(O(s,lt(c,l)),O(p,l))}let u=W6(s,i);return Br(u,a,o)}var qE=N({sigmoidCrossEntropy_:U6});function H6(r,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return mn((o,s,i)=>{let u=Nh(s,[e],!0),l=lt(Z(s,"float32"),u);i([o,l]);let c=Zt(O(l,o));return{value:mt(c,[e]),gradFunc:(f,d)=>{let[h,g]=d,y=wo(f.shape,[e]);return[O(M(f,y),lt(Z(h,"float32"),Ze(g))),O(M(f,y),lt(Ze(g),Z(h,"float32")))]}}})(r,t)}function q6(r,t,e,n=0,o=Qe.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"onehotLabels","softmaxCrossEntropy"),i=C(t,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=C(e,"weights","softmaxCrossEntropy")),Me(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let l=pt(n),c=pt(1),p=pt(s.shape[1]);s=J(O(s,lt(c,l)),ct(l,p))}let u=H6(s,i);return Br(u,a,o)}var KE=N({softmaxCrossEntropy_:q6});function K6(r,t,e,n){let o=C(r,"indices","sparseFillEmptyRows","int32"),s=C(t,"values","sparseFillEmptyRows"),i=C(e,"denseShape","sparseFillEmptyRows","int32"),a=C(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=_.runKernel(Vl,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var jE=N({sparseFillEmptyRows_:K6});function j6(r,t,e){let n=C(r,"inputIndices","sparseReshape","int32"),o=C(t,"inputShape","sparseReshape","int32"),s=C(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=_.runKernel(Pa,i);return{outputIndices:a[0],outputShape:a[1]}}var XE=N({sparseReshape_:j6});function X6(r,t,e){let n=C(r,"data","sparseSegmentMean"),o=C(t,"indices","sparseSegmentMean","int32"),s=C(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Gl,i)}var YE=N({sparseSegmentMean_:X6});function Y6(r,t,e){let n=C(r,"data","sparseSegmentSum"),o=C(t,"indices","sparseSegmentSum","int32"),s=C(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return _.runKernel(Wl,i)}var ZE=N({sparseSegmentSum_:Y6});function Z6(r,t,e,n,o,s,i,a){let u=C(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=C(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:e,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:u,dataSplits:l},m=_.runKernel(tm,p,c);return{nGrams:m[0],nGramsSplits:m[1]}}var JE=N({stringNGrams_:Z6});function J6(r,t,e=!0){let n=C(r,"input","stringSplit","string"),o=C(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:n,delimiter:o},a=_.runKernel(em,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var QE=N({stringSplit_:J6});function Q6(r,t){let e=C(r,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return _.runKernel(rm,o,n)}var tA=N({stringToHashBucketFast_:Q6});var aFt={fft:ol,ifft:Wi,rfft:sl,irfft:dc},mFt={hammingWindow:wE,hannWindow:Xx,frame:Yx,stft:vE},dn={flipLeftRight:IE,grayscaleToRGB:SE,resizeNearestNeighbor:ey,resizeBilinear:ty,rotateWithOffset:kE,cropAndResize:CE,nonMaxSuppression:NE,nonMaxSuppressionAsync:EE,nonMaxSuppressionWithScore:AE,nonMaxSuppressionWithScoreAsync:$E,nonMaxSuppressionPadded:DE,nonMaxSuppressionPaddedAsync:RE,threshold:FE,transform:OE},eA={bandPart:ME,gramSchmidt:PE,qr:zE},zFt={absoluteDifference:BE,computeWeightedLoss:Br,cosineDistance:VE,hingeLoss:GE,huberLoss:WE,logLoss:UE,meanSquaredError:HE,sigmoidCrossEntropy:qE,softmaxCrossEntropy:KE},Bh={sparseFillEmptyRows:jE,sparseReshape:XE,sparseSegmentMean:YE,sparseSegmentSum:ZE},ry={stringNGrams:JE,stringSplit:QE,stringToHashBucketFast:tA};var Vr=class extends oh{minimize(t,e=!1,n){let{value:o,grads:s}=this.computeGradients(t,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return _t(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return Mx(t,e)}dispose(){this.iterations_!=null&&_t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:pt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(Vr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var eu=class extends Vr{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:B(()=>St(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:B(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;B(()=>{let c=J(O(u,this.rho),O(Ut(a),1-this.rho)),p=O(ct(be(J(l,this.epsilon)),be(J(u,this.epsilon))),a),m=J(O(l,this.rho),O(Ut(p),1-this.rho));u.assign(c),l.assign(m);let f=J(O(p,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_t(this.accumulatedGrads.map(t=>t.variable)),_t(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};eu.className="Adadelta";Nn(eu);var ru=class extends Vr{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:B(()=>Qs(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[o].tensor:t[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;B(()=>{let u=J(a,Ut(i));a.assign(u);let l=J(O(ct(i,be(J(u,_.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_t(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};ru.className="Adagrad";Nn(ru);var nu=class extends Vr{constructor(t,e,n,o=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=pt(e).variable(),this.accBeta2=pt(n).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);B(()=>{let n=lt(1,this.accBeta1),o=lt(1,this.accBeta2);e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:B(()=>St(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:B(()=>St(a).variable(u))});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,m=J(O(c,this.beta1),O(l,1-this.beta1)),f=J(O(p,this.beta2),O(Ut(l),1-this.beta2)),d=ct(m,n),h=ct(f,o);c.assign(m),p.assign(f);let g=J(O(ct(d,J(be(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(O(this.accBeta1,this.beta1)),this.accBeta2.assign(O(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&_t(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),B(()=>{this.accBeta1.assign(Zr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Zr(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};nu.className="Adam";Nn(nu);var ou=class extends Vr{constructor(t,e,n,o=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=pt(0).variable(),this.accBeta1=pt(e).variable()}),o==null&&(this.epsilon=_.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);B(()=>{let n=lt(1,this.accBeta1),o=ct(-this.learningRate,J(O(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=_.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:St(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:St(a).variable(u)});let l=Array.isArray(t)?t[i].tensor:t[s];if(l==null)return;let c=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,m=J(O(c,this.beta1),O(l,1-this.beta1)),f=O(p,this.beta2),d=Ne(l),h=fn(f,d);c.assign(m),p.assign(h);let g=J(O(ct(o,n),ct(m,J(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(J(this.iteration,1)),this.accBeta1.assign(O(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&_t(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};ou.className="Adamax";Nn(ou);var Hi=class extends Vr{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=Array.isArray(t)?t[o].tensor:t[n];if(s==null)return;let i=_.registeredVariables[n];B(()=>{let a=J(O(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Pe(pt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};Hi.className="SGD";Nn(Hi);var su=class extends Hi{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=pt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${n}/momentum`,variable:B(()=>St(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(t)?t[o].tensor:t[n];a!=null&&B(()=>{let u,l=J(O(this.m,i),a);this.useNesterov?u=J(O(this.c,J(a,O(l,this.m))),s):u=J(O(this.c,l),s),i.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_t(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};su.className="Momentum";Nn(su);var iu=class extends Vr{constructor(t,e=.9,n=0,o=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=_.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,o)=>{let s=_.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:B(()=>St(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:B(()=>St(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:B(()=>St(s).variable(i))});let a=Array.isArray(t)?t[o].tensor:t[n];if(a==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;B(()=>{let c=J(O(u,this.decay),O(Ut(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,m=J(O(p,this.decay),O(a,1-this.decay)),f=ct(O(a,this.learningRate),be(lt(c,J(Ut(m),this.epsilon)))),d=J(O(l,this.momentum),f);u.assign(c),p.assign(m),l.assign(d);let h=lt(s,d);s.assign(h)}else{let p=J(O(u,this.decay),O(Ut(a),1-this.decay)),m=J(O(l,this.momentum),ct(O(a,this.learningRate),be(J(p,this.epsilon))));u.assign(p),l.assign(m);let f=lt(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_t(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_t(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&_t(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};iu.className="RMSProp";Nn(iu);var oi=class{static sgd(t){return new Hi(t)}static momentum(t,e,n=!1){return new su(t,e,n)}static rmsprop(t,e=.9,n=0,o=null,s=!1){return new iu(t,e,n,o,s)}static adam(t=.001,e=.9,n=.999,o=null){return new nu(t,e,n,o)}static adadelta(t=.001,e=.95,n=null){return new eu(t,e,n)}static adamax(t=.002,e=.9,n=.999,o=null,s=0){return new ou(t,e,n,o,s)}static adagrad(t,e=.1){return new ru(t,e)}};var vc={sgd:oi.sgd,momentum:oi.momentum,adadelta:oi.adadelta,adagrad:oi.adagrad,rmsprop:oi.rmsprop,adamax:oi.adamax,adam:oi.adam};var t5=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function Vh(){return new Promise(r=>t5(()=>r()))}var S={};Yt(S,{ERF_A1:()=>p5,ERF_A2:()=>m5,ERF_A3:()=>f5,ERF_A4:()=>d5,ERF_A5:()=>h5,ERF_P:()=>c5,PARALLELIZE_THRESHOLD:()=>ny,SELU_SCALE:()=>dS,SELU_SCALEALPHA:()=>fS,applyActivation:()=>bc,assertAndGetBroadcastShape:()=>Bt,assertAxesAreInnerMostDims:()=>eK,assertParamsConsistent:()=>e5,assignToTypedArray:()=>v5,axesAreInnerMostDims:()=>jI,calculateShapes:()=>A_,checkEinsumDimSizes:()=>T5,checkPadOnDimRoundingMode:()=>Te,combineLocations:()=>X_,complexWithEvenIndex:()=>y5,complexWithOddIndex:()=>b5,computeConv2DInfo:()=>Yu,computeConv3DInfo:()=>q_,computeDefaultPad:()=>$I,computeDilation2DInfo:()=>kH,computeOptimalWindowSize:()=>n5,computeOutAndReduceShapes:()=>XI,computeOutShape:()=>r5,computePool2DInfo:()=>AI,computePool3DInfo:()=>NH,convertConv2DDataFormat:()=>K_,decodeEinsumEquation:()=>k5,eitherStridesOrDilationsAreOne:()=>$r,expandShapeToKeepDim:()=>wo,exponent:()=>I5,exponents:()=>C5,fromStringArrayToUint8:()=>j5,fromUint8ToStringArray:()=>K5,getAxesPermutation:()=>YI,getBroadcastDims:()=>T_,getComplexWithIndex:()=>w5,getEinsumComputePath:()=>_5,getEinsumPermutation:()=>N5,getFusedBiasGradient:()=>yc,getFusedDyActivation:()=>xc,getImageCenter:()=>o5,getInnerMostAxes:()=>rK,getPermuted:()=>i5,getReductionAxes:()=>ge,getReshaped:()=>s5,getReshapedPermuted:()=>a5,getSliceBeginCoords:()=>l5,getSliceSize:()=>u5,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>D5,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>R5,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>F5,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>P5,getSparseReshapeInputOutputMismatchErrorMessage:()=>z5,getSparseReshapeInputOutputMultipleErrorMessage:()=>L5,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>O5,getSparseReshapeNegativeOutputDimErrorMessage:()=>M5,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>W5,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>B5,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>V5,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>G5,getUndoAxesPermutation:()=>kh,isIdentityPermutation:()=>E5,log:()=>VU,mergeRealAndImagArrays:()=>g5,prepareAndValidate:()=>E_,prepareSplitSize:()=>$5,segment_util:()=>gS,shouldFuse:()=>wc,slice_util:()=>Ve,splitRealAndImagArrays:()=>x5,tupleValuesAreOne:()=>Zn,upcastType:()=>ar,validateInput:()=>Dx,validateUpdateShape:()=>CI,warn:()=>Li});function e5(r,t){let e=r[0].length;r.forEach((o,s)=>{A(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),A(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<e;i++)A(i===t||o[i]===n[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function r5(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var ny=30;function n5(r){return r<=ny?r:kp(r,Math.floor(Math.sqrt(r)))}function o5(r,t,e){let n=e*(typeof r=="number"?r:r[0]),o=t*(typeof r=="number"?r:r[1]);return[n,o]}function s5(r,t,e,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(r[0]/e),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=t.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/t[i],t[i]]);o=o.concat(r.slice(s+1))}return o}function i5(r,t,e=!0){let n=[];if(e){n.push(t);for(let o=t+1;o<r;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=t*2+1||i%2===1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function a5(r,t,e,n=!0){let o=[];n?o.push(r[0]/e):o.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?n?o.push(t[s-1]*r[s]):o.push(r[s]/t[s-1]):o.push(r[s]);return o}function l5(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function u5(r,t,e){let n=r.slice(0,1);for(let o=0;o<e;++o)n.push(r[o+1]-t[o][0]-t[o][1]);return n}var fS=1.7580993408473768,dS=1.0507009873554805;var c5=.3275911,p5=.254829592,m5=-.284496736,f5=1.421413741,d5=-1.453152027,h5=1.061405429;function g5(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function x5(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function y5(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function b5(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function w5(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function v5(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function C5(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(t?2:-2)*Math.PI*(o/r);e[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:e,imag:n}}function I5(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var hS="->",S5=/->/g,rA=",",nA="...";function k5(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(S5,"").length)/hS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${hS}").`);let[n,o]=r.split(hS);A(n.indexOf(nA)===-1,()=>`The ellipsis notation ("${nA}") is not supported yet.`);let s=n.split(rA),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let m=0;m<n.length;++m){let f=n[m];a.indexOf(f)===-1&&f!==rA&&a.push(f)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let f=0;f<s[m].length;++f)u[m].push(a.indexOf(s[m][f]))}let l=a.length,c=o.length,p=[];for(let m=c;m<l;++m)p.push(m);return{allDims:a,summedDims:p,idDims:u}}function N5(r,t){let e=new Array(r);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let n=[];for(let o=0;o<r;++o)e[o]===-1&&n.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:n}}function T5(r,t,e){let n=new Array(r);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<t[o].length;++i)n[t[o][i]]===void 0?n[t[o][i]]=s[i]:A(n[t[o][i]]===s[i],()=>`Expected dimension ${n[t[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function _5(r,t){let e=r,n=[],o=0;r.length===0&&e.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],u=A5(t,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:e,steps:n}}function E5(r){return r.every((t,e)=>t===e)}function A5(r,t){let e=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function $5(r,t,e=0){let n=[];if(typeof t=="number")A(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let o=t.reduce((i,a)=>(a===-1&&(i+=1),i),0);A(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((a,u)=>u>0?a+u:a);t[s]=r.shape[e]-i}A(r.shape[e]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function D5(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function R5(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function F5(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function O5(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function M5(r,t){return`size ${r} must be non-negative, not ${t}`}function P5(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function L5(r,t){let e=re(r),n=re(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${t}`}function z5(r,t){let e=re(r),n=re(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${t}`}function B5(){return"segment ids must be >= 0"}function V5(){return"segment ids are not increasing"}function G5(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function W5(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var gS={};Yt(gS,{collectGatherOpShapeInfo:()=>q5,computeOutShape:()=>H5,segOpComputeOptimalWindowSize:()=>U5});function U5(r,t){let e=!1,n;for(r<=ny?(n=r,e=!0):n=kp(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=kp(r,n+1);return n}function H5(r,t,e){let n=[],o=r.length;for(let s=0;s<o;s++)s!==t?n.push(r[s]):n.push(e);return n}function q5(r,t,e,n){let o=t.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let p=0;p<n;++p)if(r.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${r.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=r.shape[e],a=[],u=1,l=1,c=1;for(let p=0;p<n;++p)a.push(r.shape[p]),u*=r.shape[p];for(let p=n;p<e;p++)a.push(r.shape[p]),l*=r.shape[p];for(let p=n;p<o;p++)a.push(t.shape[p]);for(let p=e+1;p<s;p++)a.push(r.shape[p]),c*=r.shape[p];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function K5(r){try{return r.map(t=>lm(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function j5(r){return r.map(t=>Kl(t))}var Gr={};Yt(Gr,{nonMaxSuppressionV3Impl:()=>Zx,nonMaxSuppressionV4Impl:()=>Jx,nonMaxSuppressionV5Impl:()=>Qx,whereImpl:()=>Ux});var oy={kernelName:wi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,ni(Z(e,"float32"),-1))}}};var oA={kernelName:ea,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ut(Z(e,"float32")),o=be(lt(pt(1),n));return Zt(ct(r,o))}}}};var sA={kernelName:ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=be(lt(Ut(Z(e,"float32")),1));return ct(r,n)}}}};var iA={kernelName:Xn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=r,u=ge(e.shape,o);return u.length>0&&(a=mt(a,u)),M(a,e.shape)},b:()=>{let a=r,u=ge(n.shape,o);return u.length>0&&(a=mt(a,u)),M(a,n.shape)}}}};var aA={kernelName:Zo,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,o)=>{e[o]=()=>r.clone()}),e}};var lA={kernelName:Jo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var uA={kernelName:$l,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>St(e)}}};var cA={kernelName:sa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,be(lt(pt(1),Ut(Z(e,"float32")))))}}};var pA={kernelName:ia,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=be(J(pt(1),Ut(Z(e,"float32"))));return ct(r,n)}}}};var mA={kernelName:ua,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=J(Ut(e),Ut(n)),u=O(r,ct(n,a)),l=ge(e.shape,o);return l.length>0&&(u=mt(u,l)),M(u,e.shape)},b:()=>{let a=J(Ut(e),Ut(n)),u=Zt(O(r,ct(e,a))),l=ge(n.shape,o);return l.length>0&&(u=mt(u,l)),M(u,n.shape)}}}};var fA={kernelName:aa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(Ut(Z(e,"float32")),1))}}};var dA={kernelName:la,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,lt(pt(1),Ut(Z(e,"float32"))))}}};function X5(r,t,e,n,o,s){let i=C(r,"dy","avgPool3dGrad"),a=C(t,"input","avgPool3dGrad"),u=i,l=a,c=!1;a.rank===4&&(c=!0,u=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=M(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),A(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),A(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Te("avgPool3dGrad",o,s);let p={dy:u,input:l},m={filterSize:e,strides:n,pad:o,dimRoundingMode:s},f=_.runKernel(_p,p,m);return c?M(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var hA=N({avgPool3dGrad_:X5});var gA={kernelName:Dl,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>hA(r,n,o,s,i,a)}}};function Y5(r,t,e,n,o){let s=C(r,"dy","avgPoolGrad"),i=C(t,"input","avgPoolGrad");A(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,u=s,l=!1;i.rank===3&&(l=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=M(s,[1,s.shape[0],s.shape[1],s.shape[2]])),A(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),A(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let c={dy:u,input:a},p={filterSize:e,strides:n,pad:o},m=_.runKernel(Tp,c,p);return l?M(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var xA=N({avgPoolGrad_:Y5});var yA={kernelName:Qo,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:i}=e;return{x:()=>xA(r,n,o,s,i)}}};var bA={kernelName:ts,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,o]=t,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>zt(r,o,!1,!0),b:()=>zt(n,r,!0,!1)}:!s&&i?{a:()=>zt(r,o,!1,!1),b:()=>zt(r,n,!0,!1)}:s&&!i?{a:()=>zt(o,r,!1,!0),b:()=>zt(n,r,!1,!1)}:{a:()=>zt(o,r,!0,!0),b:()=>zt(r,n,!0,!0)}}};var wA={kernelName:vi,gradFunc:(r,t,e)=>{let{blockShape:n,crops:o}=e;return{x:()=>tl(r,n,o)}}};var vA={kernelName:v1,gradFunc:(r,t,e)=>{let n=e,o=n.inputShape,s=n.shape,i=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])i[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>mt(r,a,!0)}}};var CA={kernelName:io,gradFunc:r=>({x:()=>r.clone()})};var IA={kernelName:es,gradFunc:r=>({x:()=>St(r)})};var SA={kernelName:ao,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>_e(Nr(Tn(n,o),_n(n,s)),r,St(r))}}};var kA={kernelName:Rl,inputsToSave:["x"],gradFunc:oy.gradFunc};var NA={kernelName:Ci,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:o}=e,s=mr(o,t[0].shape)[0],i=n.map(u=>u[s]);return ur(r,i,s).map(u=>()=>u)}};var TA={kernelName:rs,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{dilations:s,strides:i,pad:a,dataFormat:u}=e;return A(Zn(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>gm(n.shape,r,o,i,a,u),filter:()=>Cm(n,r,o.shape,i,a,u)}}};var _A={kernelName:ns,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=e;return{dy:()=>pn(r,o,s,i,a,1,u),filter:()=>Cm(r,n,o.shape,s,i,a,u)}}};function Z5(r,t,e,n,o){let s=r;r.rank===4&&(s=M(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=t;i.rank===4&&(i=M(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),A(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),A(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),A(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),A(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),A(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},u={strides:n,pad:o,filterShape:e};return _.runKernel(Rp,a,u)}var EA=N({conv3DBackpropFilter_:Z5});var AA={kernelName:Fl,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s}=e;A(Zn(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=t;return{x:()=>Ox(i.shape,r,a,o,s),filter:()=>EA(i,r,a.shape,o,s)}}};var $A={kernelName:os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(Zt(mc(Z(e,"float32"))),r)}}};var DA={kernelName:ss,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(fc(Z(e,"float32")),r)}}};var RA={kernelName:is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=YI([o],n.rank),u=tc(r,o,s,!i);return a!=null&&(u=Mt(u,a)),u}}}};var FA={kernelName:as,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=e,a=n==null?[1,1]:n;A(Zn(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[u,l]=t;return A(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),A(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),A(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),A($r(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),Te("depthwiseConv2d",s,i),{x:()=>jx(u.shape,r,l,o,s,a,i),filter:()=>Kx(u,r,l.shape,o,s,a,i)}}};var OA={kernelName:Ol,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,s={x:n,filter:o,dy:r},i={x:n,filter:o,dy:r};return{x:()=>_.runKernel(Ud,s,e),filter:()=>_.runKernel(Hd,i,e)}}};var MA={kernelName:us,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>_.runKernel(Bp,n)}}};var PA={kernelName:fa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=O(Ze(Zt(Ut(e))),2/Math.sqrt(Math.PI));return{x:()=>O(r,n)}}};var LA={kernelName:cs,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,e)}}};var zA={kernelName:Ii,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>M(r,e.shape)}}};var BA={kernelName:ha,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,Ze(e))}}};var VA={kernelName:ps,gradFunc:r=>({x:()=>St(r)})};var GA={kernelName:ms,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=ct(r,Z(n,"float32")),u=ge(e.shape,o);return u.length>0?M(mt(a,u),e.shape):a},b:()=>{let a=O(r,Z(e,"float32")),u=ge(n.shape,o);u.length>0&&(a=M(mt(a,u),n.shape));let l=Ut(n);return Zt(ct(a,Z(l,"float32")))}}}};var WA={kernelName:fs,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[o,s,i,a]=t,u=a==null?pt(1):a,l=ge(s.shape,o.shape),c=[];if(s.rank===1){for(let v=0;v<o.shape.length-1;++v)c.push(o.shape[v]);c.push(1)}let p=lt(o,s),m=O(r,u),f=cc(J(i,pt(n))),d=O(O(O(f,f),f),pt(-.5));return{x:()=>s.rank===1?M(O(O(r,kr(M(f,[1,1,1,s.shape[0]]),c)),u),o.shape):M(O(O(r,f),u),o.shape),mean:()=>{let v=O(O(f,pt(-1)),m);return s.rank===1&&(v=mt(v,l)),M(v,s.shape)},variance:()=>{let v=O(O(d,p),m);return s.rank===1&&(v=mt(v,l)),M(v,s.shape)},scale:()=>{let v=O(p,f),k=O(r,v);return s.rank===1&&(k=mt(k,l)),M(k,s.shape)},offset:()=>{let v=r;return s.rank===1&&(v=mt(v,l)),M(v,s.shape)}}}};var qA={kernelName:Si,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,o]=t,{axis:s}=e,i=mr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,c=u.slice(0,i),p=c.length,m=u.slice(s,u.length).slice(1),f=m.length,d=UA(0,p),h=UA(p+1,p+1+f),g=HA([c,[l],m]),y=M(r,g),b=M(o,[l]),w=HA([[p],d,h]),v=Mt(y,w),k=Lh(v,b,n.shape[i]),E=kh(w);return k=Mt(k,E),k},indices:()=>o}}};function UA(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function HA(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var KA={kernelName:ds,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>St(e),b:()=>St(n)}}};var jA={kernelName:lo,gradFunc:r=>({x:()=>Z(r,"float32")})};var XA={kernelName:ba,gradFunc:r=>({x:()=>St(r)})};var YA={kernelName:wa,gradFunc:r=>({x:()=>St(r)})};var ZA={kernelName:va,gradFunc:r=>({x:()=>St(r)})};var JA={kernelName:hs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:o}=e,s=Ge(n,0);return{x:()=>_e(s,r,O(r,o))}}};var QA={kernelName:Sa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,J(e,1))}}};var t2={kernelName:gs,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Z(e,"float32"))}}};var e2={kernelName:C1,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e;return{logits:()=>{let i=Ze(n);return lt(r,O(mt(r,o,!0),i))}}}};function J5(r,t,e,n=5,o=1,s=1,i=.5){let a={x:r,y:t,dy:e},u={depthRadius:n,bias:o,alpha:s,beta:i};return _.runKernel(Hp,a,u)}var r2=N({localResponseNormalizationBackprop_:J5});var n2={kernelName:Pl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{depthRadius:s,bias:i,alpha:a,beta:u}=e;return{x:()=>r2(n,o,r,s,i,a,u)}}};function sy(r,t,e,n){return t.rank<e.rank&&(t=M(t,wo(t.shape,n))),r.rank<e.rank&&(r=M(r,wo(r.shape,n))),{x:()=>O(r,Z(Sr(e,t),r.dtype))}}var xS={kernelName:xs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:o}=n,s=t[0],i=t[1],a=mr(o,s.shape),u=sy(r,i,s,a);return{x:()=>u.x()}}};var o2={kernelName:ys,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>O(r,Z(Tn(e,n),"float32")),b:()=>O(r,Z(rc(e,n),"float32"))}}};function Q5(r,t,e,n,o,s,i){let a=C(r,"dy","maxPool3dGrad"),u=C(t,"input","maxPool3dGrad"),l=C(e,"output","maxPool3dGrad"),c=a,p=u,m=l,f=!1;u.rank===4&&(f=!0,c=M(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=M(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=M(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),A(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),A(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),A(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Te("maxPool3dGrad",s,i);let d={dy:c,input:p,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:i},g=_.runKernel(Kp,d,h);return f?M(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var s2=N({maxPool3dGrad_:Q5});var i2={kernelName:Ll,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=e;return{x:()=>s2(r,n,o,s,i,a,u)}}};function tX(r,t,e,n,o,s,i){let a=C(r,"dy","maxPoolGrad"),u=C(t,"input","maxPoolGrad"),l=C(e,"output","maxPoolGrad");A(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),A(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),A(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Te("maxPoolGrad",s,i);let c={dy:a,input:u,output:l},p={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return _.runKernel(qp,c,p)}var a2=N({maxPoolGrad_:tX});var l2={kernelName:bs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:i,pad:a}=e;return{x:()=>a2(r,n,o,s,i,a)}}};var u2={kernelName:ws,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=mr(o,n.shape),a=XI(n.shape,s)[1],u=re(a);return{x:()=>{let c=n.shape.slice();s.forEach(f=>{c[f]=1});let p=M(r,c);return ct(O(p,lr(n.shape,"float32")),u)}}}};var c2={kernelName:vs,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:o}=n,[s,i]=t,a=mr(o,s.shape),u=sy(r,i,s,a);return{x:()=>u.x()}}};var p2={kernelName:Cs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>O(r,Z(_n(e,n),"float32")),b:()=>O(r,Z(Ge(e,n),"float32"))}}};var m2={kernelName:Is,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Rt(r,s,n.shape)}}};var f2={kernelName:Na,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=ge(e.shape,o);return a.length>0?M(mt(r,a),e.shape):r},b:()=>{let a=O(r,Zt(ti(ct(e,n)))),u=ge(n.shape,o);return u.length>0?M(mt(a,u),n.shape):a}}}};var d2={kernelName:Ss,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=O(r,Z(n,"float32")),u=ge(e.shape,o);return u.length>0?M(mt(a,u),e.shape):a},b:()=>{let a=O(r,Z(e,"float32")),u=ge(n.shape,o);return u.length>0?M(mt(a,u),n.shape):a}}}};var h2={kernelName:ki,gradFunc:r=>({x:()=>Zt(r)})};var g2={kernelName:ks,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>ye(e.shape,"float32")}}};var x2={kernelName:Ni,gradFunc:r=>({x:()=>St(r)})};var y2={kernelName:Ti,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return vr(r,n).map(s=>()=>s)}};var yS={kernelName:Ns,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Rt(r,s,n.shape)}}};var b2={kernelName:Ts,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,o]=t,s=e,i=n,a=Bt(s.shape,i.shape);return{a:()=>{let c=Z(i,"float32"),p=O(r,O(c,Zr(s,lt(c,pt(1))))),m=ge(s.shape,a);return m.length>0&&(p=mt(p,m)),M(p,s.shape)},b:()=>{let c=Ge(s,0),p=_e(c,wr(s),St(s)),m=O(r,O(o,p)),f=ge(i.shape,a);return f.length>0&&(m=mt(m,f)),M(m,i.shape)}}}};var w2={kernelName:_s,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,o=Ge(e,0);return{x:()=>_e(o,r,O(r,n)),alpha:()=>{let s=_e(o,St(r),O(r,e)),i=ge(n.shape,r.shape);return i.length>0&&(s=mt(s,i)),M(s,n.shape)}}}};function eX(r,t,e){let n=r.shape.slice();n[e]=1;let o=M(t,n),s=Jl(r,e,!0,!1),i=Jl(r,e,!0,!0),a=O(s,i);return O(o,a)}function rX(r,t,e){let n=r.shape.length,o=n-e.length,s=S.getAxesPermutation(e,n),i=r;s!=null&&(i=Mt(r,s));let a=i.shape.slice(),l=a.splice(n-e.length,e.length).reduce((m,f)=>m*f,1);a.push(l);let c=i.reshape(a),p=eX(c,t,o);if(p=p.reshape(i.shape),s!=null){let m=S.getUndoAxesPermutation(s);p=Mt(p,m)}return p}var v2={kernelName:Es,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=[];return o==null?s=n.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>rX(n,r,s)}}};var C2={kernelName:ls,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=ct(r,Z(n,"float32")),u=ge(e.shape,o);return u.length>0?M(mt(a,u),e.shape):a},b:()=>{let a=O(r,Z(e,"float32")),u=ge(n.shape,o);u.length>0&&(a=M(mt(a,u),n.shape));let l=Ut(n);return Zt(ct(a,Z(l,"float32")))}}}};var I2={kernelName:$a,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Zt(Ut(e)))}}};var S2={kernelName:Ds,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=O(_n(e,6),ni(e));return{x:()=>O(r,Z(n,"float32"))}}};var k2={kernelName:As,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,Z(ni(e),"float32"))}}};var N2={kernelName:_i,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>M(r,e.shape)}}};var T2={kernelName:$s,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(Jp,o,e)}}};var _2={kernelName:Bl,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>_.runKernel(Zp,o,e)}}};var E2={kernelName:Rs,gradFunc:(r,t,e)=>{let{dims:n}=e,o=mr(n,r.shape);return{x:()=>ir(r,o)}}};var A2={kernelName:Fs,gradFunc:r=>({x:()=>St(r)})};var $2={kernelName:Os,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Zt(ct(r,O(Zr(e,1.5),2)))}}};var D2={kernelName:Ei,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>Z(St(e),"float32"),t:()=>O(r,Z(e,r.dtype)),e:()=>O(r,Z(Ja(e),r.dtype))}}};var R2={kernelName:Ra,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ge(e,pt(0)),o=pt(fS),s=pt(dS),i=O(r,s),a=O(O(r,o),Ze(Z(e,"float32")));return _e(n,i,a)}}}};var F2={kernelName:Ps,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,O(e,lt(pt(1),e)))}}};var O2={kernelName:Oa,gradFunc:r=>({x:()=>St(r)})};var M2={kernelName:Ms,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(Xa(Z(e,"float32")),r)}}};var P2={kernelName:Fa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(Qu(Z(e,"float32")),r)}}};var L2={kernelName:Ai,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:o,size:s}=e,i=n.shape,[a,u]=SI(n,o,s),l=[];for(let c=0;c<r.rank;c++)l.push([a[c],i[c]-a[c]-u[c]]);return{x:()=>Yr(r,l)}}};var z2={kernelName:Bs,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:o}=e,s=!0,i=O(r,n);return{logits:()=>lt(i,O(mt(i,[o],s),n))}}};var B2={kernelName:Ma,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,Lr(e))}}};var bS={kernelName:$i,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:o}=e;return{x:()=>Ka(r,n,o)}}};var wS={kernelName:Di,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>se(r,n)}}};var V2={kernelName:Ls,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,O(be(Z(e,"float32")),2))}}};var G2={kernelName:Ul,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(r,O(Z(e,"float32"),2))}}};var W2={kernelName:Vs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=pt(2);return{a:()=>O(r,O(o,lt(e,n))),b:()=>O(r,O(o,lt(n,e)))}}};var U2={kernelName:uo,gradFunc:r=>({x:()=>St(r)})};var H2={kernelName:Gs,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=Bt(e.shape,n.shape);return{a:()=>{let a=r,u=ge(e.shape,o);return u.length>0&&(a=mt(a,u)),M(a,e.shape)},b:()=>{let a=r,u=ge(n.shape,o);return u.length>0&&(a=mt(a,u)),M(Zt(a),n.shape)}}}};var q2={kernelName:zs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,o=n.shape.slice(),{axis:s}=e;mr(s,n.shape).forEach(l=>{o[l]=1});let a=M(r,o),u=O(a,lr(n.shape,"float32"));return{x:()=>u}}};var K2={kernelName:Ws,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ct(r,Ut(Xa(e)))}}};var j2={kernelName:Us,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>O(lt(pt(1),Ut(e)),r)}}};var X2={kernelName:Yn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:o}=e;return{x:()=>{let i=St(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=J(i,Rt(r,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)i=J(i,Rt(r,[a*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)i=J(i,Rt(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let c=0;c<o[3];++c)i=J(i,Rt(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2],c*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var Y2={kernelName:Hs,gradFunc:(r,t,e)=>{let n=e,{perm:o}=n,s=kh(o);return{x:()=>Mt(r,s)}}};var Z2={kernelName:Ri,gradFunc:(r,t,e)=>{let n=e,{axis:o}=n;return{value:()=>Je(r,o)}}};var J2={kernelName:Hl,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>nX(r,e)}}};function nX(r,t){let e=fn(t,St(t)),n=yo(r,e),o=Tn(t,pt(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=fr(o,a+1);o=Nr(o,lr(n.shape,"bool"));let i=St(n);return _e(o,n,i)}var Q2={kernelName:Fi,gradFunc:r=>({x:()=>St(r)})};var oX=[oy,oA,sA,iA,aA,lA,uA,cA,pA,mA,fA,dA,gA,yA,bA,wA,vA,CA,IA,SA,kA,NA,_A,TA,AA,$A,DA,RA,FA,OA,C2,MA,PA,LA,zA,BA,GA,VA,WA,qA,KA,jA,XA,YA,ZA,JA,QA,t2,e2,n2,xS,xS,o2,i2,l2,u2,c2,p2,m2,f2,d2,h2,g2,x2,y2,yS,yS,b2,w2,v2,I2,S2,k2,N2,T2,_2,E2,A2,$2,D2,R2,F2,O2,M2,P2,L2,z2,B2,bS,bS,wS,wS,V2,W2,G2,U2,H2,q2,K2,j2,X2,Y2,Z2,J2,Q2];for(let r of oX)S1(r);L().prototype.abs=function(){return this.throwIfDisposed(),Ne(this)};L().prototype.acos=function(){return this.throwIfDisposed(),ih(this)};L().prototype.acosh=function(){return this.throwIfDisposed(),ah(this)};L().prototype.add=function(r){return this.throwIfDisposed(),J(this,r)};L().prototype.all=function(r,t){return this.throwIfDisposed(),ju(this,r,t)};L().prototype.any=function(r,t){return this.throwIfDisposed(),Zl(this,r,t)};L().prototype.argMax=function(r){return this.throwIfDisposed(),Xs(this,r)};L().prototype.argMin=function(r){return this.throwIfDisposed(),lh(this,r)};L().prototype.asScalar=function(){return this.throwIfDisposed(),A(this.size===1,()=>"The array must have only 1 element."),M(this,[])};L().prototype.asType=function(r){return this.throwIfDisposed(),Z(this,r)};L().prototype.as1D=function(){return this.throwIfDisposed(),M(this,[this.size])};L().prototype.as2D=function(r,t){return this.throwIfDisposed(),M(this,[r,t])};L().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),M(this,[r,t,e])};L().prototype.as4D=function(r,t,e,n){return this.throwIfDisposed(),M(this,[r,t,e,n])};L().prototype.as5D=function(r,t,e,n,o){return this.throwIfDisposed(),M(this,[r,t,e,n,o])};L().prototype.asin=function(){return this.throwIfDisposed(),uh(this)};L().prototype.asinh=function(){return this.throwIfDisposed(),ch(this)};L().prototype.atan=function(){return this.throwIfDisposed(),ph(this)};L().prototype.atan2=function(r){return this.throwIfDisposed(),mh(this,r)};L().prototype.atanh=function(){return this.throwIfDisposed(),fh(this)};L().prototype.avgPool=function(r,t,e,n){return this.throwIfDisposed(),qa(this,r,t,e,n)};L().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),Ka(this,r,t)};L().prototype.batchNorm=function(r,t,e,n,o){return this.throwIfDisposed(),xo(this,r,t,e,n,o)};L().prototype.broadcastTo=function(r){return this.throwIfDisposed(),ja(this,r)};L().prototype.cast=function(r){return this.throwIfDisposed(),Z(this,r)};L().prototype.ceil=function(){return this.throwIfDisposed(),gh(this)};L().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),br(this,r,t)};L().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof Lt&&(r=[r]),se([this,...r],t)};L().prototype.conv1d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Zu(this,r,t,e,n,o,s)};L().prototype.conv2dTranspose=function(r,t,e,n,o){return this.throwIfDisposed(),Ju(this,r,t,e,n,o)};L().prototype.conv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),pn(this,r,t,e,n,o,s)};L().prototype.cos=function(){return this.throwIfDisposed(),Xa(this)};L().prototype.cosh=function(){return this.throwIfDisposed(),Qu(this)};L().prototype.cumprod=function(r,t,e){return this.throwIfDisposed(),Jl(this,r,t,e)};L().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),tc(this,r,t,e)};L().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),yh(this,r,t)};L().prototype.depthwiseConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),Zs(this,r,t,e,n,o,s)};L().prototype.dilation2d=function(r,t,e,n,o){return this.throwIfDisposed(),bh(this,r,t,e,n,o)};L().prototype.divNoNan=function(r){return this.throwIfDisposed(),wh(this,r)};L().prototype.div=function(r){return this.throwIfDisposed(),ct(this,r)};L().prototype.dot=function(r){return this.throwIfDisposed(),GI(this,r)};L().prototype.elu=function(){return this.throwIfDisposed(),Js(this)};L().prototype.equal=function(r){return this.throwIfDisposed(),Sr(this,r)};L().prototype.erf=function(){return this.throwIfDisposed(),vh(this)};L().prototype.exp=function(){return this.throwIfDisposed(),Ze(this)};L().prototype.expandDims=function(r){return this.throwIfDisposed(),fr(this,r)};L().prototype.expm1=function(){return this.throwIfDisposed(),Ch(this)};L().prototype.fft=function(){return this.throwIfDisposed(),ol(this)};L().prototype.flatten=function(){return this.throwIfDisposed(),M(this,[this.size])};L().prototype.floor=function(){return this.throwIfDisposed(),ti(this)};L().prototype.floorDiv=function(r){return this.throwIfDisposed(),Ku(this,r)};L().prototype.gather=function(r,t){return this.throwIfDisposed(),yo(this,r,t)};L().prototype.greaterEqual=function(r){return this.throwIfDisposed(),Tn(this,r)};L().prototype.greater=function(r){return this.throwIfDisposed(),Ge(this,r)};L().prototype.ifft=function(){return this.throwIfDisposed(),Wi(this)};L().prototype.irfft=function(){return this.throwIfDisposed(),dc(this)};L().prototype.isFinite=function(){return this.throwIfDisposed(),UI(this)};L().prototype.isInf=function(){return this.throwIfDisposed(),HI(this)};L().prototype.isNaN=function(){return this.throwIfDisposed(),Ih(this)};L().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Ya(this,r)};L().prototype.lessEqual=function(r){return this.throwIfDisposed(),_n(this,r)};L().prototype.less=function(r){return this.throwIfDisposed(),rc(this,r)};L().prototype.localResponseNormalization=function(r,t,e,n){return this.throwIfDisposed(),Sh(this,r,t,e,n)};L().prototype.logSigmoid=function(){return this.throwIfDisposed(),KI(this)};L().prototype.logSoftmax=function(r){return this.throwIfDisposed(),nc(this,r)};L().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),Nh(this,r,t)};L().prototype.log=function(){return this.throwIfDisposed(),wr(this)};L().prototype.log1p=function(){return this.throwIfDisposed(),Za(this)};L().prototype.logicalAnd=function(r){return this.throwIfDisposed(),Nr(this,r)};L().prototype.logicalNot=function(){return this.throwIfDisposed(),Ja(this)};L().prototype.logicalOr=function(r){return this.throwIfDisposed(),oc(this,r)};L().prototype.logicalXor=function(r){return this.throwIfDisposed(),JI(this,r)};L().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),zt(this,r,t,e)};L().prototype.maxPool=function(r,t,e,n){return this.throwIfDisposed(),Qa(this,r,t,e,n)};L().prototype.max=function(r,t){return this.throwIfDisposed(),Dr(this,r,t)};L().prototype.maximum=function(r){return this.throwIfDisposed(),fn(this,r)};L().prototype.mean=function(r,t){return this.throwIfDisposed(),xe(this,r,t)};L().prototype.min=function(r,t){return this.throwIfDisposed(),Ql(this,r,t)};L().prototype.minimum=function(r){return this.throwIfDisposed(),ei(this,r)};L().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),_h(this,r,t)};L().prototype.mod=function(r){return this.throwIfDisposed(),Eh(this,r)};L().prototype.mul=function(r){return this.throwIfDisposed(),O(this,r)};L().prototype.neg=function(){return this.throwIfDisposed(),Zt(this)};L().prototype.norm=function(r,t,e){return this.throwIfDisposed(),vm(this,r,t,e)};L().prototype.notEqual=function(r){return this.throwIfDisposed(),vo(this,r)};L().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),js(this,r,t,e)};L().prototype.onesLike=function(){return this.throwIfDisposed(),dr(this)};L().prototype.pad=function(r,t){return this.throwIfDisposed(),Yr(this,r,t)};L().prototype.pool=function(r,t,e,n,o,s){return this.throwIfDisposed(),eS(this,r,t,e,n,o,s)};L().prototype.pow=function(r){return this.throwIfDisposed(),Zr(this,r)};L().prototype.prelu=function(r){return this.throwIfDisposed(),el(this,r)};L().prototype.prod=function(r,t){return this.throwIfDisposed(),sc(this,r,t)};L().prototype.reciprocal=function(){return this.throwIfDisposed(),Ah(this)};L().prototype.relu=function(){return this.throwIfDisposed(),Tr(this)};L().prototype.relu6=function(){return this.throwIfDisposed(),lc(this)};L().prototype.reshapeAs=function(r){return this.throwIfDisposed(),M(this,r.shape)};L().prototype.reshape=function(r){return this.throwIfDisposed(),M(this,r)};L().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),ty(this,r,t,e)};L().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),ey(this,r,t,e)};L().prototype.reverse=function(r){return this.throwIfDisposed(),ir(this,r)};L().prototype.rfft=function(){return this.throwIfDisposed(),sl(this)};L().prototype.round=function(){return this.throwIfDisposed(),uc(this)};L().prototype.rsqrt=function(){return this.throwIfDisposed(),cc(this)};L().prototype.selu=function(){return this.throwIfDisposed(),pc(this)};L().prototype.separableConv2d=function(r,t,e,n,o,s){return this.throwIfDisposed(),$h(this,r,t,e,n,o,s)};L().prototype.sigmoid=function(){return this.throwIfDisposed(),Lr(this)};L().prototype.sign=function(){return this.throwIfDisposed(),Dh(this)};L().prototype.sin=function(){return this.throwIfDisposed(),mc(this)};L().prototype.sinh=function(){return this.throwIfDisposed(),fc(this)};L().prototype.slice=function(r,t){return this.throwIfDisposed(),Rt(this,r,t)};L().prototype.softmax=function(r){return this.throwIfDisposed(),nl(this,r)};L().prototype.softplus=function(){return this.throwIfDisposed(),bo(this)};L().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),tl(this,r,t)};L().prototype.split=function(r,t){return this.throwIfDisposed(),ur(this,r,t)};L().prototype.sqrt=function(){return this.throwIfDisposed(),be(this)};L().prototype.square=function(){return this.throwIfDisposed(),Ut(this)};L().prototype.squaredDifference=function(r){return this.throwIfDisposed(),hc(this,r)};L().prototype.squeeze=function(r){return this.throwIfDisposed(),zr(this,r)};L().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof Lt?[this,r]:[this,...r];return Je(e,t)};L().prototype.step=function(r){return this.throwIfDisposed(),ni(this,r)};L().prototype.stridedSlice=function(r,t,e,n,o,s,i,a){return this.throwIfDisposed(),Oh(this,r,t,e,n,o,s,i,a)};L().prototype.sub=function(r){return this.throwIfDisposed(),lt(this,r)};L().prototype.sum=function(r,t){return this.throwIfDisposed(),mt(this,r,t)};L().prototype.tan=function(){return this.throwIfDisposed(),Mh(this)};L().prototype.tanh=function(){return this.throwIfDisposed(),Ys(this)};L().prototype.tile=function(r){return this.throwIfDisposed(),kr(this,r)};L().prototype.toBool=function(){return this.throwIfDisposed(),Z(this,"bool")};L().prototype.toFloat=function(){return this.throwIfDisposed(),Z(this,"float32")};L().prototype.toInt=function(){return this.throwIfDisposed(),Z(this,"int32")};L().prototype.topk=function(r,t){return this.throwIfDisposed(),Ph(this,r,t)};L().prototype.transpose=function(r){return this.throwIfDisposed(),Mt(this,r)};L().prototype.unique=function(r){return this.throwIfDisposed(),wm(this,r)};L().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),Lh(this,r,t)};L().prototype.unstack=function(r){return this.throwIfDisposed(),vr(this,r)};L().prototype.where=function(r,t){return this.throwIfDisposed(),_e(r,this,t)};L().prototype.zerosLike=function(){return this.throwIfDisposed(),St(this)};var En=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,En.prototype)}},Wr=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Wr.prototype)}},z=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,z.prototype)}},Nt=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nt.prototype)}},Im=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Im.prototype)}};var Gh=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function ko(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function Qn(r,t){if(!r)throw new Im(t)}function CS(r,t){let e=0;for(let n of r)n===t&&e++;return e}function _r(r){return r.length===1?r[0]:r}function we(r){return Array.isArray(r)?r:[r]}function No(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function il(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var So={};function Sm(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function vS(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>vS(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:vS(n))}}}function qi(r,t={},e={},n="object",o=!1){if(typeof r=="string"){let s=r,i;if(s in e)i=e[s];else if(s in So)i=So[s];else if(i=t[s],i==null)throw new z(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new z(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,u;if(i in e?[a,u]=e[i]:i in So?[a,u]=So.className:i in t&&([a,u]=t[i]),a==null)throw new z(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let f of Object.keys(So))l[f]=So[f];for(let f of Object.keys(e))l[f]=e[f];let c=s.config;c.customObjects=l;let p=Object.assign({},So);for(let f of Object.keys(e))So[f]=e[f];vS(s.config);let m=u(a,s.config,e,o);return So=Object.assign({},p),m}else{let l=Object.assign({},So);for(let p of Object.keys(e))So[p]=e[p];let c=new a(s.config);return So=Object.assign({},l),c}}}function sX(r,t){return r<t?-1:r>t?1:0}function Wh(r,t){return-1*sX(r,t)}function To(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function t$(r){if(r==null)throw new z(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function Ki(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new z(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function iy(r,t,e=0,n=1/0){return Qn(e>=0),Qn(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(o=>typeof o===t)}function er(r,t){Array.isArray(r)?(x.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>er(e,`element ${n+1} of ${t}`))):x.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${e$(r)}.`)}function e$(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>e$(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function r$(r,t,e){let n=e!=null?e():x.now(),o;return(...i)=>{let a=e!=null?e():x.now();return a-n<t||(n=a,o=r(...i)),o}}function ay(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var iX=0;function uy(){return iX++}var ly={};function au(r=""){return r in ly||(ly[r]=0),ly[r]+=1,r+ly[r].toString()}var n$=["channelsFirst","channelsLast"],o$=["nearest","bilinear"],s$=["valid","same","causal"],i$=["max","avg"],a$=["sum","mul","concat","ave"];var km=new Map;function Le(r){Ki(n$,"DataFormat",r)}function u$(r){Ki(o$,"InterpolationFormat",r)}function hn(r){Ki(s$,"PaddingMode",r)}function IS(r){Ki(i$,"PoolMode",r)}var Uh=[],l$="/";function ii(r,t){Uh.push(r);try{let e=t();return Uh.pop(),e}catch(e){throw Uh.pop(),e}}function aX(){return Uh.length===0?"":Uh.join(l$)+l$}function cy(r){if(!c$(r))throw new Error("Not a valid tensor name: '"+r+"'");return aX()+r}function py(r){if(!c$(r))throw new Error("Not a valid tensor name: '"+r+"'");km.has(r)||km.set(r,0);let t=km.get(r);if(km.set(r,km.get(r)+1),t>0){let e=`${r}_${t}`;return km.set(e,1),e}else return r}var lX=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function c$(r){return!!r.match(lX)}function p$(r){return r===parseInt(r.toString(),10)}function _o(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let o=t;o<e;++o)n*=r[o];return n}function Cc(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n<t&&(t=n)}return t}function ai(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n>t&&(t=n)}return t}function Jr(r,t){if(t<r)throw new z(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}var SS;function cr(){return SS==null&&(SS=H_().epsilon()),SS}function gn(){return"channelsLast"}function Ic(r,t){return Z(r,t)}function ll(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),M(r,e)}function m$(r,t){return B(()=>{if(r.shape.length!==2)throw new z(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=ll(r,1);return fy(e,[1,t,1])})}function f$(r){let t=[_o(r.shape)];return M(r,t)}function d$(r){if(r.rank<=1)throw new z(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],_o(r.shape,1)];return M(r,t)}function al(r,t,e){return B(()=>{switch(r.rank){case 1:return Rh(r,t,e);case 2:return Wx(r,[t,0],[e,r.shape[1]]);case 3:return Fh(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return bm(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Rt(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Rt(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function kS(r,t,e){return B(()=>{switch(r.rank){case 1:return Rh(r,t,e);case 2:return Wx(r,[0,t],[r.shape[0],e]);case 3:return Fh(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return bm(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Hh(r,t,e,n){return B(()=>{switch(r.rank){case 1:return Rh(r,t,e);case 2:switch(n){case 1:return al(r,t,e);case 2:return kS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return al(r,t,e);case 2:return Fh(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return kS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return al(r,t,e);case 2:return bm(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return bm(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return kS(r,t,e);default:throw new z(`The axis is not within the rank of the tensor ${n}`)}default:throw new z(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Nm(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),se(r,t)}function TS(r,t){switch(r.rank){case 1:return MI([r,t]);case 2:return PI([r,t],0);case 3:return LI([r,t],0);case 4:return zI([r,t],0);default:throw new z(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function fy(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new z(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return kr(r,t)}function Tm(r,t=0,e=1,n,o){return Gx(r,t,e,n,o)}function Eo(r,t,e,n){if(r.rank<2||t.rank<2)throw new Nt(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new Nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return Co.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?NS(r.rank,n,gn()):null,activation:e});{let o=r.shape.slice(),s=o.pop();r=M(r,[-1,s]);let i=t.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],c=Array.from({length:t.rank},(d,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=M(Mt(t,c),[u,-1]);let p=[...o,...l],m=!1,f=!1;return M(Co.matMul({a:r,b:t,transposeA:m,transposeB:f,bias:n?NS(r.rank,n,gn()):null,activation:e}),p)}}function dy(r,t,e){return B(()=>(Array.isArray(t)?t=Re(t,"int32"):t=Z(t,"int32"),yo(r,t,e)))}function Sc(r){return O(r,r)}function NS(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new z(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?M(t,[1,n[0],1,1,1]):M(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?M(t,[1,1,1,1,n[0]]):M(t,[1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?M(t,[1,n[0],1,1]):M(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?M(t,[1,1,1,n[0]]):M(t,[1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?M(t,[1,n[0],1]):M(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?M(t,[1,1,n[0]]):M(t,[1].concat(n))}else if(r<3)return t;throw new z(`Unsupported input rank by biasAdd: ${t.rank}`)}function xn(r,t,e){return B(()=>(e==null&&(e=gn()),Le(e),J(r,NS(r.rank,t,e))))}function h$(r,t=1){if(t!==1)throw new Nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Js(r)}function g$(r){return B(()=>ct(r,J(Ne(r),1)))}function hy(r,t,e,n){return B(()=>hE(r,t,e,n))}function x$(r){return B(()=>{let t=J(.5,O(.2,r));return br(t,0,1)})}function lu(r,t,e=!1){return e?r():t()}var y$=["fanIn","fanOut","fanAvg"],b$=["normal","uniform","truncatedNormal"];function uX(r){Ki(y$,"FanMode",r)}function cX(r){Ki(b$,"Distribution",r)}var bn=class extends et.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},_m=class extends bn{apply(t,e){return ye(t,e)}};_m.className="Zeros";et.registerClass(_m);var uu=class extends bn{apply(t,e){return lr(t,e)}};uu.className="Ones";et.registerClass(uu);var Em=class extends bn{constructor(t){if(super(),typeof t!="object")throw new z(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new z(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return B(()=>O(pt(this.value),lr(t,e)))}getConfig(){return{value:this.value}}};Em.className="Constant";et.registerClass(Em);var Am=class extends bn{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return ri(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Am.className="RandomUniform";et.registerClass(Am);var $m=class extends bn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`randomNormal does not support dType ${e}.`);return Tm(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};$m.className="RandomNormal";et.registerClass($m);var Dm=class extends bn{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`truncatedNormal does not support dType ${e}.`);return gc(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Dm.className="TruncatedNormal";et.registerClass(Dm);var Rm=class extends bn{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return B(()=>{if(t.length!==2||t[0]!==t[1])throw new z("Identity matrix initializer can only be used for 2D square matrices.");return O(this.gain,xm(t[0]))})}getConfig(){return{gain:this.gain}}};Rm.className="Identity";et.registerClass(Rm);function pX(r,t="channelsLast"){let e,n;if(Le(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let o=_o(r,2);e=r[1]*o,n=r[0]*o}else if(t==="channelsLast"){let o=_o(r,0,r.length-2);e=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=_o(r);e=Math.sqrt(o),n=Math.sqrt(o)}return[e,n]}var Ur=class extends bn{constructor(t){if(super(),t.scale<0)throw new z(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,uX(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,cX(this.distribution),this.seed=t.seed}apply(t,e){let n=pX(t),o=n[0],s=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,o):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(o+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Nt(`${this.getClassName()} does not support dType ${e}.`);return gc(t,0,a,e,this.seed)}else{let a=Math.sqrt(3*i);return ri(t,-a,a,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Ur.className="VarianceScaling";et.registerClass(Ur);var kc=class extends Ur{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};kc.className="GlorotUniform";et.registerClass(kc);var Nc=class extends Ur{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Nc.className="GlorotNormal";et.registerClass(Nc);var Tc=class extends Ur{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Tc.className="HeNormal";et.registerClass(Tc);var _c=class extends Ur{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};_c.className="HeUniform";et.registerClass(_c);var Ec=class extends Ur{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Ec.className="LeCunNormal";et.registerClass(Ec);var Ac=class extends Ur{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ur.className}};Ac.className="LeCunNormal";et.registerClass(Ac);var Fm=class extends bn{constructor(t){if(super(),this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new Nt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return B(()=>{if(t.length<2)throw new Nt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let n=t[0]>t[1]?[t[1],t[0]]:t,o=Tm(n,0,1,"float32"),s=eA.gramSchmidt(o);return t[0]>t[1]&&(s=Mt(s)),O(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Fm.className="Orthogonal";et.registerClass(Fm);var w$={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function v$(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"initializer")}function Ee(r){return Sm(r)}function de(r){if(typeof r=="string"){let t=r in w$?w$[r]:r;if(t==="GlorotNormal")return new Nc;if(t==="GlorotUniform")return new kc;if(t==="HeNormal")return new Tc;if(t==="HeUniform")return new _c;if(t==="LeCunNormal")return new Ec;if(t==="LeCunUniform")return new Ac;{let e={};return e.className=t,e.config={},v$(e)}}else return r instanceof bn?r:v$(r)}function gy(r){return Array.isArray(r)&&Array.isArray(r[0])}function Om(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Pt(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new z(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function Jt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new z(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Mm(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,o)=>n*o);return t}var I$="Variable",qh=class{constructor(t,e="float32",n=I$,o=!0,s=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=uy(),n=n==null?I$:n,this.originalName=cy(n),this.name=py(this.originalName),this.trainable_=o,this.constraint=s,this.val=pS(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),fX(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function fX(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function Kh(r){return r.map(t=>t.read())}function Pm(r){r.forEach(t=>{t[0].write(t[1])})}var ve=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},Qr=class{constructor(t,e,n,o,s,i,a){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=uy(),i!=null&&(this.originalName=cy(i),this.name=py(this.originalName)),this.rank=e.length}},dX=0,ul=class{constructor(t,e){this.callArgs=e,this.id=dX++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},hX=0,Vt=class extends et.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=hX++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=No(n)+"_"+au(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),n=[s].concat(t.inputShape)}this.batchInputShape=n;let o=t.dtype;o==null&&(o=t.inputDType),o==null&&(o="float32"),this.dtype=o}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new Wr(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new z(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return _r(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return _r(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} is not connected, no input to return.`);return _r(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return _r(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=we(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=we(this.inputSpec);if(t.length!==e.length)throw new z(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){let o=t[n],s=e[n];if(s==null)continue;let i=o.rank;if(s.ndim!=null&&i!==s.ndim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new z(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let a=o.shape;for(let u in s.axes){let l=Number(u),c=s.axes[u],p=l>=0?a[l]:a[a.length+l];if(c!=null&&[c,null].indexOf(p)===-1)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${c} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let u=s.shape[a],l=o.shape[a];if(u!=null&&l!=null&&u!==l)throw new z(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=we(t),o=!0;for(let i of n)if(!(i instanceof Qr)){o=!1;break}let s=!0;for(let i of n)if(i instanceof Qr){s=!1;break}if(o===s)throw new z("Arguments to apply() must be all SymbolicTensors or all Tensors");return ii(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let i=[];for(let a of we(t))i.push(a.shape);this.build(_r(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let i=this.call(t,e),a=we(i),u=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=_r(u),this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=gX(t),a=this.computeOutputShape(i),u,l=xX(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,p)=>new Qr(l,c,this,we(t),e,this.name,p)):u=new Qr(l,a,this,we(t),e,this.name),this.addInboundNode(t,u,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new Nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&t[o]!=null&&t[o]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new En(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new En(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Wr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Mm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Kh(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{let e=this.weights;if(e.length!==t.length)throw new z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],o=Kh(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],u=t[s];if(!x.arraysEqual(i.shape,u.shape))throw new z(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);n.push([a,u])}Pm(n)})}addWeight(t,e,n,o,s,i,a,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new z(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():de("zeros"));let l=o.apply(e,n),c=new qh(l,n,t,i,a);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=we(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,n,o,s,i,a=null){let u=we(t);e=we(e),n=we(n),o=we(o),s=Om(s),i=Om(i);let l=[],c=[],p=[];for(let m of u)l.push(m.sourceLayer),c.push(m.nodeIndex),p.push(m.tensorIndex);new ul({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let m=0;m<e.length;m++)e[m].sourceLayer=this,e[m].nodeIndex=this.inboundNodes.length-1,e[m].tensorIndex=m}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function gX(r){r=we(r);let t=[];for(let e of r)t.push(e.shape);return _r(t)}function xX(r){return"float32"}function _S(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],u=n.nodeIndices[s],l=_S(i,a,u);for(let c of l)o.indexOf(c)===-1&&o.push(c)}return o}}}var li=class extends Vt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:au("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];let o=new Qr(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new ul({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};li.className="InputLayer";et.registerClass(li);function xy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new li({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function yX(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return Z(t,r.dtype)}catch(e){throw new z(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Ao=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Ao)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=yX(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new z(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Qr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Qr){if(this.id2Value[t.id]==null)throw new z(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new z(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&_t(this.id2Mask)}},yy=new Gh,by=new Gh;function k$(r){yy!=null&&yy.setMaxEntries(r),by!=null&&by.setMaxEntries(r)}function $c(r,t,e,n){let o=e==null?!1:e.training,s=Array.isArray(r),i=s?r:[r],a=i.map(d=>d.name),u=[],l=t.names();for(let d of a)l.indexOf(d)!==-1?u.push(t.getValue(d)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let c=a.join(",")+"|"+t.names().join(","),p=yy.get(c),m;if(p==null){let d=bX(i,t);p=d.sorted,m=d.recipientCounts,yy.put(c,p),by.put(c,m)}m={},o||Object.assign(m,by.get(c));let f=new Ao(t);for(let d=0;d<p.length;++d){if(n!=null){let R=sh().numTensors;R>n.maxNumTensors&&(n.maxNumTensors=R),R<n.minNumTensors&&(n.minNumTensors=R)}let h=p[d],g=h.sourceLayer;if(g instanceof li)continue;let y=[],b=[],w=[],v=!1;for(let R of h.inputs){let P=f.getValue(R),W=f.getMask(R);y.push(P),b.push(W),W!=null&&(v=!0),o||(m[R.name]--,m[R.name]===0&&!t.hasKey(R)&&a.indexOf(R.name)===-1&&!P.isDisposed&&R.sourceLayer.stateful!==!0&&w.push(P))}v&&(e=e||{},e.mask=b[0]);let k=we(g.apply(y,e)),E=null;g.supportsMasking&&(E=g.computeMask(y,b));let $=vX(h),D=Array.isArray($)?$:[$];for(let R=0;R<D.length;++R){f.hasKey(D[R])||f.add(D[R],k[R],Array.isArray(E)?E[0]:E);let P=a.indexOf(D[R].name);P!==-1&&(u[P]=k[R])}o||_t(w)}return f.disposeMasks(),s?u:u[0]}function bX(r,t){x.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let o=S$(r[0],t);e=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:i,recipientMap:a}=S$(s,t);for(let u of i)o.has(u.name)||(e.push(u),o.add(u.name));for(let u in a)n[u]==null&&(n[u]=new Set),a[u].forEach(l=>n[u].add(l))}}return{sorted:e,recipientCounts:wX(n)}}function wX(r){let t={};for(let e in r)t[e]=r[e].size;return t}function S$(r,t){let e=new Set,n=[],o={};for(let a of t.names())e.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(a.inputs.length===0||u)s.pop(),n.push(a),e.add(a.name),u&&i.pop();else{i.push(s.length-1);for(let l of a.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(a.name),!e.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function vX(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var CX=V();CX.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,k$);var _$={};Yt(_$,{maxNorm:()=>IX,minMaxNorm:()=>NX,nonNeg:()=>kX,unitNorm:()=>SX});function ES(r,t){return B(()=>be(mt(O(r,r),t,!0)))}var Dc=class extends et.Serializable{getConfig(){return{}}},Lm=class extends Dc{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{let e=ES(t,this.axis),n=br(e,0,this.maxValue);return O(t,ct(n,J(cr(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};Lm.className="MaxNorm";et.registerClass(Lm);var zm=class extends Dc{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>ct(t,J(cr(),ES(t,this.axis))))}getConfig(){return{axis:this.axis}}};zm.className="UnitNorm";et.registerClass(zm);var Bm=class extends Dc{apply(t){return Tr(t)}};Bm.className="NonNeg";et.registerClass(Bm);var Vm=class extends Dc{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return B(()=>{let e=ES(t,this.axis),n=J(O(this.rate,br(e,this.minValue,this.maxValue)),O(1-this.rate,e));return O(t,ct(n,J(cr(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Vm.className="MinMaxNorm";et.registerClass(Vm);var N$={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function We(r){return Sm(r)}function T$(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"constraint")}function Ue(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in N$?N$[r]:r,config:{}};return T$(e)}else return r instanceof Dc?r:T$(r)}function IX(r){return new Lm(r)}function SX(r){return new zm(r)}function kX(){return new Bm}function NX(r){return new Vm(r)}var E$={};Yt(E$,{constant:()=>EX,glorotNormal:()=>MX,glorotUniform:()=>OX,heNormal:()=>PX,heUniform:()=>LX,identity:()=>RX,leCunNormal:()=>zX,leCunUniform:()=>BX,ones:()=>_X,orthogonal:()=>VX,randomNormal:()=>$X,randomUniform:()=>AX,truncatedNormal:()=>DX,varianceScaling:()=>FX,zeros:()=>TX});function TX(){return new _m}function _X(){return new uu}function EX(r){return new Em(r)}function AX(r){return new Am(r)}function $X(r){return new $m(r)}function DX(r){return new Dm(r)}function RX(r){return new Rm(r)}function FX(r){return new Ur(r)}function OX(r){return new kc(r)}function MX(r){return new Nc(r)}function PX(r){return new Tc(r)}function LX(r){return new _c(r)}function zX(r){return new Ec(r)}function BX(r){return new Ac(r)}function VX(r){return new Fm(r)}var aD={};Yt(aD,{Layer:()=>Vt,RNN:()=>$n,RNNCell:()=>fl,activation:()=>rY,add:()=>pY,alphaDropout:()=>jY,average:()=>mY,averagePooling1d:()=>WS,averagePooling2d:()=>US,averagePooling3d:()=>HS,avgPool1d:()=>vY,avgPool2d:()=>IY,avgPool3d:()=>kY,avgPooling1d:()=>CY,avgPooling2d:()=>SY,avgPooling3d:()=>NY,batchNormalization:()=>yY,bidirectional:()=>BY,concatenate:()=>fY,conv1d:()=>K8,conv2d:()=>j8,conv2dTranspose:()=>X8,conv3d:()=>Y8,conv3dTranspose:()=>Z8,convLstm2d:()=>MY,convLstm2dCell:()=>PY,cropping2D:()=>Q8,dense:()=>nY,depthwiseConv2d:()=>eY,dot:()=>xY,dropout:()=>oY,elu:()=>V8,embedding:()=>cY,flatten:()=>iY,gaussianDropout:()=>KY,gaussianNoise:()=>qY,globalAveragePooling1d:()=>TY,globalAveragePooling2d:()=>_Y,globalMaxPool1d:()=>GY,globalMaxPool2d:()=>WY,globalMaxPooling1d:()=>nD,globalMaxPooling2d:()=>oD,gru:()=>AY,gruCell:()=>$Y,input:()=>PS,inputLayer:()=>B8,layerNormalization:()=>bY,leakyReLU:()=>W8,lstm:()=>DY,lstmCell:()=>RY,masking:()=>XY,maxPool1d:()=>UY,maxPool2d:()=>HY,maxPooling1d:()=>sD,maxPooling2d:()=>iD,maxPooling3d:()=>EY,maximum:()=>dY,minimum:()=>hY,multiply:()=>gY,permute:()=>uY,prelu:()=>U8,reLU:()=>G8,repeatVector:()=>aY,reshape:()=>lY,rnn:()=>LY,separableConv2d:()=>J8,simpleRNN:()=>FY,simpleRNNCell:()=>OY,softmax:()=>H8,spatialDropout1d:()=>sY,stackedRNNCells:()=>zY,thresholdedReLU:()=>q8,timeDistributed:()=>VY,upSampling2d:()=>tY,zeroPadding2d:()=>wY});async function ji(r){if(r==null)return;let t=[],e=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let i=s;t.push(i.data()),e.push(o),n.push(i)}}if(t.length>0){let o=await Promise.all(t);for(let s=0;s<o.length;++s)r[e[s]]=o[s][0];_t(n)}}function wy(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var A$;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(A$||(A$={}));var GX=125,cl=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},vy=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},AS=class extends cl{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=B(()=>J(this.totals[o],O(s,n)));this.totals[o]=a,i!=null&&i.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:B(()=>{let o=O(ct(1,this.seen),this.totals[n]);e[n]=o,this.totals[n].dispose(),Pe(e[n])}))}},Cy=class extends cl{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){let t=[],e=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let u=i[a];t.push(u.data()),e.push(s),n.push(a)}}let o=await Promise.all(t);for(let s=0;s<o.length;++s)this.history[e[s]][n[s]].dispose(),this.history[e[s]][n[s]]=o[s][0]}},Iy=class extends cl{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||Vh,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=GX),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");x.isNumber(this.yieldEvery)&&(this.maybeWait=r$(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){let o=[];this.yield!=null&&(await ji(n),o.push(this.yield(t,e,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await ji(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let n=[];this.epochEnd!=null&&(await ji(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await ji(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let n=[];this.batchEnd!=null&&(await ji(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):x.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await ji(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await ji(t),await this.trainEnd(t))}};function Sy(r,t){return r==null&&(r={}),r instanceof cl?[r]:Array.isArray(r)&&r[0]instanceof cl?r:we(r).map(n=>new Iy(n,t))}var wn=class{constructor(){}static registerCallbackConstructor(t,e){x.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),wn.checkForDuplicate(e),wn.constructors[t]==null&&(wn.constructors[t]=[]),wn.constructors[t].push(e)}static checkForDuplicate(t){for(let e in wn.constructors)wn.constructors[+e].forEach(o=>{if(o===t)throw new z("Duplicate callback constructor.")})}static clear(){wn.constructors={}}static createCallbacks(t){let e=[];for(let n in wn.constructors){let o=+n;t>=o&&e.push(...wn.constructors[o])}return e.map(n=>new n)}};wn.constructors={};function ky(r,t,e,n,o,s,i,a,u){let l=new Cy,c=[new AS,...wn.createCallbacks(t)];r!=null&&c.push(...r),c.push(l);let p=new vy(c);return p.setParams({epochs:e,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:t,doValidation:a,metrics:u}),{callbackList:p,history:l}}function vn(r,t={},e=!1){return qi(r,et.SerializationMap.getMap().classNameMap,t,"layer",e)}function jh(r,t){return B(()=>{r.dtype!=="float32"&&(r=Z(r,"float32"));let e=mt(Sc(r),t,!0),n=Qs(e.shape,cr()),o=be(fn(e,n));return ct(r,o)})}function Xi(r,t){return B(()=>xe(Sc(lt(t,r)),-1))}function Gm(r,t){return B(()=>xe(Ne(lt(t,r)),-1))}function cu(r,t){return B(()=>{let e=lt(r,t),n=br(Ne(r),cr(),Number.MAX_VALUE),o=Ne(ct(e,n));return O(100,xe(o,-1))})}function WX(r,t){return B(()=>{let e=br(t,cr(),Number.MAX_VALUE),n=wr(J(1,e)),o=br(r,cr(),Number.MAX_VALUE),s=wr(J(1,o));return xe(Sc(lt(n,s)),-1)})}function UX(r,t){return B(()=>{let e=fn(0,lt(1,O(r,t)));return xe(Sc(e),-1)})}function HX(r,t){return B(()=>{let e=fn(0,lt(1,O(r,t)));return xe(e,-1)})}function qX(r,t){return B(()=>{let e=mt(O(r,t),-1),n=Dr(O(lt(1,r),t),-1);return fn(0,J(1,lt(n,e)))})}function KX(r,t){return B(()=>{let e=Math.log(2),n=lt(t,r),o=lt(J(n,bo(O(-2,n))),e);return xe(o,-1)})}function Rc(r,t,e=!1){return B(()=>{if(e)t=nl(t);else{let n=mt(t,t.shape.length-1,!0);t=ct(t,n)}return t=br(t,cr(),1-cr()),Zt(mt(O(Z(r,"float32"),wr(t)),t.shape.length-1))})}function Wm(r,t,e=!1){return B(()=>{let n=Z(ti(f$(r)),"int32");t=br(t,cr(),1-cr());let o=t.shape,s=M(js(n,o[o.length-1]),o);return Rc(s,t,e)})}function jX(r,t){if(!x.arraysEqual(r.shape,t.shape))throw new z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{let e=Tr(t),n=Zt(Ne(t));return J(lt(e,O(t,r)),Za(Ze(n)))})}function Um(r,t){return B(()=>{let e;return e=br(t,cr(),1-cr()),e=wr(ct(e,lt(1,e))),xe(jX(r,e),-1)})}function XX(r,t){return B(()=>{let e=br(r,cr(),1),n=br(t,cr(),1);return mt(O(r,wr(ct(e,n))),-1)})}function YX(r,t){return B(()=>{let e=wr(J(cr(),t));return xe(lt(t,O(r,e)),-1)})}function Yh(r,t){return B(()=>{let e=jh(r,-1),n=jh(t,-1),o=O(e,n);return Zt(mt(o,-1))})}var Xh={meanSquaredError:Xi,meanAbsoluteError:Gm,meanAbsolutePercentageError:cu,meanSquaredLogarithmicError:WX,squaredHinge:UX,hinge:HX,categoricalHinge:qX,logcosh:KX,categoricalCrossentropy:Rc,sparseCategoricalCrossentropy:Wm,binaryCrossentropy:Um,kullbackLeiblerDivergence:XX,poisson:YX,cosineProximity:Yh};function Ny(r){if(typeof r=="string"){if(r in Xh)return Xh[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new z(t)}else return r}function Zh(r,t){return B(()=>{let e=O(.5,dr(t)),n=Ic(Ge(t,e),r.dtype);return xe(Sr(r,n),-1)})}function Jh(r,t){return B(()=>Ic(Sr(Xs(r,-1),Xs(t,-1)),"float32"))}function D$(r,t){return B(()=>Z(mt(Nr(Sr(r,1),Sr(t,1))),"float32"))}function ZX(r,t){return B(()=>Z(mt(Nr(Sr(r,1),Sr(t,0))),"float32"))}function JX(r,t){return B(()=>Z(mt(Nr(Sr(r,0),Sr(t,1))),"float32"))}function $S(r,t){return B(()=>{let e=D$(r,t),n=JX(r,t),o=J(e,n);return Z(_e(Ge(o,0),ct(e,o),0),"float32")})}function R$(r,t){return B(()=>{let e=D$(r,t),n=ZX(r,t),o=J(e,n);return Z(_e(Ge(o,0),ct(e,o),0),"float32")})}function _y(r,t){return Um(r,t)}function Ey(r,t){return r.rank===t.rank&&(r=zr(r,[r.rank-1])),t=Xs(t,-1),t.dtype!==r.dtype&&(t=Z(t,r.dtype)),Z(Sr(r,t),"float32")}var QX=Xi,t8=Xi,e8=Gm,r8=Gm,n8=cu,o8=cu,Qh=Rc,s8=Yh,DS=Wm,Ty={binaryAccuracy:Zh,categoricalAccuracy:Jh,precision:$S,categoricalCrossentropy:Qh,sparseCategoricalCrossentropy:DS,mse:QX,MSE:t8,mae:e8,MAE:r8,mape:n8,MAPE:o8,cosine:s8};function F$(r){if(typeof r=="string"&&r in Ty)return Ty[r];if(typeof r!="string"&&r!=null)return r;throw new z(`Unknown metric ${r}`)}function tg(r){if(Qn(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Xh))if(Xh[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(Ty))if(Ty[e]===r){t=e;break}return t!==void 0?t:r.name}}function M$(r){let t={Adagrad:()=>vc.adagrad(.01),Adadelta:()=>vc.adadelta(1,.95,cr()),Adam:()=>vc.adam(.001,.9,.999,cr()),Adamax:()=>vc.adamax(.002,.9,.999,cr(),0),RMSProp:()=>vc.rmsprop(.001,.9,0,cr()),SGD:()=>vc.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new z(`Unknown Optimizer ${r}`)}function FS(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!RS(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function RS(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!RS(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!RS(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function P$(r,t,e,n=console.log){let o=l8(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c)));let i;if(!o){s.push("Receives inputs"),i=[];for(let c in r.nodesByDepth)i.push(...r.nodesByDepth[c])}n("_".repeat(t)),Ay(s,e,n),n("=".repeat(t));let a=r.layers;for(let c=0;c<a.length;++c)o?u8(a[c],e,n):c8(a[c],e,i,n),n((c===a.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=a8(r),l=Mm(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(t))}function a8(r){let t;return r.collectedTrainableWeights!=null?t=Mm(r.collectedTrainableWeights):t=Mm(r.trainableWeights),t}function l8(r){let t=!0,e=[],n=[];for(let o in r.nodesByDepth)e.push(r.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of r.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Ay(r,t,e=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);e(n)}function u8(r,t,e){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch(u){o="multiple"}try{n=JSON.stringify(r.outputShape)}catch(u){n="multiple"}let s=r.name,i=r.getClassName(),a=[`${s} (${i})`,o,n,r.countParams().toString()];Ay(a,t,e)}function c8(r,t,e,n){let o,s;try{s=r.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{o=JSON.stringify(r.outputShape)}catch(p){o="multiple"}let i=[];for(let p of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let m=0;m<p.inboundLayers.length;++m){let f=p.inboundLayers[m].name,d=p.nodeIndices[m],h=p.tensorIndices[m];i.push(`${f}[${d}][${h}]`)}let a=r.name,u=r.getClassName(),l=i.length===0?"":i[0],c=[`${a} (${u})`,s,o,r.countParams().toString(),l];Ay(c,t,n);for(let p=1;p<i.length;++p)Ay(["","","","",i[p]],t,n)}function L$(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function Fc(r,t){if(r===null)return null;if(typeof r=="string")return il(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];L$(t,o,s)?e.push(s):e.push(Fc(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")e[n]=o;else{let s=il(n);e[s]=Fc(o,s)}}return e}}function $y(r,t){if(r==null)return null;if(typeof r=="string")return No(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];L$(t,o,s)?e.push(s):e.push($y(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n],s=No(n);(n==="name"||n==="className")&&typeof o=="string"?e[s]=o:e[s]=$y(o,n)}return e}}var Hm="3.16.0";var Bn=class extends Vt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=au(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],To(this.inputs).length!==this.inputs.length)throw new z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);To(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let w=b.sourceLayer,v=b.nodeIndex,k=b.tensorIndex;this.outputLayers.push(w),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(k)}for(let b of this.inputs){let w=b.sourceLayer,v=b.nodeIndex,k=b.tensorIndex;Qn(v===0,"input layer has >1 nodes"),Qn(k===0,"input layer has >1 tensors"),this.inputLayers.push(w),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(k)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let w=this.inputLayers[b];if(!(w instanceof li))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${w.getClassName()}.`);this.inputNames.push(w.name),this.feedInputShapes.push(w.batchInputShape),this.feedInputNames.push(w.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let e={},n={},o={},s={},i={},a=[],u=(b,w,v,k,E,$)=>{(k==null||E==null||$==null)&&(k=b.sourceLayer,E=b.nodeIndex,$=b.tensorIndex);let D=k.inboundNodes[E];if(v.indexOf(D)!==-1)throw new Wr(`The tensor ${b.name} at layer "${k.name}" is part of a cycle.`);if(w.indexOf(D)!==-1)return;this.containerNodes.add(Bn.nodeKey(k,E)),k.id in i||(i[k.id]=Object.keys(i).length),v.indexOf(D)===-1&&v.push(D);let R=D.inboundLayers.length;for(let P=0;P<R;P++){let W=D.inputTensors[P],U=D.inboundLayers[P],q=D.nodeIndices[P],K=D.tensorIndices[P];u(W,w,v,U,q,K)}for(w.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},l=[],c=[];for(let b of this.outputs)u(b,l,c);let p=a.slice().reverse();for(let b of p){n[b.id]=b,b.id in e||(e[b.id]=0);let w=e[b.id],v=o[b.outboundLayer.id]==null?0:o[b.outboundLayer.id];w=Math.max(w,v),o[b.outboundLayer.id]=w,s[b.outboundLayer.id]=b.outboundLayer,e[b.id]=w;for(let k=0;k<b.inboundLayers.length;k++){let E=b.inboundLayers[k],$=b.nodeIndices[k],D=E.inboundNodes[$],R=e[D.id]==null?0:e[D.id];e[D.id]=Math.max(w+1,R),n[D.id]=D}}let m={};for(let b in e){let w=e[b];w in m||(m[w]=[]),m[w].push(n[b])}let f={};for(let b in o){let w=o[b];w in f||(f[w]=[]),f[w].push(s[b])}let d=Object.keys(f).map(b=>parseInt(b,10)).sort(Wh);this.layers=[];for(let b of d){let w=f[b];w.sort((v,k)=>{let E=i[v.id],$=i[k.id];return E<$?-1:E>$?1:0});for(let v of w)v instanceof Bn&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,d=Object.keys(m).map(b=>parseInt(b,10)).sort(Wh);let h=this.inputs.slice(),g=[];for(let b of d)for(let w of m[b]){let v=w.outboundLayer;if(v!=null){for(let k of w.inputTensors)if(h.indexOf(k)===-1)throw new Wr(`Graph disconnected: cannot obtain value for tensor ${k} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(let k of w.outputTensors)h.push(k);g.push(v.name)}}this.nodesByDepth=m;let y=this.layers.map(b=>b.name);for(let b of y){let w=y.filter(v=>v===b).length;if(w!==1)throw new Wr(`The name "${b}" is used ${w} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new ul({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let n={},o=0;for(let i of this.layers)for(let a of i.weights){if(n[a.originalName]!=null)throw new z(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,o++}let s=[];for(let i in t){let a=i;if(n[i]==null){let u=i.split("/");a=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],t[i]]);else if(e)throw new z(`Provided weight data has no target variable: ${i}`);delete n[a]}if(e){let i=[];for(let a in n)i.push(a);if(i.length>0)throw new z(`${i.length} of ${o} weights are not set: ${i}`)}Pm(s)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${Hm}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let n=$y(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return B(()=>{t=we(t);let n=new Ao;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],t[o]);return $c(this.outputs,n,e)})}computeMask(t,e){return B(()=>{t=we(t);let n;return e==null?n=ko(null,t.length):n=we(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let e=Om(t);if(e.length!==this.inputLayers.length)throw new z(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<e.length;a++){let u=this.inputLayers[a],l=e[a],c=u.name+"_0_0";n[c]=l}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(Wh);if(o.length>1)for(let a of o){let u=this.nodesByDepth[a];for(let l of u){let c=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(c.id)!==-1)continue;let p=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],y=l.nodeIndices[h],b=l.tensorIndices[h],w=`${g.name}_${y}_${b}`,v=n[w];p.push(v)}let m=c.computeOutputShape(_r(p)),f=Om(m),d=c.inboundNodes.indexOf(l);for(let h=0;h<f.length;h++){let g=`${c.name}_${d}_${h}`;n[g]=f[h]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],p=`${u.name}_${l}_${c}`;i.push(p)}for(let a=0;a<i.length;a++){let u=i[a];Qn(u in n),s.push(n[u])}return _r(s)}runInternalGraph(t,e){e==null&&(e=ko(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],c=t[u],p=e[u];n[l.id]=[c,p]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Wh);for(let u of o){let l=this.nodesByDepth[u];for(let c of l){let p=c.outboundLayer,m=c.inputTensors,f=c.outputTensors,d=new Array;for(let h of m)h.id in n&&d.push(n[h.id]);if(d.length===m.length){let h={},g,y,b,w;if(c.callArgs!=null&&(h=c.callArgs),d.length===1){let[v,k]=d[0];h.mask==null&&(h.mask=k),b=we(p.call(v,h)),w=we(p.computeMask(v,k)),g=[v],y=[k]}else g=d.map(v=>v[0]),y=d.map(v=>v[1]),h.mask==null&&(h.mask=y),b=we(p.call(g,h)),w=we(p.computeMask(g,y));if(p.activityRegularizer)throw new Nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v){let k=f[v],E=b[v],$=w[v];n[k.id]=[E,$]}}}}let s=[],i=[],a=[];for(let u of this.outputs){Qn(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,c]=n[u.id];a.push(l.shape),s.push(l),i.push(c)}return[s,i,a]}buildNodeConversionMap(t){let e={},n;for(let o of this.layers){n=o instanceof Bn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=Bn.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=n,n+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new z(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new z("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===t)return n;throw new z(`No such layer: ${t}`)}calculateLosses(){return B(()=>{let t=[];for(let e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){let o=Bn.nodeKey(e,n);this.containerNodes.has(o)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),u=i.getConfig(),l=[];for(let p=0;p<i.inboundNodes.length;p++){let m=i.inboundNodes[p],f=Bn.nodeKey(i,p),d={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),d=m.callArgs}catch(h){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let y=m.inboundLayers[g],b=m.nodeIndices[g],w=m.tensorIndices[g],v=Bn.nodeKey(y,b),k=e[v];k==null&&(k=0),h.push([y.name,k,w,d])}l.push(h)}}}let c={};c.name=i.name,c.className=a,c.config=u,c.inboundNodes=l,n.push(c)}t.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=Bn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,c,p])}t.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=Bn.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=e[l];c==null&&(c=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,c,p])}return t.outputLayers=s,t}static fromConfig(t,e,n={},o=!1){let s={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function u(g,y){let b=[],w;for(let v of y){let k=v[0],E=v[1],$=v[2];if(w=v[3]==null?{}:v[3],!(k in s)){a(g,y);return}let D=s[k];if(D.inboundNodes.length<=E){a(g,y);return}let R=D.inboundNodes[E];b.push(R.outputTensors[$])}b.length>0&&g.apply(_r(b),w)}function l(g){let y=g.name,b=vn(g,e.customObjects!=null?e.customObjects:{});b.setFastWeightInitDuringBuild(o),s[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new z(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}let c=e.name,p=e.layers;for(let g of p)l(g);for(;!t$(i);)for(let g of p){let y=s[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let w of b)u(y,w)}}let m=[],f=[],d=e.inputLayers;for(let g of d){let y=g[0],b=g[1],w=g[2];Qn(y in s);let k=s[y].inboundNodes[b].outputTensors;m.push(k[w])}let h=e.outputLayers;for(let g of h){let y=g[0],b=g[1],w=g[2];Qn(y in s);let k=s[y].inboundNodes[b].outputTensors;f.push(k[w])}return new t({inputs:m,outputs:f,name:c})}get stateful(){if(this._stateful)throw new z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function p8(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return t.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function Dy(r,t){return p8(r,t,"classWeight")}async function Ry(r,t,e,n){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=B(()=>{if(r.shape.length===1)return kn(r);if(r.shape.length===2){if(r.shape[1]>1)return Xs(r,1);if(r.shape[1]===1)return M(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());_t(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),Re(i,"float32")}else return null}function z$(r,t){return O(r,t)}var m8=32;function G$(r,t){let e,n,o=t;e=o.xs,n=o.ys,x.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=B$("input",r.inputNames,e),i=B$("output",r.outputNames,n),a=s[0].shape[0];x.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),x.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)x.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let u=0;u<i.length;u++)x.assert(i[u].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function B$(r,t,e){if(e instanceof Lt)return[e];if(Array.isArray(e))return x.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let o of t){if(e[o]==null)throw new z(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(e[o])}return n}}function f8(r){if(r.length===3)throw new Nt("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function W$(r,t,e){let n=e.batchesPerEpoch!=null;if(x.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),x.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),x.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),x.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),x.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(V$(e.validationData))x.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=f8(e.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let c=Sy(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:m,history:f}=ky(c,p,e.epochs,null,null,d8(t,e),null,o,l);m.setModel(r),r.history=f,await m.onTrainBegin(),r.stopTraining_=!1;let d=e.initialEpoch==null?0:e.initialEpoch,h=await t.iterator();for(;d<e.epochs;){let g={};await m.onEpochBegin(d);let y=0,b=0;for(n||(h=await t.iterator());!n||y<e.batchesPerEpoch;){let w=await h.next();if(n&&w.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(w.value!=null){let{xs:v,ys:k}=G$(r,w.value),E={};E.batch=b,E.size=v[0].shape[0],await m.onBatchBegin(b,E);let $=[];if(e.classWeight!=null){let P=Dy(e.classWeight,r.outputNames);for(let W=0;W<P.length;++W)$.push(await Ry(k[W],null,P[W]))}let D=v.concat(k).concat($),R=a(D);_t(D);for(let P=0;P<u.length;++P){let W=u[P],U=R[P];E[W]=U,Pe(U)}await m.onBatchEnd(b,E),wy(E),b++,y++}if(n?y>=e.batchesPerEpoch:w.done){if(o){let v;V$(e.validationData)?v=we(await r.evaluateDataset(e.validationData,{batches:e.validationBatches})):v=we(r.evaluate(s,i,{batchSize:e.validationBatchSize==null?m8:e.validationBatchSize,verbose:0}));for(let k=0;k<r.metricsNames.length;++k)g[`val_${r.metricsNames[k]}`]=v[k]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(d,g),d++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function d8(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function V$(r){return typeof r.iterator=="function"}function h8(r){return typeof r.next=="function"}async function U$(r,t,e){e=e||{};let n=e.batches!=null,o=r.testFunction,s=[];if(e.verbose>0)throw new Nt("Verbose mode is not implemented yet.");x.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=h8(t)?t:await t.iterator(),a=0,u=0;for(;!n||u<e.batches;){let l=await i.next();if(s=B(()=>{if(l.value){let{xs:c,ys:p}=G$(r,l.value),m=c.concat(p),f=B(()=>o(m));if(_t(m),u===0)for(let h=0;h<f.length;++h)s.push(pt(0));let d=m[0].shape[0];for(let h=0;h<f.length;++h){let g=f[h],y=s[h];s[h]=B(()=>J(s[h],O(d,g))),u>0&&_t(y)}_t(f),a+=d,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let c=s[l];s[l]=ct(s[l],a),_t(c)}return _r(s)}function Fy(r){x.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function qm(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>al(n,t,e-t)):al(r,t,e-t)}function Oy(r,t){return B(()=>r==null?null:Array.isArray(r)?r.map(e=>Oy(e,t)):dy(r,t.dtype==="int32"?t:Z(t,"int32")))}function My(r,t){let e=[],n=0,o=null;for(;n<r;)o=n+t,o>=r&&(o=r),e.push([n,o]),n=o;return e}async function g8(r,t,e,n,o,s,i,a,u,l,c,p,m,f,d){o==null&&(o=32),s==null&&(s=1),c==null&&(c=!0),m==null&&(m=0);let h=!1;if(u!=null&&l!=null&&(h=!0),d!=null&&(h=!0,f==null))throw new z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(e,o,f,"steps_per_epoch"),y;g!=null&&(y=Jr(0,g)),i==null&&(i=1);let{callbackList:b,history:w}=ky(a,i,s,m,g,f,o,h,p);b.setModel(r),r.history=w,await b.onTrainBegin(),r.stopTraining_=!1;for(let v=m;v<s;++v){await b.onEpochBegin(v);let k={};if(f!=null)throw new Nt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Nt("batch shuffling is not implemneted yet");c&&x.shuffle(y);let E=Re(y),$=My(g,o);for(let D=0;D<$.length;++D){let R={};if(await b.onBatchBegin(D,R),B(()=>{let P=$[D][0],W=$[D][1],U=al(E,P,W-P);R.batch=D,R.size=W-P;let q=Oy(e,U),K=t(q);for(let j=0;j<n.length;++j){let Q=n[j],rt=K[j];R[Q]=rt,Pe(rt)}if(D===$.length-1&&h){let j=r.testLoop(u,l,o);for(let Q=0;Q<n.length;++Q){let rt=n[Q],X=j[Q];Pe(X),k["val_"+rt]=X}}}),await b.onBatchEnd(D,R),wy(R),r.stopTraining_)break}E.dispose()}if(await b.onEpochEnd(v,k),r.stopTraining_)break}return await b.onTrainEnd(),await r.history.syncData(),r.history}async function H$(r,t,e,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,i,a,u,l,c,p,m;try{let f=n.batchSize==null?32:n.batchSize;Fy(f);let d=!1,h=await r.standardizeUserData(t,e,n.sampleWeight,n.classWeight,d,f);o=h[0],s=h[1],m=h[2];let g=!1,y;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Nt("validationData including sample weights is not supported yet."):new z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let R=!0,P=await r.standardizeUserData(u,l,null,null,R,f);c=P[0],p=P[1],y=c.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let R=Math.floor(o[0].shape[0]*(1-n.validationSplit)),P=o[0].shape[0];c=qm(o,R,P),i=o,o=qm(o,0,R),p=qm(s,R,P),a=s,s=qm(s,0,R),y=c.concat(p)}else n.validationSteps!=null&&(g=!0);let b=o.concat(s).concat(m);r.checkTrainableWeightsConsistency();let w=r.makeTrainFunction(),v=r.getDedupedMetricsNames(),k,E;g?(r.makeTestFunction(),k=r.testFunction,E=v.slice().concat(v.map(R=>"val_"+R))):(k=null,y=[],E=v.slice());let $=Sy(n.callbacks,n.yieldEvery);return await g8(r,w,b,v,f,n.epochs,n.verbose,$,k,y,n.shuffle,E,n.initialEpoch,null,null)}finally{r.isTraining=!1,$o(o,t),$o(s,e),$o(i,t),$o(a,e),$o(c,u),$o(p,l),m!=null&&_t(m)}}function OS(r){let t=[];r instanceof Lt&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(ll(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function $o(r,t){if(r==null)return;let e=[];if(t instanceof Lt)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let n=[];if(r instanceof Lt)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{e.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];e.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function x8(r){return r instanceof Lt}function MS(r){return Array.isArray(r)}function q$(r){return!x8(r)&&!MS(r)}function K$(r,t,e,n=!0,o=""){if(t==null||t.length===0){if(r!=null){let i=!1;if(MS(r)&&r.length>0)i=!0;else if(q$(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new z(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(i=>null);let s;if(q$(r)){r=r,s=[];for(let i of t){if(r[i]==null)throw new z(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(r[i])}}else if(MS(r)){if(r=r,r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new z(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=OS(s),e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c>=0&&l!==c)throw new z(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function y8(r,t,e){let n=To(r.map(s=>s.shape[0]));n.sort();let o=To(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!x.arraysEqual(n,o))throw new z(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function b8(r,t,e){let n=[Xi,Um,Rc];for(let o=0;o<r.length;++o){let s=r[o],i=t[o],a=e[o];if(i!=null){if(i===Rc&&s.shape[s.shape.length-1]===1)throw new z(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){let p=u[c],m=l[c];if(m!=null&&p!==m)throw new z(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function j$(r,t,e,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new z(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new z(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let i=0;i<t.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new z(`Error when checking ${o}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<e[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],c=e[i][u];if(c!=null&&c!==l)throw new z(`Error when checking ${o}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function w8(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var v8="layers-model",Vn=class extends Bn{constructor(t){super(t),this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");P$(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=M$(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Vr))throw new z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new z(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),e.push(Ny(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(a=>Ny(a))}else{let i=Ny(t.loss);this.outputs.forEach(a=>{e.push(i)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ii("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let o=w8(t.metrics,this.outputNames),s=(i,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,i])};ii("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=o[i];(l=>{let c="",p,m,f;for(let d of l){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===Um?["accuracy","acc"].indexOf(d)!==-1?m=Zh:["crossentropy","ce"].indexOf(d)!==-1&&(m=_y):this.lossFunctions[i]===Wm?["accuracy","acc"].indexOf(d)!==-1?m=Ey:["crossentropy","ce"].indexOf(d)!==-1&&(m=DS):["accuracy","acc"].indexOf(d)!==-1?m=Jh:["crossentropy","ce"].indexOf(d)!==-1&&(m=Qh);let y;["accuracy","acc"].indexOf(d)!==-1?y="acc":["crossentropy","ce"].indexOf(d)!==-1&&(y="ce"),f=m,p=c+y}else f=F$(d),p=c+tg(d);let h;ii(p,()=>{h=f}),s(i,p,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){let o=n.batchSize==null?32:n.batchSize;Fy(o);let s=!0,i=this.standardizeUserDataXY(t,e,s,o);try{let a=i[0].concat(i[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,a,o,n.verbose,n.steps);return _r(l)}finally{$o(i[0],t),$o(i[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),U$(this,t,e)}checkNumSamples(t,e,n,o="steps"){let s;if(n!=null){if(s=null,e!=null)throw new z(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new z(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new z("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(e),o=n?e:[e],s=this.retrieveSymbolicTensors(o),i=new Ao;if(t instanceof Lt&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new z(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],t[u])}else for(let u of this.inputs){let l=t[u.name];if(l==null)throw new z(`No value is provided for the model's input ${u.name}`);i.add(u,l)}let a=$c(s,i);return n?a:a[0]}retrieveSymbolicTensors(t){let e=ko(null,t.length),n=t.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],i=s.map(a=>a.name);for(let a=0;a<t.length;++a){let u=i.indexOf(t[a]);if(u!==-1&&(e[a]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw e.forEach((s,i)=>{s==null&&o.push(t[i])}),new z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return e}predictLoop(t,e=32,n=!1){return B(()=>{let o=this.checkNumSamples(t);if(n)throw new Nt("Verbose predictLoop() is not implemented yet.");let s=My(o,e),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)B(()=>{let l=s[a][0],c=s[a][1],p=qm(t,l,c),m=[];if(Array.isArray(p))for(let d=0;d<p.length;++d)m.push({key:this.inputs[d],value:p[d]});else m.push({key:this.inputs[0],value:p});let f=new Ao(m);return $c(this.outputs,f)}).forEach((l,c)=>i[c].push(l));return _r(i.map(a=>se(a,0)))})}predict(t,e={}){let n=OS(t);j$(n,this.inputNames,this.feedInputShapes,!1);try{let o=e.batchSize==null?32:e.batchSize;return Fy(o),this.predictLoop(n,o)}finally{$o(n,t)}}predictOnBatch(t){j$(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,o){if(this.optimizer_==null)throw new Wr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===Wm?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(t=K$(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=K$(e,this.feedOutputNames,s,!1,"target"),y8(t,e,null),b8(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&t[0].shape[0]%o!==0)throw new z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,o,s=!0,i){let[a,u]=this.standardizeUserDataXY(t,e,s,i);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let c=Dy(o,this.outputNames);l=[];for(let p=0;p<c.length;++p)l.push(await Ry(u[p],null,c[p]))}return[a,u,l]}testLoop(t,e,n,o=0,s){return B(()=>{let i=this.checkNumSamples(e,n,s,"steps"),a=[];if(o>0)throw new Nt("Verbose mode is not implemented yet.");if(s!=null)throw new Nt("steps mode in testLoop() is not implemented yet");{let u=My(i,n),l=Re(Jr(0,i));for(let c=0;c<u.length;++c){let p=u[c][0],m=u[c][1],f=al(l,p,m-p),d=Oy(e,f),h=t(d);if(c===0)for(let g=0;g<h.length;++g)a.push(pt(0));for(let g=0;g<h.length;++g){let y=h[g];a[g]=J(a[g],O(m-p,y))}}for(let c=0;c<a.length;++c)a[c]=ct(a[c],i)}return a})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){let o=t[n],s=o;CS(t,o)>1&&(s+=`_${CS(t.slice(0,n),o)}`),e.push(s)}return e}makeTrainFunction(){return t=>{let e=[],n=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let p=[];for(let h=0;h<this.inputs.length;++h)p.push({key:this.inputs[h],value:n[h]});let m=new Ao(p),f=$c(this.outputs,m,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let y=this.lossFunctions[h](o[h],f[h]);s[h]!=null&&(y=z$(y,s[h]));let b=xe(y);e.push(b),h===0?d=y:d=J(d,y)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=e[h];else{let y=this.metricsTensors[h][0],b=this.metricsTensors[h][1];g=xe(y(o[b],f[b]))}Pe(g),i.push(g)}return d=xe(d),this.calculateLosses().forEach(h=>{d=J(d,h)}),d},u=this.collectedTrainableWeights.map(p=>p.read()),l=!0;return[this.optimizer_.minimize(a,l,u)].concat(i)}}makeTestFunction(){this.testFunction=t=>B(()=>{let e=[],n,o=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:o[l]});let a=new Ao(i),u=$c(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let c=this.lossFunctions[l],p=xe(c(s[l],u[l]));l===0?n=p:n=J(n,p),e.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let c=this.metricsTensors[l][0],p=this.metricsTensors[l][1],m=xe(c(s[p],u[p]));e.push(m)}return e})}async fit(t,e,n={}){return H$(this,t,e,n)}async fitDataset(t,e){return W$(this,t,e)}async trainOnBatch(t,e){let n=await this.standardizeUserData(t,e),o=n[0],s=n[1],a=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of a){let c=await l.data();u.push(c[0])}return _t(a),$o(n[0],t),$o(n[1],e),_r(u)}getNamedWeights(t){let e=[],n=t!=null&&t.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<o.length;++i)n&&!o[i].trainable||e.push({name:o[i].originalName,tensor:s[i]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=sh().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-sh().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=No(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>No(e))}else{let e=Object.keys(this.loss);t={};let n=this.loss;for(let o of e)if(typeof n[o]=="string")t[o]=No(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[No(tg(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>No(tg(t)));{let t={};for(let e in this.metrics)t[e]=No(tg(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Fc(t.optimizer_config),n=vn(e),o;if(typeof t.loss=="string")o=il(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(i=>il(i));else if(t.loss!=null){o={};for(let i in t.loss)o[i]=il(t.loss[i])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(i=>il(i));else if(t.metrics!=null){s={};for(let i in t.metrics)s[i]=il(t.metrics[i])}this.compile({loss:o,metrics:s,optimizer:n})}async save(t,e){if(typeof t=="string"){let l=Mr.getSaveHandlers(t);if(l.length===0)throw new z(`Cannot find any save handlers for URL '${t}'`);if(l.length>1)throw new z(`Found more than one (${l.length}) save handlers for URL '${t}'`);t=l[0]}if(t.save==null)throw new z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Mr.encodeWeights(this.getNamedWeights(e)),o=!1,s=null,a={modelTopology:this.toJSON(s,o),format:v8,generatedBy:`TensorFlow.js tfjs-layers v${Hm}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:c,specs:p}=await Mr.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...p),n.data=Mr.concatenateArrayBuffers([n.data,c])}return this.userDefinedMetadata!=null&&(FS(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=n.data,a.weightSpecs=n.specs,t.save(a)}setUserDefinedMetadata(t){FS(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};Vn.className="Model";et.registerClass(Vn);var Py=class extends Vn{};Py.className="Functional";et.registerClass(Py);async function X$(r,t){"modelTopology"in r||(r={modelTopology:r}),r=r;let e=r.modelTopology;e.model_config!=null&&(e=e.model_config);let n=Fc(e),o=vn(n,t);if(r.weightsManifest!=null){let s=await Mr.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(a=>a.originalName)),i={};for(let a of o.weights)i[a.originalName]=s[a.originalName];o.loadWeights(i),_t(s)}return o}async function Y$(r,t){if(t==null&&(t={}),typeof r=="string"){let e=Mr.getLoadHandlers(r,t);if(e.length===0)e.push(Mr.browserHTTPRequest(r,t));else if(e.length>1)throw new z(`Found more than one (${e.length}) load handlers for URL '${r}'`);r=e[0]}return C8(r,void 0,t)}async function C8(r,t,e){if(e==null&&(e={}),r.load==null)throw new z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=e.strict==null?!0:e.strict,i=n.weightData!=null&&n.weightSpecs!=null&&s,a=vn(Fc(o),t,i),u=n.trainingConfig;if(u!=null&&a.loadTrainingConfig(u),n.userDefinedMetadata!=null&&a.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:c}=I8(n.weightData,n.weightSpecs);a.loadWeights(l,s),a.optimizer!=null&&c.length>0&&await a.optimizer.setWeights(c),_t(l),_t(c.map(p=>p.tensor))}return a}function I8(r,t){let e=Mr.decodeWeights(r,t),n={},o=[];return t.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:e[s.name]}):n[s.name]=e[s.name]}),{modelWeights:n,optimizerWeights:o}}var Yi=class extends Vn{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:au("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new z(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Yi||t instanceof Vn,n;if(e){if(n=t,n.outputs.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=xy({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=_S(this.outputs[0])}this.inboundNodes=[],new ul({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ko(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Jt(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Vn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new Wr("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},o=!1){let s,i={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new z("Legacy serialization format not supported yet.");s=e}else x.assert(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,i=e;let a=new t(i);if(!(a instanceof Yi))throw new Nt(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let u of s){let c=vn(u,void 0,o);o&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(t){if(this.model==null)throw new z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}};Yi.className="Sequential";et.registerClass(Yi);function S8(r){return new Vn(r)}function k8(r){return new Yi(r)}function N8(r,t){return t==null&&(t={}),Y$(r,t)}function PS(r){return xy(r)}function T8(r,t){wn.registerCallbackConstructor(r,t)}var tn=class extends et.Serializable{getConfig(){return{}}},Ly=class extends tn{apply(t,e=1){return h$(t,e)}};Ly.className="elu";et.registerClass(Ly);var zy=class extends tn{apply(t){return pc(t)}};zy.className="selu";et.registerClass(zy);var By=class extends tn{apply(t){return Tr(t)}};By.className="relu";et.registerClass(By);var Vy=class extends tn{apply(t){return B(()=>ei(6,Tr(t)))}};Vy.className="relu6";et.registerClass(Vy);var Gy=class extends tn{apply(t){return t}};Gy.className="linear";et.registerClass(Gy);var Wy=class extends tn{apply(t){return Lr(t)}};Wy.className="sigmoid";et.registerClass(Wy);var Uy=class extends tn{apply(t){return x$(t)}};Uy.className="hardSigmoid";et.registerClass(Uy);var Hy=class extends tn{apply(t){return bo(t)}};Hy.className="softplus";et.registerClass(Hy);var qy=class extends tn{apply(t){return g$(t)}};qy.className="softsign";et.registerClass(qy);var Ky=class extends tn{apply(t){return Ys(t)}};Ky.className="tanh";et.registerClass(Ky);var Km=class extends tn{apply(t,e=-1){return nl(t,e)}};Km.className="softmax";et.registerClass(Km);var jy=class extends tn{apply(t,e=-1){return nc(t,e)}};jy.className="logSoftmax";et.registerClass(jy);var Xy=class extends tn{apply(t,e=1){return B(()=>O(Lr(O(t,e)),t))}};Xy.className="swish";et.registerClass(Xy);var Yy=class extends tn{apply(t){return B(()=>O(t,Ys(bo(t))))}};Yy.className="mish";et.registerClass(Yy);function ui(r){return r.getClassName()}function LS(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"activation")}function ci(r){if(r==null){let t={};return t.className="linear",t.config={},LS(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},LS(t)}else return r instanceof tn?r:LS(r)}function zS(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var Zy=class extends et.Serializable{},pu=class extends Zy{constructor(t){super(),zS(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return B(()=>{let e=ye([1]);return this.hasL1&&(e=J(e,mt(O(this.l1,Ne(t))))),this.hasL2&&(e=J(e,mt(O(this.l2,Sc(t))))),M(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};pu.className="L1L2";et.registerClass(pu);function Q$(r){return zS(r),new pu({l1:r!=null?r.l1:null,l2:0})}function tD(r){return zS(r),new pu({l2:r!=null?r.l2:null,l1:0})}var Z$={l1l2:"L1L2"};function me(r){return Sm(r)}function J$(r,t={}){return qi(r,et.SerializationMap.getMap().classNameMap,t,"regularizer")}function Ce(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in Z$?Z$[r]:r,config:{}};return J$(e)}else return r instanceof Zy?r:J$(r)}var jm=class extends Vt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=Pt(t);let n=Tr(t);return this.maxValue!=null&&(n=br(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};jm.className="ReLU";et.registerClass(jm);var Xm=class extends Vt{constructor(t){super(t==null?{}:t),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Pt(t);return Ya(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Xm.className="LeakyReLU";et.registerClass(Xm);var Ym=class extends Vt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=de(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ce(t.alphaRegularizer),this.alphaConstraint=Ue(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new z(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Jt(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)e[o-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<t.length;++o)n[o]=t[o];this.inputSpec=[new ve({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=Pt(t),el(t,this.alpha.read())}getConfig(){let t={alphaInitializer:Ee(this.alphaInitializer),alphaRegularizer:me(this.alphaRegularizer),alphaConstraint:We(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};Ym.className="PReLU";et.registerClass(Ym);var Zm=class extends Vt{constructor(t){if(super(t==null?{}:t),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Nt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=Pt(t);return Js(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Zm.className="ELU";et.registerClass(Zm);var Jm=class extends Vt{constructor(t){super(t==null?{}:t),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let n=Pt(t);return O(n,Z(Ge(n,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};Jm.className="ThresholdedReLU";et.registerClass(Jm);var Qm=class extends Vt{constructor(t){super(t==null?{}:t),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Km().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let n=Pt(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};Qm.className="Softmax";et.registerClass(Qm);function mu(r,t,e){if(typeof r=="number")return ko(r,t);if(r.length!==t)throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let o=r[n];if(!p$(o))throw new z(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function An(r,t,e,n,o=1){if(r==null)return r;let s=t+(t-1)*(o-1),i;return e==="same"?i=r:i=r-s+1,Math.floor((i+n-1)/n)}function pi(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+ai([e-t,0]);else if(n==="same")r=r*t;else throw new z(`Unsupport padding mode: ${n}.`);return r}function eg(r,t){return B(()=>(Le(t),t==="channelsFirst"?Mt(r,[0,2,3,1]):r))}function BS(r,t){return B(()=>(Le(t),t==="channelsFirst"?Mt(r,[0,2,3,4,1]):r))}function E8(r,t,e,n=1,o="valid",s,i=1){return B(()=>{if(s==null&&(s=gn()),Le(s),r.shape.length!==3)throw new z(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new z(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new z(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(r=Mt(r,[0,2,1])),o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Zu(r,t,n,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=xn(a,e)),a})}function eD(r,t,e,n=[1,1],o="valid",s,i,a=null){return B(()=>{if(s==null&&(s=gn()),Le(s),r.rank!==3&&r.rank!==4)throw new z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=eg(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Co.conv2d({x:u,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(u=Mt(u,[0,3,1,2])),u})}function A8(r,t,e,n=[1,1,1],o="valid",s,i){return B(()=>{if(s==null&&(s=gn()),Le(s),r.rank!==4&&r.rank!==5)throw new z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=BS(r,s);if(o==="causal")throw new Nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=xh(a,t,n,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=xn(a,e)),s==="channelsFirst"&&(a=Mt(a,[0,4,1,2,3])),a})}var Oc=class extends Vt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Oc.verifyArgs(e),this.rank=t,er(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=mu(e.kernelSize,t,"kernelSize"),this.strides=mu(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,hn(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Le(this.dataFormat),this.activation=ci(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=de(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ue(e.biasConstraint),this.biasRegularizer=Ce(e.biasRegularizer),this.activityRegularizer=Ce(e.activityRegularizer),this.dilationRate=mu(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Qn("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!iy(t.kernelSize,"number",1,3))throw new z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ui(this.activation),useBias:this.useBias,biasInitializer:Ee(this.biasInitializer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),biasConstraint:We(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},fu=class extends Oc{constructor(t,e){super(t,e),this.kernel=null,fu.verifyArgs(e),this.filters=e.filters,er(this.filters,"filters"),this.kernelInitializer=de(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ue(e.kernelConstraint),this.kernelRegularizer=Ce(e.kernelRegularizer)}build(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[e]}`);let n=t[e],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return B(()=>{t=Pt(t);let n,o=this.bias==null?null:this.bias.read(),s=ay(this.activation.getClassName());if(s!=null&&this.rank===2)n=eD(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=E8(t,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=eD(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=A8(t,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Nt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=Jt(t);let e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=An(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[t[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let t={filters:this.filters,kernelInitializer:Ee(this.kernelInitializer),kernelRegularizer:me(this.kernelRegularizer),kernelConstraint:We(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},pl=class extends fu{constructor(t){super(2,t),pl.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!iy(t.kernelSize,"number",1,2))throw new z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};pl.className="Conv2D";et.registerClass(pl);var ml=class extends fu{constructor(t){super(3,t),ml.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};ml.className="Conv3D";et.registerClass(ml);var tf=class extends pl{constructor(t){if(super(t),this.inputSpec=[new ve({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Jt(t),t.length!==4)throw new z("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{let n=Pt(t);if(n.shape.length!==4)throw new z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let u=o[i],l=o[a],c=this.kernelSize[0],p=this.kernelSize[1],m=this.strides[0],f=this.strides[1],d=pi(u,m,c,this.padding),h=pi(l,f,p,this.padding),g=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Mt(n,[0,2,3,1]));let y=Ju(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Mt(y,[0,3,1,2])),this.bias!=null&&(y=xn(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=Jt(t);let e=t.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return e[n]=this.filters,e[o]=pi(e[o],u,i,this.padding),e[s]=pi(e[s],l,a,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};tf.className="Conv2DTranspose";et.registerClass(tf);var ef=class extends ml{constructor(t){if(super(t),this.inputSpec=[new ve({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Jt(t),t.length!==5)throw new z("Input should have rank 5; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new z("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ve({ndim:5,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{let n=Pt(t);if(n.shape.length!==5)throw new z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a,u;this.dataFormat==="channelsFirst"?(u=2,i=3,a=4):(u=1,i=2,a=3);let l=o[u],c=o[i],p=o[a],m=this.kernelSize[0],f=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],g=this.strides[1],y=this.strides[2],b=pi(l,h,m,this.padding),w=pi(c,g,f,this.padding),v=pi(p,y,d,this.padding),k=[s,b,w,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Mt(n,[0,2,3,4,1]));let E=BI(n,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Mt(E,[0,4,1,2,3])),this.bias!==null&&(E=xn(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(t){t=Jt(t);let e=t.slice(),n,o,s,i;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,i=4):(n=4,o=1,s=2,i=3);let a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],p=this.strides[1],m=this.strides[2];return e[n]=this.filters,e[o]=pi(e[o],c,a,this.padding),e[s]=pi(e[s],p,u,this.padding),e[i]=pi(e[i],m,l,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};ef.className="Conv3DTranspose";et.registerClass(ef);var Jy=class extends fu{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=de(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ce(e.depthwiseRegularizer),this.depthwiseConstraint=Ue(e.depthwiseConstraint),this.pointwiseInitializer=de(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ce(e.pointwiseRegularizer),this.pointwiseConstraint=Ue(e.pointwiseConstraint)}build(t){if(t=Jt(t),t.length<this.rank+2)throw new z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let n=t[e],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new ve({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return B(()=>{t=Pt(t);let n;if(this.rank===1)throw new Nt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Mt(t,[0,2,3,1])),n=$h(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=xn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Mt(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Ee(this.depthwiseInitializer),t.pointwiseInitializer=Ee(this.pointwiseInitializer),t.depthwiseRegularizer=me(this.depthwiseRegularizer),t.pointwiseRegularizer=me(this.pointwiseRegularizer),t.depthwiseConstraint=We(this.depthwiseConstraint),t.pointwiseConstraint=We(this.pointwiseConstraint),t}};Jy.className="SeparableConv";var rf=class extends Jy{constructor(t){super(2,t)}};rf.className="SeparableConv2D";et.registerClass(rf);var du=class extends fu{constructor(t){super(1,t),du.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!iy(t.kernelSize,"number",1,1))throw new z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};du.className="Conv1D";et.registerClass(du);var nf=class extends Vt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return B(()=>{if(t=Pt(t),this.dataFormat==="channelsLast"){let n=Hh(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Hh(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Hh(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Hh(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};nf.className="Cropping2D";et.registerClass(nf);var of=class extends Vt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,u$(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{let e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return B(()=>{let n=Pt(t),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Mt(n,[0,2,3,1]);let s=this.size[0]*o[2],i=this.size[1]*o[3],a=this.interpolation==="nearest"?dn.resizeNearestNeighbor(n,[s,i]):dn.resizeBilinear(n,[s,i]);return Mt(a,[0,3,1,2])}else{let s=this.size[0]*o[1],i=this.size[1]*o[2];return this.interpolation==="nearest"?dn.resizeNearestNeighbor(n,[s,i]):dn.resizeBilinear(n,[s,i])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};of.className="UpSampling2D";et.registerClass(of);function $8(r,t,e=[1,1],n="valid",o,s){return B(()=>{o==null&&(o=gn()),Le(o);let i=eg(r,o);if(r.rank!==4)throw new z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new z(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Zs(i,t,e,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=Mt(i,[0,3,1,2])),i})}var sf=class extends Oc{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=de(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ue(t.depthwiseConstraint),this.depthwiseRegularizer=Ce(t.depthwiseRegularizer)}build(t){if(t=Jt(t),t.length<4)throw new z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let n=t[e],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{t=Pt(t);let n=$8(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=xn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=An(e,this.kernelSize[0],this.padding,this.strides[0]),i=An(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],o,s,i]:[t[0],s,i,o]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Ee(this.depthwiseInitializer),t.depthwiseRegularizer=me(this.depthwiseRegularizer),t.depthwiseConstraint=We(this.depthwiseRegularizer),t}};sf.className="DepthwiseConv2D";et.registerClass(sf);function VS(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new z("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:r,initialState:t,constants:e}}function GS(r,t,e,n=!1,o,s,i=!1,a=!1){return B(()=>{let u=t.shape.length;if(u<3)throw new z(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Jr(2,u));if(t=Mt(t,l),s!=null)throw new Nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=Z(Z(o,"bool"),"float32"),o.rank===u-1&&(o=fr(o,-1)),o=Mt(o,l)),n&&(t=ir(t,0),o!=null&&(o=ir(o,0)));let c=[],p,m=e,f=t.shape[0],d=vr(t),h;o!=null&&(h=vr(o));for(let y=0;y<f;++y){let b=d[y],w=B(()=>r(b,m));if(o==null)p=w[0],m=w[1];else{let v=B(()=>{let k=h[y],E=lt(dr(k),k),$=J(O(w[0],k),O(m[0],E)),D=m.map((R,P)=>J(O(w[1][P],k),O(R,E)));return{output:$,newStates:D}});p=v.output,m=v.newStates}a&&c.push(p)}let g;return a&&(g=Je(c,1)),[p,g,m]})}var $n=class extends Vt{constructor(t){super(t);let e;if(t.cell==null)throw new z("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Lc({cells:t.cell}):e=t.cell,e.stateSize==null)throw new z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new ve({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Jr(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){gy(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let n=e[0],o;if(this.returnSequences?o=[t[0],t[1],n]:o=[t[0],n],this.returnState){let s=[];for(let i of e)s.push([t[0],i]);return[o].concat(s)}else return o}computeMask(t,e){return B(()=>{Array.isArray(e)&&(e=e[0]);let n=this.returnSequences?e:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Nt("Constants support is not implemented in RNN yet.");gy(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new ve({shape:[n,null,...o]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!x.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new ve({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ye([n,o])):this.states_=[ye([n,this.cell.stateSize])];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>ye([n,o])):this.states_[0]=ye([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let o=0;o<this.states_.length;++o){let s=t[o],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,a=[n,i];if(!x.arraysEqual(s.shape,a))throw new z(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Pe(o.clone()))})}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=VS(t,n,o,this.numConstants);t=s.inputs,n=s.initialState,o=s.constants;let i=[],a=[];if(n!=null){e.initialState=n,i=i.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new ve({shape:l.shape}));a=a.concat(this.stateSpec)}if(o!=null&&(e.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof Qr){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return B(()=>{let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;t=Pt(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new z(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:o},l=GS((d,h)=>{let g=this.cell.call([d].concat(h),a);return[g[0],g.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),c=l[0],p=l[1],m=l[2];this.stateful&&this.resetStates(m,o);let f=this.returnSequences?p:c;return this.returnState?[f].concat(m):f})}getInitialState(t){return B(()=>{let e=ye(t.shape);return e=mt(e,[1,2]),e=ll(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?fy(e,[1,n]):e):this.cell.stateSize>1?[fy(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===$n.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){let o=e.cell,s=vn(o,n);return new t(Object.assign(e,{cell:s}))}};$n.className="RNN";et.registerClass($n);var fl=class extends Vt{},Mc=class extends fl{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,er(this.units,"units"),this.activation=ci(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Cc([1,ai([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cc([1,ai([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Jt(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new z(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let o=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=Eo(O(t,i),this.kernel.read()):s=Eo(t,this.kernel.read()),this.bias!=null&&(s=xn(s,this.bias.read())),a!=null&&(n=O(n,a));let u=J(s,Eo(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:ui(this.activation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}};Mc.className="SimpleRNNCell";et.registerClass(Mc);var af=class extends $n{constructor(t){t.cell=new Mc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return new t(e)}};af.className="SimpleRNN";et.registerClass(af);var Pc=class extends fl{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new z("GRUCell does not support reset_after parameter set to true.");this.units=t.units,er(this.units,"units"),this.activation=ci(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ci(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Cc([1,ai([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cc([1,ai([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Jt(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return B(()=>{if(t=t,t.length!==2)throw new z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training==null?!1:e.training,o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(t),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,u,l;0<this.dropout&&this.dropout<1&&(t=O(t,s[0]));let c=Eo(t,this.kernel.read());this.useBias&&(c=xn(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=O(o,i[0]));let p=this.recurrentKernel.read(),[m,f]=ur(p,[2*this.units,this.units],p.rank-1),d=Eo(o,m),[h,g,y]=ur(c,3,c.rank-1),[b,w]=ur(d,2,d.rank-1);a=this.recurrentActivation.apply(J(h,b)),u=this.recurrentActivation.apply(J(g,w));let v=Eo(O(u,o),f);l=this.activation.apply(J(y,v));let k=J(O(a,o),O(J(1,Zt(a)),l));return[k,k]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:ui(this.activation),recurrentActivation:ui(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}};Pc.className="GRUCell";et.registerClass(Pc);var lf=class extends $n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Pc(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};lf.className="GRU";et.registerClass(lf);var dl=class extends fl{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,er(this.units,"units"),this.activation=ci(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ci(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=de(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ce(t.kernelRegularizer),this.recurrentRegularizer=Ce(t.recurrentRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.kernelConstraint=Ue(t.kernelConstraint),this.recurrentConstraint=Ue(t.recurrentConstraint),this.biasConstraint=Ue(t.biasConstraint),this.dropout=Cc([1,ai([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cc([1,ai([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Jt(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;o=new(e=class extends bn{apply(u,l){let c=s.apply([i]),p=new uu().apply([i]),m=s.apply([i*2]);return TS(TS(c,p),m)}},e.className="CustomInit",e)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return B(()=>{let n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1],s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(t),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,u,l,c,p;0<this.dropout&&this.dropout<1&&(t=O(t,i[0]));let m=Eo(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=O(o,a[0])),m=J(m,Eo(o,this.recurrentKernel.read())),this.useBias&&(m=xn(m,this.bias.read()));let[f,d,h,g]=ur(m,4,m.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(d),c=J(O(l,s),O(u,this.activation.apply(h))),p=this.recurrentActivation.apply(g);let y=O(p,this.activation.apply(c));return[y,y,c]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:ui(this.activation),recurrentActivation:ui(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),recurrentInitializer:Ee(this.recurrentInitializer),biasInitializer:Ee(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:me(this.kernelRegularizer),recurrentRegularizer:me(this.recurrentRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),recurrentConstraint:We(this.recurrentConstraint),biasConstraint:We(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}};dl.className="LSTMCell";et.registerClass(dl);var uf=class extends $n{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new dl(t),super(t)}call(t,e){return B(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};uf.className="LSTM";et.registerClass(uf);var Lc=class extends fl{constructor(t){super(t),this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return B(()=>{t=t;let n=t.slice(1),o=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?o.push(n.splice(0,a.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let u=this.cells[a];n=o[a],a===0?i=[t[0]].concat(n):i=[i[0]].concat(n),i=u.call(i,e),s.push(i.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[i[0]].concat(n)})}build(t){gy(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,o)=>{ii(`RNNCell_${o}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(e)};return Object.assign({},t,o)}static fromConfig(t,e,n={}){let o=[];for(let s of e.cells)o.push(vn(s,n));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return Kh(t)}setWeights(t){let e=[];for(let n of this.cells){let o=n.weights.length,s=t.splice(o);for(let i=0;i<n.weights.length;++i)e.push([n.weights[i],s[i]])}Pm(e)}};Lc.className="StackedRNNCells";et.registerClass(Lc);function hl(r){let{ones:t,rate:e,training:n=!1,count:o=1,dropoutFunc:s}=r,i=()=>s!=null?s(t(),e):hy(t(),e),a=()=>lu(i,t,n);return!o||o<=1?Pe(a().clone()):Array(o).fill(void 0).map(a).map(l=>Pe(l.clone()))}var D8=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,n=Object.getOwnPropertySymbols(r);o<n.length;o++)t.indexOf(n[o])<0&&Object.prototype.propertyIsEnumerable.call(r,n[o])&&(e[n[o]]=r[n[o]]);return e};var Qy=class extends $n{constructor(t){if(t.unroll)throw new Nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Nt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ve({ndim:5})]}call(t,e){return B(()=>{if(this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new z("ConvRNN2D cell does not support constants");let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return B(()=>{let{stateSize:e}=this.cell,n=t.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],i=ye(s);return Array.isArray(e)?Array(e.length).fill(i):[i]})}resetStates(t,e=!1){B(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ye(s)):this.states_=[ye(s)];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ye(s)):this.states_[0]=ye(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let a=0;a<this.states_.length;++a){let u=t[a],l=s;if(!x.arraysEqual(u.shape,l))throw new z(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Pe(a.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:n,kernelSize:o,padding:s,strides:i,dilationRate:a}=this.cell,u=e==="channelsFirst",l=t[u?3:2],c=t[u?4:3],p=An(l,o[0],s,i[0],a[0]),m=An(c,o[1],s,i[1],a[1]);return[...t.slice(0,2),...u?[n,p,m]:[p,m,n]]}};Qy.className="ConvRNN2D";var zc=class extends dl{constructor(t){let{filters:e,kernelSize:n,strides:o,padding:s,dataFormat:i,dilationRate:a}=t;super(Object.assign({},t,{units:e})),this.filters=e,er(this.filters,"filters"),this.kernelSize=mu(n,2,"kernelSize"),this.kernelSize.forEach(u=>er(u,"kernelSize")),this.strides=mu(o||1,2,"strides"),this.strides.forEach(u=>er(u,"strides")),this.padding=s||"valid",hn(this.padding),this.dataFormat=i||"channelsLast",Le(this.dataFormat),this.dilationRate=mu(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>er(u,"dilationRate"))}build(t){var e;t=Jt(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new z(`The channel dimension of the input should be defined. Found ${t[n]}`);let o=t[n],s=4,i=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,c=this.filters;u=new(e=class extends bn{apply(m,f){let d=l.apply([c]),h=lr([c]),g=l.apply([c*2]);return Nm([d,h,g])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return B(()=>{if(t.length!==3)throw new z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training||!1,o=t[0],s=t[1],i=t[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=hl({ones:()=>dr(o),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(st,it,ft)=>!it||!it[ft]?st:O(it[ft],st),c=l(o,u,0),p=l(o,u,1),m=l(o,u,2),f=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=hl({ones:()=>dr(s),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,h=l(s,d,0),g=l(s,d,1),y=l(s,d,2),b=l(s,d,3),w=3,[v,k,E,$]=ur(this.kernel.read(),a,w),[D,R,P,W]=this.useBias?ur(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,v,D,this.padding),p=this.inputConv(p,k,R,this.padding),m=this.inputConv(m,E,P,this.padding),f=this.inputConv(f,$,W,this.padding);let[U,q,K,j]=ur(this.recurrentKernel.read(),a,w);h=this.recurrentConv(h,U),g=this.recurrentConv(g,q),y=this.recurrentConv(y,K),b=this.recurrentConv(b,j);let Q=this.recurrentActivation.apply(J(c,h)),rt=this.recurrentActivation.apply(J(p,g)),X=J(O(rt,i),O(Q,this.activation.apply(J(m,y)))),ot=O(this.recurrentActivation.apply(J(f,b)),this.activation.apply(X));return[ot,ot,X]})}getConfig(){let t=super.getConfig(),{units:e}=t,n=D8(t,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,o)}inputConv(t,e,n,o){let s=pn(t,e,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?xn(s,n,this.dataFormat):s}recurrentConv(t,e){return pn(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};zc.className="ConvLSTM2DCell";et.registerClass(zc);var cf=class extends Qy{constructor(t){let e=new zc(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}};cf.className="ConvLSTM2D";et.registerClass(cf);var Bc=class extends Vt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?e[o]:this.noiseShape[o]);return n}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);if(0<this.rate&&this.rate<1){let o=e.training==null?!1:e.training,s=this.getNoiseShape(n);return lu(()=>hy(n,this.rate,s,this.seed),()=>n,o)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};Bc.className="Dropout";et.registerClass(Bc);var pf=class extends Bc{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};pf.className="SpatialDropout1D";et.registerClass(pf);var mf=class extends Vt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,er(this.units,"units"),this.activation=ci(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=de(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=de(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ue(t.kernelConstraint),this.biasConstraint=Ue(t.biasConstraint),this.kernelRegularizer=Ce(t.kernelRegularizer),this.biasRegularizer=Ce(t.biasRegularizer),this.activityRegularizer=Ce(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Jt(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Jt(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=ay(this.activation.getClassName()),s;return o!=null?s=Eo(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=Eo(n,this.kernel.read()),this.bias!=null&&(s=xn(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let t={units:this.units,activation:ui(this.activation),useBias:this.useBias,kernelInitializer:Ee(this.kernelInitializer),biasInitializer:Ee(this.biasInitializer),kernelRegularizer:me(this.kernelRegularizer),biasRegularizer:me(this.biasRegularizer),activityRegularizer:me(this.activityRegularizer),kernelConstraint:We(this.kernelConstraint),biasConstraint:We(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};mf.className="Dense";et.registerClass(mf);var ff=class extends Vt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Jt(t);for(let e of t.slice(1))if(e==null)throw new z(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],_o(t,1)]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Mt(n,o)}return d$(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};ff.className="Flatten";et.registerClass(ff);var df=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.activation=ci(t.activation)}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);return this.activation.apply(n)})}getConfig(){let t={activation:ui(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};df.className="Activation";et.registerClass(df);var hf=class extends Vt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return B(()=>(t=Pt(t),m$(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};hf.className="RepeatVector";et.registerClass(hf);var gf=class extends Vt{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let n="Total size of new array must be unchanged.",o=e.slice(),s=1,i=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(i===null)i=u;else throw new z("Can only specifiy one unknown dimension.");else s*=l}let a=_o(t);if(i!==null){if(s===0||a%s!==0)throw new z(n);o[i]=a/s}else if(a!==s)throw new z(n);return o}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return M(n,s)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};gf.className="Reshape";et.registerClass(gf);var xf=class extends Vt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=Jr(1,t.dims.length+1);if(!x.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ve({ndim:this.dims.length+1})]}computeOutputShape(t){t=Jt(t);let e=t.slice();return this.dims.forEach((n,o)=>{e[o+1]=t[n]}),e}call(t,e){return Mt(Pt(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};xf.className="Permute";et.registerClass(xf);var yf=class extends Vt{constructor(t){super(t==null?{}:t),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let n=Pt(t),o=-1;return Zl(vo(n,this.maskValue),o)}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t),o=-1,s=!0,i=Zl(vo(n,this.maskValue),o,s);return O(n,Z(i,n.dtype))})}};yf.className="Masking";et.registerClass(yf);var bf=class extends Vt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(we(t.inputLength))}this.inputDim=t.inputDim,er(this.inputDim,"inputDim"),this.outputDim=t.outputDim,er(this.outputDim,"outputDim"),this.embeddingsInitializer=de(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ce(t.embeddingsRegularizer),this.activityRegularizer=Ce(t.activityRegularizer),this.embeddingsConstraint=Ue(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return B(()=>this.maskZero?(t=Pt(t),vo(t,St(t))):null)}computeOutputShape(t){if(t=Jt(t),this.inputLength==null)return[...t,this.outputDim];let e=we(this.inputLength);if(e.length!==t.length-1)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let o=0;o<e.length;++o){let s=e[o],i=t[o+1];if(s!=null&&i!=null&&s!==i)throw new z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(e[n]=i),n++}}return[t[0],...e,this.outputDim]}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);n.dtype!=="int32"&&(n=Ic(n,"int32"));let o=dy(this.embeddings.read(),M(n,[n.size]));return M(o,Jt(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ee(this.embeddingsInitializer),embeddingsRegularizer:me(this.embeddingsRegularizer),activityRegularizer:me(this.activityRegularizer),embeddingsConstraint:We(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};bf.className="Embedding";et.registerClass(bf);var gl=class extends Vt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Nt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let o=0;o<e.length;++o){let s=t[t.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new z("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(s)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Jt(t)]),t=t,t.length<2)throw new z(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=To(e),e.length>1)throw new z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){let i=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=t.map(s=>s.length);t.indexOf(null)===-1&&To(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return B(()=>{if(t=t,this.reshapeRequired){let n=[],o=t.map(s=>s.rank);if(o.indexOf(null)===-1){let s=ai(o);for(let i of t){let a=i.rank;for(let u=0;u<s-a;++u)i=ll(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let u of t){let l=u.rank;if(l==null){let c=u.shape,p=c[0],m=c.slice(1).concat([p]),f=M(u,[p].concat(_o(c.slice(1))));f=Mt(f,[1,0]),f=M(f,m),n.push(f),s=!0}else if(l>1){let c=Jr(1,l).concat([0]);n.push(Mt(u,c)),s=!0}else n.push(u)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let u=i.shape,l=u.length,c=u[l-1],p=[c].concat(u.slice(0,u.length-1));i=M(Mt(M(i,[-1,c]),[1,0]),p)}else if(a>1){let u=[a-1].concat(Jr(0,a-1));i=Mt(i,u)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let o=1;o<t.length;++o){let s=t[o]==null?null:t[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let n=[];for(let o of t)o!=null&&o[0]!==null&&n.push(o[0]);return n=To(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return B(()=>{if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an Array");if(!Array.isArray(t))throw new z("`inputs` should be an Array");if(e.length!==t.length)throw new z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:fr(o,0));let n=e[0];for(let o=1;o<e.length-1;++o)n=Nr(n,e[o]);return n})}},wf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return e})}};wf.className="Add";et.registerClass(wf);var vf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=O(e,t[n]);return e})}};vf.className="Multiply";et.registerClass(vf);var Cf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=J(e,t[n]);return O(1/t.length,e)})}};Cf.className="Average";et.registerClass(Cf);var If=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=fn(e,t[n]);return e})}};If.className="Maximum";et.registerClass(If);var Sf=class extends gl{constructor(t){super(t)}mergeFunction(t){return B(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=ei(e,t[n]);return e})}};Sf.className="Minimum";et.registerClass(Sf);var kf=class extends gl{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new z("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let o of t)if(o!=null){e=!1;break}if(e)return;let n=[];for(let o=0;o<t.length;++o){let s=t[o].slice();s.splice(this.axis,1);let i=!1;for(let a of n)if(x.arraysEqual(a,s)){i=!0;break}i||n.push(s)}if(n.length>1)throw new z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return B(()=>Nm(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new z("A `Concatenate` layer should be called on a list of inputs.");let e=t,n=e[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of e.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new z("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new z("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new z(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return B(()=>{let n=!0;if(e.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let o=[];for(let i=0;i<t.length;++i)e[i]==null?o.push(Z(dr(t[i]),"bool")):e[i].rank<t[i].rank?o.push(fr(e[i],-1)):o.push(e[i]);let s=se(o,this.axis);return ju(s,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};kf.className="Concatenate";et.registerClass(kf);function rg(r,t){for(;r<0;)r+=t;return r}function R8(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new Nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(x.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),x.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new Nt("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=t.shape.length;e==null&&(e=[n-1,o-2]);let s=e;return B(()=>{let i;if(n>o){i=n-o;let u=[];for(let l=0;l<i;++l)u.push(1);t=M(t,t.shape.concat(u))}else if(o>n){i=o-n;let u=[];for(let l=0;l<i;++l)u.push(1);r=M(r,r.shape.concat(u))}else i=0;let a;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?a=mt(O(r,t),s[0]):a=mt(O(Mt(r,[1,0]),t),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===t.shape.length-1;a=zt(r,t,u,l)}if(i>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let c=u;c<u+i;++c)l.push(c);a=zr(a,l)}return a.shape.length===1&&(a=fr(a,1)),a})}var Nf=class extends gl{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){x.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],n=t[1];if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);if(e[o[0]]!==n[o[1]])throw new z(`Dimension incompatibility: ${e[o[0]]} !== ${n[o[1]]}`)}mergeFunction(t){if(t.length!==2)throw new z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,i)=>rg(s,t[i].shape.length)):o=[rg(this.axes,e.shape.length),rg(this.axes,n.shape.length)],this.normalize&&(e=jh(e,o[0]),n=jh(n,o[1])),R8(e,n,o)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[rg(this.axes,t.length),rg(this.axes,e.length)],n}computeOutputShape(t){x.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new Nt("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(e,n);e.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=e.concat(n);return s.length===1&&s.push(1),s}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};Nf.className="Dot";et.registerClass(Nf);var Tf=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);return lu(()=>J(Tm(n.shape,0,this.stddev),n),()=>n,e.training||!1)})}};Tf.className="GaussianNoise";et.registerClass(Tf);var _f=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{this.invokeCallHook(t,e);let n=Pt(t);return this.rate>0&&this.rate<1?lu(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return O(n,Tm(n.shape,1,s))},()=>n,e.training||!1):n})}};_f.className="GaussianDropout";et.registerClass(_f);var Ef=class extends Vt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Pt(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return B(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return lu(()=>{let s=Pt(t),i=1.6732632423543772,a=1.0507009873554805,u=-i*a,l=Tn(ri(n),this.rate);l=Ic(l,"float32");let c=((1-this.rate)*(1+this.rate*u**2))**-.5,p=-c*u*this.rate,m=J(O(s,l),O(J(l,-1),u));return J(O(m,c),p)},()=>Pt(t),e.training||!1)}return t})}};Ef.className="AlphaDropout";et.registerClass(Ef);function ng(r,t,e,n,o,s=.001){let i;if(r.rank===2)i=DI(r,t,e,n,o,s);else if(r.rank===3)i=RI(r,t,e,n,o,s);else if(r.rank===4)i=FI(r,t,e,n,o,s);else throw new Nt(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function F8(r,t,e,n,o=.001){return B(()=>{let s=ym(r,n),i=s.mean,a=s.variance;return[ng(r,i,a,e,t,o),i,a]})}function O8(r,t,e,n,o=.001){return B(()=>{let s=ym(r,n),i=s.mean,a=s.variance,u=[];for(let d of Jr(0,r.rank))n.indexOf(d)!==-1?u.push(1):u.push(r.shape[d]);let l=M(i,u),c=M(a,u),p=t==null?null:M(t,u),m=e==null?null:M(e,u);return[ng(r,l,c,m,p,o),i,a]})}function M8(r,t,e,n,o=.001){return x.arraysEqual(n.slice().sort(),Jr(0,r.rank-1))?F8(r,t,e,n,o):O8(r,t,e,n,o)}var Af=class extends Vt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=de(t.betaInitializer||"zeros"),this.gammaInitializer=de(t.gammaInitializer||"ones"),this.movingMeanInitializer=de(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=de(t.movingVarianceInitializer||"ones"),this.betaConstraint=Ue(t.betaConstraint),this.gammaConstraint=Ue(t.gammaConstraint),this.betaRegularizer=Ce(t.betaRegularizer),this.gammaRegularizer=Ce(t.gammaRegularizer)}build(t){t=Jt(t);let e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new z(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new ve({ndim:t.length,axes:{[e]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return B(()=>{let n=e.training==null?!1:e.training,o=Pt(t),s=o.shape,i=s.length,a=Jr(0,i),u=this.axis>=0?this.axis:this.axis+i;a.splice(u,1);let l=ko(1,i);l[u]=s[u];let c=a.slice();c.sort();let p=!x.arraysEqual(c,Jr(0,i).slice(0,i-1)),m=()=>{if(p){let b=M(this.movingMean.read(),l),w=M(this.movingVariance.read(),l),v=this.center?M(this.beta.read(),l):null,k=this.scale?M(this.gamma.read(),l):null;return ng(o,b,w,v,k,this.epsilon)}else return ng(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[f,d,h]=M8(o,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(b,w,v)=>{B(()=>{let k=1-v,E=b.read(),$=O(lt(E,w),k);b.write(lt(E,$))})};return(()=>{g(this.movingMean,d,this.momentum),g(this.movingVariance,h,this.momentum)})(),f})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ee(this.betaInitializer),gammaInitializer:Ee(this.gammaInitializer),movingMeanInitializer:Ee(this.movingMeanInitializer),movingVarianceInitializer:Ee(this.movingVarianceInitializer),betaRegularizer:me(this.betaRegularizer),gammaRegularizer:me(this.gammaRegularizer),betaConstraint:We(this.betaConstraint),gammaConstraint:We(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};Af.className="BatchNormalization";et.registerClass(Af);var $f=class extends Vt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=de(t.betaInitializer||"zeros"),this.gammaInitializer=de(t.gammaInitializer||"ones"),this.betaRegularizer=Ce(t.betaRegularizer),this.gammaRegularizer=Ce(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Jt(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(let s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==To(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>t[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(t,e){let n=Pt(t),o=n.shape,s=o.length;return B(()=>{let{mean:a,variance:u}=ym(n,this.axis,!0),l=ko(1,s);for(let h of this.axis)l[h]=o[h];let c=h=>h!=null&&h.shape.length!==s?M(h,l):h,p=c(this.gamma.read()),m=c(this.beta.read()),f=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(f.push(o[h]),d.push(1)):(f.push(1),d.push(o[h]));return a=kr(a,f),u=kr(u,f),p=kr(p,d),m=kr(m,d),ng(n,a,u,m,p,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ee(this.betaInitializer),gammaInitializer:Ee(this.gammaInitializer),betaRegularizer:me(this.betaRegularizer),gammaRegularizer:me(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};$f.className="LayerNormalization";et.registerClass($f);function P8(r,t,e){return B(()=>{if(r.rank!==4)throw new z(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=gn()),e!=="channelsLast"&&e!=="channelsFirst")throw new z(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Yr(r,n)})}var Df=class extends Vt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?gn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){t=Jt(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return B(()=>P8(Pt(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};Df.className="ZeroPadding2D";et.registerClass(Df);function sb(r,t,e,n,o,s){return B(()=>{Le(o),IS(s),hn(n),e==null&&(e=[1,1]),n==null&&(n="valid"),o==null&&(o=gn()),s==null&&(s="max"),r=eg(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=Qa(r,t,e,a):i=qa(r,t,e,a),o==="channelsFirst"&&(i=Mt(i,[0,3,1,2])),i})}function rD(r,t,e,n,o,s){return B(()=>{Le(o),IS(s),hn(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),o==null&&(o=gn()),s==null&&(s="max"),r=BS(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=Th(r,t,e,a):i=dh(r,t,e,a),o==="channelsFirst"&&(i=Mt(i,[0,4,1,2,3])),i})}var tb=class extends Vt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(er(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);er(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,hn(this.padding),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(t){t=Jt(t);let e=An(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=ll(Pt(t),2);let n=this.poolingFunction(Pt(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return zr(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},Rf=class extends tb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),sb(t,e,n,o,s,"max")}};Rf.className="MaxPooling1D";et.registerClass(Rf);var Ff=class extends tb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),sb(t,e,n,o,s,"avg")}};Ff.className="AveragePooling1D";et.registerClass(Ff);var eb=class extends Vt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];er(this.poolSize,"poolSize"),er(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),hn(this.padding),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=An(e,this.poolSize[0],this.padding,this.strides[0]),n=An(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Pt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Of=class extends eb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),sb(t,e,n,o,s,"max")}};Of.className="MaxPooling2D";et.registerClass(Of);var Mf=class extends eb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),sb(t,e,n,o,s,"avg")}};Mf.className="AveragePooling2D";et.registerClass(Mf);var rb=class extends Vt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];er(this.poolSize,"poolSize"),er(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),hn(this.padding),this.inputSpec=[new ve({ndim:5})]}computeOutputShape(t){t=Jt(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],o=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=An(e,this.poolSize[0],this.padding,this.strides[0]),n=An(n,this.poolSize[1],this.padding,this.strides[1]),o=An(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,o]:[t[0],e,n,o,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Pt(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Pf=class extends rb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),rD(t,e,n,o,s,"max")}};Pf.className="MaxPooling3D";et.registerClass(Pf);var Lf=class extends rb{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Le(s),hn(o),rD(t,e,n,o,s,"avg")}};Lf.className="AveragePooling3D";et.registerClass(Lf);var nb=class extends Vt{constructor(t){super(t),this.inputSpec=[new ve({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Nt}},zf=class extends nb{constructor(t){super(t||{})}call(t,e){return B(()=>{let n=Pt(t);return xe(n,1)})}};zf.className="GlobalAveragePooling1D";et.registerClass(zf);var Bf=class extends nb{constructor(t){super(t||{})}call(t,e){return B(()=>{let n=Pt(t);return Dr(n,1)})}};Bf.className="GlobalMaxPooling1D";et.registerClass(Bf);var ob=class extends Vt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Le(this.dataFormat),this.inputSpec=[new ve({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Nt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Vf=class extends ob{call(t,e){return B(()=>{let n=Pt(t);return this.dataFormat==="channelsLast"?xe(n,[1,2]):xe(n,[2,3])})}};Vf.className="GlobalAveragePooling2D";et.registerClass(Vf);var Gf=class extends ob{call(t,e){return B(()=>{let n=Pt(t);return this.dataFormat==="channelsLast"?Dr(n,[1,2]):Dr(n,[2,3])})}};Gf.className="GlobalMaxPooling2D";et.registerClass(Gf);var ib=class extends Vt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let o=e.layer,s=vn(o,n);delete e.layer;let i={layer:s};return Object.assign(i,e),new t(i)}},Wf=class extends ib{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=Jt(t),t.length<3)throw new z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Jt(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),o=t[1];return[n[0],o].concat(n.slice(1))}call(t,e){return B(()=>(t=Pt(t),GS((i,a)=>[Pt(this.layer.call(i,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};Wf.className="TimeDistributed";et.registerClass(Wf);function L8(r){Ki(a$,"BidirectionalMergeMode",r)}var z8="concat",Uf=class extends ib{constructor(t){super(t);let e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=vn(n),e.goBackwards=e.goBackwards!==!0;let o={};if(o.className=t.layer.getClassName(),o.config=e,this.backwardLayer=vn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?z8:t.mergeMode,L8(this.mergeMode),t.weights)throw new Nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,o,s;return this.returnState&&(s=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):_r(o)}apply(t,e){let n=e==null?null:e.initialState,o=e==null?null:e.constants;e==null&&(e={});let s=VS(t,n,o,this.numConstants);if(t=s.inputs,n=s.initialState,o=s.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&o==null)return super.apply(t,e);let i=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,i.push(...n);let c=n.map(p=>new ve({shape:p.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),a.push(...c)}if(o!=null)throw new Nt("Support for constants in Bidirectional layers is not implemented yet.");let u=i[0]instanceof Qr;for(let l of i)if(l instanceof Qr!==u)throw new z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[t].concat(i),c=this.inputSpec.concat(a),p=this.inputSpec;this.inputSpec=c;let m=super.apply(l,e);return this.inputSpec=p,m}else return super.apply(t,e)}call(t,e){return B(()=>{let n=e.initialState,o,s;if(n==null)o=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let i;this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=ir(s,1));let a;return this.mergeMode==="concat"?a=Nm([o,s]):this.mergeMode==="sum"?a=J(o,s):this.mergeMode==="ave"?a=O(.5,J(o,s)):this.mergeMode==="mul"?a=O(o,s):this.mergeMode==null&&(a=[o,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){ii(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),ii(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let n=vn(e.layer);if(delete e.layer,e.numConstants!=null)throw new Nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=e;return o.layer=n,new t(o)}};Uf.className="Bidirectional";et.registerClass(Uf);function B8(r){return new li(r)}function V8(r){return new Zm(r)}function G8(r){return new jm(r)}function W8(r){return new Xm(r)}function U8(r){return new Ym(r)}function H8(r){return new Qm(r)}function q8(r){return new Jm(r)}function K8(r){return new du(r)}function j8(r){return new pl(r)}function X8(r){return new tf(r)}function Y8(r){return new ml(r)}function Z8(r){return new ef(r)}function J8(r){return new rf(r)}function Q8(r){return new nf(r)}function tY(r){return new of(r)}function eY(r){return new sf(r)}function rY(r){return new df(r)}function nY(r){return new mf(r)}function oY(r){return new Bc(r)}function sY(r){return new pf(r)}function iY(r){return new ff(r)}function aY(r){return new hf(r)}function lY(r){return new gf(r)}function uY(r){return new xf(r)}function cY(r){return new bf(r)}function pY(r){return new wf(r)}function mY(r){return new Cf(r)}function fY(r){return new kf(r)}function dY(r){return new If(r)}function hY(r){return new Sf(r)}function gY(r){return new vf(r)}function xY(r){return new Nf(r)}function yY(r){return new Af(r)}function bY(r){return new $f(r)}function wY(r){return new Df(r)}function WS(r){return new Ff(r)}function vY(r){return WS(r)}function CY(r){return WS(r)}function US(r){return new Mf(r)}function IY(r){return US(r)}function SY(r){return US(r)}function HS(r){return new Lf(r)}function kY(r){return HS(r)}function NY(r){return HS(r)}function TY(r){return new zf(r)}function _Y(r){return new Vf(r)}function nD(r){return new Bf(r)}function oD(r){return new Gf(r)}function sD(r){return new Rf(r)}function iD(r){return new Of(r)}function EY(r){return new Pf(r)}function AY(r){return new lf(r)}function $Y(r){return new Pc(r)}function DY(r){return new uf(r)}function RY(r){return new dl(r)}function FY(r){return new af(r)}function OY(r){return new Mc(r)}function MY(r){return new cf(r)}function PY(r){return new zc(r)}function LY(r){return new $n(r)}function zY(r){return new Lc(r)}function BY(r){return new Uf(r)}function VY(r){return new Wf(r)}var GY=nD,WY=oD,UY=sD,HY=iD;function qY(r){return new Tf(r)}function KY(r){return new _f(r)}function jY(r){return new Ef(r)}function XY(r){return new yf(r)}var lD={};Yt(lD,{MAPE:()=>i7,MSE:()=>u7,binaryAccuracy:()=>YY,binaryCrossentropy:()=>ZY,categoricalAccuracy:()=>QY,categoricalCrossentropy:()=>t7,cosineProximity:()=>n7,mape:()=>a7,meanAbsoluteError:()=>o7,meanAbsolutePercentageError:()=>s7,meanSquaredError:()=>l7,mse:()=>c7,precision:()=>e7,recall:()=>r7,sparseCategoricalAccuracy:()=>JY});function YY(r,t){return Zh(r,t)}function ZY(r,t){return _y(r,t)}function JY(r,t){return Ey(r,t)}function QY(r,t){return Jh(r,t)}function t7(r,t){return Qh(r,t)}function e7(r,t){return $S(r,t)}function r7(r,t){return R$(r,t)}function n7(r,t){return Yh(r,t)}function o7(r,t){return Gm(r,t)}function s7(r,t){return cu(r,t)}function i7(r,t){return cu(r,t)}function a7(r,t){return cu(r,t)}function l7(r,t){return Xi(r,t)}function u7(r,t){return Xi(r,t)}function c7(r,t){return Xi(r,t)}var uD={};Yt(uD,{modelFromJSON:()=>X$});var cD={};Yt(cD,{l1:()=>m7,l1l2:()=>p7,l2:()=>f7});function p7(r){return new pu(r)}function m7(r){return Q$(r)}function f7(r){return tD(r)}var lb=class extends cl{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof Vn))throw new Error("model must be a LayersModel, not some other Container");this.model=t}};function ab(r,t){return r<t}function pD(r,t){return r>t}var ub=class extends lb{constructor(t){if(super(),t==null&&(t={}),t.restoreBestWeights)throw new Nt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=ab:this.mode==="max"?this.monitorFunc=pD:this.monitor.indexOf("acc")!==-1?this.monitorFunc=pD:this.monitorFunc=ab,this.monitorFunc===ab&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===ab?1/0:-1/0}async onEpochEnd(t,e){await ji(e);let n=this.getMonitorValue(e);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}};function d7(r){return new ub(r)}var h7={earlyStopping:d7};var g7=V();g7.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var to;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(to||(to={}));var mD;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(mD||(mD={}));var qS={};function y7(r,t){let e={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t};qS[r]=e}function cb(r){return qS[r]}function b7(r){delete qS[r]}function I(r,t,e,n,o){let s=t.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return Cr(t.inputNames[s.inputIndexStart],e,n,o);if(s.type==="tensors")return t.inputNames.slice(a,u).map(m=>Cr(m,e,n,o));let l=Cr(t.inputNames.slice(a)[0],e,n,o),c=l.dataSync();return s.type==="number"?c[0]:x.toNestedArray(l.shape,c)}let i=t.attrParams[r];return i&&i.value}function Cr(r,t,e,n){let[o,s]=Cn(r);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!t[pb(o,a)]);return i!==void 0?t[pb(o,i)][s]:void 0}function fD(r,t,e){return t[pb(r,e.currentContextId)]}function Do(r,t){let[e,n,o]=Cn(r);return[pb(e,t&&t.currentContextId),n,o]}function pb(r,t){return t?`${r}-${t}`:r}function Cn(r){let t=r.split(":");if(t.length===1)return[r,0,void 0];let e=t[0],n=t.length===3?t[1]:void 0,o=Number(t[t.length-1]);return[e,o,n]}function og(r,t,e){let n=I("pad",r,t,e);if(n==="explicit"){n=I("explicitPaddings",r,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function mi(r){return r.kept?r:kn(r)}var KS={};Yt(KS,{json:()=>w7});var w7=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var jS={};Yt(jS,{json:()=>v7});var v7=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var XS={};Yt(XS,{json:()=>C7});var C7=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var YS={};Yt(YS,{json:()=>I7});var I7=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var ZS={};Yt(ZS,{json:()=>S7});var S7=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var JS={};Yt(JS,{json:()=>k7});var k7=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var QS={};Yt(QS,{json:()=>N7});var N7=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var tk={};Yt(tk,{json:()=>T7});var T7=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var ek={};Yt(ek,{json:()=>_7});var _7=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var rk={};Yt(rk,{json:()=>E7});var E7=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var nk={};Yt(nk,{json:()=>A7});var A7=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var ok={};Yt(ok,{json:()=>$7});var $7=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var sk={};Yt(sk,{json:()=>D7});var D7=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var ik={};Yt(ik,{json:()=>R7});var R7=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var ak={};Yt(ak,{json:()=>F7});var F7=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var lk={};Yt(lk,{json:()=>O7});var O7=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var uk={};Yt(uk,{json:()=>M7});var M7=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var ck={};Yt(ck,{json:()=>P7});var P7=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var pk={};Yt(pk,{json:()=>L7});var L7=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var sg=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[KS,jS,XS,YS,ZS,JS,QS,tk,ek,rk,nk,ok,sk,ik,ak,lk,uk,ck,pk],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(t,e={}){let n=t.node,o=[],s=[],i=[],a=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),u=[],l=[],c={},p={};e!=null&&(c=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let m=Object.keys(a);m.forEach(h=>{let g=a[h];g.inputNames.forEach((y,b)=>{let[w,,v]=Do(y),k=a[w];if(k.outputs!=null){let E=k.outputs.indexOf(v);if(E!==-1){let $=`${w}:${E}`;g.inputNames[b]=$}}g.inputs.push(k),k.children.push(g)})}),Object.keys(p).length===0?m.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(p).forEach(h=>{let[g]=Do(h),y=a[g];y!=null&&(y.signatureKey=p[h],l.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=Do(h),y=a[g];y&&(y.signatureKey=c[h],u.push(y))}):u=o;let f={};t.library!=null&&t.library.function!=null&&(f=t.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:e,functions:f};return i.length>0&&(d.initNodes=i),d}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=cb(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=mb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=mb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=bb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=bb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=db(t.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=db(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=yb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=yb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=fb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=fb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=vb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=vb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=xb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=xb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=wb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=wb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=hb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=hb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=gb(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=gb(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=dD(t.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=dD(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(t){let e=t.nodeDef,n=[],o=[],s={};e!=null&&(s=e.reduce((p,m)=>(p[m.name]=this.mapNode(m),m.op==="Const"&&o.push(p[m.name]),p),{}));let i=[],a=[];t.signature.inputArg.forEach(p=>{let[m]=Do(p.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:mk(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),s[m]=f}),Object.keys(s).forEach(p=>{let m=s[p];m.inputNames.forEach((f,d)=>{let[h,,g]=Do(f),y=s[h];if(y.outputs!=null){let b=y.outputs.indexOf(g);if(b!==-1){let w=`${h}:${b}`;m.inputNames[d]=w}}m.inputs.push(y),y.children.push(m)})});let l=t.ret;t.signature.outputArg.forEach(p=>{let[m,f]=Do(l[p.name]),d=s[m];d!=null&&(d.defaultOutput=f,a.push(d))});let c=this.mapArgsToSignature(t);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:c}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function z7(r){let t=V().global;if(typeof t.atob!="undefined")return t.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function hD(r,t){let e=Array.isArray(r)?String.fromCharCode.apply(null,r):z7(r);return t?e:e.toLowerCase()}function mb(r,t,e,n=!1){let o=r[t];return o!=null?hD(o.s,n):e}function fb(r,t,e){let n=r[t];return n?n.b:e}function db(r,t,e){let n=r[t]||{},o=n.i!=null?n.i:n.f!=null?n.f:e;return typeof o=="number"?o:parseInt(o,10)}function mk(r){switch(typeof r=="string"&&(r=to[r]),r){case to.DT_FLOAT:case to.DT_HALF:return"float32";case to.DT_INT32:case to.DT_INT64:case to.DT_INT8:case to.DT_UINT8:return"int32";case to.DT_BOOL:return"bool";case to.DT_DOUBLE:return"float32";case to.DT_STRING:return"string";default:return null}}function dD(r,t,e){let n=r[t];return n&&n.func?n.func.name:e}function hb(r,t,e){let n=r[t];return n&&n.type?mk(n.type):e}function gb(r,t,e){let n=r[t];return n&&n.list&&n.list.type?n.list.type.map(o=>mk(o)):e}function gD(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function xb(r,t,e){let n=r[t];return n&&n.shape?gD(n.shape):e}function yb(r,t,e){let n=r[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function bb(r,t,e,n=!1){let o=r[t];return o&&o.list&&o.list.s?o.list.s.map(s=>hD(s,n)):e}function wb(r,t,e){let n=r[t];return n&&n.list&&n.list.shape?n.list.shape.map(o=>gD(o)):e}function vb(r,t,e){let n=r[t];return n&&n.list&&n.list.b?n.list.b:e}var Cb=class{constructor(t,e,n){this.node=t,this.tensorMap=e,this.context=n,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return Cr(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return Cr(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return db(this.node.rawAttrs,t,e);if(n.s!=null)return mb(this.node.rawAttrs,t,e);if(n.b!=null)return fb(this.node.rawAttrs,t,e);if(n.shape!=null)return xb(this.node.rawAttrs,t,e);if(n.type!=null)return hb(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return yb(this.node.rawAttrs,t,e);if(n.list.s!=null)return bb(this.node.rawAttrs,t,e);if(n.list.shape!=null)return wb(this.node.rawAttrs,t,e);if(n.list.b!=null)return vb(this.node.rawAttrs,t,e);if(n.list.type!=null)return gb(this.node.rawAttrs,t,e)}return e}};var xD=(r,t,e)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[J(I("a",r,t,e),I("b",r,t,e))];case"AddN":return[_I(I("tensors",r,t,e))];case"FloorMod":case"Mod":return[Eh(I("a",r,t,e),I("b",r,t,e))];case"Mul":return[O(I("a",r,t,e),I("b",r,t,e))];case"RealDiv":case"Div":return[ct(I("a",r,t,e),I("b",r,t,e))];case"DivNoNan":return[wh(I("a",r,t,e),I("b",r,t,e))];case"FloorDiv":return[Ku(I("a",r,t,e),I("b",r,t,e))];case"Sub":return[lt(I("a",r,t,e),I("b",r,t,e))];case"Minimum":return[ei(I("a",r,t,e),I("b",r,t,e))];case"Maximum":return[fn(I("a",r,t,e),I("b",r,t,e))];case"Pow":return[Zr(I("a",r,t,e),I("b",r,t,e))];case"SquaredDifference":return[hc(I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var yD=(r,t,e)=>{switch(r.op){case"Abs":case"ComplexAbs":return[Ne(I("x",r,t,e))];case"Acos":return[ih(I("x",r,t,e))];case"Acosh":return[ah(I("x",r,t,e))];case"Asin":return[uh(I("x",r,t,e))];case"Asinh":return[ch(I("x",r,t,e))];case"Atan":return[ph(I("x",r,t,e))];case"Atan2":return[mh(I("x",r,t,e),I("y",r,t,e))];case"Atanh":return[fh(I("x",r,t,e))];case"Ceil":return[gh(I("x",r,t,e))];case"Complex":return[zn(I("real",r,t,e),I("imag",r,t,e))];case"Cos":return[Xa(I("x",r,t,e))];case"Cosh":return[Qu(I("x",r,t,e))];case"Elu":return[Js(I("x",r,t,e))];case"Erf":return[vh(I("x",r,t,e))];case"Exp":return[Ze(I("x",r,t,e))];case"Expm1":return[Ch(I("x",r,t,e))];case"Floor":return[ti(I("x",r,t,e))];case"Log":return[wr(I("x",r,t,e))];case"Log1p":return[Za(I("x",r,t,e))];case"Imag":return[ec(I("x",r,t,e))];case"Neg":return[Zt(I("x",r,t,e))];case"Reciprocal":return[Ah(I("x",r,t,e))];case"Real":return[tu(I("x",r,t,e))];case"Relu":return[Tr(I("x",r,t,e))];case"Round":return[uc(I("x",r,t,e))];case"Selu":return[pc(I("x",r,t,e))];case"Sigmoid":return[Lr(I("x",r,t,e))];case"Sin":return[mc(I("x",r,t,e))];case"Sign":return[Dh(I("x",r,t,e))];case"Sinh":return[fc(I("x",r,t,e))];case"Softplus":return[bo(I("x",r,t,e))];case"Sqrt":return[be(I("x",r,t,e))];case"Square":return[Ut(I("x",r,t,e))];case"Tanh":return[Ys(I("x",r,t,e))];case"Tan":return[Mh(I("x",r,t,e))];case"ClipByValue":return[br(I("x",r,t,e),I("clipValueMin",r,t,e),I("clipValueMax",r,t,e))];case"Relu6":return[lc(I("x",r,t,e))];case"Rsqrt":return[cc(Cr(r.inputNames[0],t,e))];case"Prod":return[sc(I("x",r,t,e),I("axes",r,t,e))];case"LeakyRelu":return[Ya(I("x",r,t,e),I("alpha",r,t,e))];case"Prelu":return[el(I("x",r,t,e),I("alpha",r,t,e))];case"IsNan":return[Ih(Cr(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Gn(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){x.assert(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=t[n];x.assert(o<0||s<0||o===s,()=>e+` Shapes ${r} and ${t} must match`)}}}function bD(r){return!(typeof r=="number"||r.some(t=>t<0))}function Hf(r,t,e){let n=Ib(r,e),o=!bD(n);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&t.forEach(s=>{n=Ib(s.shape,n)}),!bD(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function Ib(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let e=[];for(let n=0;n<r.length;++n){let o=r[n],s=t[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[n]=o>=0?o:s}return e}var Sb=class{constructor(t,e,n,o,s,i,a){this.name=t,this.dtype=e,this.maxSize=n,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=pt(0),Pe(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Gn(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Pe(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,o)=>this.write(n,e[o]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return Ar([],[0].concat(this.elementShape));let n=this.readMany(t);return Gn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Je(n,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return Ar([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let n=this.readMany(e);return Gn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),se(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,vr(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,o=t.map(u=>(n+=u,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:e.size/n,i=[];B(()=>{e=M(e,[1,n,s]);for(let u=0;u<t.length;++u){let l=u===0?0:o[u-1],c=[0,l,0],p=[1,t[u],s];i[u]=M(Rt(e,c,p),this.elementShape)}return i});let a=[];for(let u=0;u<t.length;u++)a[u]=u;this.writeMany(a,i)}};var xl=class{constructor(t,e,n,o=-1){this.tensors=t,this.elementShape=e,this.elementDtype=n,t!=null&&t.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Gn(e,s.shape,"TensorList shape mismatch: "),Pe(s)}),this.idTensor=pt(0),this.maxNumElements=o,Pe(this.idTensor)}get id(){return this.idTensor.id}copy(){return new xl([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Gn(t,this.elementShape,"TensorList shape mismatch: ");let o=Hf(this.elementShape,this.tensors,t);return B(()=>{let s=this.tensors.map(i=>M(i,o));return Je(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Hf(this.elementShape,this.tensors,t),o=this.tensors.pop();return Gn(o.shape,t,"TensorList shape mismatch: "),M(o,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Gn(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Pe(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let e=new xl([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Gn(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=Hf(this.elementShape,this.tensors,e);return M(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Gn(this.elementShape,e.shape,"TensorList shape mismatch: "),Pe(e),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Gn(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=Hf(this.elementShape,this.tensors,n);return t.length===0?Ar([],[0].concat(o)):B(()=>{let s=t.map(i=>M(this.tensors[i],o));return Je(s,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Gn(this.elementShape,e,"TensorList shape mismatch: ");let n=Hf(this.elementShape,this.tensors,e);return this.size()===0?Ar([],[0].concat(n)):B(()=>{let o=this.tensors.map(s=>M(s,n));return se(o,0)})}};function wD(r,t,e){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);let o=r.shape.slice(1);Gn(o,t,"TensorList shape mismatch: ");let s=vr(r);return new xl(s,t,n)}function vD(r,t,e){return new xl([],r,t,e)}function CD(r,t,e,n){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let o=Math.max(...t);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new xl([],e,r.dtype,n),i=vr(r,0);return t.forEach((a,u)=>{s.setItem(a,i[u])}),s}function ID(r,t,e){let n=0,o=t.map(c=>(n+=c,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=Ib(s,e),a=n===0?0:r.size/n,u=B(()=>{let c=[];r=M(r,[1,n,a]);for(let p=0;p<t.length;++p){let m=p===0?0:o[p-1],f=[0,m,0],d=[1,t[p],a];c[p]=M(Rt(r,f,d),i)}return r.dispose(),c}),l=new xl([],e,r.dtype,t.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}var SD=async(r,t,e)=>{switch(r.op){case"If":case"StatelessIf":{let n=I("thenBranch",r,t,e),o=I("elseBranch",r,t,e),s=I("cond",r,t,e),i=I("args",r,t,e);return(await s.data())[0]?e.functionMap[n].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let n=I("body",r,t,e),o=I("cond",r,t,e),s=I("args",r,t,e),i=await e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=s;for(;u[0];){let c=l;l=await e.functionMap[n].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);let p=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()});let m=await e.functionMap[o].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&p.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=I("pred",r,t,e);return[mi(n)]}case"Switch":{let n=I("pred",r,t,e),o=I("data",r,t,e);return o.kept||(o=mi(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Cr(o,t,e)!==void 0);if(n){let o=Cr(n,t,e);return[mi(o)]}return}case"Enter":{let n=I("frameName",r,t,e),o=I("tensor",r,t,e);return e.enterFrame(n),[mi(o)]}case"Exit":{let n=I("tensor",r,t,e);return e.exitFrame(),[mi(n)]}case"NextIteration":{let n=I("tensor",r,t,e);return e.nextIteration(),[mi(n)]}case"TensorArrayV3":{let n=I("size",r,t,e),o=I("dtype",r,t,e),s=I("elementShape",r,t,e),i=I("dynamicSize",r,t,e),a=I("clearAfterRead",r,t,e),u=I("identicalElementShapes",r,t,e),l=I("name",r,t,e),c=new Sb(l,o,n,s,u,i,a);return e.addTensorArray(c),[c.idTensor,pt(1)]}case"TensorArrayWriteV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=I("tensorArrayId",r,t,e),o=I("index",r,t,e);return[e.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("dtype",r,t,e);return[e.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=I("tensorArrayId",r,t,e),o=I("indices",r,t,e),s=I("tensor",r,t,e),i=e.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id),s=I("dtype",r,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let n=I("tensorArrayId",r,t,e),o=I("tensor",r,t,e),s=I("lengths",r,t,e),i=e.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return[pt(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=I("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("tensor",r,t,e),i=e.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=I("tensorListId",r,t,e),o=I("index",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=I("indices",r,t,e),o=I("tensor",r,t,e),s=I("elementShape",r,t,e),i=I("numElements",r,t,e),a=CD(o,n,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=I("elementShape",r,t,e),o=I("elementDType",r,t,e),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=I(s,r,t,e),a=vD(n,o,i);return e.addTensorList(a),[a.idTensor]}case"TensorListGather":{let n=I("tensorListId",r,t,e),o=I("indices",r,t,e),s=I("elementShape",r,t,e),i=I("elementDType",r,t,e);return[e.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=I("numElements",r,t,e);return[e.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e),i=wD(n,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id),s=I("dtype",r,t,e),i=I("elementShape",r,t,e);return[o.concat(s,i)]}case"TensorListPushBack":{let n=I("tensorListId",r,t,e),o=I("tensor",r,t,e),s=e.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=I("tensorListId",r,t,e),o=I("elementShape",r,t,e),s=I("elementDType",r,t,e);return[e.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=I("tensor",r,t,e),o=I("elementShape",r,t,e),s=I("lengths",r,t,e),i=ID(n,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let n=I("tensorListId",r,t,e),o=e.getTensorList(n.id);return[pt(o.size(),"int32")]}case"TensorListResize":{let n=I("tensorListId",r,t,e),o=I("size",r,t,e),i=e.getTensorList(n.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function kD(r,t,e){let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=I("numArgs",r,t,e);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=I("strides",r,t,e),p=og(r,t,e),m=I("dataFormat",r,t,e).toUpperCase(),f=I("dilations",r,t,e),[d,h]=I("args",r,t,e);i&&(h=d,d=void 0);let g=I("leakyreluAlpha",r,t,e);return{stride:c,pad:p,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var ND=(r,t,e)=>{switch(r.op){case"Conv1D":{let n=I("stride",r,t,e),o=I("pad",r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilation",r,t,e);return[Zu(I("x",r,t,e),I("filter",r,t,e),n,o,s,i)]}case"Conv2D":{let n=I("strides",r,t,e),o=og(r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilations",r,t,e);return[pn(I("x",r,t,e),I("filter",r,t,e),[n[1],n[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=kD(r,t,e);return[Co.conv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=kD(r,t,e);return[Co.depthwiseConv2d({x:I("x",r,t,e),filter:I("filter",r,t,e),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=I("outputShape",r,t,e),o=I("strides",r,t,e),s=og(r,t,e);return[Ju(I("x",r,t,e),I("filter",r,t,e),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=I("strides",r,t,e),o=og(r,t,e),s=I("dilations",r,t,e),i=I("dataFormat",r,t,e).toUpperCase();return[Zs(I("input",r,t,e),I("filter",r,t,e),[n[1],n[2]],o,i,[s[1],s[2]])]}case"Conv3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("dataFormat",r,t,e).toUpperCase(),i=I("dilations",r,t,e);return[xh(I("x",r,t,e),I("filter",r,t,e),[n[1],n[2],n[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[qa(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[Qa(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e),i=I("includeBatchInIndex",r,t,e),{result:a,indexes:u}=QI(I("x",r,t,e),[s[1],s[2]],[n[1],n[2]],o,i);return[a,u]}case"AvgPool3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[dh(I("x",r,t,e),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("kernelSize",r,t,e);return[Th(I("x",r,t,e),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=I("strides",r,t,e),o=I("pad",r,t,e),s=I("dilations",r,t,e),i=n[1],a=n[2],u=s[1],l=s[2];return[bh(I("x",r,t,e),I("filter",r,t,e),[i,a],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var TD=(r,t,e)=>{switch(r.op){case"Fill":{let n=I("shape",r,t,e),o=I("dtype",r,t,e),s=I("value",r,t,e);return[Qs(n,s,o)]}case"LinSpace":{let n=I("start",r,t,e),o=I("stop",r,t,e),s=I("num",r,t,e);return[qI(n,o,s)]}case"Multinomial":{let n=I("logits",r,t,e),o=I("numSamples",r,t,e),s=I("seed",r,t,e);return[tS(n,o,s)]}case"OneHot":{let n=I("indices",r,t,e),o=I("depth",r,t,e),s=I("onValue",r,t,e),i=I("offValue",r,t,e);return[js(n,o,s,i)]}case"Ones":return[lr(I("shape",r,t,e),I("dtype",r,t,e))];case"OnesLike":return[dr(I("x",r,t,e))];case"RandomUniform":return[ri(I("shape",r,t,e),I("minval",r,t,e),I("maxval",r,t,e),I("dtype",r,t,e))];case"Range":{let n=I("start",r,t,e),o=I("stop",r,t,e),s=I("step",r,t,e);return[rl(n,o,s,I("dtype",r,t,e))]}case"TruncatedNormal":{let n=I("shape",r,t,e),o=I("mean",r,t,e),s=I("stdDev",r,t,e),i=I("seed",r,t,e);return[gc(n,o,s,I("dtype",r,t,e),i)]}case"Zeros":return[ye(I("shape",r,t,e),I("dtype",r,t,e))];case"ZerosLike":return[St(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function fk(r,t,e){let n=I("boxes",r,t,e),o=I("scores",r,t,e),s=I("maxOutputSize",r,t,e),i=I("iouThreshold",r,t,e),a=I("scoreThreshold",r,t,e),u=I("softNmsSigma",r,t,e);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var _D=async(r,t,e)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=fk(r,t,e),l=await dn.nonMaxSuppressionWithScoreAsync(n,o,s,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=fk(r,t,e),u=I("padToMaxOutputSize",r,t,e),l=await dn.nonMaxSuppressionPaddedAsync(n,o,s,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=fk(r,t,e);return[await dn.nonMaxSuppressionAsync(n,o,s,i,a)]}case"Where":{let n=Z(I("condition",r,t,e),"bool"),o=[await zh(n)];return n.dispose(),o}case"ListDiff":return cS(I("x",r,t,e),I("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ED=(r,t,e)=>{switch(r.op){case"TopKV2":{let n=I("x",r,t,e),o=I("k",r,t,e),s=I("sorted",r,t,e),i=Ph(n,o,s);return[i.values,i.indices]}case"Unique":{let n=I("x",r,t,e),o=wm(n);return[o.values,o.indices]}case"UniqueV2":{let n=I("x",r,t,e),o=I("axis",r,t,e),s=wm(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var AD=(r,t,e)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let n=I("default",r,t,e);return[Cr(r.name,t,e)||n];case"Placeholder":return[Cr(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=I("x",r,t,e);return[mi(l)]}case"IdentityN":return I("x",r,t,e).map(l=>mi(l));case"Snapshot":let o=I("x",r,t,e);return[mi(o)];case"Shape":return[Re(I("x",r,t,e).shape,"int32")];case"ShapeN":return I("x",r,t,e).map(l=>Re(l.shape));case"Size":return[pt(I("x",r,t,e).size,"int32")];case"Rank":return[pt(I("x",r,t,e).rank,"int32")];case"NoOp":return[pt(1)];case"Print":let s=I("x",r,t,e),i=I("data",r,t,e),a=I("message",r,t,e),u=I("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var kb=class{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=pt(0),this.tensorMap=new Map,Pe(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),B(()=>{let o=vr(e),s=n.length,i=o.length;x.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];Pe(l),this.tensorMap.set(u,l)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return B(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,e);o.push(a)}return Je(o)})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n!=null?n:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var $D=async(r,t,e,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=I("keyDType",r,t,e),s=I("valueDType",r,t,e),i=new kb(o,s);return n.addHashTable(r.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("values",r,t,e);return[await n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=I("tableHandle",r,t,e,n),s=I("keys",r,t,e),i=I("defaultValue",r,t,e);return[await n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=I("tableHandle",r,t,e,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var DD=(r,t,e)=>{switch(r.op){case"ResizeBilinear":{let n=I("images",r,t,e),o=I("size",r,t,e),s=I("alignCorners",r,t,e),i=I("halfPixelCenters",r,t,e);return[dn.resizeBilinear(n,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{let n=I("images",r,t,e),o=I("size",r,t,e),s=I("alignCorners",r,t,e),i=I("halfPixelCenters",r,t,e);return[dn.resizeNearestNeighbor(n,[o[0],o[1]],s,i)]}case"CropAndResize":{let n=I("image",r,t,e),o=I("boxes",r,t,e),s=I("boxInd",r,t,e),i=I("cropSize",r,t,e),a=I("method",r,t,e),u=I("extrapolationValue",r,t,e);return[dn.cropAndResize(n,o,s,i,a,u)]}case"ImageProjectiveTransformV3":{let n=I("images",r,t,e),o=I("transforms",r,t,e),s=I("outputShape",r,t,e),i=I("fillValue",r,t,e),a=I("interpolation",r,t,e),u=I("fillMode",r,t,e);return[dn.transform(n,o,a.toLowerCase(),u.toLowerCase(),i,s)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var RD=(r,t,e)=>{switch(r.op){case"Equal":return[Sr(I("a",r,t,e),I("b",r,t,e))];case"NotEqual":return[vo(I("a",r,t,e),I("b",r,t,e))];case"Greater":return[Ge(I("a",r,t,e),I("b",r,t,e))];case"GreaterEqual":return[Tn(I("a",r,t,e),I("b",r,t,e))];case"Less":return[rc(I("a",r,t,e),I("b",r,t,e))];case"LessEqual":return[_n(I("a",r,t,e),I("b",r,t,e))];case"LogicalAnd":return[Nr(I("a",r,t,e),I("b",r,t,e))];case"LogicalNot":return[Ja(I("a",r,t,e))];case"LogicalOr":return[oc(I("a",r,t,e),I("b",r,t,e))];case"Select":case"SelectV2":return[_e(I("condition",r,t,e),I("a",r,t,e),I("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var FD=(r,t,e)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[zt(I("a",r,t,e),I("b",r,t,e),I("transposeA",r,t,e),I("transposeB",r,t,e))];case"Einsum":return[WI(I("equation",r,t,e),...I("tensors",r,t,e))];case"Transpose":return[Mt(I("x",r,t,e),I("perm",r,t,e))];case"_FusedMatMul":let[n,o]=I("fusedOps",r,t,e),s=n==="biasadd",i=o==="prelu",a=I("numArgs",r,t,e),u=I("leakyreluAlpha",r,t,e);if(s){if(i&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,c]=I("args",r,t,e);return[Co.matMul({a:I("a",r,t,e),b:I("b",r,t,e),transposeA:I("transposeA",r,t,e),transposeB:I("transposeB",r,t,e),bias:l,activation:o,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var OD=(r,t,e)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[xo(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"FusedBatchNormV3":return[xo(I("x",r,t,e),I("mean",r,t,e),I("variance",r,t,e),I("offset",r,t,e),I("scale",r,t,e),I("epsilon",r,t,e))];case"LRN":return[Sh(I("x",r,t,e),I("radius",r,t,e),I("bias",r,t,e),I("alpha",r,t,e),I("beta",r,t,e))];case"Softmax":return[nl(I("x",r,t,e))];case"LogSoftmax":return[nc(I("x",r,t,e))];case"SparseToDense":return[Hx(I("sparseIndices",r,t,e),I("outputShape",r,t,e),I("sparseValues",r,t,e),I("defaultValue",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var MD=(r,t,e)=>{switch(r.op){case"Max":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Dr(I("x",r,t,e),i,a)]}case"Mean":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[xe(I("x",r,t,e),i,a)]}case"Min":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Ql(I("x",r,t,e),i,a)]}case"Sum":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[mt(I("x",r,t,e),i,a)]}case"All":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[ju(I("x",r,t,e),i,a)]}case"Any":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[Zl(I("x",r,t,e),i,a)]}case"ArgMax":{let i=I("axis",r,t,e);return[Xs(I("x",r,t,e),i)]}case"ArgMin":{let i=I("axis",r,t,e);return[lh(I("x",r,t,e),i)]}case"Prod":{let i=I("axis",r,t,e),a=I("keepDims",r,t,e);return[sc(I("x",r,t,e),i,a)]}case"Cumprod":{let i=I("axis",r,t,e),a=I("exclusive",r,t,e),u=I("reverse",r,t,e);return[Jl(I("x",r,t,e),i,a,u)]}case"Cumsum":{let i=I("axis",r,t,e),a=I("exclusive",r,t,e),u=I("reverse",r,t,e);return[tc(I("x",r,t,e),i,a,u)]}case"Bincount":let n=I("x",r,t,e),o=I("weights",r,t,e),s=I("size",r,t,e);return[hh(n,o,s)];case"DenseBincount":{let i=I("x",r,t,e),a=I("weights",r,t,e),u=I("size",r,t,e),l=I("binaryOutput",r,t,e);return[VI(i,a,u,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var PD=(r,t,e)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=I("n",r,t,e),o=I("axis",r,t,e),s=I("tensors",r,t,e);return s=s.slice(0,n),[se(s,o)]}case"Gather":{let n=I("x",r,t,e),o=I("indices",r,t,e);return[yo(n,Z(o,"int32"),0)]}case"GatherV2":{let n=I("axis",r,t,e),o=I("batchDims",r,t,e),s=I("x",r,t,e),i=I("indices",r,t,e);return[yo(s,Z(i,"int32"),n,o)]}case"Reverse":{let n=I("dims",r,t,e),o=[];for(let i=0;i<n.length;i++)n[i]&&o.push(i);let s=I("x",r,t,e);return[ir(s,o)]}case"ReverseV2":{let n=I("axis",r,t,e),o=I("x",r,t,e);return[ir(o,n)]}case"Slice":{let n=I("begin",r,t,e),o=I("size",r,t,e);return[Rt(I("x",r,t,e),n,o)]}case"StridedSlice":{let n=I("begin",r,t,e),o=I("end",r,t,e),s=I("strides",r,t,e),i=I("beginMask",r,t,e),a=I("endMask",r,t,e),u=I("ellipsisMask",r,t,e),l=I("newAxisMask",r,t,e),c=I("shrinkAxisMask",r,t,e),p=I("x",r,t,e);return[Oh(p,n,o,s,i,a,u,l,c)]}case"Pack":return B(()=>{let n=I("axis",r,t,e),o=I("tensors",r,t,e),s=o[0].shape,i=zr(o[0]).shape,a=o.map(u=>{let l=x.arraysEqual(u.shape,s);if(!l&&!x.arraysEqual(zr(u).shape,i))throw new Error("the input tensors shape does not match");return l?u:M(u,s)});return[Je(a,n)]});case"Unpack":{let n=I("axis",r,t,e),o=I("tensor",r,t,e);return vr(o,n)}case"Tile":{let n=I("reps",r,t,e);return[kr(I("x",r,t,e),n)]}case"Split":case"SplitV":{let n=I("axis",r,t,e),o=I("numOrSizeSplits",r,t,e),s=I("x",r,t,e);return ur(s,o,n)}case"ScatterNd":{let n=I("indices",r,t,e),o=I("values",r,t,e),s=I("shape",r,t,e);return[pE(n,o,s)]}case"GatherNd":{let n=I("x",r,t,e),o=I("indices",r,t,e);return[fE(n,o)]}case"SparseToDense":{let n=I("sparseIndices",r,t,e),o=I("outputShape",r,t,e),s=I("sparseValues",r,t,e),i=I("defaultValue",r,t,e);return[Hx(n,s,o,s.dtype===i.dtype?i:Z(i,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var LD=(r,t,e)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=Bh.sparseFillEmptyRows(I("indices",r,t,e),I("values",r,t,e),I("denseShape",r,t,e),I("defaultValue",r,t,e));return[n,o,s,i]}case"SparseReshape":{let{outputIndices:n,outputShape:o}=Bh.sparseReshape(I("inputIndices",r,t,e),I("inputShape",r,t,e),I("newShape",r,t,e));return[n,o]}case"SparseSegmentMean":return[Bh.sparseSegmentMean(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];case"SparseSegmentSum":return[Bh.sparseSegmentSum(I("data",r,t,e),I("indices",r,t,e),I("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var zD=(r,t,e)=>{switch(r.op){case"FFT":return[ol(I("x",r,t,e))];case"IFFT":return[Wi(I("x",r,t,e))];case"RFFT":return[sl(I("x",r,t,e))];case"IRFFT":return[dc(I("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var BD=(r,t,e)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:o}=ry.stringNGrams(I("data",r,t,e),I("dataSplits",r,t,e),I("separator",r,t,e),I("nGramWidths",r,t,e),I("leftPad",r,t,e),I("rightPad",r,t,e),I("padWidth",r,t,e),I("preserveShortSequences",r,t,e));return[n,o]}case"StringSplit":{let{indices:n,values:o,shape:s}=ry.stringSplit(I("input",r,t,e),I("delimiter",r,t,e),I("skipEmpty",r,t,e));return[n,o,s]}case"StringToHashBucketFast":return[ry.stringToHashBucketFast(I("input",r,t,e),I("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var VD=(r,t,e)=>{switch(r.op){case"Cast":return[Z(I("x",r,t,e),I("dtype",r,t,e))];case"ExpandDims":{let n=I("axis",r,t,e);return[fr(I("x",r,t,e),n)]}case"Squeeze":{let n=I("axis",r,t,e);return[zr(I("x",r,t,e),n)]}case"Reshape":return[M(I("x",r,t,e),I("shape",r,t,e))];case"MirrorPad":return[_h(I("x",r,t,e),I("padding",r,t,e),I("mode",r,t,e))];case"PadV2":case"Pad":return[Yr(I("x",r,t,e),I("padding",r,t,e),I("constantValue",r,t,e))];case"SpaceToBatchND":{let n=I("blockShape",r,t,e),o=I("paddings",r,t,e);return[tl(I("x",r,t,e),n,o)]}case"BatchToSpaceND":{let n=I("blockShape",r,t,e),o=I("crops",r,t,e);return[Ka(I("x",r,t,e),n,o)]}case"DepthToSpace":{let n=I("blockSize",r,t,e),o=I("dataFormat",r,t,e).toUpperCase();return[yh(I("x",r,t,e),n,o)]}case"BroadcastTo":return[ja(I("x",r,t,e),I("shape",r,t,e))];case"BroadcastArgs":return[OI(I("s0",r,t,e),I("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function dk(r,t,e,n){let o=((s,i,a)=>{switch(s.category){case"arithmetic":return B(()=>xD(s,i,a));case"basic_math":return B(()=>yD(s,i,a));case"control":return SD(s,i,a);case"convolution":return B(()=>ND(s,i,a));case"creation":return B(()=>TD(s,i,a));case"dynamic":return _D(s,i,a);case"evaluation":return B(()=>ED(s,i,a));case"image":return B(()=>DD(s,i,a));case"graph":return B(()=>AD(s,i,a));case"logical":return B(()=>RD(s,i,a));case"matrices":return B(()=>FD(s,i,a));case"normalization":return B(()=>OD(s,i,a));case"reduction":return B(()=>MD(s,i,a));case"slice_join":return B(()=>PD(s,i,a));case"sparse":return B(()=>LD(s,i,a));case"spectral":return B(()=>zD(s,i,a));case"string":return B(()=>BD(s,i,a));case"transformation":return B(()=>VD(s,i,a));case"hash_table":return $D(s,i,a,n);case"custom":let u=cb(s.op);if(u&&u.customExecutor)return u.customExecutor(new Cb(s,i,a));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return x.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var ig=class{constructor(t={},e={},n={},o={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=n,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function hk(r,t,e,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=Object.keys(r).map(m=>Cn(m)[0]),c=[];n!=null&&(c=n.map(m=>Cn(m.name)[0]));let p=[...t];for(;p.length>0;){let m=p.pop();if((gk(m)||lZ(m)||uZ(m))&&i==null&&(i=m,a=i.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),e[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:r,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function GD(r,t,e){let{usedNodes:n,inputs:o}=e,s=[],i=Object.keys(o).map(c=>Cn(c)[0]).map(c=>r.nodes[c]),a=r.initNodes;i.forEach(c=>{n.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{n.has(c.name)&&s.push(c)}),a!=null&&a.forEach(c=>{n.has(c.name)&&s.push(c)});let u=new Set,l=[];for(;s.length>0;){let c=s.pop();u.add(c.name),t[c.name]||l.push(c),c.children.forEach(p=>{!u.has(p.name)&&n.has(p.name)&&p.inputs.every(m=>u.has(m.name))&&s.push(p)})}return l}var sZ=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],iZ=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],aZ=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function gk(r){return sZ.indexOf(r.op)>=0}function lZ(r){return iZ.indexOf(r.op)>=0}function uZ(r){return aZ.indexOf(r.op)>=0}var Vc=class{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new Vc(t.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(n=>t[n].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let n=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(t,e){let n=hk(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let a=e.map(l=>l.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return GD(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=n.map(p=>this.graph.nodes[Cn(p)[0]]),s=e.map(p=>Cn(p)[0]),i=s.map(p=>this.graph.nodes[p]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);let a=this.getCompilationKey(o,i),u=this.compiledMap.get(a);u==null&&(u=this.compile(t,i),this.compiledMap.set(a,u));let l={},c={};return B(()=>{let p=new ig(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(t).forEach(h=>{let[g,y]=Cn(h),b=[];b[y]=t[h],m[g]=b});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let y=dk(g,m,p,this._resourceManager);if(x.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=y,this.checkTensorForDisposal(g.name,g,m,p,f,s,d)}}return this.parent==null&&p.dispose(f),e.map(h=>Cr(h,m,p))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,n,o,s,i,a){e.category==="control"||i.indexOf(t)!==-1||(n[t].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+e.children.length)}),e.inputs.forEach(u=>{if(u.category!=="control"){let l=fD(u.name,n,o);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let p=a[c.id];if(p===1){if(!this.keepTensorForDebug)c.dispose();else{let[m,f]=Do(e.name,o);this.intermediateTensors[m]?this.intermediateTensors[m][f]=c:(this.intermediateTensors[m]=[],this.intermediateTensors[m][f]=c)}delete a[c.id]}else p!=null&&a[c.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let t in this.intermediateTensors)this.intermediateTensors[t].forEach(e=>e.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,e,n=!1,o={},s={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepTensorForDebug=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();let i=new ig(this.weightMap,o,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,i,e,n);let a=e.map(c=>Cr(c,this.tensorsMap,i)),u=a.map(c=>c.id),l=Object.keys(t).map(c=>t[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(t,e,n){let o=t.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,o){let s=Object.keys(t),i=s.map(w=>this.graph.nodes[Cn(w)[0]]),a=n.map(w=>Cn(w)[0]),u=a.map(w=>this.graph.nodes[w]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:c,dynamicNode:p,syncInputs:m}=hk(t,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:e.currentContext})),d=Object.assign({},this.weightMap);Object.keys(t).forEach(w=>{let[v,k]=Cn(w),E=[];E[k]=t[w],d[v]=E});let h={},g=this.getFrozenTensorIds(d),y={};for(;f.length>0;){let w=this.processStack(i,f,e,d,y,g,a,h,l);await Promise.all(w)}p==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=u.filter(w=>!gk(w)&&!Cr(w.name,d,e)).map(w=>w.name);if(b.length>0){let w="";throw p!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${w}`)}return d}processStack(t,e,n,o,s,i,a,u,l){let c=[];for(;e.length>0;){let p=e.pop();n.currentContext=p.contexts;let m="";if(p.node.op==="Enter"&&I("isConstant",p.node,o,n)&&([m]=Do(p.node.name,n)),o[p.node.name]==null){let f=dk(p.node,o,n,this._resourceManager);m||([m]=Do(p.node.name,n));let d=n.currentContext;x.isPromise(f)?c.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l),h))):(o[m]=f,this.checkTensorForDisposal(m,p.node,o,n,i,a,u),this.processChildNodes(p.node,e,n,o,s,l))}else this.processChildNodes(p.node,e,n,o,s,l)}return c}processChildNodes(t,e,n,o,s,i){t.children.forEach(a=>{let[u]=Do(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Cr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!Cr(l,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let n=t[e],[o]=Cn(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);x.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&x.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){let e={};for(let n in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];e[o.name]=t[n]}else e[n]=t[n];return e}checkInputs(t){let e=Object.keys(t).filter(n=>{let[o]=Cn(n);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{let[n]=Cn(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}};var Nb=class{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var cZ="?tfjs-format=file",pZ="model.json",Tb=class{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",e==null&&(this.loadOptions={}),this.resourceManager=new Nb}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=Mr.browserHTTPRequest(t,this.loadOptions);else{let e=Mr.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(Mr.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let o=Mr.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Vc(sg.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=sg.Instance.transformGraph(t.modelInitializer);this.initializer=new Vc(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let n=Mr.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof Lt)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,o)=>(e[n]=t[o],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function mZ(r,t={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${pZ}${cZ}`);let e=new Tb(r,t);return await e.load(),e}var WD="3.16.0";var SR={};Yt(SR,{CSVDataset:()=>jf,Dataset:()=>fi,FileDataSource:()=>Qf,TextLineDataset:()=>Kf,URLDataSource:()=>td,array:()=>dR,csv:()=>bR,func:()=>wR,generator:()=>vR,microphone:()=>IR,version_data:()=>Uk,webcam:()=>CR,zip:()=>hR});var fR=Ru(Ik());var cR=Ru(Ik());function sR(r,t){return Eb(r,t)}function Eb(r,t,e=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(hu(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let a=r[i],u=Eb(a,t,e,n);s[i]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,o.value),o.value}function iR(r,t=kk){return aR(r,t)}function aR(r,t,e=new Set){let n=r[0];if(e.has(n))throw new Error("Circular references are not supported.");let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(hu(n)){let s=Array.isArray(n)?[]:{};e.add(n);for(let i in n){let a=r.map(l=>l[i]),u=aR(a,t,e);s[i]=u}return e.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function kk(r){return r===null?null:hu(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function Ab(r,t){let e=new Map;Eb(r,t,e);for(let o of Array.from(e.keys())){let s=e.get(o);if(x.isPromise(s)){let i=await s;e.set(o,i)}}return Eb(r,t,e)}function hu(r){let t=!1;if(V().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:e}=Sk();t=r instanceof e}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Lt)&&!(r instanceof Promise)&&!t)}function lR(r){return r==null||bZ(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Lt||x.isTypedArray(r)}function bZ(r){return r===null||typeof r!="object"&&typeof r!="function"}function uR(r){return sR(r,wZ)}function wZ(r){return r instanceof Lt?{value:r.clone(),recurse:!1}:hu(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var qf=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}};var Wc=class extends qf{constructor(){super(Wc.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),n=this.length();for(let o=0;o<n;o++)e[o]=this.get(this.wrap(this.begin+o));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};Wc.INITIAL_CAPACITY=32;function Lk(r){return new Nk(r)}function ag(r){return new Tk(r)}function pR(r,t){return new Db(r,t)}function mR(r,t=yl.FAIL){return new Mk(r,t)}var rr=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new Fk(this,t)}filter(t){return new Dk(this,t)}map(t){return new Rk(this,t)}mapAsync(t){return new $b(this,t)}serialMapAsync(t){return new $b(this,t).serial()}flatmap(t){return new Ok(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new $k(this,t,e)}columnMajorBatch(t,e=!0,n=kk){return this.rowMajorBatch(t,e).map(s=>iR(s,n))}concatenate(t,e){return new Db(Lk([this,t]),e)}take(t){return t<0||t==null?this:new Ak(this,t)}skip(t){return t<0||t==null?this:new Ek(this,t)}prefetch(t){return new Rb(this,t)}shuffle(t,e){return new Pk(this,t,e)}serial(){return new _k(this)}},Nk=class extends rr{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:uR(t),done:!1}}},Tk=class extends rr{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},_k=class extends rr{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Ek=class extends rr{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;_t(t.value)}return this.upstream.next()}},Ak=class extends rr{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},$k=class extends rr{constructor(t,e,n=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}},Dk=class extends rr{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;_t(t.value)}}},Rk=class extends rr{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=fo.getTensorsInContainer(t.value),n=this.transform(t.value),o=fo.getTensorsInContainer(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},Fk=class extends rr{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},$b=class extends rr{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=fo.getTensorsInContainer(t.value),n=await this.transform(t.value),o=fo.getTensorsInContainer(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},Uc=class extends rr{constructor(){super(),this.outputQueue=new Wc,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Ok=class extends Uc{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=fo.getTensorsInContainer(t.value),n=this.transform(t.value),o=fo.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of e)fo.isTensorInList(s,o)||s.dispose();return!0}},Db=class extends rr{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}},yl;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(yl||(yl={}));var Mk=class extends rr{constructor(t,e=yl.FAIL){super(),this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let e=0,n=0;function o(i){return i instanceof rr?{value:i.next().then(u=>(e++,u.done&&n++,u.value)),recurse:!1}:{value:null,recurse:!0}}let s=await Ab(this.iterators,o);if(e===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case yl.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case yl.SHORTEST:return{value:null,done:!0};case yl.LONGEST:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},Rb=class extends rr{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new qf(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},Pk=class extends Rb{constructor(t,e,n){super(t,e),this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=cR.alea(n||x.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}};var fi=class{constructor(){this.size=null}batch(t,e=!0){let n=this;x.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let o;return this.size===1/0||this.size==null?o=this.size:e?o=Math.ceil(this.size/t):o=Math.floor(this.size/t),Dn(async()=>(await n.iterator()).columnMajorBatch(t,e,vZ),o)}concatenate(t){let e=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,Dn(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===1/0?n=1/0:n=null,Dn(async()=>(await e.iterator()).filter(o=>B(()=>t(o))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Dn(async()=>(await e.iterator()).map(n=>B(()=>t(n))),this.size)}mapAsync(t){let e=this;return Dn(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Dn(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,Dn(async()=>{let o=ag(async()=>({value:await e.iterator(),done:!1}));return pR(o.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,Dn(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=fR.alea(e||x.now().toString());return Dn(async()=>{let i=s.int32();return n&&(i+=s.int32()),(await o.iterator()).shuffle(t,i.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,Dn(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};fi.MAX_BUFFER_SIZE=1e4;function Dn(r,t=null){return new class extends fi{constructor(){super(...arguments),this.size=t}async iterator(){return r()}}}function dR(r){return Dn(async()=>Lk(r),r.length)}function hR(r){if(!hu(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let e=0;e<r.length;e++)t=t==null?r[e].size:Math.min(t,r[e].size);else if(r instanceof Object)for(let e in r)t=t==null?r[e].size:Math.min(t,r[e].size);return Dn(async()=>{let e=await Ab(r,n=>{if(n instanceof fi)return{value:n.iterator(),recurse:!1};if(hu(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return mR(e,yl.SHORTEST)},t)}function vZ(r){if(r===null)return null;let t=r[0];return lR(t)?{value:CZ(r),recurse:!1}:{value:null,recurse:!0}}function CZ(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Lt?Je(r):Ar(r)}var Kf=class extends fi{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var Fb='"',lg=Symbol("out"),gR=Symbol("field"),Ob=Symbol("quote"),zk=Symbol("quoteafterquote"),xR=Symbol("quoteinquote"),jf=class extends fi{constructor(t,e){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Kf(t),e||(e={}),this.hasHeader=e.hasHeader!==!1,this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(x.assert(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&x.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(e).filter(o=>e[o]>1);if(x.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let n=e.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let i=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!a)){let u=e[s],l=null;if(u==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${i} is empty in this line: ${t}`);l=void 0}else{let c=Number(u);if(isNaN(c))a&&a.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!a||!a.dtype)l=c;else switch(a.dtype){case"float32":l=c;break;case"int32":l=Math.floor(c);break;case"bool":l=this.getBoolean(u);break;default:l=c}}a&&a.isLabel?o[i]=l:n[i]=l}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let n=[],o=0,s=t.length,i=lg;for(let a=0;a<s;a++)switch(i){case lg:switch(t.charAt(a)){case Fb:o=a+1,i=Ob;break;case this.delimiter:if(o=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),i=lg;break;default:i=gR,o=a;break}break;case gR:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a)),i=lg,o=a+1;break;default:}break;case Ob:switch(t.charAt(a)){case Fb:i=zk;break;default:}break;case zk:switch(t.charAt(a)){case this.delimiter:n.push(t.substring(o,a-1)),i=lg,o=a+1;break;case Fb:i=Ob;break;default:i=xR;break}break;case xR:switch(t.charAt(a)){case Fb:i=Ob;break;default:}break;default:}if(i===zk?n.push(t.substring(o,s-1)):n.push(t.substring(o)),e&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var Xf=class extends rr{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!V().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let e=new Xf(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],e=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let e=t[0].length,n=new Float32Array(t.length*e);return t.forEach((o,s)=>n.set(o,s*e)),n}getTensorFromAudioDataArray(t,e){let n=new Float32Array(x.sizeFromShape(e));return n.set(t,n.length-t.length),Ar(n,e)}};var Yf=class extends rr{constructor(t,e){if(super(),this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Re([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,i=(1-o)/2,a=s+n,u=o+i;this.cropBox=Ui([i,s,u,a],[1,4])}else this.cropBox=Ui([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(!V().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}let n=new Yf(t,e);return await n.start(),n}async start(){this.webcamConfig.facingMode&&x.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Ax.fromPixels(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return B(()=>{let e=fr(Z(t,"float32"),0),n;n=dn.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return M(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var Zf=class{};var ug=class extends rr{split(t){return new Bk(this,t)}},Bk=class extends ug{constructor(t,e){super(),this.upstream=t,this.impl=new Vk(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Vk=class extends Uc{constructor(t,e){super(),this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let n of e.slice(0,-1))this.outputQueue.push(n);return this.carryover=e[e.length-1],!0}};var Mb=class extends rr{decodeUTF8(){return new Gk(this)}},Gk=class extends ug{constructor(t){super(),this.upstream=t,this.impl=new Wk(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Wk=class extends Uc{constructor(t){if(super(),this.upstream=t,V().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=Sk();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let n;return V().get("IS_BROWSER")?n=this.decoder.decode(e,{stream:!0}):n=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(n),!0}};var Jf=class extends Mb{constructor(t,e={}){super(),this.file=t,this.options=e,x.assert(t instanceof Uint8Array||(V().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=a=>{let u=s.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));e(u)},s.onabort=a=>n(new Error("Aborted")),s.onerror=a=>n(new Error(a.type));let i=this.file.slice(this.offset,o);s.readAsArrayBuffer(i)}this.offset=o}),done:!1}}};async function yR(r,t={},e){let n,o;typeof r=="string"?n=r:(n=r.url,o=IZ(r));let s=await(e||x.fetch)(n,o);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new Jf(i,t)}else throw new Error(s.statusText)}var IZ=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function Pb(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var Qf=class extends Zf{constructor(t,e={}){super(),this.input=t,this.options=e}async iterator(){if(Pb(this.input)&&V().get("IS_NODE")){let t=Lb();this.input=t.readFileSync(this.input.slice(7))}return new Jf(this.input,this.options)}};var td=class extends Zf{constructor(t,e={}){super(),this.url=t,this.fileOptions=e}async iterator(){return Pb(this.url)?new Qf(this.url,this.fileOptions).iterator():yR(this.url,this.fileOptions)}};function bR(r,t={}){return new jf(new td(r),t)}function wR(r){let t=ag(r);return Dn(async()=>t)}function vR(r){return Dn(async()=>{let t=await r();return ag(()=>t.next())})}async function CR(r,t){return Yf.create(r,t)}async function IR(r){return Xf.create(r)}var Uk="3.16.0";function nt(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&x.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var SZ=Gr.whereImpl,gu=class extends jo{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Qi(this,go())}nextDataId(){return gu.nextDataId++}write(t,e,n){this.firstUse&&(this.firstUse=!1,V().get("IS_NODE")&&S.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:n,refCount:1}),o}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&x.isString(n[0])){let s=n.map(i=>x.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return{dataId:o,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,n,o,s){this.data.set(t,{values:e,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:n}=this.data.get(t);if(e==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return S.mergeRealAndImagArrays(o,s)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId),n=e;if(t.dtype==="string")try{n=e.map(o=>x.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return It(t.shape,t.dtype,n)}makeOutput(t,e,n){let o=this.write(t,e,n);return go().makeTensorFromDataId(o,e,n,this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let e=x.now();return t(),{kernelMs:x.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){nt([t],"where");let e=this.readSync(t.dataId);return SZ(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};gu.nextDataId=0;var Qb={};Yt(Qb,{addImpl:()=>qk,bincountImpl:()=>nd,bincountReduceImpl:()=>zb,ceilImpl:()=>Kk,concatImpl:()=>Hc,equalImpl:()=>jk,expImpl:()=>Yk,expm1Impl:()=>Jk,floorImpl:()=>Qk,gatherNdImpl:()=>Bb,gatherV2Impl:()=>Vb,greaterEqualImpl:()=>eN,greaterImpl:()=>tN,lessEqualImpl:()=>nN,lessImpl:()=>rN,linSpaceImpl:()=>Gb,logImpl:()=>oN,maxImpl:()=>Wb,maximumImpl:()=>sN,minimumImpl:()=>iN,multiplyImpl:()=>cg,negImpl:()=>aN,notEqualImpl:()=>lN,prodImpl:()=>uN,rangeImpl:()=>Kc,rsqrtImpl:()=>cN,sigmoidImpl:()=>XR,simpleAbsImpl:()=>Hk,sliceImpl:()=>jc,sparseFillEmptyRowsImpl:()=>Ub,sparseReshapeImpl:()=>Hb,sparseSegmentReductionImpl:()=>sd,sqrtImpl:()=>JR,squaredDifferenceImpl:()=>mN,stridedSliceImpl:()=>qb,stringNGramsImpl:()=>Kb,stringSplitImpl:()=>jb,stringToHashBucketFastImpl:()=>Xb,subImpl:()=>dN,tileImpl:()=>Yb,topKImpl:()=>Zb,transposeImpl:()=>od,uniqueImpl:()=>Jb});function Hk(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var kZ=r=>{let{x:t}=r.inputs,e=r.backend;nt(t,"abs");let n=new Float32Array(x.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return n=Hk(o),e.makeOutput(n,t.shape,t.dtype)},kR={kernelName:wi,backendName:"cpu",kernelFunc:kZ};function te(r){return(t,e,n,o,s)=>{let i=S.assertAndGetBroadcastShape(t,e),a=i.length,u=x.computeStrides(i),l=x.sizeFromShape(i),c=x.getTypedArrayFromDType(s,l),p=t.length,m=e.length,f=x.computeStrides(t),d=x.computeStrides(e),h=S.getBroadcastDims(t,i),g=S.getBroadcastDims(e,i);if(h.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(n[y%n.length],o[y%o.length]);else for(let y=0;y<c.length;++y){let b=x.indexToLoc(y,a,u),w=b.slice(-p);h.forEach($=>w[$]=0);let v=x.locToIndex(w,p,f),k=b.slice(-m);g.forEach($=>k[$]=0);let E=x.locToIndex(k,m,d);c[y]=r(n[v],o[E])}return[c,i]}}function Ir(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(a.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var NR={kernelName:$p,backendName:"cpu",kernelFunc:Ir};function ed(r,t,e="float32"){if(e==="complex64"){let o=ed(r,t,"float32"),s=ed(r,t,"float32");return Ir({inputs:{real:o,imag:s},backend:r})}let n=x.makeZerosTypedArray(x.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function qr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var TR={kernelName:lo,backendName:"cpu",kernelFunc:qr};function Ro(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var _R={kernelName:Yp,backendName:"cpu",kernelFunc:Ro};function Fo(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return qr({inputs:{x:o},backend:e});let i=ed(e,o.shape,o.dtype),a=Fo({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Ir({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Ro({inputs:{input:o},backend:e}),a=Fo({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!x.hasEncodingLoss(o.dtype,s)){let i=qr({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32"){let i=e.data.get(o.dataId).values,a=Int32Array.from(i);return e.makeTensorInfo(o.shape,"int32",a)}if(s==="bool"){let i=e.data.get(o.dataId).values,a=x.toTypedArray([0],o.dtype),[u,l]=te((c,p)=>c!==p?1:0)(o.shape,[],i,a,"bool");return e.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var ER={kernelName:io,backendName:"cpu",kernelFunc:Fo};function ie(r,t,e,n){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;nt([i,a],r);let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=i.dtype==="string"?S.fromUint8ToStringArray(l):l,m=i.dtype==="string"?S.fromUint8ToStringArray(c):c,f=n||i.dtype,[d,h]=t(i.shape,a.shape,p,m,f);return u.makeTensorInfo(h,f,d)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=Fo({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),p=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=u.data.get(p.dataId).values,d=u.data.get(m.dataId).values,h=Fo({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,w=u.data.get(y.dataId).values,v=u.data.get(b.dataId).values,[k,E,$]=e(i.shape,a.shape,f,d,w,v),D=u.makeTensorInfo($,"float32",k),R=u.makeTensorInfo($,"float32",E),P=Ir({inputs:{real:D,imag:R},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(D),u.disposeIntermediateTensorInfo(R),P}else{let l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,p=n||i.dtype,[m,f]=t(i.shape,a.shape,l,c,p);return u.makeTensorInfo(f,p,m)}}}function rd(r){return(t,e,n,o,s,i)=>{let a=S.assertAndGetBroadcastShape(t,e),u=x.sizeFromShape(a),l=a.length,c=x.computeStrides(a),p=x.getTypedArrayFromDType("float32",u),m=x.getTypedArrayFromDType("float32",u),f=S.getBroadcastDims(t,a),d=S.getBroadcastDims(e,a),h=S.mergeRealAndImagArrays(n,o),g=S.mergeRealAndImagArrays(s,i),y=t.length,b=x.computeStrides(t),w=e.length,v=x.computeStrides(e);if(f.length+d.length===0)for(let k=0;k<p.length;k++){let E=k%h.length,$=k%g.length,D=r(h[E*2],h[E*2+1],g[$*2],g[$*2+1]);p[k]=D.real,m[k]=D.imag}else for(let k=0;k<p.length;k++){let E=x.indexToLoc(k,l,c),$=E.slice(-y);f.forEach(U=>$[U]=0);let D=x.locToIndex($,y,b),R=E.slice(-w);d.forEach(U=>R[U]=0);let P=x.locToIndex(R,w,v),W=r(h[D*2],h[D*2+1],g[P*2],g[P*2+1]);p[k]=W.real,m[k]=W.imag}return[p,m,a]}}var qk=te((r,t)=>r+t),NZ=rd((r,t,e,n)=>({real:r+e,imag:t+n})),bl=ie(Xn,qk,NZ),AR={kernelName:Xn,backendName:"cpu",kernelFunc:bl};function nd(r,t,e,n,o){let s=x.sizeFromShape(n),i=x.makeZerosTypedArray(o,e);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=t[a]:i[u]+=1)}return i}function zb(r,t,e,n=!1){let o=r.shape[0],s=r.shape[1],i=It([o,e],t.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(n?i.set(1,a,l):t.size>0?i.set(i.get(a,l)+t.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}function In(r){return(t,e,n)=>{let o=x.getTypedArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=r(t[s],n);return o}}function Et(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(nt(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=x.sizeFromShape(i.shape),c=e||i.dtype,p=x.getArrayFromDType(c,l);for(let m=0;m<l;++m)p[m]=t(u[m],o);return a.makeTensorInfo(i.shape,c,p)}}function Oo(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(nt(i,r),i.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=e||i.dtype,c=t(u,l,o);return a.makeTensorInfo(i.shape,l,c)}}var Kk=In(r=>Math.ceil(r)),TZ=Oo(es,Kk),$R={kernelName:es,backendName:"cpu",kernelFunc:TZ};function Hc(r,t,e,n){let o=x.getArrayFromDType(e,x.sizeFromShape(t));if(n&&e!=="string"){let s=0;r.forEach(i=>{let a=x.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=e==="string"?S.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let c=l*t[1]+s;for(let p=0;p<i.shape[1];++p)o[c+p]=a[u++]}s+=i.shape[1]})}return o}var jk=te((r,t)=>r===t?1:0),Xk=ie(da,jk,null,"bool"),DR={kernelName:da,backendName:"cpu",kernelFunc:Xk};var Yk=In(r=>Math.exp(r)),Zk=Oo(cs,Yk,"float32"),RR={kernelName:cs,backendName:"cpu",kernelFunc:Zk};var Jk=In(r=>Math.expm1(r)),_Z=Oo(ha,Jk),FR={kernelName:ha,backendName:"cpu",kernelFunc:_Z};var Qk=In(r=>Math.floor(r)),EZ=Oo(ps,Qk),OR={kernelName:ps,backendName:"cpu",kernelFunc:EZ};function Bb(r,t,e,n,o,s,i,a,u){let l=It([n,s],e);for(let c=0;c<n;c++){let p=[],m=0;for(let f=0;f<o;f++){let d=r[c*o+f];m+=d*i[f],p.push(d)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let f=0;f<s;f++)l.values[c*s+f]=t.get(...t.indexToLoc(m*s+f))}return l}function Vb(r,t,e){let n=It(e,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=t.locToIndex([a,u]);i[2]=t.values[l];let c=r.locToIndex(i);0<=c&&c<r.values.length&&(n.values[o]=r.values[c])}return n}var tN=te((r,t)=>r>t?1:0),AZ=ie(ya,tN,null,"bool"),MR={kernelName:ya,backendName:"cpu",kernelFunc:AZ};var eN=te((r,t)=>r>=t?1:0),$Z=ie(ds,eN,null,"bool"),PR={kernelName:ds,backendName:"cpu",kernelFunc:$Z};var rN=te((r,t)=>r<t?1:0),DZ=ie(Ca,rN,null,"bool"),LR={kernelName:Ca,backendName:"cpu",kernelFunc:DZ};var nN=te((r,t)=>r<=t?1:0),RZ=ie(Ia,nN,null,"bool"),zR={kernelName:Ia,backendName:"cpu",kernelFunc:RZ};function Gb(r,t,e){let n=(t-r)/(e-1),o=x.makeZerosTypedArray(e,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var oN=In(r=>Math.log(r)),FZ=Oo(gs,oN),BR={kernelName:gs,backendName:"cpu",kernelFunc:FZ};function Wb(r,t,e,n){let o=x.getTypedArrayFromDType(n,x.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*t,a=r[i];for(let u=0;u<t;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var sN=te((r,t)=>Math.max(r,t)),OZ=ie(ys,sN),VR={kernelName:ys,backendName:"cpu",kernelFunc:OZ};var iN=te((r,t)=>Math.min(r,t)),MZ=ie(Cs,iN),GR={kernelName:Cs,backendName:"cpu",kernelFunc:MZ};var cg=te((r,t)=>r*t),PZ=rd((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),qc=ie(Ss,cg,PZ),WR={kernelName:Ss,backendName:"cpu",kernelFunc:qc};function aN(r,t,e){let n=x.createScalarValue(-1,e);return cg([],t,n,r,e)}function LZ(r){let{inputs:t,backend:e}=r,{x:n}=t;nt(n,"neg");let o=e.data.get(n.dataId).values,[s,i]=aN(o,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,s)}var UR={kernelName:ki,backendName:"cpu",kernelFunc:LZ};var lN=te((r,t)=>r!==t?1:0),zZ=ie(Ta,lN,null,"bool"),HR={kernelName:Ta,backendName:"cpu",kernelFunc:zZ};function od(r,t,e,n,o){let s=t.length,i=x.sizeFromShape(t),a=x.computeStrides(t),u=x.computeStrides(o),l=x.getTypedArrayFromDType(e,x.sizeFromShape(o));for(let c=0;c<i;++c){let p=x.indexToLoc(c,s,a),m=new Array(p.length);for(let d=0;d<m.length;d++)m[d]=p[n[d]];let f=x.locToIndex(m,s,u);l[f]=r[c]}return l}function He(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{perm:s}=e;nt(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let u=n.data.get(o.dataId).values,l=od(u,o.shape,o.dtype,s,a);return{dataId:n.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var qR={kernelName:Hs,backendName:"cpu",kernelFunc:He};function uN(r,t,e,n){let[o,s]=S.computeOutAndReduceShapes(r,n),i=ar(t,"int32"),a=x.makeZerosTypedArray(x.sizeFromShape(o),i),u=x.sizeFromShape(s);for(let l=0;l<a.length;++l){let c=l*u,p=1;for(let m=0;m<u;++m)p*=e[c+m];a[l]=p}return{outVals:a,outShape:o,outDtype:i}}function BZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"prod");let a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=S.getAxesPermutation(u,a),c=u,p=o,m=[];l!=null&&(p=He({inputs:{x:o},backend:e,attrs:{perm:l}}),m.push(p),c=S.getInnerMostAxes(c.length,a));let f=e.data.get(p.dataId).values,{outVals:d,outShape:h,outDtype:g}=uN(p.shape,p.dtype,f,c),y=h;return i&&(y=S.expandShapeToKeepDim(h,u)),m.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,d)}var KR={kernelName:Es,backendName:"cpu",kernelFunc:BZ};function Kc(r,t,e,n){let o=r===t,s=r<t&&e<0,i=t<r&&e>1;if(o||s||i)return x.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((t-r)/e)),u=x.makeZerosTypedArray(a,n);t<r&&e===1&&(e=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+e;return u}var cN=In(r=>1/Math.sqrt(r)),VZ=Oo(Os,cN),jR={kernelName:Os,backendName:"cpu",kernelFunc:VZ};var XR=In(r=>1/(1+Math.exp(-r))),pN=Et(Ps,r=>1/(1+Math.exp(-r))),YR={kernelName:Ps,backendName:"cpu",kernelFunc:pN};function jc(r,t,e,n,o){let s=Ve.isSliceContinous(n,t,e),i=x.sizeFromShape(e),a=x.computeStrides(n);if(s){let p=Ve.computeFlatOffset(t,a);return o==="string"?r.slice(p,p+i):r.subarray(p,p+i)}let u=o==="string"?S.fromUint8ToStringArray(r):r,l=It(n,o,u),c=It(e,o);for(let p=0;p<c.size;++p){let m=c.indexToLoc(p),f=m.map((d,h)=>d+t[h]);c.set(l.get(...f),...m)}return o==="string"?S.fromStringArrayToUint8(c.values):c.values}function Mo(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n;nt(o,"slice");let[a,u]=Ve.parseSliceParams(o,s,i);Ve.assertParamsValid(o,a,u);let l=e.data.get(o.dataId).values,c=jc(l,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}var ZR={kernelName:Ai,backendName:"cpu",kernelFunc:Mo};function Ub(r,t,e,n,o,s,i){let a=t[0],u=s[0],l=new Array(u),c=new Array(a),p=t[1];if(u===0){if(a!==0)throw new Error(S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=x.getArrayFromDType(e,0),y=x.getArrayFromDType(o,0);return[g,[0,p],y,l,c]}let m=!0,f=0,d=new Array(u).fill(0);for(let g=0;g<a;++g){let y=r[g*p];if(y<0)throw new Error(S.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=u)throw new Error(S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,u));++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<u;++g){let y=d[g]===0;l[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=n;for(let b=0;b<a;++b)c[b]=b;return[g,[a,p],y,l,c]}else{let g=d[u-1],y=x.getArrayFromDType(e,g*p),b=x.getArrayFromDType(o,g),w=new Array(u).fill(0);for(let v=0;v<a;++v){let k=r[v*p],E=w[k],$=(k===0?0:d[k-1])+E;w[k]++;for(let D=0;D<p;++D)y[$*p+D]=r[v*p+D];b[$]=n[v],c[v]=$}for(let v=0;v<u;++v)if(w[v]===0){let E=v===0?0:d[v-1];y[E*p+0]=v;for(let $=1;$<p;++$)y[E*p+$]=0;b[E]=i}return[y,[g,p],b,l,c]}}function Hb(r,t,e,n,o){let s=x.sizeFromShape(n),i=t[0],a=o.length,u=[],l=1,c=-1;for(let g=0;g<a;++g){let y=o[g];if(y===-1){if(c!==-1)throw new Error(S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,u.push(1)}else{if(y<0)throw new Error(S.getSparseReshapeNegativeOutputDimErrorMessage(g,y));l*=y,u.push(y)}}if(c!==-1){if(l<=0)throw new Error(S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(S.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[c]=g}if(x.sizeFromShape(u)!==s)throw new Error(S.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(a>0){d[a-1]=1;for(let g=a-2;g>=0;--g)d[g]=d[g+1]*u[g+1]}let h=x.getArrayFromDType(e,i*a);for(let g=0;g<i;++g){let y=0;for(let b=0;b<m;++b)y+=r[g*m+b]*f[b];for(let b=0;b<a;++b)h[g*a+b]=Math.trunc(y/d[b]),y%=d[b]}return[h,[i,a],u]}function sd(r,t,e,n,o,s=!1,i=0){let a=n.length,u=[t[0],r.length/t[0]],l=u[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=t.slice();m[0]=p;let f=m.reduce((w,v)=>w*v,1),d=x.getArrayFromDType(e,f);if(a===0)return p>0&&d.fill(i),[d,m];if(p<=0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,y=0,b=o[h];for(;;){let w=0;if(g<a){if(w=o[g],b===w){++g;continue}if(b>=w)throw new Error(S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>y&&d.fill(i,y*l,b*l);for(let v=h;v<g;++v){let k=n[v];if(k<0||k>=u[0])throw new Error(S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v,n[v],u[0]));for(let E=0;E<l;E++)d[b*l+E]+=r[k*l+E]}if(s)for(let v=0;v<l;v++)d[b*l+v]/=g-h;if(h=g,++g,y=b+1,b=w,g>a)break}return y<p&&d.fill(i,y*l,p*l),[d,m]}var JR=In(r=>Math.sqrt(r)),GZ=Et(Ls,r=>Math.sqrt(r)),QR={kernelName:Ls,backendName:"cpu",kernelFunc:GZ};var mN=te((r,t)=>{let e=r-t;return e*e}),WZ=ie(Vs,mN),tF={kernelName:Vs,backendName:"cpu",kernelFunc:WZ};function qb(r,t,e,n){let o=It(r,t.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*e[u]+n[u];o.set(t.get(...a),...i)}return o}var fN=class{constructor(t,e,n,o,s,i){this.separator=x.encodeString(t),this.nGramWidths=e,this.leftPad=x.encodeString(n),this.rightPad=x.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(s-(a+1))),p=i-(l+c),m=e+(l>0?0:a-u),f=0;f+=l*this.leftPad.length;for(let b=0;b<p;++b)f+=t[m+b].length;f+=c*this.rightPad.length,f+=(l+c+p-1)*this.separator.length,n[o+a]=new Uint8Array(f);let h=n[o+a],g=0,y=b=>b.forEach(w=>h[g++]=w);for(let b=0;b<l;++b)y(this.leftPad),y(this.separator);for(let b=0;b<p-1;++b)y(t[m+b]),y(this.separator);if(p>0){y(t[m+p-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){let n=t.length,o=e.length;if(o>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let c=e[l]>=u;if(c=c&&e[l]<=n,!c)throw new Error(`Invalid split value ${e[l]}, must be in [${u}, ${n}]`);u=e[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=x.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=e[u]-e[u-1],c=0;this.nGramWidths.forEach(p=>{c+=this.getNumNGrams(l,p)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=e[u],c=i[u];if(this.nGramWidths.forEach(p=>{let m=e[u+1]-e[u],f=this.getNumNGrams(m,p);this.createNGrams(t,l,a,c,f,p),c+=f}),this.preserveShort&&c===i[u]){let p=e[u+1]-e[u];if(p===0)continue;let m=p+2*this.padWidth,f=1;this.createNGrams(t,l,a,c,f,m)}}return[a,i]}};function Kb(r,t,e,n,o,s,i,a){return new fN(e,n,o,s,i,a).compute(r,t)}function UZ(r,t,e,n){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!e||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!e||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!e||i.length!==0)&&n.push(i),o=s+1}}function jb(r,t,e){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let m=0;m<n;++m){let f=o.length;UZ(r[m],t,e,o);let d=o.length-f;a[m]=d,s+=d,i=Math.max(i,d)}let u=x.getArrayFromDType("int32",s*2),l=new Array(s),c=[n,i],p=0;for(let m=0;m<n;++m)for(let f=0;f<a[m];++f)u[p*2]=m,u[p*2+1]=f,l[p]=o[p],++p;return[u,l,c]}function Xb(r,t){let e=x.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)e[n]=x.fingerPrint64(r[n]).modulo(t).getLowBitsUnsigned();return e}var dN=te((r,t)=>r-t),HZ=rd((r,t,e,n)=>({real:r-e,imag:t-n})),pg=ie(Gs,dN,HZ),eF={kernelName:Gs,backendName:"cpu",kernelFunc:pg};function Yb(r,t){let e=new Array(r.rank);for(let o=0;o<e.length;o++)e[o]=r.shape[o]*t[o];let n=It(e,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var mg=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function rF(r,t,e=0,n=r.length-1){for(;n>e;){if(n-e>600){let a=n-e+1,u=t-e+1,l=Math.log(a),c=.5*Math.exp(2*l/3),p=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),m=Math.max(e,Math.floor(t-u*c/a+p)),f=Math.min(n,Math.floor(t+(a-u)*c/a+p));rF(r,t,m,f)}let o=r[t],s=e,i=n;for(x.swap(r,e,t),mg(r[n],o)>0&&x.swap(r,e,n);s<i;){for(x.swap(r,s,i),s++,i--;mg(r[s],o)<0;)s=s+1;for(;mg(r[i],o)>0;)i=i-1}mg(r[e],o)===0?x.swap(r,e,i):(i=i+1,x.swap(r,i,n)),i<=t&&(e=i+1),t<=i&&(n=i-1)}}function Zb(r,t,e,n,o){let s=t[t.length-1],[i,a]=[r.length/s,s],u=x.getTypedArrayFromDType(e,i*n),l=x.getTypedArrayFromDType("int32",i*n);for(let p=0;p<i;p++){let m=p*a,f=r.subarray(m,m+a),d=new Array(f.length);f.forEach((b,w)=>d[w]={value:b,index:w}),n<d.length&&(rF(d,n),d=d.slice(0,n)),o&&d.sort(mg);let h=p*n,g=u.subarray(h,h+n),y=l.subarray(h,h+n);for(let b=0;b<n;b++)g[b]=d[b].value,y[b]=d[b].index}let c=t.slice();return c[c.length-1]=n,[It(c,e,u),It(c,"int32",l)]}function Jb(r,t,e,n){let o=x.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let d=0;d<o;d++)s[0]*=e[d];s[1]=e[o];for(let d=o+1;d<e.length;d++)s[2]*=e[d];let i={},a=new Int32Array(e[o]),u=new pe(s,n,r),l=[],c=s[0]===1&&s[2]===1;for(let d=0;d<e[o];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)g.push(u.get(y,d,b));h=g.join(",")}if(i[h]!==void 0)a[d]=i[h];else{let g=Object.keys(i).length;i[h]=g,a[d]=g,l.push(d)}}let p=s.slice();p[1]=Object.keys(i).length;let m=new pe(p,n);l.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(u.get(g,d,y),g,h,y)});let f=e.slice();return f[o]=p[1],{outputValues:m.values,outputShape:f,indices:a}}dm("cpu",()=>new gu,1);var hN=Et(us,r=>r>=0?r:Math.exp(r)-1),nF={kernelName:us,backendName:"cpu",kernelFunc:hN};function gN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n;nt([o],"leakyRelu");let i=x.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,u=x.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?s*a[l]:a[l];return e.makeTensorInfo(o.shape,"float32",u)}var oF={kernelName:hs,backendName:"cpu",kernelFunc:gN};var KZ=te((r,t)=>r<0?t*r:r);function xN(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t;nt([n,o],"prelu");let s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,[a,u]=KZ(n.shape,o.shape,s,i,"float32");return e.makeTensorInfo(u,"float32",a)}var sF={kernelName:_s,backendName:"cpu",kernelFunc:xN};var yN=Et(As,r=>Math.max(0,r)),iF={kernelName:As,backendName:"cpu",kernelFunc:yN};var bN=Et(Ds,r=>Math.min(Math.max(0,r),6)),aF={kernelName:Ds,backendName:"cpu",kernelFunc:bN};function id(r,t,e,n,o){if(e==="linear")return qr({inputs:{x:t},backend:r});if(e==="relu")return yN({inputs:{x:t},backend:r});if(e==="elu")return hN({inputs:{x:t},backend:r});if(e==="relu6")return bN({inputs:{x:t},backend:r});if(e==="prelu")return xN({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return gN({inputs:{x:t},backend:r,attrs:{alpha:o}});if(e==="sigmoid")return pN({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function ne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=x.sizeFromShape(o.shape),a=x.inferFromImplicitShape(s,i),u=x.sizeFromShape(a);x.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let l=e.data.get(o.dataId);if(l.complexTensorInfos!=null){let c=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;c.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var lF={kernelName:_i,backendName:"cpu",kernelFunc:ne};function wN(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;nt([o,s],"matMul");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),w=Pr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[g,c,m]:[g,m,c],k=a?[y,f,p]:[y,p,f],E=ne({inputs:{x:o},backend:e,attrs:{shape:v}}),$=ne({inputs:{x:s},backend:e,attrs:{shape:k}}),D=i?E.shape[1]:E.shape[2],R=i?E.shape[2]:E.shape[1],P=a?$.shape[1]:$.shape[2],W=Math.max(g,y),U=e.data.get(E.dataId).values,q=e.data.get($.dataId).values,K=x.computeStrides(E.shape),j=x.computeStrides($.shape),[Q,rt,X]=i?[K[0],1,K[1]]:[K[0],K[1],1],[ot,st,it]=a?[1,j[1],j[0]]:[j[1],1,j[0]],ft=R*P,at=It([W,R,P],E.dtype),xt=at.values,dt=e.blockSize;for(let bt=0;bt<W;bt++)for(let kt=0;kt<R;kt+=dt)for(let At=0;At<P;At+=dt)for(let Dt=0;Dt<D;Dt+=dt){let qt=Math.min(kt+dt,R),Kt=Math.min(At+dt,P),ce=Math.min(Dt+dt,D);for(let Ot=kt;Ot<qt;Ot++)for(let $e=At;$e<Kt;$e++){let Se=0;for(let ae=Dt;ae<ce;ae++){let je=Math.min(bt,g-1)*Q,Fe=Math.min(bt,y-1)*it,rn=U[je+Ot*rt+ae*X],ze=q[ae*ot+$e*st+Fe];Se+=rn*ze}xt[bt*ft+(Ot*P+$e)]+=Se}}return e.disposeIntermediateTensorInfo(E),e.disposeIntermediateTensorInfo($),e.makeTensorInfo(w,at.dtype,at.values)}var uF={kernelName:ts,backendName:"cpu",kernelFunc:wN};function jZ(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m,f,d,h=[];m=wN({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:e}),i&&(f=bl({inputs:{a:m,b:i},backend:e}),h.push(m),m=f),c&&(d=id(e,m,c,a,p),h.push(m),m=d);for(let y of h)e.disposeIntermediateTensorInfo(y);return m}var cF={kernelName:Oi,backendName:"cpu",kernelFunc:jZ};var XZ=Et(ea,r=>Math.acos(r)),pF={kernelName:ea,backendName:"cpu",kernelFunc:XZ};var YZ=Et(ra,r=>Math.acosh(r)),mF={kernelName:ra,backendName:"cpu",kernelFunc:YZ};function ZZ(r){let{inputs:t,backend:e}=r,n=t;nt(t,"addN");let o=n.map(a=>e.data.get(a.dataId).values),s=It(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let u=o[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var fF={kernelName:Zo,backendName:"cpu",kernelFunc:ZZ};function JZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"all");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("all",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];w=w&&k}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=ne({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var dF={kernelName:na,backendName:"cpu",kernelFunc:JZ};function QZ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"any");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("any",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];w=w||k}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=ne({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var hF={kernelName:oa,backendName:"cpu",kernelFunc:QZ};function t9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;nt(o,"argMax");let i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=He({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],w=0;for(let v=0;v<d;++v){let k=h[y+v];k>b&&(b=k,w=v)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var gF={kernelName:Jo,backendName:"cpu",kernelFunc:t9};function e9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;nt(o,"argMin");let i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=He({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],S.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,p]=S.computeOutAndReduceShapes(u.shape,i),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(p),h=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],w=0;for(let v=0;v<d;++v){let k=h[y+v];k<b&&(b=k,w=v)}f[g]=w}return l.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(c,"int32",f)}var xF={kernelName:$l,backendName:"cpu",kernelFunc:e9};var r9=Et(sa,r=>Math.asin(r)),yF={kernelName:sa,backendName:"cpu",kernelFunc:r9};var n9=Et(ia,r=>Math.asinh(r)),bF={kernelName:ia,backendName:"cpu",kernelFunc:n9};var o9=Et(aa,r=>Math.atan(r)),wF={kernelName:aa,backendName:"cpu",kernelFunc:o9};var s9=te((r,t)=>Math.atan2(r,t)),i9=ie(ua,s9),vF={kernelName:ua,backendName:"cpu",kernelFunc:i9};var a9=Et(la,r=>Math.atanh(r)),CF={kernelName:la,backendName:"cpu",kernelFunc:a9};function ad(r,t,e,n,o,s){let i=o.strideHeight,a=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,c=o.effectiveFilterHeight,p=o.effectiveFilterWidth,m=o.padInfo.top,f=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=It(o.outShape,e),g=h.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],b=o.outShape[2]*o.outShape[3],w=o.outShape[3];for(let v=0;v<o.batchSize;++v){let k=v*y,E=v*n[0];for(let $=0;$<o.inChannels;++$)for(let D=0;D<o.outHeight;++D){let R=D*i-m,P=Math.max(0,R),W=Math.min(o.inHeight,c+R),U=k+D*b;for(let q=0;q<o.outWidth;++q){let K=q*a-f,j=Math.max(0,K),Q=Math.min(o.inWidth,p+K),rt=d,X=0,ot=0;for(let it=P;it<W;it+=u){let ft=E+it*n[1];for(let at=j;at<Q;at+=l){let xt=ft+at*n[2],dt=r[xt+$];s==="max"&&dt>rt?rt=dt:s==="avg"&&(X+=dt,ot++)}if(isNaN(rt))break}let st=U+q*w+$;g[st]=s==="avg"?X/ot:rt}}}return h}function tw(r,t,e,n,o=!1,s=!1){let i=It(n.outShape,"int32"),a=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,c=n.dilationWidth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,f=n.padInfo.top,d=n.padInfo.left,h=It(t,e,r);for(let g=0;g<n.batchSize;++g)for(let y=0;y<n.inChannels;++y)for(let b=0;b<n.outHeight;++b){let w=b*a-f,v=w;for(;v<0;)v+=l;let k=Math.min(n.inHeight,p+w);for(let E=0;E<n.outWidth;++E){let $=E*u-d,D=$;for(;D<0;)D+=c;let R=Math.min(n.inWidth,m+$),P=Number.NEGATIVE_INFINITY,W=-1;for(let U=v;U<k;U+=l){let q=U-w;for(let K=D;K<R;K+=c){let j=K-$,Q=h.get(g,U,K,y);Q>P&&(P=Q,o?W=s?((g*n.inHeight+U)*n.inWidth+K)*n.inChannels+y:(U*n.inWidth+K)*n.inChannels+y:W=q*m+j)}}i.set(W,g,b,E,y)}}return i}function ew(r,t,e,n,o,s){let i=o.strideDepth,a=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,c=o.dilationHeight,p=o.dilationWidth,m=o.effectiveFilterDepth,f=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,y=o.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=It(o.outShape,e),v=w.values,k=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],E=o.outShape[2]*o.outShape[3]*o.outShape[4],$=o.outShape[3]*o.outShape[4],D=o.outShape[4];for(let R=0;R<o.batchSize;++R){let P=R*k,W=R*n[0];for(let U=0;U<o.inChannels;++U)for(let q=0;q<o.outDepth;++q){let K=q*i-h,j=K;for(;j<0;)j+=l;let Q=Math.min(o.inDepth,m+K),rt=P+q*E;for(let X=0;X<o.outHeight;++X){let ot=X*a-g,st=ot;for(;st<0;)st+=c;let it=Math.min(o.inHeight,f+ot),ft=rt+X*$;for(let at=0;at<o.outWidth;++at){let xt=at*u-y,dt=xt;for(;dt<0;)dt+=p;let bt=Math.min(o.inWidth,d+xt),kt=ft+at*D,At=b,Dt=0,qt=0;for(let ce=j;ce<Q;ce+=l){let Ot=W+ce*n[1];for(let $e=st;$e<it;$e+=c){let Se=Ot+$e*n[2];for(let ae=dt;ae<bt;ae+=p){let je=Se+ae*n[3],Fe=r[je+U];if(s==="max"&&Fe>At?At=Fe:s==="avg"&&(Dt+=Fe,qt++),isNaN(At))break}if(isNaN(At))break}if(isNaN(At))break}let Kt=kt+U;v[Kt]=s==="avg"?Dt/qt:At}}}}return w}function IF(r,t){let e=It(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,a=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,m=t.padInfo.front,f=t.padInfo.top,d=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*n-m,w=b;for(;w<0;)w+=i;let v=Math.min(t.inDepth,l+b);for(let k=0;k<t.outHeight;++k){let E=k*o-f,$=E;for(;$<0;)$+=a;let D=Math.min(t.inHeight,c+E);for(let R=0;R<t.outWidth;++R){let P=R*s-d,W=P;for(;W<0;)W+=u;let U=Math.min(t.inWidth,p+P),q=Number.NEGATIVE_INFINITY,K=-1;for(let j=w;j<v;j+=i){let Q=j-b;for(let rt=$;rt<D;rt+=a){let X=rt-E;for(let ot=W;ot<U;ot+=u){let st=ot-P,it=r.get(h,j,rt,ot,g);it>=q&&(q=it,K=Q*c*p+X*c+st)}}}e.set(K,h,y,k,R,g)}}}return e}function l9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;nt(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))p=qr({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=x.computeStrides(o.shape),d=ad(m,o.shape,o.dtype,f,c,"avg");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var SF={kernelName:Qo,backendName:"cpu",kernelFunc:l9};function u9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;nt(o,"avgPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=ew(p,o.shape,o.dtype,x.computeStrides(o.shape),c,"avg");return e.makeTensorInfo(m.shape,"float32",m.values)}var kF={kernelName:Dl,backendName:"cpu",kernelFunc:u9};function c9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;nt([o,s],"avgPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=c.strideDepth,m=c.strideHeight,f=c.strideWidth,d=c.filterDepth,h=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,v=c.effectiveFilterDepth,k=c.effectiveFilterHeight,E=c.effectiveFilterWidth,$=v-1-c.padInfo.front,D=E-1-c.padInfo.left,R=k-1-c.padInfo.top,P=It(s.shape,"float32"),W=1/(d*h*g),U=e.bufferSync(o);for(let q=0;q<c.batchSize;++q)for(let K=0;K<c.inChannels;++K)for(let j=0;j<c.inDepth;++j)for(let Q=0;Q<c.inHeight;++Q)for(let rt=0;rt<c.inWidth;++rt){let X=j-$,ot=Q-R,st=rt-D,it=0;for(let ft=0;ft<v;ft+=y){let at=(X+ft)/p;if(!(at<0||at>=c.outDepth||Math.floor(at)!==at))for(let xt=0;xt<k;xt+=b){let dt=(ot+xt)/m;if(!(dt<0||dt>=c.outHeight||Math.floor(dt)!==dt))for(let bt=0;bt<E;bt+=w){let kt=(st+bt)/f;if(kt<0||kt>=c.outWidth||Math.floor(kt)!==kt)continue;it+=U.get(q,at,dt,kt,K)}}}P.set(it*W,q,j,Q,rt,K)}return e.makeTensorInfo(P.shape,P.dtype,P.values)}var NF={kernelName:_p,backendName:"cpu",kernelFunc:c9};function p9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;nt([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=c.strideHeight,m=c.strideWidth,f=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,v=y-1-c.padInfo.top,k=It(i.shape,"float32"),E=1/(f*d),$=e.data.get(o.dataId).values,D=It(o.shape,"float32",$);for(let R=0;R<c.batchSize;++R)for(let P=0;P<c.inChannels;++P)for(let W=0;W<c.inHeight;++W)for(let U=0;U<c.inWidth;++U){let q=W-v,K=U-w,j=0;for(let Q=0;Q<y;Q+=h){let rt=(q+Q)/p;if(!(rt<0||rt>=c.outHeight||Math.floor(rt)!==rt))for(let X=0;X<b;X+=g){let ot=(K+X)/m;if(ot<0||ot>=c.outWidth||Math.floor(ot)!==ot)continue;j+=D.get(R,rt,ot,P)}}k.set(j*E,R,W,U,P)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}var TF={kernelName:Tp,backendName:"cpu",kernelFunc:p9};function m9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,scale:s,offset:i,mean:a,variance:u}=t;x.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),nt([o,a,u,s,i],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let c=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,m=e.data.get(u.dataId).values,f=s?e.data.get(s.dataId).values:new Float32Array([1]),d=i?e.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),g=d.length,y=f.length,b=m.length,w=p.length,v=0,k=0,E=0,$=0;for(let D=0;D<c.length;++D)h[D]=d[v++]+(c[D]-p[k++])*f[E++]/Math.sqrt(m[$++]+l),v>=g&&(v=0),k>=w&&(k=0),E>=y&&(E=0),$>=b&&($=0);return e.makeTensorInfo(o.shape,o.dtype,h)}var _F={kernelName:fs,backendName:"cpu",kernelFunc:m9};function f9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;nt([o],"batchToSpaceND");let a=s.reduce((y,b)=>y*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=ne({inputs:{x:o},backend:e,attrs:{shape:u}}),d=He({inputs:{x:f},backend:e,attrs:{perm:l}}),h=ne({inputs:{x:d},backend:e,attrs:{shape:c}}),g=Mo({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var EF={kernelName:vi,backendName:"cpu",kernelFunc:f9};function d9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,l=nd(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var AF={kernelName:Ep,backendName:"cpu",kernelFunc:d9};function h9(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var $F={kernelName:Ap,backendName:"cpu",kernelFunc:h9};var g9=Et(ao,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),DF={kernelName:ao,backendName:"cpu",kernelFunc:g9};var x9=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(x.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let c=a[l],p=u[l];n[l]=Math.hypot(c,p)}return e.makeOutput(n,t.shape,"float32")},RF={kernelName:Rl,backendName:"cpu",kernelFunc:x9};function Zi(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var FF={kernelName:Wp,backendName:"cpu",kernelFunc:Zi};function xu(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=x.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(h=>h.shape),s);if(x.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(h=>x.sizeFromShape(h.shape)>0);if(a.length===1)return qr({inputs:{x:a[0]},backend:e});let u=a.map(h=>h.shape);if(S.assertParamsConsistent(u,s),a[0].dtype==="complex64"){let h=a.map(v=>Ro({inputs:{input:v},backend:e})),g=a.map(v=>Zi({inputs:{input:v},backend:e})),y=xu({inputs:h,backend:e,attrs:{axis:s}}),b=xu({inputs:g,backend:e,attrs:{axis:s}}),w=Ir({inputs:{real:y,imag:b},backend:e});return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),w}let l=a.map(h=>{let g=x.sizeFromShape(h.shape.slice(s));return ne({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}})}),c=l.map(h=>({vals:e.data.get(h.dataId).values,shape:h.shape}));i=S.computeOutShape(l.map(h=>h.shape),1);let p=l[0].shape[0]===1,m=Hc(c,i,t[0].dtype,p),f=S.computeOutShape(a.map(h=>h.shape),s),d=e.makeTensorInfo(f,t[0].dtype,m);return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var OF={kernelName:Ci,backendName:"cpu",kernelFunc:xu};function vN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n;nt([o,s],"conv2d");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,y=m.padInfo.left,b=m.padInfo.top,w=m.dataFormat==="channelsLast",v=new pe(m.outShape,o.dtype),k=x.computeStrides(o.shape),E=x.computeStrides(s.shape),$=k[0],D=w?k[1]:k[2],R=w?k[2]:1,P=w?1:k[1],W=v.strides[0],U=w?v.strides[1]:v.strides[2],q=w?v.strides[2]:1,K=w?1:v.strides[1],j=e.data.get(o.dataId).values,Q=e.data.get(s.dataId).values,rt=v.values;for(let X=0;X<m.batchSize;++X){let ot=X*$,st=X*W;for(let it=0;it<m.outHeight;++it){let ft=st+it*U,at=it*m.strideHeight-b;for(let xt=0;xt<f;++xt){let dt=at+xt*h;if(dt<0||dt>=m.inHeight)continue;let bt=xt*E[0],kt=ot+dt*D;for(let At=0;At<m.outWidth;++At){let Dt=ft+At*q,qt=At*m.strideWidth-y;for(let Kt=0;Kt<d;++Kt){let ce=qt+Kt*g;if(ce<0||ce>=m.inWidth)continue;let Ot=bt+Kt*E[1],$e=kt+ce*R,Se=Ot;for(let ae=0;ae<m.inChannels;++ae){let je=j[$e+ae*P];for(let Fe=0;Fe<m.outChannels;++Fe)rt[Dt+Fe*K]+=je*Q[Se+Fe];Se+=m.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,rt)}var MF={kernelName:rs,backendName:"cpu",kernelFunc:vN};function y9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n;nt([o,s],"conv2dBackpropFilter");let p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,y=m.dataFormat==="channelsLast",b=new pe(m.filterShape,"float32"),w=m.padInfo.left,v=m.padInfo.top,k=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=new pe(o.shape,o.dtype,k),D=new pe(s.shape,s.dtype,E);for(let R=0;R<h;++R){let P=Math.max(0,Math.ceil((v-R)/f)),W=Math.min(m.outHeight,(m.inHeight+v-R)/f);for(let U=0;U<g;++U){let q=Math.max(0,Math.ceil((w-U)/d)),K=Math.min(m.outWidth,(m.inWidth+w-U)/d);for(let j=0;j<m.inChannels;++j)for(let Q=0;Q<m.outChannels;++Q){let rt=0;for(let X=0;X<m.batchSize;++X)for(let ot=P;ot<W;++ot){let st=R+ot*f-v;for(let it=q;it<K;++it){let ft=U+it*d-w;y?rt+=$.get(X,st,ft,j)*D.get(X,ot,it,Q):rt+=$.get(X,j,st,ft)*D.get(X,Q,ot,it)}}b.set(rt,R,U,j,Q)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var PF={kernelName:Dp,backendName:"cpu",kernelFunc:y9};function b9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n;nt([o,s],"conv2dBackpropInput");let p=x.computeStrides(s.shape),m=x.computeStrides(o.shape),f=S.convertConv2DDataFormat(l),d=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,f),h=new pe(d.inShape,"float32"),g=h.values,y=e.data.get(o.dataId).values,b=e.data.get(s.dataId).values,[w,v,k]=p,{batchSize:E,filterHeight:$,filterWidth:D,inChannels:R,inHeight:P,inWidth:W,outChannels:U,outHeight:q,outWidth:K,strideHeight:j,strideWidth:Q}=d;f=d.dataFormat;let rt=$-1-d.padInfo.top,X=D-1-d.padInfo.left,ot=f==="channelsLast",st=h.strides[0],it=ot?h.strides[1]:h.strides[2],ft=ot?h.strides[2]:1,at=ot?1:h.strides[1],xt=m[0],dt=ot?m[1]:m[2],bt=ot?m[2]:1,kt=ot?1:m[1];for(let At=0;At<E;++At)for(let Dt=0;Dt<R;++Dt)for(let qt=0;qt<P;++qt){let Kt=qt-rt,ce=Math.max(0,Math.ceil(Kt/j)),Ot=Math.min(q,($+Kt)/j);for(let $e=0;$e<W;++$e){let Se=$e-X,ae=Math.max(0,Math.ceil(Se/Q)),je=Math.min(K,(D+Se)/Q),Fe=0;for(let ze=ce;ze<Ot;++ze){let Bo=ze*j-Kt;for(let Fr=ae;Fr<je;++Fr){let nn=Fr*Q-Se,on=xt*At+dt*ze+bt*Fr,jr=w*($-1-Bo)+v*(D-1-nn)+k*Dt;for(let oo=0;oo<U;++oo){let Fn=y[on+kt*oo],Vo=b[jr+oo];Fe+=Fn*Vo}}}let rn=st*At+it*qt+ft*$e+at*Dt;g[rn]=Fe}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var LF={kernelName:ns,backendName:"cpu",kernelFunc:b9};function w9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n;nt([o,s],"conv3d");let l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),{filterDepth:c,filterHeight:p,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=l,y=g.front,b=g.left,w=g.top,v=new pe(l.outShape,o.dtype),k=e.data.get(o.dataId).values,E=e.data.get(s.dataId).values,$=v.values,D=x.computeStrides(o.shape),R=x.computeStrides(s.shape);for(let P=0;P<l.batchSize;++P){let W=P*D[0],U=P*v.strides[0];for(let q=0;q<l.outDepth;++q){let K=U+q*v.strides[1],j=q*l.strideDepth-y;for(let Q=0;Q<c;++Q){let rt=j+Q*f;if(rt<0||rt>=l.inDepth)continue;let X=Q*R[0],ot=W+rt*D[1];for(let st=0;st<l.outHeight;++st){let it=K+st*v.strides[2],ft=st*l.strideHeight-w;for(let at=0;at<p;++at){let xt=ft+at*d;if(xt<0||xt>=l.inHeight)continue;let dt=X+at*R[1],bt=ot+xt*D[2];for(let kt=0;kt<l.outWidth;++kt){let At=it+kt*l.outChannels,Dt=kt*l.strideWidth-b;for(let qt=0;qt<m;++qt){let Kt=Dt+qt*h;if(Kt<0||Kt>=l.inWidth)continue;let ce=dt+qt*R[2],Ot=bt+Kt*l.inChannels,$e=ce;for(let Se=0;Se<l.inChannels;++Se){let ae=k[Ot+Se];for(let je=0;je<l.outChannels;++je)$[At+je]+=ae*E[$e+je];$e+=l.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}var zF={kernelName:Fl,backendName:"cpu",kernelFunc:w9};function v9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n;nt([o,s],"conv3dBackpropFilterV2");let l=x.computeStrides(o.shape),c=x.computeStrides(s.shape),p=S.computeConv3DInfo(o.shape,u,i,1,a),m=p.strideDepth,f=p.strideHeight,d=p.strideWidth,h=p.filterDepth,g=p.filterHeight,y=p.filterWidth,b=new pe(p.filterShape,"float32"),w=b.values,[v,k,E,$]=b.strides,D=e.data.get(s.dataId).values,[R,P,W,U]=c,q=e.data.get(o.dataId).values,[K,j,Q,rt]=l,X=p.padInfo.front,ot=p.padInfo.left,st=p.padInfo.top;for(let it=0;it<h;++it){let ft=Math.max(0,Math.ceil((X-it)/m)),at=Math.min(p.outDepth,(p.inDepth+X-it)/m),xt=it*v;for(let dt=0;dt<g;++dt){let bt=Math.max(0,Math.ceil((st-dt)/f)),kt=Math.min(p.outHeight,(p.inHeight+st-dt)/f),At=dt*k+xt;for(let Dt=0;Dt<y;++Dt){let qt=Math.max(0,Math.ceil((ot-Dt)/d)),Kt=Math.min(p.outWidth,(p.inWidth+ot-Dt)/d),ce=Dt*E+At;for(let Ot=0;Ot<p.inChannels;++Ot){let $e=Ot*$+ce;for(let Se=0;Se<p.outChannels;++Se){let ae=0;for(let je=0;je<p.batchSize;++je){let Fe=je*K,rn=je*R;for(let ze=ft;ze<at;++ze){let Fr=(it+ze*m-X)*j+Fe,nn=ze*P+rn;for(let on=bt;on<kt;++on){let oo=(dt+on*f-st)*Q+Fr,Fn=on*W+nn;for(let Vo=qt;Vo<Kt;++Vo){let Tl=(Dt+Vo*d-ot)*rt+oo,Nu=Vo*U+Fn;ae+=q[Tl+Ot]*D[Nu+Se]}}}}w[$e+Se]=ae}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var BF={kernelName:Rp,backendName:"cpu",kernelFunc:v9};function C9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n;nt([o],"conv3dBackpropInputV2");let l=x.computeStrides(o.shape),c=x.computeStrides(s.shape),p=S.computeConv3DInfo(u,s.shape,a,1,i),m=new pe(p.inShape,"float32"),f=m.values,[d,h,g,y]=m.strides,b=e.data.get(o.dataId).values,[w,v,k,E]=l,$=e.data.get(s.dataId).values,[D,R,P,W]=c,{batchSize:U,filterDepth:q,filterHeight:K,filterWidth:j,inChannels:Q,inDepth:rt,inHeight:X,inWidth:ot,outChannels:st,outDepth:it,outHeight:ft,outWidth:at,strideDepth:xt,strideHeight:dt,strideWidth:bt}=p,kt=q-1-p.padInfo.front,At=K-1-p.padInfo.top,Dt=j-1-p.padInfo.left;for(let qt=0;qt<U;++qt)for(let Kt=0;Kt<Q;++Kt)for(let ce=0;ce<rt;++ce){let Ot=ce-kt,$e=Math.max(0,Math.ceil(Ot/xt)),Se=Math.min(it,(q+Ot)/xt);for(let ae=0;ae<X;++ae){let je=ae-At,Fe=Math.max(0,Math.ceil(je/dt)),rn=Math.min(ft,(K+je)/dt);for(let ze=0;ze<ot;++ze){let Bo=ze-Dt,Fr=Math.max(0,Math.ceil(Bo/bt)),nn=Math.min(at,(j+Bo)/bt),on=0;for(let jr=$e;jr<Se;++jr){let oo=jr*xt-Ot;for(let Fn=Fe;Fn<rn;++Fn){let Vo=Fn*dt-je;for(let so=Fr;so<nn;++so){let Tl=so*bt-Bo,Nu=w*qt+v*jr+k*Fn+E*so,lp=D*(q-1-oo)+R*(K-1-Vo)+P*(j-1-Tl)+W*Kt;for(let gr=0;gr<st;++gr){let up=b[Nu+gr],cp=$[lp+gr];on+=up*cp}}}}f[d*qt+h*ce+g*ae+y*ze+Kt]=on}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var VF={kernelName:Fp,backendName:"cpu",kernelFunc:C9};var I9=Et(os,r=>Math.cos(r)),GF={kernelName:os,backendName:"cpu",kernelFunc:I9};var S9=Et(ss,r=>Math.cosh(r)),WF={kernelName:ss,backendName:"cpu",kernelFunc:S9};function k9(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,[c,p,m,f]=o.shape,d=s.shape[0],[h,g]=a,y=It([d,h,g,f],"float32"),b=e.data.get(s.dataId).values,w=e.data.get(i.dataId).values,v=e.data.get(o.dataId).values,k=x.computeStrides(o.shape),E=x.computeStrides(y.shape);for(let $=0;$<d;$++){let D=$*4,R=b[D],P=b[D+1],W=b[D+2],U=b[D+3],q=w[$];if(q>=c)continue;let K=h>1?(W-R)*(p-1)/(h-1):0,j=g>1?(U-P)*(m-1)/(g-1):0;for(let Q=0;Q<h;Q++){let rt=h>1?R*(p-1)+Q*K:.5*(R+W)*(p-1);if(rt<0||rt>p-1){for(let X=0;X<g;X++)for(let ot=0;ot<f;ot++){let st=ot+X*E[2]+Q*E[1]+$*E[0];y.values[st]=l}continue}if(u==="bilinear"){let X=Math.floor(rt),ot=Math.ceil(rt),st=rt-X;for(let it=0;it<g;it++){let ft=g>1?P*(m-1)+it*j:.5*(P+U)*(m-1);if(ft<0||ft>m-1){for(let bt=0;bt<f;bt++){let kt=bt+it*E[2]+Q*E[1]+$*E[0];y.values[kt]=l}continue}let at=Math.floor(ft),xt=Math.ceil(ft),dt=ft-at;for(let bt=0;bt<f;bt++){let kt=bt+at*k[2]+X*k[1]+q*k[0],At=v[kt];kt=bt+xt*k[2]+X*k[1]+q*k[0];let Dt=v[kt];kt=bt+at*k[2]+ot*k[1]+q*k[0];let qt=v[kt];kt=bt+xt*k[2]+ot*k[1]+q*k[0];let Kt=v[kt],ce=At+(Dt-At)*dt,Ot=qt+(Kt-qt)*dt;kt=bt+it*E[2]+Q*E[1]+$*E[0],y.values[kt]=ce+(Ot-ce)*st}}}else for(let X=0;X<g;++X){let ot=g>1?P*(m-1)+X*j:.5*(P+U)*(m-1);if(ot<0||ot>m-1){for(let ft=0;ft<f;ft++){let at=ft+X*E[2]+Q*E[1]+$*E[0];y.values[at]=l}continue}let st=Math.round(ot),it=Math.round(rt);for(let ft=0;ft<f;ft++){let at=ft+st*k[2]+it*k[1]+q*k[0],xt=ft+X*E[2]+Q*E[1]+$*E[0];y.values[xt]=v[at]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var UF={kernelName:pa,backendName:"cpu",kernelFunc:k9};function N9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;nt(o,"cumprod");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=He({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ar(l.dtype,"int32"),m=x.makeOnesTypedArray(x.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let w=h(y,b);if(b===0)m[w]=i?1:f[w];else{let v=h(y,b-1);m[w]=i?f[v]*m[v]:f[w]*m[v]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let y=S.getUndoAxesPermutation(u),b=He({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var HF={kernelName:ca,backendName:"cpu",kernelFunc:N9};function T9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n;nt(o,"cumsum");let u=S.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=He({inputs:{x:o},backend:e,attrs:{perm:u}}));let c=S.getInnerMostAxes(1,o.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);let p=ar(l.dtype,"int32"),m=x.makeZerosTypedArray(x.sizeFromShape(l.shape),p),f=e.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=a?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let w=h(y,b);if(b===0)m[w]=i?0:f[w];else{let v=h(y,b-1);m[w]=i?f[v]+m[v]:f[w]+m[v]}}let g=e.makeTensorInfo(l.shape,p,m);if(u!=null){let y=S.getUndoAxesPermutation(u),b=He({inputs:{x:g},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(l),b}return g}var qF={kernelName:is,backendName:"cpu",kernelFunc:T9};function _9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=nd(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=zb(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var KF={kernelName:Op,backendName:"cpu",kernelFunc:_9};function E9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n;x.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],u=o.shape[1],l=o.shape[2],c=o.shape[3],p=u*s,m=l*s,f=c/(s*s),d=e.data.get(o.dataId).values,h=new Float32Array(a*p*m*f),g=0;for(let y=0;y<a;++y)for(let b=0;b<p;++b){let w=Math.floor(b/s),v=b%s;for(let k=0;k<m;++k){let E=Math.floor(k/s),$=k%s,D=(v*s+$)*f;for(let R=0;R<f;++R){let W=R+D+c*(E+l*(w+u*y));h[g++]=d[W]}}}return e.makeTensorInfo([a,p,m,f],o.dtype,h)}var jF={kernelName:ma,backendName:"cpu",kernelFunc:E9};function CN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n;nt([o,s],"depthwiseConv2DNative");let c=x.computeStrides(o.shape),p=x.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let f=S.computeConv2DInfo(o.shape,s.shape,i,m,a,l,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:y,padInfo:b}=f,w=b.left,v=b.top,k=f.outChannels/f.inChannels,E=new pe(f.outShape,o.dtype),$=e.data.get(o.dataId).values,D=e.data.get(s.dataId).values,R=E.values;for(let P=0;P<f.batchSize;++P){let W=P*c[0],U=P*E.strides[0];for(let q=0;q<f.outHeight;++q){let K=U+q*E.strides[1],j=q*f.strideHeight-v;for(let Q=0;Q<d;++Q){let rt=j+Q*g;if(rt<0||rt>=f.inHeight)continue;let X=Q*p[0],ot=W+rt*c[1];for(let st=0;st<f.outWidth;++st){let it=K+st*E.strides[2],ft=st*f.strideWidth-w;for(let at=0;at<h;++at){let xt=ft+at*y;if(xt<0||xt>=f.inWidth)continue;let dt=X+at*p[1],bt=ot+xt*f.inChannels,kt=it,At=dt;for(let Dt=0;Dt<f.inChannels;++Dt){let qt=$[bt+Dt];for(let Kt=0;Kt<k;++Kt)R[kt+Kt]+=qt*D[At+Kt];kt+=k,At+=k}}}}}}return e.makeTensorInfo(E.shape,E.dtype,E.values)}var XF={kernelName:as,backendName:"cpu",kernelFunc:CN};function A9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n;nt([o,s],"depthwiseConv2dNativeBackpropFilter");let p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=p,g=new pe(p.filterShape,"float32"),y=p.padInfo.left,b=p.padInfo.top,w=p.outChannels/p.inChannels,v=e.data.get(o.dataId).values,k=new pe(o.shape,o.dtype,v),E=e.data.get(s.dataId).values,$=new pe(s.shape,s.dtype,E);for(let D=0;D<d;++D){let R=Math.max(0,Math.ceil((b-D)/m)),P=Math.min(p.outHeight,(p.inHeight+b-D)/m);for(let W=0;W<h;++W){let U=Math.max(0,Math.ceil((y-W)/f)),q=Math.min(p.outWidth,(p.inWidth+y-W)/f);for(let K=0;K<p.outChannels;++K){let j=Math.trunc(K/w),Q=K%w,rt=0;for(let X=0;X<p.batchSize;++X)for(let ot=R;ot<P;++ot){let st=D+ot*m-b;for(let it=U;it<q;++it){let ft=W+it*f-y;rt+=k.get(X,st,ft,j)*$.get(X,ot,it,K)}}g.set(rt,D,W,j,Q)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var YF={kernelName:Mp,backendName:"cpu",kernelFunc:A9};function $9(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n;nt([o,s],"depthwiseConv2DNativeBackpropInput");let p=x.computeStrides(o.shape),m=x.computeStrides(s.shape),f=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),d=new pe(f.inShape,"float32"),h=d.values,[g,y,b]=d.strides,w=e.data.get(o.dataId).values,[v,k,E]=p,$=e.data.get(s.dataId).values,[D,R,P]=m,{batchSize:W,filterHeight:U,filterWidth:q,inChannels:K,inHeight:j,inWidth:Q,outChannels:rt,outHeight:X,outWidth:ot,strideHeight:st,strideWidth:it}=f,ft=U-1-f.padInfo.top,at=q-1-f.padInfo.left,xt=rt/K;for(let dt=0;dt<W;++dt)for(let bt=0;bt<K;++bt)for(let kt=0;kt<j;++kt){let At=kt-ft,Dt=Math.max(0,Math.ceil(At/st)),qt=Math.min(X,(U+At)/st);for(let Kt=0;Kt<Q;++Kt){let ce=Kt-at,Ot=Math.max(0,Math.ceil(ce/it)),$e=Math.min(ot,(q+ce)/it),Se=0;for(let ae=Dt;ae<qt;++ae){let je=ae*st-At;for(let Fe=Ot;Fe<$e;++Fe){let rn=Fe*it-ce,ze=v*dt+k*ae+E*Fe,Bo=D*(U-1-je)+R*(q-1-rn)+P*bt;for(let Fr=0;Fr<xt;++Fr){let nn=bt*xt+Fr,on=w[ze+nn],jr=$[Bo+Fr];Se+=on*jr}}}h[g*dt+y*kt+b*Kt+bt]=Se}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var ZF={kernelName:Pp,backendName:"cpu",kernelFunc:$9};function D9(r){let{inputs:t,backend:e}=r,{x:n}=t,o=x.sizeFromShape(n.shape),s=e.data.get(n.dataId).values,i=It([o,o],n.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,i.dtype,i.values)}var JF={kernelName:Lp,backendName:"cpu",kernelFunc:D9};var QF={kernelName:Ol,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o}=r,{strides:s,pad:i,dilations:a}=e,u=t,l=u.data.get(n.dataId).values,c=n.shape.length,p=u.data.get(o.dataId).values,m=o.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:v,strideWidth:k,filterHeight:E,filterWidth:$,dilationHeight:D,dilationWidth:R,outShape:P}=S.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),W=x.sizeFromShape(P),U=P.length,q=x.getArrayFromDType(n.dtype,W);for(let j=0;j<f;++j)for(let Q=0;Q<y;++Q){let rt=Q*v-w.top;for(let X=0;X<b;++X){let ot=X*k-w.left;for(let st=0;st<g;++st){let it=Number.MIN_SAFE_INTEGER;for(let at=0;at<E;++at){let xt=rt+at*D;if(xt>=0&&xt<d)for(let dt=0;dt<$;++dt){let bt=ot+dt*R;if(bt>=0&&bt<h){let kt=x.locToIndex([j,xt,bt,st],c,x.computeStrides(n.shape)),At=x.locToIndex([at,dt,st],m,x.computeStrides(o.shape)),Dt=l[kt]+p[At];Dt>it&&(it=Dt)}}}let ft=x.locToIndex([j,Q,X,st],U,x.computeStrides(P));q[ft]=it}}}return{dataId:u.write(x.toTypedArray(q,n.dtype),P,n.dtype),shape:P,dtype:n.dtype}}};var tO={kernelName:Hd,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=x.toNestedArray(n.shape,l.data.get(n.dataId).values),p=x.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:R}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);x.assert(s.rank===R.length,()=>`Error in ${Hd}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let P=x.toNestedArray(R,l.data.get(s.dataId).values),W=x.makeZerosNestedTypedArray(o.shape,o.dtype);for(let q=0;q<m;++q)for(let K=0;K<g;++K){let j=K*w-b.top;for(let Q=0;Q<y;++Q){let rt=Q*v-b.left;for(let X=0;X<h;++X){let ot=Number.MIN_SAFE_INTEGER,st=0,it=0;for(let ft=0;ft<k;++ft){let at=j+ft*$;if(at>=0&&at<f)for(let xt=0;xt<E;++xt){let dt=rt+xt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][X]+p[ft][xt][X];bt>ot&&(ot=bt,st=ft,it=xt)}}}W[st][it][X]+=P[q][K][Q][X]}}}return{dataId:l.write(x.toTypedArray(W,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var eO={kernelName:Ud,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=e,l=t,c=x.toNestedArray(n.shape,l.data.get(n.dataId).values),p=x.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:v,filterHeight:k,filterWidth:E,dilationHeight:$,dilationWidth:D,outShape:R}=S.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);x.assert(s.rank===R.length,()=>`Error in ${Ud}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let P=x.toNestedArray(R,l.data.get(s.dataId).values),W=x.makeZerosNestedTypedArray(n.shape,n.dtype);for(let q=0;q<m;++q)for(let K=0;K<g;++K){let j=K*w-b.top;for(let Q=0;Q<y;++Q){let rt=Q*v-b.left;for(let X=0;X<h;++X){let ot=Number.MIN_SAFE_INTEGER,st=j<0?0:j,it=rt<0?0:rt;for(let ft=0;ft<k;++ft){let at=j+ft*$;if(at>=0&&at<f)for(let xt=0;xt<E;++xt){let dt=rt+xt*D;if(dt>=0&&dt<d){let bt=c[q][at][dt][X]+p[ft][xt][X];bt>ot&&(ot=bt,st=at,it=dt)}}}W[q][st][it][X]+=P[q][K][Q][X]}}}return{dataId:l.write(x.toTypedArray(W,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function wl(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"sum");let a;o.dtype==="bool"?a=Fo({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=qr({inputs:{x:o},backend:e});let u=a.shape.length,l=x.parseAxisParam(s,a.shape),c=S.getAxesPermutation(l,u),p=l,m=a;c!=null&&(m=He({inputs:{x:a},backend:e,attrs:{perm:c}}),p=S.getInnerMostAxes(p.length,u)),S.assertAxesAreInnerMostDims("sum",p,m.shape.length);let[f,d]=S.computeOutAndReduceShapes(m.shape,p),h=S.upcastType(m.dtype,"int32"),g=ed(e,f,h),y=x.sizeFromShape(d),b=e.data.get(g.dataId).values,w=e.data.get(m.dataId).values;for(let v=0;v<b.length;++v){let k=v*y,E=0;for(let $=0;$<y;++$)E+=w[k+$];b[v]=E}if(i){let v=S.expandShapeToKeepDim(g.shape,l),k=g;g=ne({inputs:{x:g},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(k)}return e.disposeIntermediateTensorInfo(a),c!=null&&e.disposeIntermediateTensorInfo(m),g}var rO={kernelName:zs,backendName:"cpu",kernelFunc:wl};function R9(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(y)?w=s[g]:(w=He({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),d.push(w));let v=w.shape.slice();for(let k=0;k<b.length;++k)v.splice(b[k],0,1);x.arraysEqual(w.shape,v)||(w=ne({inputs:{x:w},backend:e,attrs:{shape:v}}),d.push(w)),m===null?m=w:(m=qc({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=wl({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var nO={kernelName:zp,backendName:"cpu",kernelFunc:R9};function F9(r){let{inputs:t,backend:e}=r,{dy:n,y:o}=t;nt([n,o],"eluGrad");let s=new Float32Array(x.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let l=i[u];l>=1?s[u]=a[u]:s[u]=a[u]*(l+1)}return e.makeTensorInfo(o.shape,"float32",s)}var oO={kernelName:Bp,backendName:"cpu",kernelFunc:F9};var O9=S.ERF_P,M9=S.ERF_A1,P9=S.ERF_A2,L9=S.ERF_A3,z9=S.ERF_A4,B9=S.ERF_A5,V9=Et(fa,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+O9*e);return t*(1-((((B9*n+z9)*n+L9)*n+P9)*n+M9)*n*Math.exp(-e*e))}),sO={kernelName:fa,backendName:"cpu",kernelFunc:V9};function ld(r){let{inputs:t,backend:e,attrs:n}=r,{input:o}=t,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(x.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),ne({inputs:{x:o},backend:e,attrs:{shape:a}})}var iO={kernelName:Ii,backendName:"cpu",kernelFunc:ld};var G9=te((r,t)=>r/t),fg=ie(ls,G9),dg={kernelName:ls,backendName:"cpu",kernelFunc:fg};function rw(r,t,e){let n=r.shape,o=n[0],s=n[1],i=e.data.get(r.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[o,s],c=x.sizeFromShape(l),p=x.getTypedArrayFromDType("float32",c),m=x.getTypedArrayFromDType("float32",c);for(let g=0;g<o;g++){let y=Mo({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,s]}}),b=Mo({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,s]}}),w=Ir({inputs:{real:y,imag:b},backend:e}),{real:v,imag:k}=W9(w,t,e),E=S.mergeRealAndImagArrays(v,k);for(let $=0;$<s;$++){let D=S.getComplexWithIndex(E,$);p[g*s+$]=D.real,m[g*s+$]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(w)}let f=e.makeTensorInfo(l,"float32",p),d=e.makeTensorInfo(l,"float32",m),h=Ir({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}function W9(r,t,e){let n=x.sizeFromShape(r.shape),o=e.data.get(r.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(U9(n)){let a=IN(s,i,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let l=e.makeTensorInfo(u,"float32",a.real),c=e.makeTensorInfo(u,"float32",a.imag),p=e.makeTensorInfo([],"float32",x.createScalarValue(n,"float32")),m=qr({inputs:{x:p},backend:e}),f=dg.kernelFunc({inputs:{a:l,b:p},backend:e}),d=dg.kernelFunc({inputs:{a:c,b:m},backend:e}),h=e.data.get(f.dataId).values,g=e.data.get(d.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return a}else{let a=S.mergeRealAndImagArrays(s,i),u=H9(a,n,t);return S.splitRealAndImagArrays(u)}}function U9(r){return(r&r-1)===0}function IN(r,t,e,n,o){if(e===1)return{real:r,imag:t};let s=S.mergeRealAndImagArrays(r,t),i=e/2,a=S.complexWithEvenIndex(s),u=a.real,l=a.imag,c=[u.length],p=o.makeTensorInfo(c,"float32",u),m=o.makeTensorInfo(c,"float32",l),f=Ir({inputs:{real:p,imag:m},backend:o}),d=S.complexWithOddIndex(s),h=d.real,g=d.imag,y=[h.length],b=o.makeTensorInfo(y,"float32",h),w=o.makeTensorInfo(y,"float32",g),v=Ir({inputs:{real:b,imag:w},backend:o}),k=IN(u,l,i,n,o),E=k.real,$=k.imag,D=[E.length],R=o.makeTensorInfo(D,"float32",E),P=o.makeTensorInfo(D,"float32",$),W=Ir({inputs:{real:R,imag:P},backend:o}),U=IN(h,g,i,n,o),q=U.real,K=U.imag,j=[q.length],Q=o.makeTensorInfo(j,"float32",q),rt=o.makeTensorInfo(j,"float32",K),X=Ir({inputs:{real:Q,imag:rt},backend:o}),ot=S.exponents(e,n),st=[ot.real.length],it=o.makeTensorInfo(st,"float32",ot.real),ft=o.makeTensorInfo(st,"float32",ot.imag),at=Ir({inputs:{real:it,imag:ft},backend:o}),xt=qc({inputs:{a:at,b:X},backend:o}),dt=bl({inputs:{a:W,b:xt},backend:o}),bt=pg({inputs:{a:W,b:xt},backend:o}),kt=Ro({inputs:{input:dt},backend:o}),At=Ro({inputs:{input:bt},backend:o}),Dt=Zi({inputs:{input:dt},backend:o}),qt=Zi({inputs:{input:bt},backend:o}),Kt=xu({inputs:[kt,At],backend:o,attrs:{axis:0}}),ce=xu({inputs:[Dt,qt],backend:o,attrs:{axis:0}}),Ot=o.data.get(Kt.dataId).values,$e=o.data.get(ce.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(P),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(rt),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(it),o.disposeIntermediateTensorInfo(ft),o.disposeIntermediateTensorInfo(at),o.disposeIntermediateTensorInfo(xt),o.disposeIntermediateTensorInfo(dt),o.disposeIntermediateTensorInfo(bt),o.disposeIntermediateTensorInfo(kt),o.disposeIntermediateTensorInfo(Dt),o.disposeIntermediateTensorInfo(At),o.disposeIntermediateTensorInfo(qt),o.disposeIntermediateTensorInfo(Kt),o.disposeIntermediateTensorInfo(ce),{real:Ot,imag:$e}}function H9(r,t,e){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,i=0;for(let a=0;a<t;a++){let u=S.exponent(o*a,t,e),l=S.getComplexWithIndex(r,a);s+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}e&&(s/=t,i/=t),S.assignToTypedArray(n,s,i,o)}return n}function q9(r){let{inputs:t,backend:e}=r,{input:n}=t,o=x.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ne({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=rw(a,!1,e),l=ne({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var aO={kernelName:Vp,backendName:"cpu",kernelFunc:q9};function hg(r){let{backend:t,attrs:e}=r,{shape:n,value:o,dtype:s}=e,i=s||x.inferDtype(o),a=x.getArrayFromDType(i,x.sizeFromShape(n));return K9(a,o,i),t.makeTensorInfo(n,i,a)}var lO={kernelName:Ml,backendName:"cpu",kernelFunc:hg};function K9(r,t,e){r.fill(t)}var uO={kernelName:ga,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,o=e,s=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(n.shape)),[i,a,u,l]=n.shape,c=o.data.get(n.dataId).values;for(let m=0;m<i;m++){let f=m*u*a*l;for(let d=0;d<a;d++){let h=d*(u*l);for(let g=0;g<u;g++){let y=g*l;for(let b=0;b<l;b++){let w=Math.round(u-g-1),v=f+h+y+b,k=c[v];if(w>=0&&w<u){let E=w*l,$=f+h+E+b;k=c[$]}s[v]=k}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var j9=te((r,t)=>Math.floor(r/t)),X9=ie(ms,j9,null,"int32"),cO={kernelName:ms,backendName:"cpu",kernelFunc:X9};function Y9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=vN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;h=bl({inputs:{a:h,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=id(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var pO={kernelName:Mi,backendName:"cpu",kernelFunc:Y9};function Z9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=CN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m}});if(i){let g=h;h=bl({inputs:{a:h,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=id(e,h,f,a,d),e.disposeIntermediateTensorInfo(g)}return h}var mO={kernelName:Pi,backendName:"cpu",kernelFunc:Z9};function J9(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=x.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[u,l,c,p]=S.prepareAndValidate(n,o);if(l===0)return e.makeTensorInfo(u,n.dtype,[]);let m=e.data.get(o.dataId).values,f=e.bufferSync(n),d=Bb(m,f,n.dtype,l,a,c,p,n.shape,s);return e.makeTensorInfo(u,n.dtype,d.values)}var fO={kernelName:xa,backendName:"cpu",kernelFunc:J9};function Q9(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n;nt([o,s],"gatherV2");let u=x.parseAxisParam(i,o.shape)[0],l=e.data.get(s.dataId).values,c=o.shape[u];for(let v=0;v<l.length;++v){let k=l[v];x.assert(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let p=a;a==null&&(p=0);let m=x.sizeFromShape(s.shape),f=S.segment_util.collectGatherOpShapeInfo(o,s,u,p),d=ne({inputs:{x:o},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=ne({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],y=e.bufferSync(h),b=e.bufferSync(d),w=Vb(b,y,g);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.makeTensorInfo(f.outputShape,w.dtype,w.values)}var dO={kernelName:Si,backendName:"cpu",kernelFunc:Q9};function tJ(r){let{inputs:t,backend:e}=r,{input:n}=t,o=x.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ne({inputs:{x:n},backend:e,attrs:{shape:[i,s]}}),u=rw(a,!0,e),l=ne({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),l}var hO={kernelName:Gp,backendName:"cpu",kernelFunc:tJ};var eJ=Et(ba,r=>Number.isFinite(r)?1:0,"bool"),gO={kernelName:ba,backendName:"cpu",kernelFunc:eJ};var rJ=Et(wa,r=>Math.abs(r)===1/0?1:0,"bool"),xO={kernelName:wa,backendName:"cpu",kernelFunc:rJ};var nJ=Et(va,r=>Number.isNaN(r)?1:0,"bool"),yO={kernelName:va,backendName:"cpu",kernelFunc:nJ};function oJ(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=Gb(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var bO={kernelName:Up,backendName:"cpu",kernelFunc:oJ};var sJ=Et(Sa,r=>Math.log1p(r)),wO={kernelName:Sa,backendName:"cpu",kernelFunc:sJ};var iJ=te((r,t)=>r&&t),aJ=ie(ka,iJ,null,"bool"),vO={kernelName:ka,backendName:"cpu",kernelFunc:aJ};var lJ=Et(Mu,r=>r?0:1,"bool"),CO={kernelName:Mu,backendName:"cpu",kernelFunc:lJ};var uJ=te((r,t)=>r||t),cJ=ie(Pu,uJ,null,"bool"),IO={kernelName:Pu,backendName:"cpu",kernelFunc:cJ};function pJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n;nt(o,"LRN");let l=o.shape[3],c=l-1,p=e.data.get(o.dataId).values,m=x.sizeFromShape(o.shape),f=new Float32Array(m);function d(h){let g=h%l,y=h-g+Math.max(0,g-s),b=h-g+Math.min(g+s,c),w=0;for(;y<=b;y++){let v=p[y];w+=v*v}return w}for(let h=0;h<m;h++){let g=d(h),y=p[h]*Math.pow(i+a*g,-u);f[h]=y}return e.makeTensorInfo(o.shape,o.dtype,f)}var SO={kernelName:Pl,backendName:"cpu",kernelFunc:pJ};function mJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n;nt(i,"LRNGrad");let p=x.sizeFromShape(i.shape),m=i.shape[3],f=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=e.data.get(s.dataId).values,g=new Float32Array(p),y=p;for(let b=0;b<y;b++){let w=b%m,v=b-w+Math.max(0,w-a),k=b-w+Math.min(m,w+a+1),E=0;for(let $=v;$<k;$++)E+=Math.pow(d[$],2);E=l*E+u;for(let $=v;$<k;$++){let D=-2*l*c*d[$]*h[b]/E;b===$&&(D+=Math.pow(E,-c)),D*=f[b],g[$]+=D}}return e.makeTensorInfo(i.shape,o.dtype,g)}var kO={kernelName:Hp,backendName:"cpu",kernelFunc:mJ};function SN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=e,u=o.shape,l=u.length,c=x.parseAxisParam(s,u),p=c,m=S.getAxesPermutation(p,l),f=a.data.get(o.dataId).values;if(m!=null){let v=new Array(l);for(let k=0;k<v.length;k++)v[k]=u[m[k]];f=od(f,u,o.dtype,m,v),p=S.getInnerMostAxes(p.length,l),u=v}nt(o,"max"),S.assertAxesAreInnerMostDims("max",p,l);let[d,h]=S.computeOutAndReduceShapes(u,p),g=x.sizeFromShape(h),y=Wb(f,g,d,o.dtype),b=a.write(y,d,o.dtype),w=d;return i&&(w=S.expandShapeToKeepDim(d,c)),{dataId:b,shape:w,dtype:o.dtype}}var NO={kernelName:xs,backendName:"cpu",kernelFunc:SN};function fJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;nt(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u),p;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))p=qr({inputs:{x:o},backend:e});else{let m=e.data.get(o.dataId).values,f=x.computeStrides(o.shape),d=ad(m,o.shape,o.dtype,f,c,"max");p=e.makeTensorInfo(c.outShape,o.dtype,d.values)}return p}var TO={kernelName:bs,backendName:"cpu",kernelFunc:fJ};function dJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;nt(o,"maxPool3d");let c=S.computePool3DInfo(o.shape,s,i,1,a,u,l),p=e.data.get(o.dataId).values,m=ew(p,o.shape,o.dtype,x.computeStrides(o.shape),c,"max");return e.makeTensorInfo(m.shape,"float32",m.values)}var _O={kernelName:Ll,backendName:"cpu",kernelFunc:dJ};function hJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;nt([o,s],"maxPool3DGrad");let c=S.computePool3DInfo(s.shape,i,a,1,u,l),p=e.bufferSync(s),m=IF(p,c),f=c.strideDepth,d=c.strideHeight,h=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,E=w-1-c.padInfo.front,$=k-1-c.padInfo.left,D=v-1-c.padInfo.top,R=It(s.shape,"float32"),P=e.bufferSync(o);for(let W=0;W<c.batchSize;++W)for(let U=0;U<c.inChannels;++U)for(let q=0;q<c.inDepth;++q)for(let K=0;K<c.inHeight;++K)for(let j=0;j<c.inWidth;++j){let Q=q-E,rt=K-D,X=j-$,ot=0;for(let st=0;st<w;st+=g){let it=(Q+st)/f;if(!(it<0||it>=c.outDepth||Math.floor(it)!==it))for(let ft=0;ft<v;ft+=y){let at=(rt+ft)/d;if(!(at<0||at>=c.outHeight||Math.floor(at)!==at))for(let xt=0;xt<k;xt+=b){let dt=(X+xt)/h;if(dt<0||dt>=c.outWidth||Math.floor(dt)!==dt)continue;let bt=w*v*k-1-m.get(W,it,at,dt,U),kt=st*v*k+ft*k+xt,At=bt===kt?1:0;if(At===0)continue;ot+=P.get(W,it,at,dt,U)*At}}}R.set(ot,W,q,K,j,U)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}var EO={kernelName:Kp,backendName:"cpu",kernelFunc:hJ};function gJ(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;nt([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=e.data.get(a.dataId).values,d=It(m.outShape,a.dtype,tw(f,a.shape,a.dtype,m).values),h=m.strideHeight,g=m.strideWidth,y=m.dilationHeight,b=m.dilationWidth,w=m.effectiveFilterHeight,v=m.effectiveFilterWidth,k=v-1-m.padInfo.left,E=w-1-m.padInfo.top,$=It(a.shape,"float32"),D=e.data.get(o.dataId).values,R=It(o.shape,"float32",D);for(let P=0;P<m.batchSize;++P)for(let W=0;W<m.inChannels;++W)for(let U=0;U<m.inHeight;++U)for(let q=0;q<m.inWidth;++q){let K=U-E,j=q-k,Q=0;for(let rt=0;rt<w;rt+=y){let X=(K+rt)/h;if(!(X<0||X>=m.outHeight||Math.floor(X)!==X))for(let ot=0;ot<v;ot+=b){let st=(j+ot)/g;if(st<0||st>=m.outWidth||Math.floor(st)!==st)continue;let it=w*v-1-d.get(P,X,st,W),ft=rt*v+ot,at=it===ft?1:0;if(at===0)continue;Q+=R.get(P,X,st,W)*at}}$.set(Q,P,U,q,W)}return e.makeTensorInfo($.shape,$.dtype,$.values)}var AO={kernelName:qp,backendName:"cpu",kernelFunc:gJ};function $O(r,t,e,n,o){let s=x.computeStrides(t),i=ad(r,t,e,s,o,"max"),a=tw(r,t,e,o,!0,n);return[i.values,a.values]}var DO={kernelName:jp,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;nt(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,c=S.computePool2DInfo(n.shape,o,s,[1,1],i),[p,m]=$O(l,n.shape,n.dtype,a,c),f=u.write(p,c.outShape,n.dtype),d=u.write(m,c.outShape,n.dtype);return[{dataId:f,shape:c.outShape,dtype:n.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function xJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=x.parseAxisParam(s,o.shape),l=S.computeOutAndReduceShapes(o.shape,a)[1],c=x.sizeFromShape(l),p=[],m=e.makeTensorInfo([],"float32",new Float32Array([c]));p.push(m);let f=Fo({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(f);let d=fg({inputs:{a:f,b:m},backend:e});p.push(d);let h=wl({inputs:{x:d},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var RO={kernelName:ws,backendName:"cpu",kernelFunc:xJ};function yJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;nt(o,"min");let a=x.parseAxisParam(s,o.shape),u=a,l=S.getAxesPermutation(u,o.shape.length),c=o;l!=null&&(c=He({inputs:{x:o},backend:e,attrs:{perm:l}}),u=S.getInnerMostAxes(u.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",u,c.shape.length);let[p,m]=S.computeOutAndReduceShapes(c.shape,u),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(p),c.dtype),h=e.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,w=h[b];for(let v=0;v<f;++v){let k=h[b+v];(Number.isNaN(k)||k<w)&&(w=k)}d[y]=w}l!=null&&e.disposeIntermediateTensorInfo(c);let g=e.makeTensorInfo(p,c.dtype,d);if(i){let y=S.expandShapeToKeepDim(p,a),b=ne({inputs:{x:g},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(g),b}return g}var FO={kernelName:vs,backendName:"cpu",kernelFunc:yJ};function bJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,mode:i}=n;nt(o,"mirrorPad");let a=s.map((w,v)=>w[0]+o.shape[v]+w[1]),u=s.map(w=>w[0]),l=s.map((w,v)=>w[0]+o.shape[v]),c=i==="reflect"?0:1,p=e.data.get(o.dataId).values,m=o.shape.length,f=x.computeStrides(o.shape),d=x.sizeFromShape(a),h=a.length,g=x.computeStrides(a),y=x.getTypedArrayFromDType(o.dtype,d);for(let w=0;w<d;w++){let v=x.indexToLoc(w,h,g);for(let E=0;E<h;E++)v[E]<u[E]?v[E]=u[E]*2-v[E]-c:v[E]>=l[E]&&(v[E]=(l[E]-1)*2-v[E]+c);v=v.map((E,$)=>E-u[$]);let k=x.locToIndex(v,m,f);y[w]=p[k]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var OO={kernelName:Is,backendName:"cpu",kernelFunc:bJ};var wJ=te((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),vJ=ie(Na,wJ),MO={kernelName:Na,backendName:"cpu",kernelFunc:vJ};var LO=Ru(uS());function kN(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let u=x.parseAxisParam([a],o.shape),l=SN({inputs:{x:o},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),c=S.expandShapeToKeepDim(l.shape,u),p=ne({inputs:{x:l},backend:e,attrs:{shape:c}}),m=pg({inputs:{a:o,b:p},backend:e}),f=Zk({inputs:{x:m},backend:e}),d=wl({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),h=ne({inputs:{x:d},backend:e,attrs:{shape:c}}),g=fg({inputs:{a:f,b:h},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var PO={kernelName:Bs,backendName:"cpu",kernelFunc:kN};function CJ(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n;nt(o,"multinomial");let u=a?o:kN({inputs:{logits:o},backend:e,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],p=e.data.get(u.dataId).values,m=[l,s],f=x.makeZerosTypedArray(x.sizeFromShape(m),"int32");for(let d=0;d<l;++d){let h=d*c,g=new Float32Array(c-1);g[0]=p[h];for(let w=1;w<g.length;++w)g[w]=g[w-1]+p[h+w];let y=LO.alea(i.toString()),b=d*s;for(let w=0;w<s;++w){let v=y();f[b+w]=g.length;for(let k=0;k<g.length;k++)if(v<g[k]){f[b+w]=k;break}}}return a||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(m,"int32",f)}var zO={kernelName:Xp,backendName:"cpu",kernelFunc:CJ};var IJ=Gr.nonMaxSuppressionV3Impl;function SJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n;nt(o,"NonMaxSuppression");let l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,{selectedIndices:p}=IJ(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var BO={kernelName:_a,backendName:"cpu",kernelFunc:SJ};var kJ=Gr.nonMaxSuppressionV4Impl;function NJ(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n;nt(o,"NonMaxSuppressionPadded");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=kJ(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var VO={kernelName:Ea,backendName:"cpu",kernelFunc:NJ};var TJ=Gr.nonMaxSuppressionV5Impl;function _J(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n;nt(o,"NonMaxSuppressionWithScore");let c=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=TJ(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var GO={kernelName:Aa,backendName:"cpu",kernelFunc:_J};function EJ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n;nt(o,"oneHot");let u=x.sizeFromShape(o.shape),l=new Float32Array(u*s);l.fill(a);let c=e.data.get(o.dataId).values;for(let p=0;p<u;++p)c[p]>=0&&c[p]<s&&(l[p*s+c[p]]=i);return e.makeTensorInfo([...o.shape,s],"int32",l)}var WO={kernelName:ks,backendName:"cpu",kernelFunc:EJ};function gg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Ro({inputs:{input:n},backend:e}),s=gg({inputs:{x:o},backend:e}),i=Zi({inputs:{input:n},backend:e}),a=gg({inputs:{x:i},backend:e}),u=Ir({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return hg({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var UO={kernelName:Fi,backendName:"cpu",kernelFunc:gg};function HO(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Ro({inputs:{input:n},backend:e}),s=HO({inputs:{x:o},backend:e}),i=Zi({inputs:{input:n},backend:e}),a=gg({inputs:{x:i},backend:e}),u=Ir({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return hg({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var qO={kernelName:Ni,backendName:"cpu",kernelFunc:HO};function NN(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return ld({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=ld({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=xu({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var KO={kernelName:Ti,backendName:"cpu",kernelFunc:NN};function AJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;nt(o,"pad");let a=s.map((b,w)=>b[0]+o.shape[w]+b[1]),u=s.map(b=>b[0]),l=e.data.get(o.dataId).values,c=x.sizeFromShape(o.shape),p=o.shape.length,m=x.computeStrides(o.shape),f=x.sizeFromShape(a),d=a.length,h=x.computeStrides(a),g=x.getTypedArrayFromDType(o.dtype,f);i!==0&&g.fill(i);for(let b=0;b<c;b++){let v=x.indexToLoc(b,p,m).map((E,$)=>E+u[$]),k=x.locToIndex(v,d,h);g[k]=l[b]}return{dataId:e.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var nw={kernelName:Ns,backendName:"cpu",kernelFunc:AJ};var $J=te((r,t)=>Math.pow(r,t)),DJ=ie(Ts,$J),jO={kernelName:Ts,backendName:"cpu",kernelFunc:DJ};function RJ(r){let{backend:t,attrs:e}=r,{start:n,stop:o,dtype:s,step:i}=e,a=Kc(n,o,i,s);return t.makeTensorInfo([a.length],s,a)}var XO={kernelName:zl,backendName:"cpu",kernelFunc:RJ};var FJ=Et($a,r=>1/r),YO={kernelName:$a,backendName:"cpu",kernelFunc:FJ};function OJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;nt(o,"resizeBilinear");let u=x.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(x.sizeFromShape([p,l,c,d])),y=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=0,v=y[0]/b[0],k=y[1]/b[1];for(let E=0;E<p;E++)for(let $=0;$<l;$++){let D;i?D=v*($+.5)-.5:D=v*$;let R=Math.max(0,Math.floor(D)),P=D-R,W=Math.min(m-1,Math.ceil(D)),U=E*u[0]+R*u[1],q=E*u[0]+W*u[1];for(let K=0;K<c;K++){let j;i?j=k*(K+.5)-.5:j=k*K;let Q=Math.max(0,Math.floor(j)),rt=j-Q,X=Math.min(f-1,Math.ceil(j)),ot=U+Q*u[2],st=q+Q*u[2],it=U+X*u[2],ft=q+X*u[2];for(let at=0;at<d;at++){let xt=h[ot+at],dt=h[st+at],bt=h[it+at],kt=h[ft+at],At=xt+(bt-xt)*rt,Dt=dt+(kt-dt)*rt,qt=At+(Dt-At)*P;g[w++]=qt}}}return e.makeTensorInfo([p,l,c,d],"float32",g)}var ZO={kernelName:$s,backendName:"cpu",kernelFunc:OJ};function MJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;nt([s,o],"resizeBilinearGrad");let a=x.computeStrides(o.shape),[u,l,c,p]=o.shape,[,m,f]=s.shape,d=new Float32Array(u*l*c*p),h=[i&&m>1?l-1:l,i&&f>1?c-1:c],g=[i&&m>1?m-1:m,i&&f>1?f-1:f],y=h[0]/g[0],b=h[1]/g[1],w=e.data.get(s.dataId).values,v=0;for(let k=0;k<u;k++){let E=k*a[0];for(let $=0;$<m;$++){let D=$*y,R=Math.floor(D),P=Math.min(Math.ceil(D),l-1),W=E+R*a[1],U=E+P*a[1],q=D-R,K=1-q;for(let j=0;j<f;j++){let Q=j*b,rt=Math.floor(Q),X=Math.min(Math.ceil(Q),c-1),ot=Q-rt,st=1-ot,it=W+rt*a[2],ft=W+X*a[2],at=U+rt*a[2],xt=U+X*a[2],dt=K*st,bt=K*ot,kt=q*st,At=q*ot;for(let Dt=0;Dt<p;Dt++){let qt=w[v++];d[it+Dt]+=qt*dt,d[ft+Dt]+=qt*bt,d[at+Dt]+=qt*kt,d[xt+Dt]+=qt*At}}}}return e.makeTensorInfo([u,c,l,p],"float32",d)}var JO={kernelName:Jp,backendName:"cpu",kernelFunc:MJ};function PJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n;nt(o,"resizeNearestNeighbor");let u=x.computeStrides(o.shape),[l,c]=a,[p,m,f,d]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(p*l*c*d),y=[s&&l>1?m-1:m,s&&c>1?f-1:f],b=[s&&l>1?l-1:l,s&&c>1?c-1:c],w=y[0]/b[0],v=y[1]/b[1],k=0;for(let E=0;E<p;E++){let $=E*u[0];for(let D=0;D<l;D++){let R=i?w*(D+.5):w*D,P=Math.min(m-1,s?Math.round(R):Math.floor(R));i&&(P=Math.max(0,P));let W=$+P*u[1];for(let U=0;U<c;U++){let q=i?v*(U+.5):v*U,K=Math.min(f-1,s?Math.round(q):Math.floor(q));i&&(K=Math.max(0,K));let j=W+K*u[2];for(let Q=0;Q<d;Q++){let rt=h[j+Q];g[k++]=rt}}}}return e.makeTensorInfo([p,l,c,d],o.dtype,g)}var QO={kernelName:Bl,backendName:"cpu",kernelFunc:PJ};function LJ(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n;nt([s,o],"resizeNearestNeighborGrad");let a=x.computeStrides(o.shape),u=x.computeStrides(s.shape),[l,c,p,m]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*c*p*m),g=e.data.get(s.dataId).values,y=[i&&f>1?c-1:c,i&&d>1?p-1:p],b=[i&&f>1?f-1:f,i&&d>1?d-1:d],w=y[0]/b[0],v=y[1]/b[1],k=1/w,E=1/v,$=Math.ceil(k)*2+2,D=Math.ceil(E)*2+2;for(let R=0;R<l;R++){let P=R*a[0];for(let W=0;W<c;W++){let U=P+W*a[1],q=Math.floor(W*k),K=Math.floor(q-$/2);for(let j=0;j<p;j++){let Q=U+j*a[2],rt=Math.floor(j*E),X=Math.floor(rt-D/2);for(let ot=0;ot<m;ot++){let st=0;for(let it=0;it<$;it++){let ft=it+K;if(ft<0||ft>=f)continue;let at=P+ft*u[1],xt=ft*w,dt=Math.min(c-1,i?Math.round(xt):Math.floor(xt));if(W===dt)for(let bt=0;bt<D;bt++){let kt=bt+X;if(kt<0||kt>=d)continue;let At=at+kt*u[2],Dt=kt*v,qt=Math.min(p-1,i?Math.round(Dt):Math.floor(Dt));j===qt&&(st+=g[At+ot])}}h[Q+ot]=st}}}}return e.makeTensorInfo(o.shape,o.dtype,h)}var tM={kernelName:Zp,backendName:"cpu",kernelFunc:LJ};function zJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n;nt(o,"reverse");let i=o.shape.length,a=x.parseAxisParam(s,o.shape);if(i===0)return qr({inputs:{x:o},backend:e});let u=new pe(o.shape,o.dtype),l=e.bufferSync(o);for(let c=0;c<u.size;c++){let p=u.indexToLoc(c),m=p.slice();a.forEach(f=>m[f]=o.shape[f]-1-m[f]),u.set(l.get(...m),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var eM={kernelName:Rs,backendName:"cpu",kernelFunc:zJ};var rM={kernelName:Va,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(n.shape)),[l,c,p,m]=n.shape,[f,d]=S.getImageCenter(i,c,p),h=255,g=Math.sin(o),y=Math.cos(o),b=a.data.get(n.dataId).values;for(let v=0;v<l;v++){let k=v*p*c*m;for(let E=0;E<c;E++){let $=E*(p*m);for(let D=0;D<p;D++){let R=D*m;for(let P=0;P<m;P++){let W=[l,E,D,P],U=W[2],q=W[1],K=(U-f)*y-(q-d)*g,j=(U-f)*g+(q-d)*y;K=Math.round(K+f),j=Math.round(j+d);let Q=s;if(typeof s!="number"&&(P===3?Q=h:Q=s[P]),K>=0&&K<p&&j>=0&&j<c){let X=j*(p*m),ot=K*m,st=k+X+ot+P;Q=b[st]}let rt=k+$+R+P;u[rt]=Q}}}}return{dataId:a.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var BJ=Et(Fs,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),nM={kernelName:Fs,backendName:"cpu",kernelFunc:BJ};function ow(r,t,e,n,o,s,i,a,u,l){let c=[n/o,o],p=r.values,m=t.values;if(n===0)return It(e,t.dtype);let f=It(c,t.dtype);f.values.fill(u);for(let d=0;d<s;d++){let h=[],g=0;for(let y=0;y<i;y++){let b=p[d*i+y];h.push(b),g+=b*a[y]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${e}`);for(let y=0;y<o;y++)l?f.values[g*o+y]+=m[d*o+y]:f.values[g*o+y]=t.rank===0?m[0]:m[d*o+y]}return f}function VJ(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=!0,f=e.bufferSync(o),d=e.bufferSync(s),h=ow(f,d,i,p,l,u,a,c,0,m);return e.makeTensorInfo(i,h.dtype,h.values)}var oM={kernelName:Da,backendName:"cpu",kernelFunc:VJ};function GJ(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t;nt([n,o,s],"select");let i=n.shape.length,a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=ar(o.dtype,s.dtype),p=x.makeZerosTypedArray(x.sizeFromShape(o.shape),c),m=0,f=i===0||i>1||o.shape.length===1?1:x.sizeFromShape(o.shape.slice(1));for(let d=0;d<a.length;d++)for(let h=0;h<f;h++)a[d]===1?p[m++]=u[d]:p[m++]=l[d];return e.makeTensorInfo(o.shape,c,p)}var sM={kernelName:Ei,backendName:"cpu",kernelFunc:GJ};var WJ=S.SELU_SCALEALPHA,UJ=S.SELU_SCALE,HJ=Et(Ra,r=>r>=0?UJ*r:WJ*(Math.exp(r)-1)),iM={kernelName:Ra,backendName:"cpu",kernelFunc:HJ};var qJ=Et(Oa,r=>r<0?-1:r>0?1:0),aM={kernelName:Oa,backendName:"cpu",kernelFunc:qJ};var KJ=Et(Ms,r=>Math.sin(r)),lM={kernelName:Ms,backendName:"cpu",kernelFunc:KJ};var jJ=Et(Fa,r=>Math.sinh(r)),uM={kernelName:Fa,backendName:"cpu",kernelFunc:jJ};var XJ=11920928955078125e-23,cM=Math.log(XJ)+2,YJ=Et(Ma,r=>{let t=r>-cM,e=r<cM,n=Math.exp(r),o;return e?o=n:t?o=r:o=Math.log(1+n),o}),pM={kernelName:Ma,backendName:"cpu",kernelFunc:YJ};function ZJ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;nt([o],"spaceToBatchND");let a=x.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=nw.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=ne({inputs:{x:l},backend:e,attrs:{shape:c}}),b=He({inputs:{x:h},backend:e,attrs:{perm:p}}),k=ne({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(b),k}var mM={kernelName:$i,backendName:"cpu",kernelFunc:ZJ};function JJ(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values[0],[p,m,f,d,h]=Ub(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var fM={kernelName:Vl,backendName:"cpu",kernelFunc:JJ};function QJ(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(n.dataId).values,u=Array.from(e.data.get(s.dataId).values),[l,c,p]=Hb(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var dM={kernelName:Pa,backendName:"cpu",kernelFunc:QJ};function tQ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=sd(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var hM={kernelName:Gl,backendName:"cpu",kernelFunc:tQ};function eQ(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[l,c]=sd(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var gM={kernelName:Wl,backendName:"cpu",kernelFunc:eQ};function rQ(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=S.calculateShapes(s,o,a),f=!1,d=e.bufferSync(o),h=e.bufferSync(s),g=e.data.get(i.dataId).values[0],y=ow(d,h,a,m,c,l,u,p,g,f);return e.makeTensorInfo(a,y.dtype,y.values)}var xM={kernelName:Qp,backendName:"cpu",kernelFunc:rQ};function nQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=Mo({inputs:{x:o},backend:e,attrs:{begin:l,size:m}});return l[a]+=p,f})}var yM={kernelName:Di,backendName:"cpu",kernelFunc:nQ};var bM={kernelName:Ul,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;nt(e,"square");let o=n.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let u=o[a];s[a]=u*u}return{dataId:n.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var oQ=Et(uo,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),wM={kernelName:uo,backendName:"cpu",kernelFunc:oQ};function sQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n;nt(o,"stridedSlice");let{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=ne({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Ve.computeOutShape(b,w,v),$=Mo({inputs:{x:o},backend:e,attrs:{begin:b,size:E}});k=ne({inputs:{x:$},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo($)}else{let E=e.bufferSync(o),$=qb(f,E,v,b);k=e.makeTensorInfo(d,$.dtype,$.values)}return k}var vM={kernelName:La,backendName:"cpu",kernelFunc:sQ};function iQ(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.data.get(c.dataId).values,f=e.data.get(p.dataId).values,[d,h]=Kb(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var CM={kernelName:tm,backendName:"cpu",kernelFunc:iQ};function aQ(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values[0],[l,c,p]=jb(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var IM={kernelName:em,backendName:"cpu",kernelFunc:aQ};function lQ(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=Xb(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var SM={kernelName:rm,backendName:"cpu",kernelFunc:lQ};var uQ=Et(Ws,r=>Math.tan(r)),kM={kernelName:Ws,backendName:"cpu",kernelFunc:uQ};var cQ=Et(Us,r=>Math.tanh(r)),NM={kernelName:Us,backendName:"cpu",kernelFunc:cQ};function pQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;nt(o,"tile");let i=Yb(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var TM={kernelName:Yn,backendName:"cpu",kernelFunc:pQ};function mQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n;nt(o,"topk");let a=e.data.get(o.dataId).values,[u,l]=Zb(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}var _M={kernelName:za,backendName:"cpu",kernelFunc:mQ};function fQ(r){let{inputs:t,attrs:e,backend:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=e,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=x.computeStrides(o.shape),b=y[0],w=y[1],v=y[2],k=x.getTypedArrayFromDType(o.dtype,x.sizeFromShape(g));k.fill(u);let E=n.data.get(o.dataId).values,$=n.data.get(s.dataId).values;for(let R=0;R<c;++R){let P=s.shape[0]===1?$:$.subarray(R*8,R*8+8);for(let W=0;W<d;++W)for(let U=0;U<h;++U)for(let q=0;q<f;++q){let K,j=P[6]*U+P[7]*W+1;if(j===0)continue;let Q=(P[0]*U+P[1]*W+P[2])/j,rt=(P[3]*U+P[4]*W+P[5])/j,X=EM(Q,m,a),ot=EM(rt,p,a);switch(i){case"nearest":K=yQ(E,p,m,b,w,v,R,ot,X,q,u);break;case"bilinear":K=bQ(E,p,m,b,w,v,R,ot,X,q,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let st=R*b+W*w+U*v+q;k[st]=K}return n.makeTensorInfo(g,o.dtype,k)}return{dataId:n.write(k,g,o.dtype),shape:o.shape,dtype:o.dtype}}var AM={kernelName:Ba,backendName:"cpu",kernelFunc:fQ};function EM(r,t,e){switch(e){case"reflect":return dQ(r,t);case"wrap":return hQ(r,t);case"nearest":return xQ(r,t);case"constant":default:return gQ(r,t)}}function dQ(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{let n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return x.clamp(0,e,t-1)}function hQ(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{let n=t-1;e-=t*Math.trunc(e/n)}return x.clamp(0,e,t-1)}function gQ(r,t){return r}function xQ(r,t){return x.clamp(0,r,t-1)}function xg(r,t,e,n,o,s,i,a,u,l,c){let p=i*n+a*o+u*s+l;return 0<=a&&a<t&&0<=u&&u<e?r[p]:c}function yQ(r,t,e,n,o,s,i,a,u,l,c){let p=Math.round(a),m=Math.round(u);return xg(r,t,e,n,o,s,i,p,m,l,c)}function bQ(r,t,e,n,o,s,i,a,u,l,c){let p=Math.floor(a),m=Math.floor(u),f=p+1,d=m+1,h=(d-u)*xg(r,t,e,n,o,s,i,p,m,l,c)+(u-m)*xg(r,t,e,n,o,s,i,p,d,l,c),g=(d-u)*xg(r,t,e,n,o,s,i,f,m,l,c)+(u-m)*xg(r,t,e,n,o,s,i,f,d,l,c);return(f-a)*h+(a-p)*g}function wQ(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;nt(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:l}=Jb(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var $M={kernelName:nm,backendName:"cpu",kernelFunc:wQ};function vQ(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],u=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let m=new Array(a);for(let f=0;f<m.length;f++){c[s]=f;let d=Mo({inputs:{x:o},backend:e,attrs:{begin:c,size:p}});m[f]=ne({inputs:{x:d},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(d)}return m}var DM={kernelName:Ri,backendName:"cpu",kernelFunc:vQ};function CQ(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n;nt(o,"unsortedSegmentSum");let a=o.shape.length,u=s.shape.length,l=[],c=[],p=a-u,m=s;for(let d=0;d<p;++d){let h=ld({inputs:{input:m},backend:e,attrs:{dim:d+1}});m=h,c.push(h)}for(let d=0;d<i;++d){let h=x.createScalarValue(d,"int32"),g=e.makeTensorInfo([],"int32",h),y=Xk({inputs:{a:g,b:m},backend:e}),b=Fo({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),w=qc({inputs:{a:b,b:o},backend:e}),v=wl({inputs:{x:w},backend:e,attrs:{axis:0,keepDims:!1}});l.push(v),c.push(g),c.push(y),c.push(b),c.push(w),c.push(v)}let f=NN({inputs:l,backend:e,attrs:{axis:0}});return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var RM={kernelName:Hl,backendName:"cpu",kernelFunc:CQ};var IQ=[cF,kR,pF,mF,AR,fF,dF,hF,gF,xF,yF,bF,wF,vF,CF,SF,kF,NF,TF,uF,_F,EF,AF,$F,ER,$R,DF,NR,RF,OF,MF,PF,LF,zF,BF,VF,GF,WF,UF,HF,qF,KF,jF,XF,YF,ZF,JF,QF,tO,eO,nO,nF,oO,DR,sO,RR,iO,FR,aO,lO,uO,OR,cO,pO,mO,fO,dO,MR,PR,TR,hO,FF,gO,xO,yO,oF,LR,zR,bO,BR,wO,vO,CO,IO,SO,kO,NO,VR,TO,_O,EO,AO,DO,RO,FO,GR,OO,MO,zO,WR,UR,BO,VO,GO,HR,WO,qO,KO,nw,jO,sF,KR,XO,_R,dg,YO,iF,aF,lF,ZO,JO,QO,tM,eM,rM,nM,jR,oM,sM,iM,YR,aM,lM,uM,ZR,PO,pM,mM,fM,dM,hM,gM,xM,yM,QR,bM,tF,wM,vM,CM,IM,SM,eF,rO,kM,NM,TM,_M,AM,qR,$M,DM,RM,UO];for(let r of IQ)Lu(r);var pd={};Yt(pd,{assertNotComplex:()=>di,bindCanvasToFramebuffer:()=>DQ,bindColorTextureToFramebuffer:()=>vg,bindTextureToProgramUniformSampler:()=>WN,bindTextureUnit:()=>PM,bindVertexBufferToProgramAttribute:()=>uw,callAndCheck:()=>vt,canBeRepresented:()=>$N,createFragmentShader:()=>RN,createFramebuffer:()=>BN,createProgram:()=>FN,createStaticIndexBuffer:()=>PN,createStaticVertexBuffer:()=>MN,createTexture:()=>LN,createVertexShader:()=>DN,getBatchDim:()=>Cl,getExtensionOrThrow:()=>ud,getFramebufferErrorMessage:()=>LM,getMaxTexturesInShader:()=>qN,getNumChannels:()=>AQ,getProgramUniformLocation:()=>GN,getProgramUniformLocationOrThrow:()=>VN,getRowsCols:()=>Il,getShapeAs3D:()=>Cg,getTextureShapeFromLogicalShape:()=>UN,getWebGLDisjointQueryTimerVersion:()=>KN,getWebGLErrorMessage:()=>MM,getWebGLMaxTextureSize:()=>HN,hasExtension:()=>Un,isCapableOfRenderingToFloatTexture:()=>jN,isDownloadFloatTextureEnabled:()=>XN,isReshapeFree:()=>bu,isWebGLFenceEnabled:()=>YN,isWebGLVersionEnabled:()=>pw,linkProgram:()=>ON,logShaderSourceAndInfoLog:()=>lw,resetMaxTextureSize:()=>RQ,resetMaxTexturesInShader:()=>FQ,unbindColorTextureFromFramebuffer:()=>cw,unbindTextureUnit:()=>$Q,validateFramebuffer:()=>cd,validateProgram:()=>wg,validateTextureSize:()=>zN});var Xc={},TN={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function _N(r,t){Xc[r]=t}function Wn(r,t){if(!(r in Xc)||t!=null){let n=kQ(r,t);if(n!==null)Xc[r]=n;else return console.log("Could not get context for WebGL version",r),null}let e=Xc[r];return e==null||e.isContextLost()?(delete Xc[r],Wn(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Xc[r])}function SQ(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function kQ(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t==null?SQ(r):t;return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Xc[r]},!1),r===1?e.getContext("webgl",TN)||e.getContext("experimental-webgl",TN):e.getContext("webgl2",TN)}var yu;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(yu||(yu={}));var Kr;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(Kr||(Kr={}));var Rr;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Rr||(Rr={}));function Yc(r,t){return[t,r]}function FM(r,t){return r*t}function yg(r){let t=x.sizeFromShape(r),e=Math.ceil(t/4);return x.sizeToSquarishShape(e)}function Ji(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function OM(r,t){let[e,n]=Ji(r,t);return e*n*4}function bg(r,t){let e=r,n,o,s,i,a,u,l,c,p,m;return V().getNumber("WEBGL_VERSION")===2?(n=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,l=4,c=1,p=e.HALF_FLOAT,m=e.FLOAT,u=e.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=e.RGBA,a=r.RGBA,l=4,c=4,p=t!=null?t.HALF_FLOAT_OES:null,m=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:p,textureTypeFloat:m}}function vt(r,t){let e=t();return V().getBool("DEBUG")&&NQ(r),e}function NQ(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+MM(r,t))}var TQ=596e-10,_Q=65504;function $N(r){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||TQ<Math.abs(r)&&Math.abs(r)<_Q)}function MM(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function ud(r,t){return vl(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function DN(r,t){let e=vl(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(vt(r,()=>r.shaderSource(e,t)),vt(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function RN(r,t){let e=vl(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(vt(r,()=>r.shaderSource(e,t)),vt(r,()=>r.compileShader(e)),V().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw lw(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var EQ=/ERROR: [0-9]+:([0-9]+):/g;function lw(r,t){let e=EQ.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((p,m)=>x.rightPad((m+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${x.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function FN(r){return vl(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function ON(r,t){if(vt(r,()=>r.linkProgram(t)),!V().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function wg(r,t){if(vt(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function MN(r,t){let e=vl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),vt(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function PN(r,t){let e=vl(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return vt(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),vt(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function AQ(){return V().getNumber("WEBGL_VERSION")===2?1:4}function LN(r){return vl(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function zN(r,t){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function BN(r){return vl(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function uw(r,t,e,n,o,s,i){let a=r.getAttribLocation(t,e);return a===-1?!1:(vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),vt(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),vt(r,()=>r.enableVertexAttribArray(a)),!0)}function PM(r,t,e){zM(r,e),vt(r,()=>r.activeTexture(r.TEXTURE0+e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function $Q(r,t){zM(r,t),vt(r,()=>r.activeTexture(r.TEXTURE0+t)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function VN(r,t,e){return vl(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function GN(r,t,e){return r.getUniformLocation(t,e)}function WN(r,t,e,n){vt(r,()=>PM(r,t,n)),vt(r,()=>r.uniform1i(e,n))}function DQ(r){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),vt(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),vt(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function vg(r,t,e){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),vt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function cw(r,t){vt(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),vt(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function cd(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+LM(r,t))}function LM(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function vl(r,t,e){let n=vt(r,()=>t());if(n==null)throw new Error(e);return n}function zM(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Cl(r,t=2){return x.sizeFromShape(r.slice(0,r.length-t))}function Il(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Cg(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[Cl(r),...Il(r)]),t}function UN(r,t=!1){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,r=r.map((o,s)=>s>=r.length-2?x.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=x.squeezeShape(r).newShape);let n=x.sizeFromShape(r);if(r.length<=1&&n<=e)return[1,n];if(r.length===2&&r[0]<=e&&r[1]<=e)return r;if(r.length===3&&r[0]*r[1]<=e&&r[2]<=e)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=e&&r[1]*r[2]<=e)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e)return[r[0],r[1]*r[2]*r[3]];if(t){let o=Cl(r),s=2,i=2;return r.length&&([s,i]=Il(r)),n=o*(s/2)*(i/2),x.sizeToSquarishShape(n).map(a=>a*2)}return x.sizeToSquarishShape(n)}function sw(r){return r%2===0}function bu(r,t){if(r=r.slice(-2),t=t.slice(-2),x.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],n=t.slice(-1)[0];if(e===n||sw(e)&&sw(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&sw(r[0])&&sw(t[0])}var iw,aw;function HN(r){if(iw==null){let t=Wn(r);iw=t.getParameter(t.MAX_TEXTURE_SIZE)}return iw}function RQ(){iw=null}function FQ(){aw=null}function qN(r){if(aw==null){let t=Wn(r);aw=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,aw)}function KN(r){if(r===0)return 0;let t,e=Wn(r);return Un(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Un(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Un(r,t){return r.getExtension(t)!=null}function pw(r){try{if(Wn(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function jN(r){if(r===0)return!1;let t=Wn(r);if(r===1){if(!Un(t,"OES_texture_float"))return!1}else if(!Un(t,"EXT_color_buffer_float"))return!1;return AN(t)}function XN(r){if(r===0)return!1;let t=Wn(r);if(r===1){if(!Un(t,"OES_texture_float")||!Un(t,"WEBGL_color_buffer_float"))return!1}else{if(Un(t,"EXT_color_buffer_float"))return AN(t);let n="EXT_color_buffer_half_float";if(Un(t,n)){let o=t.getExtension(n);return OQ(t,o)}return!1}return AN(t)}function AN(r){let t=bg(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,n,o,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),i}function OQ(r,t){let e=bg(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,o,s,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function YN(r){return r!==2?!1:Wn(r).fenceSync!=null}function di(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&x.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Ft=V();Ft.registerFlag("HAS_WEBGL",()=>Ft.getNumber("WEBGL_VERSION")>0);Ft.registerFlag("WEBGL_VERSION",()=>pw(2)?2:pw(1)?1:0);Ft.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ft.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ft.get("WEBGL_VERSION")===2);Ft.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ft.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ft.registerFlag("WEBGL_PACK",()=>Ft.getBool("HAS_WEBGL"));Ft.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_CLIP",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_PACK_REDUCE",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_CONV_IM2COL",()=>Ft.getBool("WEBGL_PACK"));Ft.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>HN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>qN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Ft.getNumber("WEBGL_VERSION");return r===0?0:KN(r)});Ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ft.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Xl.isMobile());Ft.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>jN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ft.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ft.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ft.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>XN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_FENCE_API_ENABLED",()=>YN(Ft.getNumber("WEBGL_VERSION")));Ft.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ft.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ft.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Ft.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Xl.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Ft.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ft.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ft.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ft.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function qe(){let r,t,e,n,o,s,i,a,u,l;return V().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function hi(r,t,e="index"){let n=x.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Zc(r,t,e="index"){let n=x.computeStrides(t);return n.map((o,s)=>{let i=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function MQ(r,t){let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function BM(r,t,e="index"){let n=r.map((s,i)=>i),o=MQ(n,t);return o.map((s,i)=>{let a=`int ${r[i]} = ${e} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${e} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function md(r){let t=x.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function fd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var mw=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:VM}=S;function GM(r,t,e){let n=[];if(r.forEach(f=>{let d=x.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){let{uniformShape:h}=fw(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>PQ(f,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=t.texShape,a=qe(),u=BQ(a),l,c,p=WQ(a);return t.isPacked?(l=LQ(t.logicalShape,i,e.enableShapeUniforms),c=GQ(a)):(l=zQ(t.logicalShape,i,e.enableShapeUniforms),c=VQ(a)),e.packedInputs&&(p+=KQ),[p,u,c,o,l,s,e.userCode].join(`
`)}function hd(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return stt(r,t);case 1:return att(r,t);case 2:return utt(r,t);case 3:return ptt(r,t);case 4:return ftt(r,t);case 5:return dtt(r);case 6:return htt(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function WM(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return ott(r);case 1:return itt(r,t);case 2:return ltt(r,t);case 3:return ctt(r,t);default:return mtt(r,t)}}function PQ(r,t,e=!1,n){let o="";e?o+=WM(r,n):o+=hd(r,n);let s=r.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(e?o+=gtt(r,t):o+=xtt(r,t)),o}function LQ(r,t,e){switch(r.length){case 0:return UM();case 1:return jQ(r,t,e);case 2:return rtt(r,t,e);case 3:return YQ(r,t,e);default:return JQ(r,t,e)}}function zQ(r,t,e){switch(r.length){case 0:return UM();case 1:return XQ(r,t,e);case 2:return ntt(r,t,e);case 3:return ZQ(r,t,e);case 4:return QQ(r,t,e);case 5:return ttt(r,t);case 6:return ett(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function BQ(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function VQ(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function GQ(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function WQ(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${UQ}
    ${HQ}
    ${qQ}
  `}var UQ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,HQ=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qQ=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,KQ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function UM(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function jQ(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function XQ(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function YQ(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function ZQ(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Zc(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=hi(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function JQ(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function QQ(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Zc(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=hi(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function ttt(r,t){let e=hi(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function ett(r,t){let e=hi(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function rtt(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(x.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function ntt(r,t,e){return x.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Jc(r){return`offset${r}`}function ott(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=qe();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function stt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Jc(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function itt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=r.shapeInfo.texShape,s=qe();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function att(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${gd(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Jc(e);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function ltt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=qe();if(s!=null&&x.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function utt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&x.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=x.squeezeShape(e),u=i;if(u.length<e.length){let m=xd(r,u),f=["row","col"];return`
      ${hd(m,t)}
      float ${o}(int row, int col) {
        return ${o}(${yd(f,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${gd(r)}
      }
    `;let l=s[0],c=s[1],p=Jc(n);return c===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function ctt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let m=e.slice(1),f=[1,2],d=xd(r,m),h=["b","row","col"];return`
        ${WM(d,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${yd(h,f)});
        }
      `}let a=qe();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],c=Math.ceil(e[2]/2),p=c*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${p}, ${c}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function ptt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:u}=x.squeezeShape(e),l=a;if(l.length<e.length){let h=xd(r,l),g=["row","col","depth"];return`
        ${hd(h,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${yd(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${gd(r)}
      }
    `;let c=r.shapeInfo.texShape,p=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${p}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&f==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=Jc(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${i} + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${d};
        vec2 uv = uvFromFlat(${p}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function mtt(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=qe();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],p=Math.ceil(s[i-1]/2),m=p*Math.ceil(s[i-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${p} + (col / 2)`;for(let h=2;h<i-1;h++)f=`int b${h}, `+f,m*=s[i-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${n}(${f}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${o.texture2D}(${e}, uv);
    }
  `}function ftt(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=x.squeezeShape(e);if(u.length<e.length){let b=xd(r,u),w=["row","col","depth","depth2"];return`
      ${hd(b,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${yd(w,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${gd(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===a&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&c==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=Jc(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function dtt(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=x.squeezeShape(t);if(u.length<t.length){let h=xd(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${hd(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${yd(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${gd(r)}
      }
    `;let c=r.shapeInfo.flatOffset,p=r.shapeInfo.texShape,m=p[0],f=p[1];if(f===a&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;let d=Jc(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function htt(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=x.squeezeShape(t);if(o.length<t.length){let g=xd(r,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${hd(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${yd(y,s)});
      }
    `}let i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${gd(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Jc(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function gd(r){let t=r.name,e=x.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function gtt(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=VM(r.shapeInfo.logicalShape,t.logicalShape),u=Gt(i),l=i-s,c,p=["x","y","z","w","u","v"];s===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(b=>`coords.${p[b+l]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,w)=>`coords.${p[w+l]}`).join(", ");let f="return outputValue;",h=x.sizeFromShape(r.shapeInfo.logicalShape)===1,y=x.sizeFromShape(t.logicalShape)===1;if(s===1&&!h&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!y)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){let b=s-2,w=s-1;a.indexOf(b)>-1&&a.indexOf(w)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(w)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function xtt(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&x.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let l=Gt(u),c=VM(r.shapeInfo.logicalShape,t.logicalShape),p=u-a,m,f=["x","y","z","w","u","v"];a===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+p]} = 0;`).join(`
`);let d="";return u<2&&a>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+p]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function Gt(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function fw(r,t,e){let{newShape:n,keptDims:o}=x.squeezeShape(t),s=t.length,i=r&&s===3&&t[0]===1,a=i?t.slice(1):n,u=!r&&s>1&&!x.arraysEqual(t,e)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:t,keptDims:o}}function xd(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function yd(r,t){return t.map(e=>r[e]).join(", ")}function qM(r,t,e,n){let o=e.map((c,p)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:m}}),s=o.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=GM(o,i,t),u=RN(r.gl,a),l=r.createProgram(u);return V().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:s,outShapeInfo:i},ZN(r,t,l))}function ZN(r,t,e){let n={},o={},s={},i=[],a,u,l,c=null,p=null;p=r.getUniformLocation(e,"NAN",!1),V().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(e,"INFINITY",!1));let m=!1;for(let f=0;f<t.variableNames.length;f++){let d=t.variableNames[f];n[d]=r.getUniformLocation(e,d,m),n[`offset${d}`]=r.getUniformLocation(e,`offset${d}`,m),t.enableShapeUniforms&&(o[`${d}Shape`]=r.getUniformLocation(e,`${d}Shape`,m),s[`${d}TexShape`]=r.getUniformLocation(e,`${d}TexShape`,m))}return t.enableShapeUniforms&&(a=r.getUniformLocation(e,"outShape",m),l=r.getUniformLocation(e,"outShapeStrides",m),u=r.getUniformLocation(e,"outTexShape",m)),t.customUniforms&&t.customUniforms.forEach((f,d)=>{i[d]=r.getUniformLocation(e,f.name,m)}),{uniformLocations:n,customUniformLocations:i,infLoc:c,nanLoc:p,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}}function HM(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let o=e.logicalShape,s=t[n],i=s.shape;if(!x.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!x.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function KM(r,t,e,n,o){t.program.enableShapeUniforms||(HM(t.inShapeInfos,e),HM([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):r.setOutputMatrixTexture(s.texture,i[0],i[1]),r.setProgram(t.webGLProgram),V().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((u,l)=>{let c=t.program.variableNames[l],p=t.uniformLocations[c],m=t.uniformLocations[`offset${c}`],f=t.inShapesLocations[`${c}Shape`],d=t.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:h}=fw(t.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),p!=null){if(u.isUniform){if(x.sizeFromShape(u.shape)<2)r.gl.uniform1f(p,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(p,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,p,l)}});let a=t.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let u=x.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o&&t.program.customUniforms.forEach((u,l)=>{let c=t.customUniformLocations[l],p=o[l];if(u.type==="float")r.gl.uniform1fv(c,p);else if(u.type==="vec2")r.gl.uniform2fv(c,p);else if(u.type==="vec3")r.gl.uniform3fv(c,p);else if(u.type==="vec4")r.gl.uniform4fv(c,p);else if(u.type==="int")r.gl.uniform1iv(c,p);else if(u.type==="ivec2")r.gl.uniform2iv(c,p);else if(u.type==="ivec3")r.gl.uniform3iv(c,p);else if(u.type==="ivec4")r.gl.uniform4iv(c,p);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function jM(r,t,e){let n="";t.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:p}=fw(r.packedInputs,i.shape,u),m="",f="",d="";if(c.length===1&&r.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${k[0]>1}_${k[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let k=x.computeStrides(c);d=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let h=i.shape.length,g=c.length===2&&x.arraysEqual(i.shape,u),y=x.sizeFromShape(i.shape)===1,b=S.getBroadcastDims(i.shape,e.shape),w=!r.packedInputs&&h===e.shape.length&&x.arraysEqual(u,e.texData.texShape),v=r.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${w}_${l?p:""}_${c.length}_${y}_${b}_${g}_${m}_${f}_${d}_${v}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${V().getNumber("WEBGL_VERSION")}`,s}function De(r){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var dw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=yu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Zc(["r","c","d"],t):hi(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var hw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=yu.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Zc(["r","c","d"],t):hi(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var gw=class{constructor(t){this.variableNames=["A"],this.outTexUsage=Kr.DOWNLOAD;let e=qe();this.outputShape=t,this.userCode=`
      ${mw}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var xw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Kr.DOWNLOAD;let e=qe();this.outputShape=t,this.userCode=`
      ${mw}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var yw=class{constructor(t,e=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?fd():md(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var bw=class{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=qe();this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?fd():md(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var dT={};Yt(dT,{bindVertexProgramAttributeStreams:()=>iT,createBufferFromOutputTexture:()=>uT,createFloat16MatrixTexture:()=>rT,createFloat16PackedMatrixTexture:()=>sT,createFloat32MatrixTexture:()=>eT,createIndexBuffer:()=>tT,createPackedMatrixTexture:()=>oT,createUnsignedBytesMatrixTexture:()=>nT,createVertexBuffer:()=>QN,createVertexShader:()=>JN,downloadByteEncodedFloatMatrixFromOutputTexture:()=>pT,downloadFloat32MatrixFromBuffer:()=>cT,downloadMatrixFromPackedOutputTexture:()=>fT,downloadPackedMatrixFromBuffer:()=>mT,getInternalFormatForFloat16MatrixTexture:()=>vw,getInternalFormatForFloat16PackedMatrixTexture:()=>Sw,getInternalFormatForFloat32MatrixTexture:()=>ww,getInternalFormatForPackedMatrixTexture:()=>Iw,getInternalFormatForUnsignedBytesMatrixTexture:()=>Cw,uploadDenseMatrixToTexture:()=>aT,uploadPixelDataToTexture:()=>lT});function JN(r){let t=qe(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return DN(r,e)}function QN(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return MN(r,t)}function tT(r){let t=new Uint16Array([0,1,2,2,1,3]);return PN(r,t)}function Ig(r,t,e,n,o,s){zN(t,e);let i=LN(r),a=r.TEXTURE_2D;return vt(r,()=>r.bindTexture(a,i)),vt(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),vt(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),vt(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),vt(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),V().getNumber("WEBGL_VERSION")===1?vt(r,()=>r.texImage2D(a,0,n,t,e,0,o,s,null)):vt(r,()=>r.texStorage2D(a,1,n,t,e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function ww(r){return r.internalFormatFloat}function eT(r,t,e,n){let[o,s]=Yc(t,e);return Ig(r,o,s,ww(n),n.textureFormatFloat,r.FLOAT)}function vw(r){return r.internalFormatHalfFloat}function rT(r,t,e,n){let[o,s]=Yc(t,e);return Ig(r,o,s,vw(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function Cw(r){return r.downloadTextureFormat}function nT(r,t,e,n){let[o,s]=Yc(t,e);return Ig(r,o,s,Cw(n),r.RGBA,r.UNSIGNED_BYTE)}function Iw(r){return r.internalFormatPackedFloat}function oT(r,t,e,n){let[o,s]=Ji(t,e);return Ig(r,o,s,Iw(n),r.RGBA,r.FLOAT)}function Sw(r){return r.internalFormatPackedHalfFloat}function sT(r,t,e,n){let[o,s]=Ji(t,e);return Ig(r,o,s,Sw(n),r.RGBA,n.textureTypeHalfFloat)}function iT(r,t,e){return vt(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),uw(r,t,"clipSpacePos",e,3,20,0)&&uw(r,t,"uv",e,2,20,12)}function aT(r,t,e,n,o,s){vt(r,()=>r.bindTexture(r.TEXTURE_2D,t));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(e*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(e*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,n,r.RGBA,a,i)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,a,i)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function lT(r,t,e){vt(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):V().getNumber("WEBGL_VERSION")===2?vt(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):vt(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),vt(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function uT(r,t,e,n){let o=r.createBuffer();vt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*t*e;return vt(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),vt(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),vt(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function cT(r,t,e){let n=r,o=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function pT(r,t,e,n){let[o,s]=Yc(t,e),i=4,a=new Uint8Array(FM(t*e,i));return vt(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function mT(r,t,e,n,o,s,i,a){let u=r,l=new Float32Array(OM(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function fT(r,t,e){let n=new Float32Array(t*e*4);return vt(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var Qc=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=V().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,_N(e,t)):this.gl=Wn(e);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),V().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=ud(this.gl,s),Un(this.gl,i))this.textureHalfFloatExtension=ud(this.gl,i);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Un(this.gl,o))this.colorBufferHalfFloatExtension=ud(this.gl,o);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Un(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Un(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=QN(this.gl),this.indexBuffer=tT(this.gl),this.framebuffer=BN(this.gl),this.textureConfig=bg(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;vt(t,()=>t.finish()),vt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),vt(t,()=>t.deleteFramebuffer(this.framebuffer)),vt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),vt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),vt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),eT(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),rT(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),nT(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),lT(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,o){this.throwIfDisposed(),aT(this.gl,t,e,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),sT(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),oT(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(cw(this.gl,this.framebuffer),this.outputTexture=null),vt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>pT(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,o,s,i){return mT(this.gl,t,e,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return cT(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let o=uT(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(V().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>fT(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=JN(e));let n=FN(e);return vt(e,()=>e.attachShader(n,this.vertexShader)),vt(e,()=>e.attachShader(n,t)),ON(e,n),this.debug&&wg(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=iT(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&vt(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&wg(this.gl,this.program),vt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?VN(this.gl,t,e):GN(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),vt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),WN(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[o,s]=Ji(e,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&wg(this.gl,this.program),cd(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),vt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),vt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ud(this.gl,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await x.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=wtt(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&x.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),vg(this.gl,t,this.framebuffer),this.debug&&cd(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(vg(this.gl,this.outputTexture,this.framebuffer),this.debug&&cd(this.gl)):cw(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let o=this.gl;vg(o,t,this.framebuffer),this.debug&&cd(o),this.outputTexture=t,vt(o,()=>o.viewport(0,0,e,n)),vt(o,()=>o.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,o){this.throwIfDisposed(),vt(this.gl,()=>this.gl.scissor(t,e,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function wtt(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:XM,bincountImpl:kw,bincountReduceImpl:YM,ceilImpl:ZM,concatImpl:JM,equalImpl:QM,expImpl:tP,expm1Impl:eP,floorImpl:rP,gatherNdImpl:nP,gatherV2Impl:oP,greaterImpl:sP,greaterEqualImpl:iP,lessImpl:aP,lessEqualImpl:lP,linSpaceImpl:uP,logImpl:cP,maxImpl:pP,maximumImpl:mP,minimumImpl:fP,multiplyImpl:dP,negImpl:hP,notEqualImpl:gP,prodImpl:xP,rangeImpl:yP,rsqrtImpl:bP,sigmoidImpl:wP,simpleAbsImpl:Nw,sliceImpl:vP,sparseFillEmptyRowsImpl:CP,sparseReshapeImpl:IP,sparseSegmentReductionImpl:Tw,sqrtImpl:SP,stridedSliceImpl:kP,stringNGramsImpl:NP,stringSplitImpl:TP,stringToHashBucketFastImpl:_P,subImpl:EP,tileImpl:AP,topKImpl:$P,transposeImpl:tp,uniqueImpl:DP}=Qb;function hT(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function nr(r,t){return t===1?[r]:hT(r,t)}function RP(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var _w=class{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=De(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=nr("rc",this.rank),n=Gt(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${t[t.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var bd=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${vtt(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?fd():md(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function vtt(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?BM(["r","c","d"],"inputShape"):hi(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var Ew=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){let o=OP(e,n),s=MP(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=FP(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let a;return o===Rr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===Rr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===Rr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===Rr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===Rr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(t,e,n,o){if(this.freeTextures==null)return;let s=OP(n,o),i=MP(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=FP(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=V().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],c=l.indexOf(t);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Ctt(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function FP(r,t,e,n,o){let s=Itt(t,n),i;if(o){let[u,l]=Ji(r[0],r[1]);i=u*l}else{let[u,l]=Yc(r[0],r[1]);i=u*l}let a=Ctt(e,s);return i*a}function Itt(r,t){switch(r){case Rr.PACKED_2X2_FLOAT32:return Iw(t);case Rr.PACKED_2X2_FLOAT16:return Sw(t);case Rr.UNPACKED_FLOAT32:return ww(t);case Rr.UNPACKED_FLOAT16:return vw(t);case Rr.PACKED_4X1_UNSIGNED_BYTE:return Cw(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function Stt(r){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Rr.PACKED_2X2_FLOAT32:Rr.UNPACKED_FLOAT32:r?Rr.PACKED_2X2_FLOAT16:Rr.UNPACKED_FLOAT16}function OP(r,t){if(r===Kr.UPLOAD)return Rr.PACKED_2X2_FLOAT32;if(r===Kr.RENDER||r==null)return Stt(t);if(r===Kr.DOWNLOAD||r===Kr.PIXELS)return Rr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function MP(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var en=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},hr="if (isnan(x)) return x;",PP="return x;",gT="return abs(x);";var LP="return (x >= 0.0) ? x : (exp(x) - 1.0);",zP=hr+`
  return (x < 0.0) ? 0.0 : x;
`,BP=hr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ep="return x;",VP="return 1.0 / (1.0 + exp(-1.0 * x));";var WP="return x;",UP=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,HP=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qP=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,KP="return 1.0 / (1.0 + exp(-1.0 * x));",eo=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var Aw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let e=t.length,n=nr("rc",e),o=Gt(e),s=RP(e,n),i=n.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Ntt=Gr.whereImpl,Ttt=1e-7,_tt=1e-4,$w={};function Ett(r){return r in $w||($w[r]={}),$w[r]}var Att=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),$tt=600;function Dtt(){return V().global.screen==null?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*$tt/1024/1024}var wu=class extends jo{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof Qc)e=t;else{let n=Wn(V().getNumber("WEBGL_VERSION"),t);e=new Qc(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=Wn(V().getNumber("WEBGL_VERSION"));e=new Qc(n),this.binaryCache=Ett(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Ew(this.gpgpu),this.numMBBeforeWarning=Dtt(),this.texData=new Qi(this,go())}nextDataId(){return wu.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:e,dtype:n,values:t,usage:Kr.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,n,o,s){if(V().getBool("DEBUG")&&this.checkNumericalProblems(e),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:o,values:e,usage:Kr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let e=this.texData.get(t),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:u}=e;if(i!=null){let m;u?m=new eo(a,ep):m=new en(a,ep);let f=this.runWebGLProgram(m,[{dataId:t,shape:a,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(t);if(o==="string")return n;let l=this.activeTimers!=null,c;l&&(c=x.now());let p;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);p=S.mergeRealAndImagArrays(m,f)}else p=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=x.now()-c),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){let d=this.pendingRead.get(t);return new Promise(h=>d.push(h))}let e=this.texData.get(t),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:u}=e;if(s!=null){let d;u?d=new eo(o,ep):d=new en(o,ep);let h=this.runWebGLProgram(d,[{dataId:t,shape:o,dtype:i}],i),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(t);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&V().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&V().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let d=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(d.texture.texture,...yg(o))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let p;if(i==="complex64"){let d=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=d[0],g=d[1];p=S.mergeRealAndImagArrays(h,g)}else if(l==null)p=this.getValuesFromTexture(t);else{let d=x.sizeFromShape(o);p=this.gpgpu.downloadFloat32MatrixFromBuffer(l,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){let d=this.gpgpu.gl;vt(d,()=>d.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(t,p),f=this.pendingRead.get(t);return this.pendingRead.delete(t),f.forEach(d=>d(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&go().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,e={}){let n=this.texData.get(t),{values:o,shape:s,slice:i,dtype:a,isPacked:u,texture:l}=n;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;u?f=new eo(s,ep):f=new en(s,ep);let d=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:a}],a),h=this.readToGPU(d,e);return this.disposeIntermediateTensorInfo(d),h}if(l==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,e.customTexShape),p=go().makeTensorFromDataId(c.dataId,c.shape,c.dtype),m=this.texData.get(c.dataId);return Object.assign({tensorRef:p},m.texture)}bufferSync(t){let e=this.readSync(t.dataId),n=e;if(t.dtype==="string")try{n=e.map(o=>x.decodeString(o))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return It(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let n=t[e];if(!$N(n))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:n,isPacked:o}=this.texData.get(t),s=x.sizeFromShape(e);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...yg(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let i=V().getBool("WEBGL_PACK")&&o===!0,a=i?Cg(e):e,u=i?new xw(a):new gw(a),l=this.runWebGLProgram(u,[{shape:a,dtype:n,dataId:t}],"float32"),c=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let e=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t();let s=x.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=x.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);a.kernelMs=x.sum(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:x.now(),endMs:null}}endTimer(t){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=x.now(),t)}async getQueryTime(t){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:e,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(t),u=a&&a.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(e,o,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=Att){return V().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&x.sizeFromShape(n.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){S.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return Ntt(t.shape,e)}packedUnaryOp(t,e,n){let o=new eo(t.shape,e),s=this.compileAndRun(o,[t],n);return go().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let o=Nw(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,gT,t.dtype);let e=new en(t.shape,gT),n=this.compileAndRun(e,[t]);return go().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let o;if(e==="string"&&n!=null&&n.length>0&&x.isString(n[0])){let s=n.map(i=>x.encodeString(i));o=this.write(s,t,e)}else o=this.write(n,t,e);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:e}}makeOutput(t,e,n){let{dataId:o}=this.makeTensorInfo(t,e,n);return go().makeTensorFromDataId(o,t,e,this)}unpackTensor(t){let e=new Aw(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new _w(t.shape),n=!0;return this.runWebGLProgram(e,[t],t.dtype,null,n)}packedReshape(t,e){let n=[Cl(t.shape),...Il(t.shape)],o={dtype:t.dtype,shape:n,dataId:t.dataId},s=[Cl(e),...Il(e)],i=new bd(s,n),a=!0,u=[n],l=this.runWebGLProgram(i,[o],t.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t,e){let n=this.texData.get(t),{isPacked:o,shape:s,dtype:i}=n;if(e!=null){let m=x.sizeFromShape(s),f=e[0]*e[1]*4;x.assert(m<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let a=Cg(s),u;o?u=new hw(a):u=new dw(a);let l=!0,c=[e!=null?e:yg(a)],p=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:t}],i,c,l,e);return{dtype:i,shape:s,dataId:p.dataId}}runWebGLProgram(t,e,n,o,s=!1,i){let a=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(a.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===yu.DENSE){let y=i!=null?i:yg(t.outputShape);u.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),x.sizeFromShape(a.shape)===0)return u.values=x.getTypedArrayFromDType(a.dtype,0),a;let l=[],c=e.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&x.sizeFromShape(y.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),l.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!bu(b.shape,y.shape)){let w=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),l.push(y),b=this.texData.get(y.dataId),w.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:u,isUniform:!1},m=jM(t,c,p),f=this.getAndSaveBinary(m,()=>qM(this.gpgpu,t,c,p)),d=this.activeTimers!=null,h;d&&(h=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||KM(this.gpgpu,f,c,p,o),l.forEach(y=>this.disposeIntermediateTensorInfo(y)),d&&(h=this.endTimer(h),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(h)}));let g=V().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=x.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(t,e,n,o,s=!1){return n=n||e[0].dtype,this.runWebGLProgram(t,e,n,o,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=B(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=V().getBool("DEBUG");V().set("DEBUG",!1);let e=this.abs(pt(1e-8)).dataSync()[0];if(V().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Ttt:_tt}uploadToGPU(t){let e=this.texData.get(t),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:u}=e;if(i!=null)return;let l=this.activeTimers!=null,c;l&&(c=x.now());let p=e.texShape;if(p==null&&(p=UN(n,u),e.texShape=p),s!=null){let m=Cg(n),f,d=p[1],h=p[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([d,h]=Ji(p[0],p[1])),u?f=new bw(m,g):f=new yw(m,g);let y=g?[h,d]:p,b=this.makeTensorInfo(y,o),w=this.texData.get(b.dataId);g?w.usage=Kr.PIXELS:w.usage=Kr.UPLOAD,w.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),d,h,s);let v=[[h,d]],k=!0,E=this.runWebGLProgram(f,[b],o,v,k),$=this.texData.get(E.dataId);e.texShape=$.texShape,e.isPacked=$.isPacked,e.usage=$.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(e.texture=$.texture,e.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(b),l&&(this.uploadWaitMs+=x.now()-c)}else{let m=this.acquireTexture(p,a,o,u);e.texture=m}}convertAndCacheOnCPU(t,e){let n=this.texData.get(t),{dtype:o}=n;return this.releaseGPUData(t),e!=null&&(n.values=Rtt(e,o)),n.values}acquireTexture(t,e,n,o){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,o)}computeBytes(t,e){return t[0]*t[1]*x.bytesPerElement(e)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(let[,e]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(e),o(!0)}catch(s){throw s}});t.push(n)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await Vh(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(lw(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,t]of Object.entries(this.binaryCache)){let{uniformLocations:e,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:c}=ZN(this.gpgpu,t.program,t.webGLProgram);t.uniformLocations=e,t.customUniformLocations=n,t.infLoc=o,t.nanLoc=s,t.inShapesLocations=i,t.inTexShapesLocations=a,t.outShapeLocation=u,t.outShapeStridesLocation=l,t.outTexShapeLocation=c}}};wu.nextDataId=0;function Rtt(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}var jP="3.16.0";function XP(){V().set("WEBGL_FORCE_F16_TEXTURES",!0)}Xl.isBrowser()&&dm("webgl",()=>new wu,2);var gke={forceHalfFloat:XP};var Dw=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var ro=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=De(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var vu=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Po=class{constructor(t,e,n,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=S.assertAndGetBroadcastShape(e,n);let s=this.outputShape.length;this.enableShapeUniforms=De(s);let i="";if(o)if(s===0||x.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Gt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=nr("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Ke(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var YP={kernelName:lo,backendName:"webgl",kernelFunc:Ke};function Rn(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),i=e.texData.get(s.dataId),a=Ke({inputs:{x:n},backend:e}),u=Ke({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:u},s}var ZP={kernelName:$p,backendName:"webgl",kernelFunc:Rn};var xT="return (a < 0.) ? b * a : a;",yT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ftt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,i=e.makeTensorInfo([],"float32",x.createScalarValue(s,"float32")),a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(yT,o.shape,i.shape):new ro(xT,o.shape,i.shape),u=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),u}var JP={kernelName:hs,backendName:"webgl",kernelFunc:Ftt};var bT="return (a < 0.) ? b * a : a;",wT=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ott(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(wT,n.shape,o.shape):new ro(bT,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],"float32")}var QP={kernelName:_s,backendName:"webgl",kernelFunc:Ott};var Lo="if (isnan(x)) return x;",tL=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,eL=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Ct({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),m=e(p.values,u);return a.makeTensorInfo(i.shape,u,m)}let l=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return l?c=new eo(i.shape,t):c=new en(i.shape,r),a.runWebGLProgram(c,[i],u)}}function le({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,c=a;if(n&&u.dtype==="complex64"){let d=c.texData.get(u.dataId),h=c.texData.get(l.dataId),[g,y]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(w=>{let[v,k]=w,E={dataId:v.dataId,dtype:v.dtype,shape:u.shape},$={dataId:k.dataId,dtype:k.dtype,shape:l.shape},D=new ro(r,u.shape,l.shape);return c.runWebGLProgram(D,[E,$],ar(v.dtype,k.dtype))}),b=Rn({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}let p=s||ar(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&o!=null){let d=c.texData.get(u.dataId).values,h=c.texData.get(l.dataId).values,g=u.dtype==="string"?S.fromUint8ToStringArray(d):d,y=u.dtype==="string"?S.fromUint8ToStringArray(h):h,[b,w]=o(u.shape,l.shape,g,y,p),v=c.makeTensorInfo(w,p),k=c.texData.get(v.dataId);return k.values=b,v}let m=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,f;return m?f=new Po(t,u.shape,l.shape,e):f=new ro(r,u.shape,l.shape),c.runWebGLProgram(f,[u,l],p)}}function Cu(r,t=!1){if(r==="linear")return t?WP:PP;if(r==="relu")return t?HP:zP;if(r==="elu")return t?UP:LP;if(r==="relu6")return t?qP:BP;if(r==="prelu")return t?wT:bT;if(r==="leakyrelu")return t?yT:xT;if(r==="sigmoid")return t?KP:VP;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var wd=class{constructor(t,e,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=De(this.outputShape.length);let c=o?t[1]:t[2],p=Math.ceil(c/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",v="rc.x";t[0]<e[0]?w=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${p}; i++) {
          int batchA = ${w};
          int batchB = ${v};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};var vT={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Sg=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=S.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var rL="return a * b;";function kg(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=S.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),l=new Sg(vT.REAL,n.shape,o.shape),c=new Sg(vT.IMAG,n.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=Rn({inputs:{real:m,imag:f},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}if(e.shouldExecuteOnCPU([n,o])){let a=e.texData.get(n.dataId),u=e.texData.get(o.dataId),[l,c]=dP(n.shape,o.shape,a.values,u.values,s),p=e.makeTensorInfo(c,s),m=e.texData.get(p.dataId);return m.values=l,p}let i;return V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Po(rL,n.shape,o.shape):i=new ro(rL,n.shape,o.shape),e.runWebGLProgram(i,[n,o],s)}var nL={kernelName:Ss,backendName:"webgl",kernelFunc:kg};function oL(r,t,e){let n=[Cl(r.shape),...Il(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[Cl(t),...Il(t)],i=new bd(s,n),a=!0,u=[n],l=e.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function ut(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,i=e,a=x.sizeFromShape(o.shape),u=x.inferFromImplicitShape(s,a),l=x.sizeFromShape(u);x.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(o.dataId);return c.isPacked&&!bu(o.shape,u)&&!(c.texture!==null&&bu(c.shape,u))?oL(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var sL={kernelName:_i,backendName:"webgl",kernelFunc:ut};var Ng=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(e!=null){let p=1/e;l=`sumValue += dot(values * ${x.isInt(p)?p.toPrecision(2):p}, ones);`}let c="";s%n>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var Rw=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=t;this.outputShape=[o,i];let a="0.0",u="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",u="min"):e==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");let c=Math.floor(n/4)*4,p=n%4,m=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";e==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):e==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${p===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Ptt(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=S.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Hn(r,t,e,n){let o=Ptt(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],c,p;e==="mean"?c=i===0?new Ng({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new Ng({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):c=new Rw({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},e),p=s,s=n.runWebGLProgram(c,[s],t),p.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(p)}return s}var Fw=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[e[i]];this.outputShape=n,this.rank=n.length;let o=Gt(this.rank),s=Ltt(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Ltt(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<r.length;o++)n[r[o]]=e[o];return n.join()}var Ow=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let c=0;c<n.length;c++)n[c]=t[e[c]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Gt(this.rank),s=hT("rc",this.rank),i=new Array(this.rank);for(let c=0;c<e.length;c++)i[e[c]]=s[c];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Iu(r,t,e){let n=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ow(r.shape,t):new Fw(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function iL(r,t,e,n){let o=t,s=r.shape.length,i=x.parseAxisParam(o,r.shape),a=i,u=S.getAxesPermutation(a,s),l=u!=null,c=r;l&&(c=Iu(r,u,n),a=S.getInnerMostAxes(a.length,s)),S.assertAxesAreInnerMostDims("sum",a,s);let[p,m]=S.computeOutAndReduceShapes(c.shape,a),f=p;e&&(f=S.expandShapeToKeepDim(p,i));let d=x.sizeFromShape(m),g=x.sizeFromShape(r.shape)/d,y=ut({inputs:{x:c},attrs:{shape:[g,d]},backend:n}),b=Uu(r.dtype),w=Hn(y,b,"sum",n),v=ut({inputs:{x:w},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),l&&n.disposeIntermediateTensorInfo(c),v}function rp(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n;return iL(o,s,i,e)}var aL={kernelName:zs,backendName:"webgl",kernelFunc:rp};function Ae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,i=e,a=o.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=o.shape[s[c]];let l;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,m=tp(p,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let f=i.texData.get(l.dataId);f.values=m}else l=Iu(o,s,i);return l}var lL={kernelName:Hs,backendName:"webgl",kernelFunc:Ae};var CT=1e3;function np({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,c=t.shape.length,p=e?r.shape[l-2]:r.shape[l-1],m=n?t.shape[c-1]:t.shape[c-2],f=e?r.shape[l-1]:r.shape[l-2],d=n?t.shape[c-2]:t.shape[c-1],h=r.shape.slice(0,-2),g=t.shape.slice(0,-2),y=x.sizeFromShape(h),b=x.sizeFromShape(g),v=Pr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,d]);x.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let k=e?[y,p,f]:[y,f,p],E=n?[b,d,m]:[b,m,d],$=ut({inputs:{x:r},backend:o,attrs:{shape:k}}),D=ut({inputs:{x:t},backend:o,attrs:{shape:E}}),R=[$,D],P=Math.max(y,b),W=e?$.shape[1]:$.shape[2],U=s!=null,q=i!=null,K=u==="leakyrelu",j=u!=null?Cu(u,!0):null,Q=U||q||K||j!=null,rt;if((f===1||d===1)&&W>CT&&Q===!1){let ot=$,st=D;e&&(ot=Ae({inputs:{x:$},backend:o,attrs:{perm:[0,2,1]}}),R.push(ot)),n&&(st=Ae({inputs:{x:D},backend:o,attrs:{perm:[0,2,1]}}),R.push(st));let it=d!==1,ft=d===1,at=ot;it&&(at=ut({inputs:{x:ot},backend:o,attrs:{shape:[P,W,1]}}),R.push(at));let xt=d===1?2:1,dt=st;ft&&(dt=ut({inputs:{x:st},backend:o,attrs:{shape:[P,1,W]}}),R.push(dt));let bt=kg({inputs:{a:at,b:dt},backend:o});rt=rp({inputs:{x:bt},backend:o,attrs:{axis:xt,keepDims:!0}}),R.push(bt)}else{let ot=ar(r.dtype,t.dtype),st=new wd(k,E,[P,f,d],e,n,U,j,q,K),it=[$,D];if(s!=null&&it.push(s),q&&it.push(i),K){let ft=o.makeTensorInfo([],"float32",x.createScalarValue(a,"float32"));it.push(ft),R.push(ft)}rt=o.runWebGLProgram(st,it,ot)}let X=ut({inputs:{x:rt},backend:o,attrs:{shape:v}});R.push(rt);for(let ot of R)o.disposeIntermediateTensorInfo(ot);return X}function ztt(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n;return np({a:o,b:s,transposeA:u,transposeB:l,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:c})}var uL={kernelName:Oi,backendName:"webgl",kernelFunc:ztt};var cL="return abs(x);";function Btt(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=e.texData.get(n.dataId),i=Nw(s.values);return e.makeTensorInfo(n.shape,n.dtype,i)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new eo(n.shape,cL):o=new en(n.shape,cL),e.runWebGLProgram(o,[n],n.dtype)}var pL={kernelName:wi,backendName:"webgl",kernelFunc:Btt};var Vtt=hr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Gtt=Ct({opSnippet:Vtt}),mL={kernelName:ea,backendName:"webgl",kernelFunc:Gtt};var Wtt=hr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Utt=Ct({opSnippet:Wtt}),fL={kernelName:ra,backendName:"webgl",kernelFunc:Utt};var dL="return a + b;",Htt=le({opSnippet:dL,packedOpSnippet:dL,supportsComplex:!0,cpuKernelImpl:XM}),hL={kernelName:Xn,backendName:"webgl",kernelFunc:Htt};var Mw=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var Pw=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Lw(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return Ke({inputs:{x:n[0]},backend:e});if(n.length>V().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=Lw({inputs:n.slice(0,u),backend:e}),c=Lw({inputs:n.slice(u),backend:e});return Lw({inputs:[l,c],backend:e})}let o=n.map(u=>u.dtype).reduce((u,l)=>ar(u,l)),s=n.map(u=>u.shape),a=V().getBool("WEBGL_PACK")?new Pw(n[0].shape,s):new Mw(n[0].shape,s);return e.runWebGLProgram(a,n,o)}var gL={kernelName:Zo,backendName:"webgl",kernelFunc:Lw};function qtt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("all",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"all",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var xL={kernelName:na,backendName:"webgl",kernelFunc:qtt};function Ktt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,a)),S.assertAxesAreInnerMostDims("any",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"any",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var yL={kernelName:oa,backendName:"webgl",kernelFunc:Ktt};var zw=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var Bw=class{constructor(t,e,n,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,x.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],i=Math.ceil(s/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=Gt(u),c=nr("coords",u),p,m;if(i===1){m=u+1;let D=Gt(m);p=`
        ${D} sourceLocR = ${D}(${c.join()}, 0);
        ++${c[u-1]};
        ${D} sourceLocG = ${D}(${c.join()}, 0);
        ++${c[u-2]};
        ${D} sourceLocA = ${D}(${c.join()}, 0);
        --${c[u-1]};
        ${D} sourceLocB = ${D}(${c.join()}, 0);
        --${c[u-2]};`}else m=u,p=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(D=>"int "+D),g=nr("sourceLocR",m-1).concat("inIdx.r"),y=nr("sourceLocG",m-1).concat("inIdx.g"),b=nr("sourceLocB",m-1).concat("inIdx.b"),w=nr("sourceLocA",m-1).concat("inIdx.a"),v=n==="max"?"greaterThan":"lessThan",k=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()})));`,E=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,$=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function bL(r,t,e,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=S.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new zw(a,e,n==null),l=[t];n!=null&&l.push(n);let c=r.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;let p=bL(r,t,e,c);return r.disposeIntermediateTensorInfo(c),p}function wL(r,t,e,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],i=S.computeOptimalWindowSize(s),a=new Bw(o,i,e,n==null),u=n==null?[t]:[t,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===t.shape.length){let c=wL(r,t,e,l);return r.disposeIntermediateTensorInfo(l),c}return l}function Vw(r,t,e,n){let o=[e];if(S.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=r.texData.get(t.dataId),a=i!==null&&i.isPacked,u=t;a&&(u=r.unpackTensor(t),s.push(u));let[l,c]=S.computeOutAndReduceShapes(u.shape,o),p=x.sizeFromShape(c),m=ut({inputs:{x:u},backend:r,attrs:{shape:[-1,p]}});s.push(m);let f=bL(r,m,n);s.push(f);let d=ut({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return wL(r,t,n)}function jtt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ae({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=Vw(e,u,i[0],"max");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var vL={kernelName:Jo,backendName:"webgl",kernelFunc:jtt};function Xtt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,i=x.parseAxisParam(s,o.shape),a=S.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ae({inputs:{x:o},backend:e,attrs:{perm:a}}),l.push(u),i=S.getInnerMostAxes(i.length,u.shape.length)),S.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=Vw(e,u,i[0],"min");return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),c}var CL={kernelName:$l,backendName:"webgl",kernelFunc:Xtt};var Ytt=hr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Ztt=Ct({opSnippet:Ytt}),IL={kernelName:sa,backendName:"webgl",kernelFunc:Ztt};var Jtt=hr+"return log(x + sqrt(x * x + 1.0));",Qtt=Ct({opSnippet:Jtt}),SL={kernelName:ia,backendName:"webgl",kernelFunc:Qtt};var tet=hr+`
  return atan(x);
`,eet=Ct({opSnippet:tet}),kL={kernelName:aa,backendName:"webgl",kernelFunc:eet};var ret=tL+`
  return atan(a, b);
`,net=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+eL+`
  return result;
`,oet=le({opSnippet:ret,packedOpSnippet:net}),NL={kernelName:ua,backendName:"webgl",kernelFunc:oet};var set=hr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,iet=Ct({opSnippet:set}),TL={kernelName:la,backendName:"webgl",kernelFunc:iet};var gi=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,f=t.padInfo.top,d=t.padInfo.left;this.outputShape=t.outShape;let h=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,b="0.0";if(h||(b="-1.0 / 1e-20"),n){let D=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${D} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:y:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(v="avgValue / count");let k=Math.floor(i/4)*4,E=i%4,$=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${k};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${v});
      }
    `}},Su=class{constructor(t,e,n,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=t.filterWidth,a=t.strideDepth,u=t.strideHeight,l=t.strideWidth,c=t.dilationDepth,p=t.dilationHeight,m=t.dilationWidth,f=t.effectiveFilterDepth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;let w=e==="avg",v="0.0";if(w||(v="-1.0 / 1e-20"),n){let P=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${P} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",E=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(E="avgValue / count");let $=Math.floor(i/4)*4,D=i%4,R=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${$};
            if (${D===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${D===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${D===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${R}
            }
          }
          setOutput(${E});
        }
      }
    `}};function aet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;di(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return Ke({inputs:{x:o},backend:e});let p=new gi(c,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var _L={kernelName:Qo,backendName:"webgl",kernelFunc:aet};function uet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,u,l),m=new Su(p,"avg",!1);return e.runWebGLProgram(m,[o],"float32")}var EL={kernelName:Dl,backendName:"webgl",kernelFunc:uet};var Gw=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,c=u-1-t.padInfo.top,p=l-1-t.padInfo.left,m=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${p});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Ww=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,f=t.effectiveFilterWidth,d=p-1-t.padInfo.front,h=m-1-t.padInfo.top,g=f-1-t.padInfo.left,y=1/(e*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function cet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Ww(m);return e.runWebGLProgram(f,[o],i.dtype)}var AL={kernelName:_p,backendName:"webgl",kernelFunc:cet};function pet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s;di([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,c=S.computePool2DInfo(i.shape,a,u,1,l),p=new Gw(c);return e.runWebGLProgram(p,[o],i.dtype)}var $L={kernelName:Tp,backendName:"webgl",kernelFunc:pet};function met(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;return np({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var DL={kernelName:ts,backendName:"webgl",kernelFunc:met};var Uw=class{constructor(t,e,n,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="0.0";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var Hw=class{constructor(t,e,n,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],S.assertAndGetBroadcastShape(t,e),S.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";o!=null&&(S.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(S.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var fet=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;x.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let l=[n,o,s],c=null;i!=null&&(c=i.shape,l.push(i));let p=null;a!=null&&(p=a.shape,l.push(a));let m=V().getBool("WEBGL_PACK_NORMALIZATION")?new Hw(n.shape,o.shape,s.shape,c,p,u):new Uw(n.shape,o.shape,s.shape,c,p,u);return t.runWebGLProgram(m,l,l[0].dtype)},RL={kernelName:fs,backendName:"webgl",kernelFunc:fet};var qw=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=Gt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=det(this.rank),o,s=t.map((i,a)=>`sourceLoc.${IT[a]} = start[${a}] + coords.${IT[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},IT=["x","y","z","w","u","v"];function det(r){if(r===1)return"sourceLoc";if(r<=6)return IT.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var Kw=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Gt(this.rank),n=nr("coords",this.rank),o=nr("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((c,p)=>`start[${p}]`).join()});`:t.map((c,p)=>`${o[p]} = ${n[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function het(r,t,e,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(e,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=r.dtype;let a=Ve.computeFlatOffset(t,x.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function xi(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:i}=n,[a,u]=Ve.parseSliceParams(o,s,i);if(Ve.assertParamsValid(o,a,u),x.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),m=vP(p.values,a,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=e.texData.get(o.dataId),c=Ve.isSliceContinous(o.shape,a,u);if(l||!c){let p=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Kw(u):new qw(u),m=[a];return e.runWebGLProgram(p,[o],o.dtype,m)}return e.uploadToGPU(o.dataId),het(o,a,u,e)}var FL={kernelName:Ai,backendName:"webgl",kernelFunc:xi};var get=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n;x.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((b,w)=>b*w),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=[],d=ut({inputs:{x:o},backend:e,attrs:{shape:u}}),h=Ae({inputs:{x:d},backend:e,attrs:{perm:l}}),g=ut({inputs:{x:h},backend:e,attrs:{shape:c}}),y=xi({inputs:{x:g},backend:e,attrs:{begin:p,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y},OL={kernelName:vi,backendName:"webgl",kernelFunc:get};function xet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i}=n,a=e.readSync(o.dataId),u=e.readSync(s.dataId),l=kw(a,u,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,l)}var ML={kernelName:Ep,backendName:"webgl",kernelFunc:xet};function yet(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.readSync(n.dataId),i=e.readSync(o.dataId),a=S.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var PL={kernelName:Ap,backendName:"webgl",kernelFunc:yet};var bet="return float(a != b);",ST=le({opSnippet:bet,cpuKernelImpl:gP,dtype:"bool"}),LL={kernelName:Ta,backendName:"webgl",kernelFunc:ST};function Sl(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return Ke({inputs:{x:o.complexTensorInfos.real},backend:e})}var zL={kernelName:Yp,backendName:"webgl",kernelFunc:Sl};var wet="return float(int(x));";function BL(r,t){let e=new en(r.shape,wet),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function kT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Ke({inputs:{x:o},backend:e});let i=ye(o.shape),a=kT({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=Rn({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Sl({inputs:{input:o},backend:e}),a=kT({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!x.hasEncodingLoss(o.dtype,s)){let i=Ke({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32")return BL(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",x.getTypedArrayFromDType("bool",1)),u=ST({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var VL={kernelName:io,backendName:"webgl",kernelFunc:kT};var GL="return ceil(x);",vet=Ct({opSnippet:GL,packedOpSnippet:GL,cpuKernelImpl:ZM}),WL={kernelName:es,backendName:"webgl",kernelFunc:vet};var jw=class{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Xw=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Cet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a;V().getBool("WEBGL_PACK_CLIP")?a=new Xw(o.shape):a=new jw(o.shape);let u=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,u)}var UL={kernelName:ao,backendName:"webgl",kernelFunc:Cet};var Yw=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function HL(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function Iet(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.texData.get(n.dataId),s=new Yw(n.shape),i=[HL(n,o.complexTensorInfos.real),HL(n,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var qL={kernelName:Rl,backendName:"webgl",kernelFunc:Iet};var Zw=class{constructor(t){this.outputShape=[],this.outputShape=S.computeOutShape(t,1),this.variableNames=t.map((i,a)=>`T${a}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var Qw=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=S.computeOutShape(t,e);let n=this.outputShape,o=n.length,s=Gt(o),i=nr("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((h,g)=>`T${g}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let h=1;h<u.length;h++)u[h]=u[h-1]+t[h][e];let l=a[e],c=a.slice(-2),p=a.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${Jw(a,l,g)}),
            vec2(${Jw(c,l,g)}));
        }`}let f=u.length,d=u[u.length-1];m+=`
        return getChannel(
          getT${f}(${Jw(a,l,d)}),
          vec2(${Jw(c,l,d)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Jw(r,t,e){let n=r.indexOf(t);return r.map((s,i)=>i===n?`${s} - ${e}`:s).join()}function op(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return Ke({inputs:{x:o.complexTensorInfos.imag},backend:e})}var KL={kernelName:Wp,backendName:"webgl",kernelFunc:op};function sp(r,t,e){let n=r[0].dtype;if(n==="complex64"){let c=r.map(h=>Sl({inputs:{input:h},backend:e})),p=r.map(h=>op({inputs:{input:h},backend:e})),m=sp(c,t,e),f=sp(p,t,e),d=Rn({inputs:{real:m,imag:f},backend:e});return c.forEach(h=>e.disposeIntermediateTensorInfo(h)),p.forEach(h=>e.disposeIntermediateTensorInfo(h)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let c=r.map(y=>{let b=x.sizeFromShape(y.shape.slice(t));return ut({inputs:{x:y},backend:e,attrs:{shape:[-1,b]}})}),p=c.map(y=>({vals:e.readSync(y.dataId),shape:y.shape})),m=S.computeOutShape(c.map(y=>y.shape),1),f=c[0].shape[0]===1,d=JM(p,m,n,f),h=S.computeOutShape(r.map(y=>y.shape),t),g=e.makeTensorInfo(h,n,d);return c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}if(r.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let c=Math.floor(r.length/2),p=sp(r.slice(0,c),t,e),m=sp(r.slice(c),t,e),f=sp([p,m],t,e);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),f}if(V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let c=new Qw(r.map(p=>p.shape),t);return e.runWebGLProgram(c,r,n)}let{tensors2D:s,outShape:i}=ket(r,t,e),a=new Zw(s.map(c=>c.shape)),u=e.runWebGLProgram(a,s,n);s.forEach(c=>e.disposeIntermediateTensorInfo(c));let l=ut({inputs:{x:u},attrs:{shape:i},backend:e});return e.disposeIntermediateTensorInfo(u),l}function ket(r,t,e){let n=S.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>ut({inputs:{x:s},attrs:{shape:[-1,x.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:n}}function NT(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=x.parseAxisParam(o,t[0].shape)[0],i=S.computeOutShape(t.map(l=>l.shape),s);if(x.sizeFromShape(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);let a=t.filter(l=>x.sizeFromShape(l.shape)>0);if(a.length===1)return Ke({inputs:{x:a[0]},backend:e});let u=a.map(l=>l.shape);return S.assertParamsConsistent(u,s),sp(a,s,e)}var jL={kernelName:Ci,backendName:"webgl",kernelFunc:NT};var vd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let i=t.padInfo.top,a=t.padInfo.left,u=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,p=t.dilationWidth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,w=g?3:1,v="",k="";n&&(o?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:v=`
          float activation(float x) {
            ${n}
          }
        `,k="result = activation(result);");let E=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${k}
        setOutput(result);
      }
    `}},tv=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,c=t.dilationWidth,p=t.filterDepth,m=t.filterHeight,f=t.filterWidth,d=Math.floor(t.inChannels/4)*4,h=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var ev=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=De(this.outputShape.length);let{dataFormat:n}=e,o=qe(),s=n==="channelsLast",i=s?0:1,a=s?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${t[1]} && pos < ${t[0]}) {`,l="";for(let c=0;c<=1;c++)for(let p=0;p<=1;p++)l+=`
          blockIndex = rc.y + ${p};
          pos = rc.x + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+p}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+p}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function rv({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),c=e.inChannels,p=u[0]*u[1]*u[2],m=e.outChannels,f=e.dataFormat==="channelsLast",d=!1,h=!1,g,y=[];if(!((p===1||m===1)&&c>CT)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!==0&&x.arraysEqual(l.shape.slice(-3),u.slice(-3))){let v=u[0]*u[1]*(u[2]+1),k={dataId:r.dataId,shape:[1,v,e.inChannels],dtype:r.dtype},E=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,x.assert(bu(l.shape,k.shape),()=>`packed reshape ${l.shape} to ${k.shape} isn't free`);let $=ut({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push($);let D=np({a:k,b:$,backend:n,transposeA:d,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),R=n.texData.get(D.dataId);x.assert(R.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=E,R.shape=e.outShape,g=Ke({inputs:{x:D},backend:n}),g.shape=e.outShape,y.push(D)}else{let v=f?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],k=ut({inputs:{x:r},backend:n,attrs:{shape:[1,v,e.inChannels]}}),E=ut({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),$=np({a:k,b:E,transposeA:d,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=ut({inputs:{x:$},backend:n,attrs:{shape:e.outShape}}),y.push(k),y.push(E),y.push($)}for(let v of y)n.disposeIntermediateTensorInfo(v);return g}function nv({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:c,outWidth:p,outHeight:m,dataFormat:f}=e,d=f==="channelsLast",h=u*l*c,g=m*p,y=[h,g],b=!0,w=!1,v=[],k=ut({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),E=ut({inputs:{x:t},backend:n,attrs:{shape:[1,h,x.sizeFromShape(t.shape)/h]}});v.push(k),v.push(E);let $=new ev(y,e),D=[k.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],R=n.runWebGLProgram($,[k],"float32",D),P=ut({inputs:{x:R},backend:n,attrs:{shape:[1,y[0],y[1]]}});v.push(R),v.push(P);let W=o!=null,U=s!=null,q=a==="leakyrelu",K=a?Cu(a,!0):null,j=new wd(P.shape,E.shape,[1,g,e.outChannels],b,w,W,K,U,q),Q=[P,E];if(o&&Q.push(o),U&&Q.push(s),q){let st=n.makeTensorInfo([],"float32",x.createScalarValue(i,"float32"));Q.push(st),v.push(st)}let rt=n.runWebGLProgram(j,Q,"float32"),X=d?[1,m,p,e.outChannels]:[1,e.outChannels,m,p],ot=ut({inputs:{x:rt},backend:n,attrs:{shape:X}});v.push(rt);for(let st of v)n.disposeIntermediateTensorInfo(st);return ot}function Net(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,s.shape,i,l,a,c,!1,p),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=rv({x:o,filter:s,convInfo:m,backend:e});else if(V().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)f=nv({x:o,filter:s,convInfo:m,backend:e});else{let h=new vd(m);f=e.runWebGLProgram(h,[o,s],"float32")}let d=ut({inputs:{x:f},backend:e,attrs:{shape:m.outShape}});return e.disposeIntermediateTensorInfo(f),d}var XL={kernelName:rs,backendName:"webgl",kernelFunc:Net};var ov=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},sv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=t.dataFormat==="channelsLast",a=e-1-t.padInfo.top,u=n-1-t.padInfo.left,l=i?1:2,c=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},iv=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,i=t.padInfo.top,a=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},av=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,i=t.strideHeight,a=t.strideWidth,u=e-1-t.padInfo.front,l=n-1-t.padInfo.top,c=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Tet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=n,p=S.convertConv2DDataFormat(u),m=S.computeConv2DInfo(o.shape,c,i,1,a,l,!1,p),f=new ov(m);return e.runWebGLProgram(f,[o,s],"float32")}var YL={kernelName:Dp,backendName:"webgl",kernelFunc:Tet};function _et(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=n,p=S.convertConv2DDataFormat(l),m=S.computeConv2DInfo(i,s.shape,a,1,u,c,!1,p),f=new sv(m);return e.runWebGLProgram(f,[o,s],"float32")}var ZL={kernelName:ns,backendName:"webgl",kernelFunc:_et};function Eet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeConv3DInfo(o.shape,s.shape,i,u,a),c=new tv(l);return e.runWebGLProgram(c,[o,s],"float32")}var JL={kernelName:Fl,backendName:"webgl",kernelFunc:Eet};function Aet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,pad:a,filterShape:u}=n,l=S.computeConv3DInfo(o.shape,u,i,1,a),c=new iv(l);return e.runWebGLProgram(c,[o,s],"float32")}var QL={kernelName:Rp,backendName:"webgl",kernelFunc:Aet};function $et(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:i,strides:a,inputShape:u}=n,l=S.computeConv3DInfo(u,s.shape,a,1,i),c=new av(l);return e.runWebGLProgram(c,[o,s],"float32")}var t3={kernelName:Fp,backendName:"webgl",kernelFunc:$et};var Det=Lo+`
  return cos(x);
`,Ret=Ct({opSnippet:Det}),e3={kernelName:os,backendName:"webgl",kernelFunc:Ret};var Fet=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Oet=Ct({opSnippet:Fet}),r3={kernelName:ss,backendName:"webgl",kernelFunc:Oet};var lv=class{constructor(t,e,n,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,u,l]=t,[c]=e,[p,m]=n;this.outputShape=[c,p,m,l];let f=o==="bilinear"?1:0,[d,h]=[`${a-1}.0`,`${u-1}.0`],[g,y,b]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[w,v,k]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${v};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Met=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=n,c=new lv(o.shape,s.shape,a,u,l);return e.runWebGLProgram(c,[o,s,i],"float32")},n3={kernelName:pa,backendName:"webgl",kernelFunc:Met};var Tg=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;let o=t.length,s=e?"1.0":`getX(${o3(o,"coords")})`,i=t[t.length-1],a="",u="";e?(a=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Gt(o)} coords = getOutputCoords();
        int end = ${s3(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${u};
          ${s3(o,"coords")} = idx;
          val *= getX(${o3(o,"coords")});
        }
        setOutput(val);
      }
    `}};function o3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative product for rank ${r} is not yet supported`)}function s3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative product for rank ${r} is not yet supported`)}function Pet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length,l=S.getAxesPermutation([s],u),c=o;l!=null&&(c=Ae({inputs:{x:o},backend:e,attrs:{perm:l}}));let p=S.getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=c.shape[p],f=Ke({inputs:{x:c},backend:e});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new Tg(c.shape,!1,a),g=[[d]],y=f;f=e.runWebGLProgram(h,[f],f.dtype,g),e.disposeIntermediateTensorInfo(y)}if(i){let d=new Tg(c.shape,i,a),h=f;f=e.runWebGLProgram(d,[f],f.dtype),e.disposeIntermediateTensorInfo(h)}if(l!=null){let d=S.getUndoAxesPermutation(l),h=Ae({inputs:{x:f},backend:e,attrs:{perm:d}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(c),h}return f}var i3={kernelName:ca,backendName:"webgl",kernelFunc:Pet};var _g=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=t;let o=t.length,s=e?"0.0":`getX(${a3(o,"coords")})`,i=t[t.length-1],a="",u="";e?(a=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Gt(o)} coords = getOutputCoords();
        int end = ${l3(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${u};
          ${l3(o,"coords")} = idx;
          val += getX(${a3(o,"coords")});
        }
        setOutput(val);
      }
    `}};function a3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function l3(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function Let(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length,l=S.getAxesPermutation([s],u),c=o;l!=null&&(c=Ae({inputs:{x:o},backend:e,attrs:{perm:l}}));let p=S.getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=c.shape[p],f=Ke({inputs:{x:c},backend:e});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new _g(c.shape,!1,a),g=[[d]],y=f;f=e.runWebGLProgram(h,[f],f.dtype,g),e.disposeIntermediateTensorInfo(y)}if(i){let d=new _g(c.shape,i,a),h=f;f=e.runWebGLProgram(d,[f],f.dtype),e.disposeIntermediateTensorInfo(h)}if(l!=null){let d=S.getUndoAxesPermutation(l),h=Ae({inputs:{x:f},backend:e,attrs:{perm:d}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(c),h}return f}var u3={kernelName:is,backendName:"webgl",kernelFunc:Let};function zet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=kw(u,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}else if(o.shape.length===2){let u=e.bufferSync(o),l=e.bufferSync(s),c=YM(u,l,i,a);return e.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var c3={kernelName:Op,backendName:"webgl",kernelFunc:zet};var uv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Bet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=new uv(d,s,i);return e.runWebGLProgram(h,[o],o.dtype)}var p3={kernelName:ma,backendName:"webgl",kernelFunc:Bet};var Cd=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=De(this.outputShape.length);let i=t.filterHeight,a=t.filterWidth,u=t.outChannels/t.inChannels,l="",c="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,c="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${c}
        setOutput(result);
      }
    `}};var Id=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=De(this.outputShape.length);let i=t.outChannels/t.inChannels,a=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,p=t.filterWidth,m=p,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<p;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(m+1)/2;y++){let b=y*2;if(f+=`
          xC = xCCorner + ${b*l};
          `,u===1){if(b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,l===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<p)){let w=a%2===0?x.nearestLargerEven(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,l>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                      xTexelC${b} = getX(batch, xR, xCOffset, d1);
                      xTexelC${b}Ready = 1;
                    }
                    `),f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                  `):w===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<p&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<p&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<p&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<p&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<p&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function Vet(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,c=u;c==null&&(c=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let p=S.computeConv2DInfo(o.shape,s.shape,i,c,a,l,!0),m;V().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?m=new Id(p):m=new Cd(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(m,[o,s],"float32",f)}var m3={kernelName:as,backendName:"webgl",kernelFunc:Vet};var cv=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},pv=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,i=e-1-t.padInfo.top,a=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Get(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=n,p=S.computeConv2DInfo(o.shape,c,i,a,u,l,!0),m=new cv(p);return e.runWebGLProgram(m,[o,s],"float32")}var f3={kernelName:Mp,backendName:"webgl",kernelFunc:Get};function Wet(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=n,p=S.computeConv2DInfo(c,s.shape,i,a,u,l,!0),m=new pv(p);return e.runWebGLProgram(m,[o,s],"float32")}var d3={kernelName:Pp,backendName:"webgl",kernelFunc:Wet};var mv=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Uet(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=x.sizeFromShape(n.shape),i=ut({inputs:{x:n},backend:e,attrs:{shape:[s]}}),a=new mv(s),u=e.runWebGLProgram(a,[i],i.dtype),l=ut({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}var h3={kernelName:Lp,backendName:"webgl",kernelFunc:Uet};var fv=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=t,{top:p,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Het(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:i,pad:a,dilations:u}=n,l=S.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),c,p=new fv(l);c=e.runWebGLProgram(p,[o,s],"float32");let m=ut({inputs:{x:c},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(c),m}var g3={kernelName:Ol,backendName:"webgl",kernelFunc:Het};function qet(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:i,summedDims:a,idDims:u}=S.decodeEinsumEquation(o,s.length);S.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:c}=S.getEinsumComputePath(a,u),p=c.length,m=null,f=i.length,d=[];for(let h=0;h<p;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=S.getEinsumPermutation(f,u[g]),w;S.isIdentityPermutation(y)?w=s[g]:(w=Ae({inputs:{x:s[g]},backend:e,attrs:{perm:y}}),d.push(w));let v=w.shape.slice();for(let k=0;k<b.length;++k)v.splice(b[k],0,1);x.arraysEqual(w.shape,v)||(w=ut({inputs:{x:w},backend:e,attrs:{shape:v}}),d.push(w)),m===null?m=w:(m=kg({inputs:{a:w,b:m},backend:e}),d.push(m))}h<p-1&&(l[h]>=0&&(m=rp({inputs:{x:m},backend:e,attrs:{axis:l[h]-(i.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&e.disposeIntermediateTensorInfo(h);return m}var x3={kernelName:zp,backendName:"webgl",kernelFunc:qet};var Ket="return (x >= 0.0) ? x : (exp(x) - 1.0);",jet=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Xet=Ct({opSnippet:Ket,packedOpSnippet:jet}),y3={kernelName:us,backendName:"webgl",kernelFunc:Xet};var Yet="return (b >= 1.0) ? a : a * (b + 1.0);",Zet=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Jet=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Po(Zet,n.shape,o.shape):new ro(Yet,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],n.dtype)},b3={kernelName:Bp,backendName:"webgl",kernelFunc:Jet};var Qet=`
  return vec4(equal(a, b));
`,trt="return float(a == b);",ert=le({opSnippet:trt,packedOpSnippet:Qet,dtype:"bool",cpuKernelImpl:QM}),w3={kernelName:da,backendName:"webgl",kernelFunc:ert};var rrt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${S.ERF_P};
  float a1 = ${S.ERF_A1};
  float a2 = ${S.ERF_A2};
  float a3 = ${S.ERF_A3};
  float a4 = ${S.ERF_A4};
  float a5 = ${S.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,nrt=Ct({opSnippet:rrt}),v3={kernelName:fa,backendName:"webgl",kernelFunc:nrt};var ort=Lo+`
  return exp(x);
`,srt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,TT=Ct({opSnippet:ort,packedOpSnippet:srt,cpuKernelImpl:tP,dtype:"float32"}),C3={kernelName:cs,backendName:"webgl",kernelFunc:TT};function dv(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(x.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),ut({inputs:{x:s},backend:n,attrs:{shape:a}})}var I3={kernelName:Ii,backendName:"webgl",kernelFunc:dv};var S3="return exp(x) - 1.0;",irt=Ct({opSnippet:S3,packedOpSnippet:S3,cpuKernelImpl:eP}),k3={kernelName:ha,backendName:"webgl",kernelFunc:irt};var Eg=class{constructor(t,e,n){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(t==="real")a="return real * expR - imag * expI;";else if(t==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function hv(r,t,e){let n=e.texData.get(r.dataId),o=x.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=ut({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),u=a.shape,l=new Eg("real",u,t),c=new Eg("imag",u,t),p=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=e.runWebGLProgram(l,p,"float32"),f=e.runWebGLProgram(c,p,"float32"),d=Rn({inputs:{real:m,imag:f},backend:e});e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f);let h=ut({inputs:{x:d},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(d),h}function art(r){let{inputs:t,backend:e}=r,{input:n}=t;return hv(n,!1,e)}var N3={kernelName:Vp,backendName:"webgl",kernelFunc:art};var gv=class{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function kl(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||x.inferDtype(o),s==="string"){let i=x.getArrayFromDType(s,x.sizeFromShape(n));return i.fill(o),t.makeTensorInfo(n,s,i)}else{let i=new gv(n,o),a=[[o]];return t.runWebGLProgram(i,[],s,a)}}var T3={kernelName:Ml,backendName:"webgl",kernelFunc:kl};var xv=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var _3={kernelName:ga,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new xv(e.shape);return n.runWebGLProgram(o,[e],e.dtype)}};var E3="return floor(x);",lrt=Ct({opSnippet:E3,packedOpSnippet:E3,cpuKernelImpl:rP}),A3={kernelName:ps,backendName:"webgl",kernelFunc:lrt};var urt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,crt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,prt=le({opSnippet:urt,packedOpSnippet:crt,dtype:"int32"}),$3={kernelName:ms,backendName:"webgl",kernelFunc:prt};var yv=class{constructor(t){this.variableNames=["A"];let e=qe(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var bv=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=qe(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var D3={kernelName:qd,backendName:"webgl",kernelFunc:mrt},Sd;function mrt(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[l,u],p=[l,u,s];(a||i)&&(Sd==null&&(Sd=document.createElement("canvas").getContext("2d")),Sd.canvas.width=u,Sd.canvas.height=l,Sd.drawImage(o,0,0,u,l),o=Sd.canvas);let m=e.makeTensorInfo(c,"int32");e.texData.get(m.dataId).usage=Kr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),o);let f=V().getBool("WEBGL_PACK")?new bv(p):new yv(p),d=e.runWebGLProgram(f,[m],"int32");return e.disposeData(m.dataId),d}function frt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=S.convertConv2DDataFormat(c),g=S.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!1,h),y,b=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=rv({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else if(V().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)y=nv({x:o,filter:s,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:d});else{let v=i!=null,k=a!=null,E=f==="leakyrelu",$=f?Cu(f,!1):null,D=new vd(g,v,$,k,E),R=[o,s];if(i&&R.push(i),a&&R.push(a),E){let P=e.makeTensorInfo([],"float32",x.createScalarValue(d,"float32"));R.push(P),b.push(P)}y=e.runWebGLProgram(D,R,"float32")}let w=ut({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(v=>e.disposeIntermediateTensorInfo(v)),w}var R3={kernelName:Mi,backendName:"webgl",kernelFunc:frt};function drt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:p,activation:m,leakyreluAlpha:f}=n,d=[],h=c;h==null&&(h=[1,1]),x.assert(S.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=S.computeConv2DInfo(o.shape,s.shape,u,h,l,p,!0),y=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=m?Cu(m,y):null,w=[o,s],v=i!=null,k=a!=null,E=m==="leakyrelu";if(v&&w.push(i),k&&w.push(a),E){let P=e.makeTensorInfo([],"float32",x.createScalarValue(f,"float32"));w.push(P),d.push(P)}let $;y?$=new Id(g,v,b,k,E):$=new Cd(g,v,b,k,E);let D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],R=e.runWebGLProgram($,w,"float32",D);return d.forEach(P=>e.disposeIntermediateTensorInfo(P)),R}var F3={kernelName:Pi,backendName:"webgl",kernelFunc:drt};var wv=class{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;let o=Gt(e.length),s=Gt(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${i};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function hrt(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,i=s[s.length-1],a=x.sizeFromShape(n.shape),[u,l,c,p]=S.prepareAndValidate(n,o),m=ut({inputs:{x:o},backend:e,attrs:{shape:[l,i]}}),f=ut({inputs:{x:n},backend:e,attrs:{shape:[x.sizeFromShape(n.shape)/c,c]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=e.readSync(o.dataId),b=e.bufferSync(n),w=nP(y,b,n.dtype,l,i,c,p,n.shape,a);return e.makeTensorInfo(u,n.dtype,w.values)}let d=new wv(i,p,[l,c]),h=e.runWebGLProgram(d,[f,m],f.dtype),g=ut({inputs:{x:h},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),g}var O3={kernelName:xa,backendName:"webgl",kernelFunc:hrt};var vv=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=Gt(this.rank),o=grt(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function grt(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${e[o]}`);return n.join()}function _T(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=x.parseAxisParam(i,o.shape)[0];if(V().get("DEBUG")){let b=e.readSync(s.dataId),w=o.shape[u];for(let v=0;v<b.length;++v){let k=b[v];x.assert(k<=w-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${w-1}]`)}}let l=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),c=x.sizeFromShape(s.shape),p=[],m=ut({inputs:{x:o},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=ut({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,c/l.batchSize]}});p.push(m),p.push(f);let d=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let b=e.bufferSync(f),w=e.bufferSync(m),v=oP(w,b,d);return p.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.makeTensorInfo(l.outputShape,v.dtype,v.values)}let h=new vv(m.shape,d),g=e.runWebGLProgram(h,[m,f],m.dtype);p.push(g);let y=ut({inputs:{x:g},backend:e,attrs:{shape:l.outputShape}});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}var M3={kernelName:Si,backendName:"webgl",kernelFunc:_T};var xrt="return float(a > b);",yrt=`
  return vec4(greaterThan(a, b));
`,brt=le({opSnippet:xrt,packedOpSnippet:yrt,cpuKernelImpl:sP,dtype:"bool"}),P3={kernelName:ya,backendName:"webgl",kernelFunc:brt};var wrt="return float(a >= b);",vrt=`
  return vec4(greaterThanEqual(a, b));
`,Crt=le({opSnippet:wrt,packedOpSnippet:vrt,dtype:"bool",cpuKernelImpl:iP}),L3={kernelName:ds,backendName:"webgl",kernelFunc:Crt};function Irt(r){let{inputs:t,backend:e}=r,{input:n}=t;return hv(n,!0,e)}var z3={kernelName:Gp,backendName:"webgl",kernelFunc:Irt};var Srt="return float(!isnan(x) && !isinf(x));",krt=Ct({opSnippet:Srt,dtype:"bool"}),B3={kernelName:ba,backendName:"webgl",kernelFunc:krt};var Nrt="return float(isinf(x));",Trt=Ct({opSnippet:Nrt,dtype:"bool"}),V3={kernelName:wa,backendName:"webgl",kernelFunc:Trt};var _rt="return float(isnan(x));",Ert=Ct({opSnippet:_rt,dtype:"bool"}),G3={kernelName:va,backendName:"webgl",kernelFunc:Ert};var Art="return float(a < b);",$rt=`
  return vec4(lessThan(a, b));
`,Drt=le({opSnippet:Art,packedOpSnippet:$rt,cpuKernelImpl:aP,dtype:"bool"}),W3={kernelName:Ca,backendName:"webgl",kernelFunc:Drt};var Rrt="return float(a <= b);",Frt=`
  return vec4(lessThanEqual(a, b));
`,Ort=le({opSnippet:Rrt,packedOpSnippet:Frt,cpuKernelImpl:lP,dtype:"bool"}),U3={kernelName:Ia,backendName:"webgl",kernelFunc:Ort};function Mrt(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,i=uP(n,o,s);return t.makeTensorInfo([i.length],"float32",i)}var H3={kernelName:Up,backendName:"webgl",kernelFunc:Mrt};var Prt=Lo+`
  return x < 0.0 ? 0./0. : log(x);
`,Lrt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,zrt=Ct({opSnippet:Prt,packedOpSnippet:Lrt,cpuKernelImpl:cP}),q3={kernelName:gs,backendName:"webgl",kernelFunc:zrt};var Brt=Lo+`
  return log(1.0 + x);
`,Vrt=Ct({opSnippet:Brt}),K3={kernelName:Sa,backendName:"webgl",kernelFunc:Vrt};var Grt="return float(a >= 1.0 && b >= 1.0);",Wrt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Urt=le({opSnippet:Grt,packedOpSnippet:Wrt,dtype:"bool"}),j3={kernelName:ka,backendName:"webgl",kernelFunc:Urt};var Hrt="return float(!(x >= 1.0));",qrt=Ct({opSnippet:Hrt}),X3={kernelName:Mu,backendName:"webgl",kernelFunc:qrt};var Krt="return float(a >= 1.0 || b >= 1.0);",jrt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Xrt=le({opSnippet:Krt,packedOpSnippet:jrt,dtype:"bool"}),Y3={kernelName:Pu,backendName:"webgl",kernelFunc:Xrt};var Cv=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var Iv=class{constructor(t,e,n,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=t[3]-1;this.outputShape=t;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Yrt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=V().getBool("WEBGL_PACK_NORMALIZATION")?new Iv(o.shape,s,i,a,u):new Cv(o.shape,s,i,a,u);return e.runWebGLProgram(l,[o],o.dtype)},Z3={kernelName:Pl,backendName:"webgl",kernelFunc:Yrt};var Sv=class{constructor(t,e,n,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Zrt=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=n,p=new Sv(o.shape,a,u,l,c);return e.runWebGLProgram(p,[o,s,i],o.dtype)},J3={kernelName:Hp,backendName:"webgl",kernelFunc:Zrt};function Q3(r,t,e,n){let o=x.sizeFromShape(t),i=x.sizeFromShape(r.shape)/o,a=ut({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Hn(a,r.dtype,"max",n),l=ut({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function ET(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=e.shouldExecuteOnCPU([o]),f=o;if(p){if(m){let w=e.texData.get(f.dataId).values,v=new Array(a);for(let $=0;$<v.length;$++)v[$]=o.shape[c[$]];let k=tp(w,o.shape,o.dtype,c,v);f=e.makeTensorInfo(v,o.dtype);let E=e.texData.get(f.dataId);E.values=k}else f=Iu(o,c,e);l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("max",l,a);let[d,h]=S.computeOutAndReduceShapes(f.shape,l),g=d;i&&(g=S.expandShapeToKeepDim(d,u));let y;if(m){let w=e.texData.get(f.dataId).values,v=pP(w,x.sizeFromShape(h),g,o.dtype);y=e.makeTensorInfo(g,o.dtype);let k=e.texData.get(y.dataId);k.values=v}else y=Q3(f,h,g,e);return p&&e.disposeIntermediateTensorInfo(f),y}var tz={kernelName:xs,backendName:"webgl",kernelFunc:ET};var Jrt=Dw+`
  return max(a, b);
`,Qrt=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+vu+`
  return result;
`,tnt=le({opSnippet:Jrt,packedOpSnippet:Qrt,cpuKernelImpl:mP}),ez={kernelName:ys,backendName:"webgl",kernelFunc:tnt};function ent(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;di(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;x.assert(S.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let c=S.computePool2DInfo(o.shape,s,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return Ke({inputs:{x:o},backend:e});let p=new gi(c,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var rz={kernelName:bs,backendName:"webgl",kernelFunc:ent};function rnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,c=[1,1,1],p=S.computePool3DInfo(o.shape,s,i,c,a,l,u),m=new Su(p,"max",!1);return e.runWebGLProgram(m,[o],o.dtype)}var nz={kernelName:Ll,backendName:"webgl",kernelFunc:rnt};var kv=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,i=t.effectiveFilterWidth,a=s-1-t.padInfo.top,u=i-1-t.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Nv=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,i=t.dilationHeight,a=t.dilationWidth,u=t.effectiveFilterDepth,l=t.effectiveFilterHeight,c=t.effectiveFilterWidth,p=u-1-t.padInfo.front,m=l-1-t.padInfo.top,f=c-1-t.padInfo.left,d=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function nnt(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=n,p=[1,1,1],m=S.computePool3DInfo(i.shape,a,u,p,l,c),f=new Su(m,"max",!0),d=e.runWebGLProgram(f,[i],i.dtype),h=new Nv(m),g=e.runWebGLProgram(h,[o,d],i.dtype);return e.disposeIntermediateTensorInfo(d),g}var oz={kernelName:Kp,backendName:"webgl",kernelFunc:nnt};function ont(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:i}=t,a=s;di([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:c,dimRoundingMode:p}=n,m=S.computePool2DInfo(a.shape,u,l,1,c,p),f=!0,d=new gi(m,"max",f),h=e.runWebGLProgram(d,[a],a.dtype),g=new kv(m),y=e.runWebGLProgram(g,[o,h],a.dtype);return e.disposeIntermediateTensorInfo(h),y}var sz={kernelName:qp,backendName:"webgl",kernelFunc:ont};function iz(r,t,e,n){let o=new gi(e,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new gi(e,"max",!0,!0,t);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var az={kernelName:jp,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=t,u=e;x.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];x.assert(S.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let c=S.computePool2DInfo(n.shape,o,s,l,i),[p,m]=iz(n,a,c,u);return[p,m]}};function lz(r,t,e,n){let o=x.sizeFromShape(t),i=x.sizeFromShape(r.shape)/o,a=ut({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=Hn(a,"float32","mean",n),l=ut({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var uz={kernelName:ws,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:o,axis:s}=t,i=e,a=n.shape.length,u=x.parseAxisParam(s,n.shape),l=u,c=S.getAxesPermutation(l,a),p=c!=null,m=i.shouldExecuteOnCPU([n]),f=[],d=n;if(p){if(m){let v=i.texData.get(d.dataId).values,k=new Array(a);for(let D=0;D<k.length;D++)k[D]=n.shape[c[D]];let E=tp(v,n.shape,n.dtype,c,k);d=i.makeTensorInfo(k,n.dtype);let $=i.texData.get(d.dataId);$.values=E}else d=Iu(n,c,i);f.push(d),l=S.getInnerMostAxes(l.length,a)}S.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=S.computeOutAndReduceShapes(d.shape,l),y=h;o&&(y=S.expandShapeToKeepDim(h,u));let b=lz(d,g,y,i);for(let w of f)i.disposeIntermediateTensorInfo(w);return b}};function snt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=x.parseAxisParam(s,o.shape),l=u,c=S.getAxesPermutation(l,a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),l=S.getInnerMostAxes(l.length,o.shape.length)),S.assertAxesAreInnerMostDims("min",l,a);let[m,f]=S.computeOutAndReduceShapes(p.shape,l),d=x.sizeFromShape(f),h=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}}),g=Hn(h,h.dtype,"min",e),y;if(i){let b=S.expandShapeToKeepDim(m,u);y=ut({inputs:{x:g},backend:e,attrs:{shape:b}})}else y=ut({inputs:{x:g},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),c!=null&&e.disposeIntermediateTensorInfo(p),y}var cz={kernelName:vs,backendName:"webgl",kernelFunc:snt};var int=Dw+`
  return min(a, b);
`,ant=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+vu+`
  return result;
`,lnt=le({opSnippet:int,packedOpSnippet:ant,cpuKernelImpl:fP}),pz={kernelName:Cs,backendName:"webgl",kernelFunc:lnt};var Tv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((c,p)=>c[0]+t[p]+c[1]);let o=t.length,s=Gt(o),i=e.map(c=>c[0]).join(","),a=e.map((c,p)=>c[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var _v=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((d,h)=>d[0]+t[h]+d[1]);let o=t.length,s=Gt(o),i=e.map(d=>d[0]).join(","),a=e.map((d,h)=>d[0]+t[h]).join(","),u=nr("rc",o),l=nr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${p});
        ${u[o-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${p});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${l.join()}), ${p});
          ${u[o-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${l.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var unt=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:o,mode:s}=e,i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _v(n.shape,o,s):new Tv(n.shape,o,s);return t.runWebGLProgram(i,[n],n.dtype)},mz={kernelName:Is,backendName:"webgl",kernelFunc:unt};var cnt=`if (b == 0.0) return NAN;
  return mod(a, b);`,pnt=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+vu+`
  return result;
`,mnt=le({opSnippet:cnt,packedOpSnippet:pnt}),fz={kernelName:Na,backendName:"webgl",kernelFunc:mnt};var Ev=class{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var fnt=`
if (a == b) {
  return 1.0;
};
return a / b;`,dnt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,AT=le({opSnippet:fnt,packedOpSnippet:dnt,checkOutOfBounds:!0}),dz={kernelName:ls,backendName:"webgl",kernelFunc:AT};var hz="return a - b;",$T=le({opSnippet:hz,packedOpSnippet:hz,supportsComplex:!0,cpuKernelImpl:EP}),gz={kernelName:Gs,backendName:"webgl",kernelFunc:$T};function DT(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,i=x.parseAxisParam([s],o.shape),a=ET({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=S.expandShapeToKeepDim(a.shape,i),l=ut({inputs:{x:a},backend:e,attrs:{shape:u}}),c=$T({inputs:{a:o,b:l},backend:e}),p=TT({inputs:{x:c},backend:e}),m=rp({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=ut({inputs:{x:m},backend:e,attrs:{shape:u}}),d=AT({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(f),d}var xz={kernelName:Bs,backendName:"webgl",kernelFunc:DT};function hnt(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:i,normalized:a}=n,u=a?o:DT({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),l=u.shape[0],c=u.shape[1],p=new Ev(l,c,s),m=[[i]],f=e.runWebGLProgram(p,[u],"int32",m);return a||e.disposeIntermediateTensorInfo(u),f}var yz={kernelName:Xp,backendName:"webgl",kernelFunc:hnt};var gnt=hr+`
  return -x;
`,xnt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ynt(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.texData.get(n.dataId),[i,a]=hP(s.values,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,i)}let o;return V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new eo(n.shape,xnt):o=new en(n.shape,gnt),e.runWebGLProgram(o,[n],n.dtype)}var bz={kernelName:ki,backendName:"webgl",kernelFunc:ynt};var bnt=Gr.nonMaxSuppressionV3Impl;function wnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=e.readSync(o.dataId),c=e.readSync(s.dataId),{selectedIndices:p}=bnt(l,c,i,a,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var wz={kernelName:_a,backendName:"webgl",kernelFunc:wnt};var vnt=Gr.nonMaxSuppressionV4Impl;function Cnt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=vnt(c,p,i,a,u,l);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}var vz={kernelName:Ea,backendName:"webgl",kernelFunc:Cnt};var Int=Gr.nonMaxSuppressionV5Impl;function Snt(r){S.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,c=e.readSync(o.dataId),p=e.readSync(s.dataId),m=i,f=a,d=u,h=l,{selectedIndices:g,selectedScores:y}=Int(c,p,m,f,d,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var Cz={kernelName:Aa,backendName:"webgl",kernelFunc:Snt};var Av=class{constructor(t,e,n,o){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var knt=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n,u=x.sizeFromShape(o.shape),l=new Av(u,s,i,a),c=ut({inputs:{x:o},backend:e,attrs:{shape:[u]}}),p=e.runWebGLProgram(l,[c],o.dtype);e.disposeIntermediateTensorInfo(c);let m=[...o.shape,s],f=ut({inputs:{x:p},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(p),f},Iz={kernelName:ks,backendName:"webgl",kernelFunc:knt};function Ag(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=Sl({inputs:{input:n},backend:e}),s=Ag({inputs:{x:o},backend:e}),i=op({inputs:{input:n},backend:e}),a=Ag({inputs:{x:i},backend:e}),u=Rn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return kl({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var Sz={kernelName:Fi,backendName:"webgl",kernelFunc:Ag};function kz(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Sl({inputs:{input:n},backend:e}),s=kz({inputs:{x:o},backend:e}),i=op({inputs:{input:n},backend:e}),a=Ag({inputs:{x:i},backend:e}),u=Rn({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),u}else return kl({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var Nz={kernelName:Ni,backendName:"webgl",kernelFunc:kz};function Nnt(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return dv({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=dv({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=NT({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeIntermediateTensorInfo(c)),l}var Tz={kernelName:Ti,backendName:"webgl",kernelFunc:Nnt};var $v=class{constructor(t,e,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,c)=>l[0]+t[c]+l[1]);let o=t.length,s=Gt(o),i=e.map(l=>l[0]).join(","),a=e.map((l,c)=>l[0]+t[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var Dv=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((h,g)=>h[0]+t[g]+h[1]);let o=t.length,s=Gt(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+t[g]).join(","),u=nr("rc",o),l=nr("source",o),c=`${u[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${c}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${c}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${p});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var RT=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:i}=n;if(x.sizeFromShape(o.shape)===0){let l=s.map((c,p)=>c[0]+o.shape[p]+c[1]);return kl({backend:e,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dv(o.shape,s,i):new $v(o.shape,s,i),u=[[i]];return e.runWebGLProgram(a,[o],o.dtype,u)},_z={kernelName:Ns,backendName:"webgl",kernelFunc:RT};var Tnt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,_nt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+vu+`
  return result;
`,Ent=le({opSnippet:Tnt,packedOpSnippet:_nt}),Ez={kernelName:Ts,backendName:"webgl",kernelFunc:Ent};function Ant(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=x.parseAxisParam(s,o.shape),c=l,p=S.getAxesPermutation(c,a),m=o;p!=null&&(m=Ae({inputs:{x:o},backend:e,attrs:{perm:p}}),c=S.getInnerMostAxes(c.length,a),u.push(m)),S.assertAxesAreInnerMostDims("prod",c,a);let f;if(e.shouldExecuteOnCPU([m])){let d=e.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:y}=xP(m.shape,m.dtype,d,c);f=e.makeTensorInfo(g,y,h)}else{let[d,h]=S.computeOutAndReduceShapes(m.shape,c),g=x.sizeFromShape(h),y=ut({inputs:{x:m},backend:e,attrs:{shape:[-1,g]}}),b=Uu(o.dtype),w=Hn(y,b,"prod",e);f=ut({inputs:{x:w},backend:e,attrs:{shape:d}}),u.push(y),u.push(w)}if(i){u.push(f);let d=S.expandShapeToKeepDim(f.shape,l);f=ut({inputs:{x:f},backend:e,attrs:{shape:d}})}return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),f}var Az={kernelName:Es,backendName:"webgl",kernelFunc:Ant};var FT=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=yP(n,o,s,i);return t.makeTensorInfo([a.length],i,a)},$z={kernelName:zl,backendName:"webgl",kernelFunc:FT};var $nt="return 1.0 / x;",Dnt=Ct({opSnippet:$nt}),Dz={kernelName:$a,backendName:"webgl",kernelFunc:Dnt};var Rnt=hr+`
  return (x < 0.0) ? 0.0 : x;
`,Fnt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ont=Ct({opSnippet:Rnt,packedOpSnippet:Fnt}),Rz={kernelName:As,backendName:"webgl",kernelFunc:Ont};var Mnt=hr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Pnt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lnt=Ct({opSnippet:Mnt,packedOpSnippet:Pnt}),Fz={kernelName:Ds,backendName:"webgl",kernelFunc:Lnt};var Rv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var Fv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function znt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Fv(o.shape,u,l,s,i):new Rv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],"float32")}var Oz={kernelName:$s,backendName:"webgl",kernelFunc:znt};var Ov=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Bnt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new Ov(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var Mz={kernelName:Jp,backendName:"webgl",kernelFunc:Bnt};var Mv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/p[0]},
          ${c[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var Pv=class{constructor(t,e,n,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,u,l]=t;this.outputShape=[i,e,n,l];let c=[o&&e>1?a-1:a,o&&n>1?u-1:u],p=[o&&e>1?e-1:e,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/p[0]},
          ${c[1]/p[1]},
          ${c[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Vnt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Pv(o.shape,u,l,s,i):new Mv(o.shape,u,l,s,i);return e.runWebGLProgram(c,[o],o.dtype)}var Pz={kernelName:Bl,backendName:"webgl",kernelFunc:Vnt};var Lv=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=t,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],c=u[0]/l[0],p=u[1]/l[1],m=1/c,f=1/p,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${p});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Gnt(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:i}=n,a=new Lv(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var Lz={kernelName:Zp,backendName:"webgl",kernelFunc:Gnt};var zv=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&t[a]!==1?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`,s=t.map((a,u)=>o(u)).join(","),i=Gt(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var Bv=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=nr("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=Gt(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${c(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(d){return m(d)}function l(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function c(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function p(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=t.map((b,w)=>f(w,d)),g=h.join(","),y=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(d,h){return e.indexOf(d)!==-1&&t[d]!==1?`${t[d]} - ${h[d]} - 1`:`${h[d]}`}}};function Wnt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=o.shape.length,a=x.parseAxisParam(s,o.shape);if(i===0)return Ke({inputs:{x:o},backend:e});let u=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bv(o.shape,a):new zv(o.shape,a);return e.runWebGLProgram(u,[o],o.dtype)}var zz={kernelName:Rs,backendName:"webgl",kernelFunc:Wnt};var Vv=class{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Bz={kernelName:Va,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=t,a=e,u=new Vv(n.shape,s),[l,c]=S.getImageCenter(i,n.shape[1],n.shape[2]),p=[[l,c,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,p)}};var Unt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Hnt=Ct({opSnippet:Unt}),Vz={kernelName:Fs,backendName:"webgl",kernelFunc:Hnt};var qnt="return inversesqrt(x);",Knt=Ct({opSnippet:qnt,cpuKernelImpl:bP}),Gz={kernelName:Os,backendName:"webgl",kernelFunc:Knt};var kd=class{constructor(t,e,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=Gt(s.length),l=Gt(i.length),c="";n===1?c="i":n===2&&(c="i, j");let p=`getIndices(${c})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${p});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function jnt(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:p}=S.calculateShapes(s,o,i),m=[p/l,l];if(p===0)return e.makeTensorInfo(i,o.dtype);let f=ut({inputs:{x:o},backend:e,attrs:{shape:[u,a]}}),d=ut({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),h=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new kd(u,a,f.shape.length,d.shape.length,c,m),y=e.runWebGLProgram(g,[d,f,h],d.dtype),b=ut({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(h),b}var Wz={kernelName:Da,backendName:"webgl",kernelFunc:jnt};var Gv=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<e.length;c++)l.push(`${a[c]}`),c<t&&u.push(`${a[c]}`);o=u.join(),s=l.join()}let i=Gt(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Xnt(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=new Gv(n.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[n,o,s],ar(o.dtype,s.dtype))}var Uz={kernelName:Ei,backendName:"webgl",kernelFunc:Xnt};var Ynt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${S.SELU_SCALEALPHA};
  float scale = ${S.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Znt=Ct({opSnippet:Ynt}),Hz={kernelName:Ra,backendName:"webgl",kernelFunc:Znt};var Jnt=Lo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Qnt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tot=Ct({opSnippet:Jnt,packedOpSnippet:Qnt,cpuKernelImpl:wP}),qz={kernelName:Ps,backendName:"webgl",kernelFunc:tot};var eot=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,rot=Ct({opSnippet:eot}),Kz={kernelName:Oa,backendName:"webgl",kernelFunc:rot};var not=Lo+`
  return sin(x);
`,oot=Ct({opSnippet:not}),jz={kernelName:Ms,backendName:"webgl",kernelFunc:oot};var sot=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,iot=Ct({opSnippet:sot}),Xz={kernelName:Fa,backendName:"webgl",kernelFunc:iot};var aot=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,lot=Ct({opSnippet:aot}),Yz={kernelName:Ma,backendName:"webgl",kernelFunc:lot};var uot=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n;x.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,b)=>y*b),u=[[0,0]];u.push(...i);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],c=RT({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),p=S.getReshaped(c.shape,s,a,!1),m=S.getPermuted(p.length,s.length,!1),f=S.getReshapedPermuted(c.shape,s,a,!1),d=ut({inputs:{x:c},backend:e,attrs:{shape:p}}),h=Ae({inputs:{x:d},backend:e,attrs:{perm:m}}),g=ut({inputs:{x:h},backend:e,attrs:{shape:f}});return l.push(c),l.push(d),l.push(h),l.forEach(y=>e.disposeIntermediateTensorInfo(y)),g},Zz={kernelName:$i,backendName:"webgl",kernelFunc:uot};function cot(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(n.dataId),u=e.readSync(o.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId)[0],[p,m,f,d,h]=CP(a,n.shape,n.dtype,u,o.dtype,l,c);return[e.makeTensorInfo(m,n.dtype,p),e.makeTensorInfo([m[0]],o.dtype,f),e.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var Jz={kernelName:Vl,backendName:"webgl",kernelFunc:cot};function pot(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(n.dataId),u=Array.from(e.readSync(s.dataId)),[l,c,p]=IP(a,n.shape,n.dtype,i,u);return[e.makeTensorInfo(c,n.dtype,l),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var Qz={kernelName:Pa,backendName:"webgl",kernelFunc:pot};function mot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=Tw(i,n.shape,n.dtype,a,u,!0);return e.makeTensorInfo(c,n.dtype,l)}var tB={kernelName:Gl,backendName:"webgl",kernelFunc:mot};function fot(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(n.dataId),a=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,c]=Tw(i,n.shape,n.dtype,a,u);return e.makeTensorInfo(c,n.dtype,l)}var eB={kernelName:Wl,backendName:"webgl",kernelFunc:fot};function dot(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=t,{outputShape:a}=n,{sliceRank:u,numUpdates:l,strides:c,outputSize:p}=S.calculateShapes(s,o,a),m=!1,f=new kd(l,u,o.shape.length,s.shape.length,c,[p,1],m),d=e.runWebGLProgram(f,[s,o,i],s.dtype),h=ut({inputs:{x:d},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(d),h}var rB={kernelName:Qp,backendName:"webgl",kernelFunc:dot};function hot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=n,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=o.shape.length,c=new Array(l).fill(0),p=o.shape.slice();return u.map(m=>{let f=[...p];f[a]=m;let d=xi({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=m,d})}var nB={kernelName:Di,backendName:"webgl",kernelFunc:hot};var oB="return sqrt(x);",got=Ct({opSnippet:oB,packedOpSnippet:oB,cpuKernelImpl:SP}),sB={kernelName:Ls,backendName:"webgl",kernelFunc:got};var xot="return x * x;",yot=Ct({opSnippet:xot}),iB={kernelName:Ul,backendName:"webgl",kernelFunc:yot};var aB="return (a - b) * (a - b);",bot=le({opSnippet:aB,packedOpSnippet:aB}),lB={kernelName:Vs,backendName:"webgl",kernelFunc:bot};function wot({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=hr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new en(n.shape,o);return e.runWebGLProgram(s,[n],n.dtype)}var uB={kernelName:uo,backendName:"webgl",kernelFunc:wot};var Wv=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let o=n.length,s=Gt(n.length),i=Gt(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,c)=>(u++,n.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function vot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=ut({inputs:{x:o},backend:e,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let $=Ve.computeOutShape(b,w,v),D=xi({inputs:{x:o},backend:e,attrs:{begin:b,size:$}});k=ut({inputs:{x:D},backend:e,attrs:{shape:d}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([o])){let D=e.readSync(o.dataId),R=It(o.shape,o.dtype,D),P=kP(f,R,v,b);k=e.makeTensorInfo(d,o.dtype,P.values)}else{let D=new Wv(b,v,f);k=e.runWebGLProgram(D,[o],o.dtype)}let E=ut({inputs:{x:k},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(k),E}var cB={kernelName:La,backendName:"webgl",kernelFunc:vot};function Cot(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:c,dataSplits:p}=t,m=e.readSync(c.dataId),f=e.readSync(p.dataId),[d,h]=NP(m,f,o,s,i,a,u,l);return[e.makeTensorInfo([d.length],"string",d),e.makeTensorInfo(p.shape,"int32",h)]}var pB={kernelName:tm,backendName:"webgl",kernelFunc:Cot};function Iot(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),u=e.readSync(i.dataId)[0],[l,c,p]=TP(a,u,o),m=c.length;return[e.makeTensorInfo([m,2],"int32",l),e.makeTensorInfo([m],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var mB={kernelName:em,backendName:"webgl",kernelFunc:Iot};function Sot(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=_P(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var fB={kernelName:rm,backendName:"webgl",kernelFunc:Sot};var kot="return tan(x);",Not=Ct({opSnippet:kot}),dB={kernelName:Ws,backendName:"webgl",kernelFunc:Not};var Tot=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,_ot=Ct({opSnippet:Tot}),hB={kernelName:Us,backendName:"webgl",kernelFunc:_ot};var Uv=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[i]*e[i];this.outputShape=n,this.rank=n.length;let o=Gt(this.rank),s=Eot(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Eot(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${e[o]}, ${r[o]})`);return n.join()}function OT(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=e.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>x.decodeString(m)):u,c=It(o.shape,o.dtype,l),p=AP(c,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new Uv(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var gB={kernelName:Yn,backendName:"webgl",kernelFunc:OT};var Hv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},qv=class{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function ip(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function xB(r){let t=1;for(;t<r;)t*=2;return t}function Aot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:i}=n,a=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,c=l[l.length-1];if(e.shouldExecuteOnCPU([o])||c<a||s>u){let P=e.readSync(o.dataId),[W,U]=$P(P,l,o.dtype,s,i);return[e.makeTensorInfo(W.shape,W.dtype,W.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(s===0)return l[l.length-1]=0,[e.makeTensorInfo(l,o.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(c===1)return[o,kl({attrs:{shape:l,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),m=p!==null&&p.isPacked,f=m?e.unpackTensor(o):o,h=x.sizeFromShape(l)/c,g=ut({inputs:{x:f},attrs:{shape:[h,c]},backend:e});m&&ip(e,f);let y=xB(s),b=xB(c),w=null,v=()=>w===null?[g,g]:[g,w],k=(P,W,U)=>{let q=v(),K=new Hv(U),Q=[[c],[w===null?1:0],[Number.NEGATIVE_INFINITY],[P],[W]],rt=w;w=e.runWebGLProgram(K,q,"int32",Q),ip(e,rt)};for(let P=1;P<y;P*=2){let W=P*2;for(let U=P;U>=1;U/=2)k(W,U,[h,b])}for(let P=b;P>y;P/=2){let W=v(),U=new qv([h,P/2]),K=[[c],[w===null?1:0],[y]],j=w;w=e.runWebGLProgram(U,W,"int32",K),ip(e,j);let Q=y/2,rt=Q*2;for(let X=Q;X>=1;X/=2)k(rt,X,w.shape)}let E=w;w=xi({inputs:{x:w},backend:e,attrs:{begin:0,size:[h,s]}}),ip(e,E);let $=_T({inputs:{x:g,indices:w},backend:e,attrs:{axis:1,batchDims:1}});ip(e,g);let D=l.slice(0,-1);D.push(s),E=w,w=ut({inputs:{x:w},attrs:{shape:D},backend:e}),ip(e,E);let R=$;return $=ut({inputs:{x:$},attrs:{shape:D},backend:e}),ip(e,R),[$,w]}var yB={kernelName:za,backendName:"webgl",kernelFunc:Aot};var Kv=class{constructor(t,e,n,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function $ot(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=new Kv(p,m,i,a,u,g);return e.runWebGLProgram(y,[o,s],"float32")}var bB={kernelName:Ba,backendName:"webgl",kernelFunc:$ot};function Dot(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;di(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=DP(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var wB={kernelName:nm,backendName:"webgl",kernelFunc:Dot};function Rot(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),c=0;for(let h=0;h<a;h++)h!==s&&(l[c++]=i.shape[h]);let p=[],m=new Array(a).fill(0),f=i.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=xi({inputs:{x:i},backend:e,attrs:{begin:m,size:f}}),y=ut({inputs:{x:g},backend:e,attrs:{shape:l}});d[h]=y,p.push(g)}return p.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var vB={kernelName:Ri,backendName:"webgl",kernelFunc:Rot};var jv=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,i=t.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",c=Math.floor(n/4)*4,p=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Fot(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:i}=n,a=o.shape.length,u=[],l=0,c=S.getAxesPermutation([l],a),p=o;c!=null&&(p=Ae({inputs:{x:o},backend:e,attrs:{perm:c}}),u.push(p),l=S.getInnerMostAxes(1,a)[0]);let m=S.segment_util.computeOutShape(p.shape,l,i),f=x.sizeFromShape([p.shape[l]]),d=ut({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(d);let h=Uu(o.dtype),g=(v,k,E,$,D)=>{let R=v.shape[0],P=v.shape[1],W=S.segment_util.segOpComputeOptimalWindowSize(P,D),U={windowSize:W,inSize:P,batchSize:R,numSegments:D},q=new jv(U,k),K=e.compileAndRun(q,[v,E],$);if(u.push(K),K.shape[1]===D)return K;let j=FT({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),Q=OT({inputs:{x:j},backend:e,attrs:{reps:[P/W]}});return u.push(j),u.push(Q),g(K,k,Q,$,D)},y=g(d,"unsortedSegmentSum",s,h,i),b=ut({inputs:{x:y},backend:e,attrs:{shape:m}}),w=b;if(c!=null){u.push(b);let v=S.getUndoAxesPermutation(c);w=Ae({inputs:{x:w},backend:e,attrs:{perm:v}})}return u.forEach(v=>e.disposeIntermediateTensorInfo(v)),w}var CB={kernelName:Hl,backendName:"webgl",kernelFunc:Fot};var Oot=[uL,pL,mL,fL,hL,gL,xL,yL,vL,CL,IL,SL,kL,NL,TL,_L,EL,AL,$L,DL,RL,OL,ML,PL,VL,WL,UL,ZP,qL,jL,XL,YL,ZL,JL,QL,t3,e3,r3,n3,i3,u3,c3,p3,m3,f3,d3,h3,g3,x3,y3,b3,w3,v3,C3,I3,k3,N3,T3,_3,A3,$3,D3,R3,F3,O3,M3,P3,L3,YP,z3,KL,B3,V3,G3,JP,W3,U3,H3,q3,K3,j3,X3,Y3,Z3,J3,tz,ez,rz,nz,oz,sz,az,uz,cz,pz,mz,fz,yz,nL,bz,wz,vz,Cz,LL,Iz,Nz,Tz,_z,Ez,QP,Az,$z,zL,dz,Dz,Rz,Fz,sL,Oz,Mz,Pz,Lz,zz,Bz,Vz,Gz,Wz,Uz,Hz,qz,Kz,jz,Xz,FL,xz,Yz,Zz,Jz,Qz,tB,eB,rB,nB,sB,iB,lB,uB,cB,pB,mB,fB,gz,aL,dB,hB,gB,yB,bB,lL,wB,vB,CB,Sz];for(let r of Oot)Lu(r);var Xt;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Xt||(Xt={}));var ku;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(ku||(ku={}));var IB;function Mot(r){IB=r.wasm.cwrap(Oi,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Pot(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=t;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:p}=n,m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=0;if(i!=null){let D=e.dataIdMap.get(i.dataId);if(D.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${D.shape.length}.`);d=D.id}let h=a==null?0:e.dataIdMap.get(a.dataId).id,g=ku[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=u?o.shape[2]:o.shape[1],b=l?s.shape[1]:s.shape[2],w=Pr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),v=e.makeOutput([...w,y,b],o.dtype),k=e.dataIdMap.get(v.dataId).id,E=new Uint8Array(new Int32Array(o.shape).buffer),$=new Uint8Array(new Int32Array(s.shape).buffer);return IB(m,E,o.shape.length,f,$,s.shape.length,u,l,g,d,h,p||0,k),v}var SB={kernelName:Oi,backendName:"wasm",setupFunc:Mot,kernelFunc:Pot};function ue(r,t){let e;function n(s){e=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:i,inputs:{x:a}}=s,u=i.dataIdMap.get(a.dataId).id,l=i.makeOutput(a.shape,t||a.dtype),c=i.dataIdMap.get(l.dataId).id;return x.sizeFromShape(l.shape)===0||e(u,Xt[a.dtype],c),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var kB=ue(wi);function Ie(r,t,e){let n;function o(i){n=i.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:a,inputs:u}=i,{a:l,b:c}=u,p=a.dataIdMap.get(l.dataId).id,m=a.dataIdMap.get(c.dataId).id,f=e!=null?e:l.dtype,d=S.assertAndGetBroadcastShape(l.shape,c.shape),h=a.makeOutput(d,f);if(x.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),b=a.dataIdMap.get(h.dataId).id;return(()=>n(p,g,l.shape.length,m,y,c.shape.length,Xt[l.dtype],b))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var Lot=!0,NB=Ie(Xn,Lot);var TB;function zot(r){TB=r.wasm.cwrap(Zo,null,["array","number","number","number"])}function Bot(r){let{inputs:t,backend:e}=r,n=e.makeOutput(t[0].shape,t[0].dtype);if(x.sizeFromShape(n.shape)===0)return n;let o=t.map(a=>e.dataIdMap.get(a.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),i=e.dataIdMap.get(n.dataId).id;return TB(s,o.length,Xt[n.dtype],i),n}var _B={kernelName:Zo,backendName:"wasm",setupFunc:zot,kernelFunc:Bot};function ap(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype),o=e.typedArrayFromHeap(t);return e.typedArrayFromHeap(n).set(o),n}var EB={kernelName:lo,backendName:"wasm",kernelFunc:ap};var AB;function Vot(r){AB=r.wasm.cwrap(Hs,null,["number","array","number","number","number","array","number"])}function no(r){let{inputs:t,backend:e,attrs:n}=r,[o,s]=Wot(t.x.shape,n.perm),i=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(i=!1);let a=Got(t.x.shape,n.perm),u={dataId:t.x.dataId,shape:o,dtype:t.x.dtype};if(i){let d=ap({inputs:t,backend:e});return d.shape=a,d}let l=e.makeOutput(a,u.dtype),c=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(u.shape).buffer);return AB(c,f,u.shape.length,Xt[u.dtype],p,m,s.length),l}function Got(r,t){let e=new Array(r.length);for(let n=0;n<e.length;n++)e[n]=r[t[n]];return e}function Wot(r,t){let e=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&e.push(r[o]),r[t[o]]!==1&&n.push(t[o]);for(let o=0;o<n.length;++o){let s=-1;for(let i=0;i<n.length;++i)n[i]>=o&&(s===-1||n[s]>n[i])&&(s=i);n[s]=o}return[e,n]}var $B={kernelName:Hs,backendName:"wasm",kernelFunc:no,setupFunc:Vot};function Sn(r,t,e){let n=r.shape,o=r.shape.length,s=x.parseAxisParam(t,n),i=s,a=S.getAxesPermutation(i,o),u=null,l=!1;if(a!=null){let c=new Array(o);for(let f=0;f<c.length;f++)c[f]=n[a[f]];i=S.getInnerMostAxes(i.length,o),u=no({inputs:{x:r},attrs:{perm:a},backend:e});let p=e.dataIdMap.get(r.dataId).id;e.dataIdMap.get(u.dataId).id!==p&&(l=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:l}}var DB;function Uot(r){DB=r.wasm.cwrap(na,null,["number, number, number"])}function Hot(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("all",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;DB(u,y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var RB={kernelName:na,backendName:"wasm",setupFunc:Uot,kernelFunc:Hot};var FB;function qot(r){FB=r.wasm.cwrap(oa,null,["number, number, number"])}function Kot(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("any",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;FB(u,y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var OB={kernelName:oa,backendName:"wasm",setupFunc:qot,kernelFunc:Kot};var MB;function jot(r){MB=r.wasm.cwrap(Jo,null,["number","number","number","number","number"])}function Xot(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=i,u=s,{transposed:l,axes:c,inputWasTransposed:p}=Sn(s,o,t);if(p){let y=t.dataIdMap.get(l.dataId).id;y!==i&&(u=l,a=y)}let m=u.shape.slice(0,-1),f=t.makeOutput(m,"int32"),d=t.dataIdMap.get(f.dataId).id,h=x.sizeFromShape(f.shape),g=u.shape[c[0]];return MB(a,Xt[u.dtype],h,g,d),p&&t.disposeData(l.dataId),f}var PB={kernelName:Jo,backendName:"wasm",kernelFunc:Xot,setupFunc:jot};var LB;function Yot(r){LB=r.wasm.cwrap(Qo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Zot(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,w=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let v=n.makeOutput(c.outShape,"float32"),k=n.dataIdMap.get(v.dataId).id;return LB(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,b,w,k),v}var zB={kernelName:Qo,backendName:"wasm",setupFunc:Yot,kernelFunc:Zot};function pr(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=x.sizeFromShape(n.shape),i=x.inferFromImplicitShape(o,s);return x.assert(s===x.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var BB={kernelName:_i,backendName:"wasm",kernelFunc:pr};var VB;function Jot(r){VB=r.wasm.cwrap(ts,null,["number","array","number","number","array","number","number","number","number"])}function Qot(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:i,transposeB:a}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,c=i?o.shape[u-2]:o.shape[u-1],p=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],f=a?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),w=Pr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===p,()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let v=i?[g,c,m]:[g,m,c],k=a?[y,f,p]:[y,p,f],E=pr({inputs:{x:o},backend:e,attrs:{shape:v}}),$=pr({inputs:{x:s},backend:e,attrs:{shape:k}}),D=e.dataIdMap.get(E.dataId).id,R=e.dataIdMap.get($.dataId).id,P=i?E.shape[2]:E.shape[1],W=a?$.shape[1]:$.shape[2],U=Math.max(g,y),q=e.makeOutput([U,P,W],E.dtype),K=e.dataIdMap.get(q.dataId).id,j=new Uint8Array(new Int32Array(E.shape).buffer),Q=new Uint8Array(new Int32Array($.shape).buffer);return VB(D,j,E.shape.length,R,Q,$.shape.length,i,a,K),e.disposeData(E.dataId),e.disposeData($.dataId),q.shape=w,q}var GB={kernelName:ts,backendName:"wasm",setupFunc:Jot,kernelFunc:Qot};function zo(r){let{inputs:{x:t},attrs:{begin:e,size:n},backend:o}=r,[s,i]=Ve.parseSliceParams(t,e,n),a=Ve.isSliceContinous(t.shape,s,i),u=o.readSync(t.dataId),l=o.makeOutput(i,t.dtype),c=x.computeStrides(t.shape),p=o.dataIdMap.get(l.dataId);if(a){let d=Ve.computeFlatOffset(s,c);return t.dtype==="string"?p.stringBytes=u.slice(d,d+x.sizeFromShape(i)):o.typedArrayFromHeap(l).set(u.subarray(d,d+x.sizeFromShape(i))),l}if(t.dtype==="string"){let d=jc(u,s,i,t.shape,t.dtype);return p.stringBytes=d,l}let m=o.typedArrayFromHeap(l),f=t.shape.length;if(f===2)tst(u,c[0],m,s,i);else if(f===3)est(u,c[0],c[1],m,s,i);else if(f===4)rst(u,c[0],c[1],c[2],m,s,i);else{let d=jc(u,s,i,t.shape,t.dtype);m.set(d)}return l}function tst(r,t,e,n,o){let s=0,i=n[0],a=n[1],u=i+o[0];for(let l=i;l<u;l++){let c=l*t+a;e.set(r.subarray(c,c+o[1]),s),s+=o[1]}}function est(r,t,e,n,o,s){let i=0,a=o[0],u=o[1],l=o[2],c=a+s[0],p=u+s[1];for(let m=a;m<c;m++)for(let f=u;f<p;f++){let d=m*t+f*e+l;n.set(r.subarray(d,d+s[2]),i),i+=s[2]}}function rst(r,t,e,n,o,s,i){let a=0,u=s[0],l=s[1],c=s[2],p=u+i[0],m=l+i[1],f=c+i[2],d=s[3];for(let h=u;h<p;h++)for(let g=l;g<m;g++)for(let y=c;y<f;y++){let b=h*t+g*e+y*n+d;o.set(r.subarray(b,b+i[3]),a),a+=i[3]}}var WB={kernelName:Ai,backendName:"wasm",kernelFunc:zo};function nst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:i}=n,a=s.reduce((y,b)=>y*b),u=S.getReshaped(o.shape,s,a),l=S.getPermuted(u.length,s.length),c=S.getReshapedPermuted(o.shape,s,a),p=S.getSliceBeginCoords(i,s.length),m=S.getSliceSize(c,i,s.length),f=pr({inputs:{x:o},backend:e,attrs:{shape:u}}),d=no({inputs:{x:f},backend:e,attrs:{perm:l}}),h=pr({inputs:{x:d},backend:e,attrs:{shape:c}}),g=zo({inputs:{x:h},backend:e,attrs:{begin:p,size:m}});return e.disposeData(f.dataId),e.disposeData(d.dataId),e.disposeData(f.dataId),g}var UB={kernelName:vi,backendName:"wasm",kernelFunc:nst};function Nl(r){let{inputs:{x:t},attrs:{dtype:e},backend:n}=r,o=n.makeOutput(t.shape,e),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(o).set(s),o}var HB={kernelName:io,backendName:"wasm",kernelFunc:Nl};var qB=ue(es);var KB;function ost(r){KB=r.wasm.cwrap(ao,null,["number","number","number","number"])}function sst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:i}=n,a=e.dataIdMap.get(o.dataId).id,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(u.dataId).id;return KB(a,s,i,l),u}var jB={kernelName:ao,backendName:"wasm",setupFunc:ost,kernelFunc:sst};function MT(r){let{inputs:t,backend:e}=r,n=x.parseAxisParam(r.attrs.axis,t[0].shape)[0],o=S.computeOutShape(t.map(f=>f.shape),n),s=t.filter(f=>x.sizeFromShape(f.shape)>0);if(s.length===1)return ap({inputs:{x:s[0]},backend:e});let i=e.makeOutput(o,t[0].dtype);if(x.sizeFromShape(o)===0)return i;let a=s.map(f=>f.shape);if(S.assertParamsConsistent(a,n),s[0].dtype==="string"){let f=s.map(w=>{let v=x.sizeFromShape(w.shape.slice(n));return pr({inputs:{x:w},backend:e,attrs:{shape:[-1,v]}})}),d=f.map(w=>({vals:e.readSync(w.dataId),shape:w.shape}));o=S.computeOutShape(f.map(w=>w.shape),1);let h=f[0].shape[0]===1,g=Hc(d,o,t[0].dtype,h),y=S.computeOutShape(s.map(w=>w.shape),n);i.shape=y;let b=e.dataIdMap.get(i.dataId);return b.stringBytes=S.fromStringArrayToUint8(g),f.forEach(w=>e.disposeData(w.dataId)),i}let u=x.sizeFromShape(s[0].shape.slice(0,n)),l=0,c=s.map(f=>{let d=x.sizeFromShape(f.shape.slice(n));return l+=d,d}),p=s.map(f=>e.typedArrayFromHeap(f)),m=e.typedArrayFromHeap(i);for(let f=0;f<u;f++){let d=f*l;for(let h=0;h<p.length;h++){let g=c[h],y=f*g,b=p[h].subarray(y,y+g);m.set(b,d),d+=g}}return i}var XB={kernelName:Ci,backendName:"wasm",kernelFunc:MT};var YB;function ist(r){YB=r.wasm.cwrap(rs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ast(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p,dataFormat:m}=e,f=S.convertConv2DDataFormat(m),d=S.computeConv2DInfo(o.shape,s.shape,u,l,c,p,!1,f),h=d.filterHeight,g=d.filterWidth,y=d.padInfo.top,b=d.padInfo.right,w=d.padInfo.bottom,v=d.padInfo.left,k=d.dilationHeight,E=d.dilationWidth,$=d.strideHeight,D=d.strideWidth,R=d.inChannels,P=d.outChannels,W=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let U=n.makeOutput(d.outShape,"float32"),q=n.dataIdMap.get(U.dataId).id;return YB(i,o.shape[0],o.shape[1],o.shape[2],a,h,g,y,b,w,v,W,k,E,$,D,R,P,q),U}var ZB={kernelName:rs,backendName:"wasm",setupFunc:ist,kernelFunc:ast};var JB;function lst(r){JB=r.wasm.cwrap(ns,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ust(r){let{backend:t,inputs:e,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,inputShape:c}=n,p=1,m=S.convertConv2DDataFormat(u),f=S.computeConv2DInfo(c,s.shape,i,p,a,l,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:y,inHeight:b,inWidth:w,outChannels:v,outHeight:k,outWidth:E,strideHeight:$,strideWidth:D}=f,R=h-1-f.padInfo.top,P=g-1-f.padInfo.left,W=f.dataFormat==="channelsLast",U=x.computeStrides(f.inShape),q=x.computeStrides(o.shape),[K,j,Q]=x.computeStrides(s.shape),rt=U[0],X=W?U[1]:U[2],ot=W?U[2]:1,st=W?1:U[1],it=q[0],ft=W?q[1]:q[2],at=W?q[2]:1,xt=W?1:q[1],dt=t.makeOutput(f.inShape,"float32"),bt=t.dataIdMap.get(dt.dataId).id,kt=t.dataIdMap.get(o.dataId).id,At=t.dataIdMap.get(s.dataId).id;return JB(kt,At,d,h,g,b,w,y,k,E,v,$,D,R,P,K,j,Q,rt,X,ot,st,it,ft,at,xt,bt),dt}var QB={kernelName:ns,backendName:"wasm",setupFunc:lst,kernelFunc:ust};var tV=ue(os);var eV=ue(ss);var PT;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(PT||(PT={}));var rV;function cst(r){rV=r.wasm.cwrap(pa,null,["number","number","number","number","array","number","number","number","number","number"])}function pst(r){let{backend:t,inputs:e,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:i}=n,{image:a,boxes:u,boxInd:l}=e,c=u.shape[0],[p,m]=i,f=[c,p,m,a.shape[3]],d=t.dataIdMap.get(a.dataId),h;a.dtype!=="float32"&&(h=Nl({backend:t,inputs:{x:a},attrs:{dtype:"float32"}}),d=t.dataIdMap.get(h.dataId));let g=d.id,y=t.dataIdMap.get(u.dataId).id,b=t.dataIdMap.get(l.dataId).id,w=t.makeOutput(f,"float32"),v=t.dataIdMap.get(w.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer);return rV(g,y,b,c,k,p,m,PT[o],s,v),h!=null&&t.disposeData(h.dataId),w}var nV={kernelName:pa,backendName:"wasm",setupFunc:cst,kernelFunc:pst};var oV;function mst(r){oV=r.wasm.cwrap(ca,null,["number","number","number","number","number","number"])}function fst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;x.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=no({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumprod",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;oV(d,i?1:0,a?1:0,f,h,Xt[o.dtype]);let g=m;if(l!==null){let y=S.getUndoAxesPermutation(l);g=no({inputs:{x:m},attrs:{perm:y},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var sV={kernelName:ca,backendName:"wasm",setupFunc:mst,kernelFunc:fst};var iV;function dst(r){iV=r.wasm.cwrap(is,null,["number","number","number","number","number","number"])}function hst(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;x.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=S.getAxesPermutation([s],u),c=o;l!==null&&(c=no({inputs:{x:o},attrs:{perm:l},backend:e}));let p=S.getInnerMostAxes(1,u)[0];S.assertAxesAreInnerMostDims("cumsum",[p],u);let m=e.makeOutput(c.shape,c.dtype),f=c.shape[p],d=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(m.dataId).id;iV(d,i?1:0,a?1:0,f,h,Xt[o.dtype]);let g=m;if(l!==null){let y=S.getUndoAxesPermutation(l);g=no({inputs:{x:m},attrs:{perm:y},backend:e}),e.disposeData(c.dataId),e.disposeData(m.dataId)}return g}var aV={kernelName:is,backendName:"wasm",setupFunc:dst,kernelFunc:hst};var lV;function gst(r){lV=r.wasm.cwrap(ma,null,["number","number","number","array","number","array","array","number","number"])}function xst(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],c=i==="NHWC"?o.shape[3]:o.shape[1],p=u*s,m=l*s,f=c/(s*s),d=i==="NHWC"?[a,p,m,f]:[a,f,p,m],h=t.makeOutput(d,"float32"),y=t.dataIdMap.get(o.dataId).id,b=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),w=new Uint8Array(new Int32Array(d).buffer),v=new Uint8Array(new Int32Array(x.computeStrides(d)).buffer),k=t.dataIdMap.get(h.dataId).id;return lV(y,s,i==="NHWC"?1:0,b,o.shape.length-1,w,v,d.length,k),h}var uV={kernelName:ma,backendName:"wasm",setupFunc:gst,kernelFunc:xst};var cV;function yst(r){cV=r.wasm.cwrap(as,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:c,dimRoundingMode:p}=e,m=l==null?[1,1]:l,f=S.computeConv2DInfo(o.shape,s.shape,u,m,c,p,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,b=f.padInfo.bottom,w=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,E=f.strideHeight,$=f.strideWidth,D=f.inChannels,R=f.outChannels,P=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),U=n.dataIdMap.get(W.dataId).id;return cV(i,o.shape[0],o.shape[1],o.shape[2],a,d,h,g,y,b,w,P,v,k,E,$,D,R,U),W}var pV={kernelName:as,backendName:"wasm",setupFunc:yst,kernelFunc:bst};var mV=ue(us);var wst=!1,fV=Ie(da,wst,"bool");var dV=ue(cs,"float32");function Xv(r){let{inputs:t,attrs:e,backend:n}=r,{input:o}=t,{dim:s}=e,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(x.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),pr({inputs:{x:o},backend:n,attrs:{shape:a}})}var hV={kernelName:Ii,backendName:"wasm",kernelFunc:Xv};function LT(r){let{attrs:{shape:t,value:e,dtype:n},backend:o}=r,s=o.makeOutput(t,n);return o.typedArrayFromHeap(s).fill(e),s}var gV={kernelName:Ml,backendName:"wasm",kernelFunc:LT};var xV;function vst(r){xV=r.wasm.cwrap(ga,null,["number","number","number","number","number","number"])}function Cst(r){let{inputs:t,backend:e}=r,{image:n}=t,o=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,[a,u,l,c]=n.shape;return xV(s,a,u,l,c,i),o}var yV={kernelName:ga,backendName:"wasm",kernelFunc:Cst,setupFunc:vst};var bV=ue(ps);var Ist=!1,wV=Ie(ms,Ist);var vV;function Sst(r){vV=r.wasm.cwrap(fs,null,["number","number","number","number","number","number","number"])}function kst(r){let{backend:t,inputs:e,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:i,variance:a,offset:u,scale:l}=e,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(a.dataId).id,f=u!=null?t.dataIdMap.get(u.dataId).id:0,d=l!=null?t.dataIdMap.get(l.dataId).id:0,h=t.makeOutput(s.shape,s.dtype);if(x.sizeFromShape(s.shape)===0)return h;let g=t.dataIdMap.get(h.dataId).id;return vV(c,p,m,f,d,o,g),h}var CV={kernelName:fs,backendName:"wasm",setupFunc:Sst,kernelFunc:kst};var IV;function Nst(r){IV=r.wasm.cwrap(Mi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Tst(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m),g=ku[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,v=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);v=at.id}let k=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,R=h.padInfo.bottom,P=h.padInfo.left,W=h.dilationHeight,U=h.dilationWidth,q=h.strideHeight,K=h.strideWidth,j=h.inChannels,Q=h.padInfo.type==="SAME"?1:0,rt=h.batchSize,X=h.inHeight,ot=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,ft=a==null?0:n.dataIdMap.get(a.dataId).id;return IV(y,rt,X,ot,b,k,E,v,$,D,R,P,Q,W,U,q,K,j,w,g,ft,d||0,it),st}var SV={kernelName:Mi,backendName:"wasm",setupFunc:Nst,kernelFunc:Tst};var kV;function _st(r){kV=r.wasm.cwrap(Pi,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Est(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dataFormat:p,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=e,h=S.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!0),g=ku[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,b=n.dataIdMap.get(s.dataId).id,w=h.outChannels,v=0;if(i!=null){let at=n.dataIdMap.get(i.dataId);if(at.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${at.shape.length}.`);if(at.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${at.shape}) does not match the number of output channels (${w})`);v=at.id}let k=h.filterHeight,E=h.filterWidth,$=h.padInfo.top,D=h.padInfo.right,R=h.padInfo.bottom,P=h.padInfo.left,W=h.dilationHeight,U=h.dilationWidth,q=h.strideHeight,K=h.strideWidth,j=h.inChannels,Q=h.padInfo.type==="SAME"?1:0,rt=h.batchSize,X=h.inHeight,ot=h.inWidth;if(p!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let st=n.makeOutput(h.outShape,"float32"),it=n.dataIdMap.get(st.dataId).id,ft=a==null?0:n.dataIdMap.get(a.dataId).id;return kV(y,rt,X,ot,b,k,E,v,$,D,R,P,Q,W,U,q,K,j,w,g,ft,d||0,it),st}var NV={kernelName:Pi,backendName:"wasm",setupFunc:_st,kernelFunc:Est};var TV;function Ast(r){TV=r.wasm.cwrap(xa,null,["number","number","number","number","number","number","array","number"])}function $st(r){let{backend:t,inputs:e}=r,{params:n,indices:o}=e,[s,i,a,u]=$x.prepareAndValidate(n,o),l=t.makeOutput(s,n.dtype);if(i===0)return l;let c=o.shape,p=c[c.length-1],f=t.dataIdMap.get(n.dataId).id,h=t.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),y=t.dataIdMap.get(l.dataId).id;return TV(f,Xt[n.dtype],h,i,p,a,g,y),l}var _V={kernelName:xa,backendName:"wasm",setupFunc:Ast,kernelFunc:$st};var EV;function Dst(r){EV=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Rst(r){let{backend:t,inputs:e,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=x.parseAxisParam(i,o.shape)[0],l=t.readSync(s.dataId),c=o.shape[u];for(let R=0;R<l.length;++R){let P=l[R];x.assert(P<=c-1&&P>=0,()=>`GatherV2: the index value ${P} is not in [0, ${c-1}]`)}let p=S.segment_util.collectGatherOpShapeInfo(o,s,u,a),m=pr({inputs:{x:o},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),f=x.sizeFromShape(s.shape),d=pr({inputs:{x:s},attrs:{shape:[p.batchSize,f/p.batchSize]},backend:t}),h=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize],g=t.makeOutput(h,o.dtype);if(x.sizeFromShape(o.shape)===0)return g;let y=m.shape.length-1,w=t.dataIdMap.get(m.dataId).id,k=t.dataIdMap.get(d.dataId).id,E=t.dataIdMap.get(g.dataId).id,$=new Uint8Array(new Int32Array(x.computeStrides(m.shape)).buffer),D=new Uint8Array(new Int32Array(x.computeStrides(h)).buffer);return EV(w,Xt[o.dtype],$,y,k,p.batchSize,D,E),t.disposeData(m.dataId),t.disposeData(d.dataId),g.shape=p.outputShape,g}var AV={kernelName:Si,backendName:"wasm",setupFunc:Dst,kernelFunc:Rst};var Fst=!1,$V=Ie(ya,Fst,"bool");var Ost=!1,DV=Ie(ds,Ost,"bool");var RV;function Mst(r){RV=r.wasm.cwrap(hs,null,["number","number","number","number"])}function Pst(r){let{inputs:{x:t},attrs:{alpha:e},backend:n}=r,o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(t.shape,"float32");if(x.sizeFromShape(t.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;RV(o,Xt[t.dtype],e,i)}return s}var FV={kernelName:hs,backendName:"wasm",setupFunc:Mst,kernelFunc:Pst};var Lst=!1,OV=Ie(Ca,Lst,"bool");var zst=!1,MV=Ie(Ia,zst,"bool");var PV=ue(gs);var Bst=!1,LV=Ie(ka,Bst,"bool");var zV;function Vst(r){zV=r.wasm.cwrap(xs,null,["number","number","number","number"])}function Gst(r){let{backend:t,inputs:e,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:i}=e,u=t.dataIdMap.get(i.dataId).id,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;l=c,u=w}let d=l.shape.length;S.assertAxesAreInnerMostDims("max",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,i.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;zV(u,Xt[i.dtype],y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var BV={kernelName:xs,backendName:"wasm",setupFunc:Vst,kernelFunc:Gst};var Wst=!1,VV=Ie(ys,Wst);var GV;function Ust(r){GV=r.wasm.cwrap(bs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hst(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id;x.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=e,c=S.computePool2DInfo(o.shape,i,a,1,u,l),p=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,v=c.strideWidth,k=c.inChannels,E=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let $=n.makeOutput(c.outShape,"float32"),D=n.dataIdMap.get($.dataId).id;return GV(s,o.shape[0],o.shape[1],o.shape[2],p,m,f,d,h,g,y,b,w,v,k,E,D),$}var WV={kernelName:bs,backendName:"wasm",setupFunc:Ust,kernelFunc:Hst};var UV;function qst(r){UV=r.wasm.cwrap(ws,null,["number, number, number"])}function Kst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let v=t.dataIdMap.get(c.dataId).id;v!==a&&(l=c,u=v,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("mean",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=l;l.dtype!=="float32"&&(b=Nl({backend:t,inputs:{x:l},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(b.dataId).id);let w=t.makeOutput(h,"float32");if(x.sizeFromShape(l.shape)!==0){let v=t.dataIdMap.get(w.dataId).id;UV(u,y,v)}if(f&&t.disposeData(c.dataId),s){let v=S.expandShapeToKeepDim(w.shape,m);w.shape=v}return l.dtype!=="float32"&&t.disposeData(b.dataId),w}var HV={kernelName:ws,backendName:"wasm",setupFunc:qst,kernelFunc:Kst};var qV;function jst(r){qV=r.wasm.cwrap(vs,null,["number","number","number","number"])}function Xst(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t);if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w)}let d=l.shape.length;S.assertAxesAreInnerMostDims("min",p,d);let[h,g]=S.computeOutAndReduceShapes(l.shape,p),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;qV(u,Xt[i.dtype],y,w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var KV={kernelName:vs,backendName:"wasm",setupFunc:jst,kernelFunc:Xst};var Yst=!1,jV=Ie(Cs,Yst);var zT;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(zT||(zT={}));var XV;function Zst(r){XV=r.wasm.cwrap(Is,null,["number","array","number","number","array","array","number","number"])}function Jst(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+t.shape[h]+d[1]),i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),u=e.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),c=n.map(d=>d[0]),p=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(p).buffer);return XV(i,l,t.shape.length,Xt[t.dtype],m,f,zT[o],u),a}var YV={kernelName:Is,backendName:"wasm",kernelFunc:Jst,setupFunc:Zst};var Qst=!0,ZV=Ie(Ss,Qst);var JV=ue(ki);function Nd(r,t){let e=new Int32Array(r.wasm.HEAPU8.buffer,t,4),n=e[0],o=e[1],s=e[2],i=e[3];return r.wasm._free(t),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:i}}var QV;function tit(r){QV=r.wasm.cwrap(_a,"number",["number","number","number","number","number"])}function eit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i}=n,{boxes:a,scores:u}=e,l=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(u.dataId).id,p=QV(l,c,s,o,i),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=Nd(t,p);return t.wasm._free(d),t.wasm._free(h),t.makeOutput([f],"int32",m)}var tG={kernelName:_a,backendName:"wasm",setupFunc:tit,kernelFunc:eit};var eG;function rit(r){eG=r.wasm.cwrap(Ea,"number",["number","number","number","number","number","bool"])}function nit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=eG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=Nd(t,m);t.wasm._free(h);let y=t.makeOutput([d],"int32",f),b=t.makeOutput([],"int32",g);return[y,b]}var rG={kernelName:Ea,backendName:"wasm",setupFunc:rit,kernelFunc:nit};var nG;function oit(r){nG=r.wasm.cwrap(Aa,"number",["number","number","number","number","number","number"])}function sit(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,softNmsSigma:a}=n,{boxes:u,scores:l}=e,c=t.dataIdMap.get(u.dataId).id,p=t.dataIdMap.get(l.dataId).id,m=nG(c,p,s,o,i,a),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=Nd(t,m);t.wasm._free(g);let y=t.makeOutput([d],"int32",f),b=t.makeOutput([d],"float32",h);return[y,b]}var oG={kernelName:Aa,backendName:"wasm",setupFunc:oit,kernelFunc:sit};var iit=!1,sG=Ie(Ta,iit,"bool");var iG;function ait(r){iG=r.wasm.cwrap(ks,null,["number","number","number","number","number"])}function lit(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{depth:s,onValue:i,offValue:a}=n,u=e.makeOutput([...o.shape,s],"int32"),l=e.dataIdMap.get(u.dataId).id,p=e.dataIdMap.get(o.dataId).id;return iG(p,s,i,a,l),u}var aG={kernelName:ks,backendName:"wasm",setupFunc:ait,kernelFunc:lit};function uit(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(1),n}var lG={kernelName:Ni,backendName:"wasm",kernelFunc:uit};function cit(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return Xv({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=t.map(c=>{let p=Xv({inputs:{input:c},backend:e,attrs:{dim:o}});return a.push(p),p}),l=MT({inputs:u,backend:e,attrs:{axis:o}});return a.forEach(c=>e.disposeData(c.dataId)),l}var uG={kernelName:Ti,backendName:"wasm",kernelFunc:cit};var cG;function pit(r){cG=r.wasm.cwrap(Ns,null,["number","array","number","number","array","array","number","number"])}function mit(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+t.shape[g]+h[1]);if(x.sizeFromShape(t.shape)===0)return LT({backend:e,attrs:{shape:s,value:o,dtype:t.dtype}});let i=e.dataIdMap.get(t.dataId).id,a=e.makeOutput(s,t.dtype),l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(t.shape).buffer),p=n.map(h=>h[0]),m=n.map(h=>h[1]),f=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return cG(i,c,t.shape.length,Xt[t.dtype],f,d,o,l),a}var Yv={kernelName:Ns,backendName:"wasm",kernelFunc:mit,setupFunc:pit};var fit=!1,pG=Ie(Ts,fit);var mG;function dit(r){mG=r.wasm.cwrap(_s,null,["number","number","number"])}function hit(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,a=s,u=n,l=u;u.dtype!=="float32"&&(l=Nl({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),a=e.dataIdMap.get(l.dataId).id);let c=e.makeOutput(n.shape,"float32"),p=e.dataIdMap.get(c.dataId).id;return mG(a,i,p),u.dtype!=="float32"&&e.disposeData(l.dataId),c}var fG={kernelName:_s,backendName:"wasm",setupFunc:dit,kernelFunc:hit};var dG;function git(r){dG=r.wasm.cwrap(Es,null,["number","number","number","number"])}function xit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("prod",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;dG(u,y,Xt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var hG={kernelName:Es,backendName:"wasm",setupFunc:git,kernelFunc:xit};var yit=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:i}=e,a=Kc(n,o,s,i),u=t.makeOutput([a.length],i);return t.typedArrayFromHeap(u).set(a),u},gG={kernelName:zl,backendName:"wasm",kernelFunc:yit};var bit=!0,xG=Ie(ls,bit);var yG=ue(As);var bG=ue(Ds);var wG;function wit(r){wG=r.wasm.cwrap($s,null,["number","number","number","number","number","number","number","number","number","number"])}function vit(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[c,p,m,f]=o.shape,d=[c,u,l,f],h=t.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=Nl({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(g.dataId));let y=h.id,b=t.makeOutput(d,"float32");if(x.sizeFromShape(o.shape)===0)return b;let w=t.dataIdMap.get(b.dataId).id;return wG(y,c,p,m,f,u,l,s?1:0,i?1:0,w),g!=null&&t.disposeData(g.dataId),b}var vG={kernelName:$s,backendName:"wasm",setupFunc:wit,kernelFunc:vit};var CG;function Cit(r){CG=r.wasm.cwrap(Rs,null,["number","array","number","array","number","number"])}function Iit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,i=x.parseAxisParam(s,o.shape);if(o.shape.length===0)return ap({inputs:{x:o},backend:e});let a=e.makeOutput(o.shape,o.dtype),u=e.dataIdMap.get(o.dataId).id,l=e.dataIdMap.get(a.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(o.shape).buffer);CG(u,c,i.length,p,o.shape.length,l);let m=pr({inputs:{x:a},attrs:{shape:o.shape},backend:e});return e.disposeData(a.dataId),m}var IG={kernelName:Rs,backendName:"wasm",kernelFunc:Iit,setupFunc:Cit};var SG;function Sit(r){SG=r.wasm.cwrap(Va,null,["number","number","number","number","number","number","number","number","array","number","number"])}function kit(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{radians:s,fillValue:i,center:a}=n,u=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(o.dataId).id,c=e.dataIdMap.get(u.dataId).id,[p,m,f,d]=o.shape,[h,g]=S.getImageCenter(a,m,f),y=i===0,b=255,w=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(w).buffer);return SG(l,p,m,f,d,s,h,g,v,w.length,c),u}var kG={kernelName:Va,backendName:"wasm",kernelFunc:kit,setupFunc:Sit};var NG=ue(Fs);var TG=ue(Os);var _G;function Nit(r){_G=r.wasm.cwrap(Da,null,["number","number","number","number","number","number","array","number","number"])}function Tit(r){let{backend:t,inputs:e,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,a=t.makeOutput(i,s.dtype);if(x.sizeFromShape(i)===0)return a;let{sliceRank:u,numUpdates:l,sliceSize:c,strides:p,outputSize:m}=nh.calculateShapes(s,o,i),d=t.dataIdMap.get(o.dataId).id,g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(p).buffer),b=t.dataIdMap.get(a.dataId).id;return _G(d,g,Xt[s.dtype],u,l,c,y,m,b),a}var EG={kernelName:Da,backendName:"wasm",setupFunc:Nit,kernelFunc:Tit};var AG;function _it(r){AG=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Eit(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,i=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=e.makeOutput(o.shape,o.dtype),c=e.dataIdMap.get(l.dataId).id,p=n.shape.length,m=o.shape.length,f=p===0||p>1||m===1?1:x.sizeFromShape(o.shape.slice(1));return AG(i,a,u,f,c),l}var $G={kernelName:Ei,backendName:"wasm",kernelFunc:Eit,setupFunc:_it};var DG;function Ait(r){DG=r.wasm.cwrap(Ps,null,["number","number"])}function $it(r){let{backend:t,inputs:{x:e}}=r,n=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(e.shape,e.dtype),s=t.dataIdMap.get(o.dataId).id;return x.sizeFromShape(o.shape)===0||DG(n,s),o}var RG={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Ait,kernelFunc:$it};var FG=ue(Ms);var OG;function Dit(r){OG=r.wasm.cwrap(Bs,null,["number","number","number","number"])}function Rit(r){let{backend:t,inputs:{logits:e},attrs:{dim:n}}=r,o=t.dataIdMap.get(e.dataId).id,s=t.makeOutput(e.shape,e.dtype),i=t.dataIdMap.get(s.dataId).id,a=e.shape[n],u=x.sizeFromShape(e.shape)/a;return x.sizeFromShape(s.shape)===0||OG(o,i,a,u),s}var MG={kernelName:Bs,backendName:"wasm",setupFunc:Dit,kernelFunc:Rit};function Fit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:i}=n,a=x.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let E=1+s.length;E<o.shape.length;++E)u.push([0,0]);let l=Yv.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),c=S.getReshaped(l.shape,s,a,!1),p=S.getPermuted(c.length,s.length,!1),m=S.getReshapedPermuted(l.shape,s,a,!1),h=pr({inputs:{x:l},backend:e,attrs:{shape:c}}),b=no({inputs:{x:h},backend:e,attrs:{perm:p}}),k=pr({inputs:{x:b},backend:e,attrs:{shape:m}});return e.disposeData(l.dataId),e.disposeData(h.dataId),e.disposeData(b.dataId),k}var PG={kernelName:$i,backendName:"wasm",kernelFunc:Fit};var LG;function Oit(r){LG=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Mit(r){let{backend:t,inputs:e}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e,a=n.shape[0],u=n.shape[1],l=t.readSync(s.dataId)[0],c=[a+l,u],p=t.dataIdMap.get(n.dataId).id,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(i.dataId).id,d=t.makeOutput(c,n.dtype),h=t.dataIdMap.get(d.dataId).id,g=t.makeOutput(c.slice(0,1),o.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([l],"bool"),w=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([a],n.dtype),k=t.dataIdMap.get(v.dataId).id,E=t.makeOutput([4],"int32"),$=t.dataIdMap.get(E.dataId).id,D=LG(p,m,Xt[o.dtype],a,l,u,f,h,y,w,k,$),R=t.readSync(E.dataId),P;switch(R[0]){case 1:{P=S.getSparseFillEmptyRowsIndicesDenseShapeMismatch(R[1]);break}case 2:{P=S.getSparseFillEmptyRowsNegativeIndexErrorMessage(R[1],R[2]);break}case 3:P=S.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(R[1],R[2],R[3]);break;default:P=""}if(t.disposeData(E.dataId),P)throw t.disposeData(d.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(P);let W=d,U=g;return D!==c[0]&&(W=zo({inputs:{x:d},attrs:{begin:0,size:[D,u]},backend:t}),U=zo({inputs:{x:g},attrs:{begin:0,size:D},backend:t}),t.disposeData(d.dataId),t.disposeData(g.dataId)),[W,U,b,v]}var zG={kernelName:Vl,backendName:"wasm",setupFunc:Oit,kernelFunc:Mit};var BG;function Pit(r){BG=r.wasm.cwrap(Pa,null,["number","number","number","number","number","number","number"])}function Lit(r){let{backend:t,inputs:e}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=n.shape[0],c=x.sizeFromShape(s.shape),p=t.makeOutput([l,c],n.dtype),m=t.dataIdMap.get(p.dataId).id,f=t.makeOutput([c],s.dtype),d=t.dataIdMap.get(f.dataId).id,h=t.makeOutput([3],"int32"),g=t.dataIdMap.get(h.dataId).id;BG(i,a,u,l,m,d,g);let y=t.readSync(h.dataId),b;switch(y[0]){case 0:{b=S.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=S.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=S.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let w=Array.from(t.readSync(o.dataId)),v=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMultipleErrorMessage(w,v);break}case 4:{let w=Array.from(t.readSync(o.dataId)),v=Array.from(t.readSync(f.dataId));b=S.getSparseReshapeInputOutputMismatchErrorMessage(w,v);break}default:b=""}if(t.disposeData(h.dataId),b)throw t.disposeData(p.dataId),t.disposeData(f.dataId),new Error(b);return[p,f]}var VG={kernelName:Pa,backendName:"wasm",setupFunc:Pit,kernelFunc:Lit};var GG;function Zv(r){GG=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Jv(r,t){let{backend:e,inputs:n}=r,{data:o,indices:s,segmentIds:i}=n,a=s.shape[0],u=e.readSync(i.dataId,a-1,a)[0],c=a>0?u+1:0;if(c<0)throw new Error(S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=o.shape.slice();p[0]=c;let m=e.dataIdMap.get(o.dataId).id,f=e.dataIdMap.get(s.dataId).id,d=e.dataIdMap.get(i.dataId).id,h=e.makeOutput(p,o.dtype),g=e.dataIdMap.get(h.dataId).id,y=e.makeOutput([4],"int32"),b=e.dataIdMap.get(y.dataId).id;GG(m,Xt[o.dtype],o.shape[0],f,d,g,b,t,0);let w=e.readSync(y.dataId),v;switch(w[0]){case 0:{v=S.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{v=S.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:v=S.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:v=S.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:v=""}if(e.disposeData(y.dataId),v)throw e.disposeData(h.dataId),new Error(v);return h}function zit(r){return Jv(r,!0)}var WG={kernelName:Gl,backendName:"wasm",setupFunc:Zv,kernelFunc:zit};function Bit(r){return Jv(r,!1)}var UG={kernelName:Wl,backendName:"wasm",setupFunc:Zv,kernelFunc:Bit};function Vit(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:i}=e,a=x.parseAxisParam(i,o.shape)[0],u=S.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),c=o.shape.slice();return u.map(p=>{let m=[...c];m[a]=p;let f=zo({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[a]+=p,f})}var HG={kernelName:Di,backendName:"wasm",kernelFunc:Vit};var qG=ue(Ls);var KG=ue(Ul);var Git=!0,jG=Ie(Vs,Git);var XG;function Wit(r){XG=r.wasm.cwrap(uo,null,["number","number","number","number"])}function Uit(r){let{backend:t,inputs:e,attrs:n}=r,{alpha:o}=n,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,a=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(a.dataId).id;return XG(i,o,Xt[s.dtype],u),a}var YG={kernelName:uo,backendName:"wasm",setupFunc:Wit,kernelFunc:Uit};var ZG;function Hit(r){ZG=r.wasm.cwrap(La,null,["number","array","number","array","array","array","array","array","number","number"])}function qit(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:m}=n,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:w,strides:v}=Ve.sliceInfo(o.shape,s,i,a,u,l,c,p,m),k;if(h)k=pr({inputs:{x:o},backend:t,attrs:{shape:d}});else if(g||y){x.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let E=Ve.computeOutShape(b,w,v),$=zo({inputs:{x:o},backend:t,attrs:{begin:b,size:E}});k=pr({inputs:{x:$},backend:t,attrs:{shape:d}}),t.disposeData($.dataId)}else{let E=t.makeOutput(f,"float32"),$=t.dataIdMap.get(o.dataId).id,D=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),R=new Uint8Array(new Int32Array(b).buffer),P=new Uint8Array(new Int32Array(w).buffer),W=new Uint8Array(new Int32Array(v).buffer),U=new Uint8Array(new Int32Array(f).buffer),q=new Uint8Array(new Int32Array(x.computeStrides(f)).buffer),K=t.dataIdMap.get(E.dataId).id;ZG($,D,o.shape.length,R,P,W,U,q,f.length,K),k=pr({inputs:{x:E},backend:t,attrs:{shape:d}}),t.disposeData(E.dataId)}return k}var JG={kernelName:La,backendName:"wasm",setupFunc:Hit,kernelFunc:qit};var Kit=!0,QG=Ie(Gs,Kit);var tW;function jit(r){tW=r.wasm.cwrap(zs,null,["number","number","number","number"])}function Xit(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=e,a=t.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:c,axes:p,originalAxes:m,inputWasTransposed:f}=Sn(i,o,t),d=p;if(f){let w=t.dataIdMap.get(c.dataId).id;w!==a&&(l=c,u=w,d=S.getInnerMostAxes(d.length,l.shape.length))}S.assertAxesAreInnerMostDims("sum",d,l.shape.length);let[h,g]=S.computeOutAndReduceShapes(l.shape,d),y=x.sizeFromShape(g),b=t.makeOutput(h,l.dtype);if(x.sizeFromShape(l.shape)!==0){let w=t.dataIdMap.get(b.dataId).id;tW(u,y,Xt[b.dtype],w)}if(f&&t.disposeData(c.dataId),s){let w=S.expandShapeToKeepDim(b.shape,m);b.shape=w}return b}var eW={kernelName:zs,backendName:"wasm",setupFunc:jit,kernelFunc:Xit};var rW=ue(Ws);var nW=ue(Us);var oW;function Yit(r){oW=r.wasm.cwrap(Yn,null,["number","array","number","array","number","number"])}function Zit(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,s=e.dataIdMap.get(o.dataId).id,{reps:i}=n,a=new Array(o.shape.length);for(let m=0;m<a.length;m++)a[m]=o.shape[m]*i[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(a).buffer),c=e.makeOutput(a,o.dtype),p=e.dataIdMap.get(c.dataId).id;return oW(s,u,o.shape.length,l,a.length,Xt[c.dtype],p),c}var sW={kernelName:Yn,backendName:"wasm",setupFunc:Yit,kernelFunc:Zit};var iW;function Jit(r){iW=r.wasm.cwrap(za,null,["number","array","number","number","number","bool","number","number"])}var Qit=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{k:o,sorted:s}=e,i=t.dataIdMap.get(n.dataId).id,a=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=t.makeOutput(u,n.dtype),c=t.dataIdMap.get(l.dataId).id,p=t.makeOutput(u,"int32"),m=t.dataIdMap.get(p.dataId).id;return iW(i,a,n.shape.length,Xt[n.dtype],o,s,c,m),[l,p]},aW={kernelName:za,backendName:"wasm",setupFunc:Jit,kernelFunc:Qit};var lW;function tat(r){lW=r.wasm.cwrap(Ba,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function eat(r){let{backend:t,inputs:e,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,p,m,f]=o.shape,[d,h]=l!=null?l:[p,m],g=[c,d,h,f],y=new Uint8Array(new Int32Array(x.computeStrides(o.shape)).buffer),b=t.makeOutput(g,o.dtype),w=t.dataIdMap.get(b.dataId).id,k=t.dataIdMap.get(o.dataId).id,$=t.dataIdMap.get(s.dataId).id,D=i==="nearest"?1:2,R;switch(a){case"constant":R=1;break;case"reflect":R=2;break;case"wrap":R=3;break;case"nearest":R=4;break;default:R=1;break}return lW(k,$,s.shape[0]>1,c,d,h,f,m,p,y,o.shape.length-1,D,R,u,w),b}var uW={kernelName:Ba,backendName:"wasm",setupFunc:tat,kernelFunc:eat};function rat(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape[s],a=o.shape.length,u=new Array(a-1),l=0;for(let f=0;f<a;f++)f!==s&&(u[l++]=o.shape[f]);let c=new Array(i),p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)p[s]=f,c[f]=zo({inputs:{x:o},attrs:{begin:p,size:m},backend:e});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:u}))}var cW={kernelName:Ri,backendName:"wasm",kernelFunc:rat};function nat(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(0),n}var pW={kernelName:Fi,backendName:"wasm",kernelFunc:nat};var oat=[SB,kB,NB,_B,RB,OB,PB,zB,GB,UB,HB,qB,jB,XB,ZB,QB,tV,eV,nV,sV,aV,uV,pV,mV,fV,dV,hV,gV,yV,bV,wV,CV,SV,NV,_V,AV,$V,DV,EB,FV,OV,MV,PV,LV,BV,VV,WV,HV,KV,jV,YV,ZV,JV,tG,rG,oG,sG,aG,lG,uG,Yv,pG,fG,hG,gG,xG,yG,bG,BB,vG,IG,kG,NG,TG,EG,$G,RG,FG,WB,MG,PG,zG,VG,WG,UG,HG,qG,KG,jG,YG,JG,QG,eW,rW,nW,sW,aW,uW,$B,cW,pW];for(let r of oat)Lu(r);var BT=V();BT.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));BT.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(BT.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var HT=Ru(hW());var gW=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});`;var bW=Ru(xW());var Og=class extends jo{constructor(t){super(),this.wasm=t,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(vW),qT=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Qi(this,go())}write(t,e,n){let o={id:this.dataIdNextNumber++};return this.move(o,t,e,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let e=x.now();return t(),{kernelMs:x.now()-e}}move(t,e,n,o,s){let i=this.dataIdNextNumber++;if(o==="string"){let c=e;this.dataIdMap.set(t,{id:i,stringBytes:c,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let a=x.sizeFromShape(n),u=a*x.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(t,{id:i,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(i,a,l),e!=null&&this.wasm.HEAPU8.set(new Uint8Array(e.buffer,e.byteOffset,u),l)}async read(t){return this.readSync(t)}readSync(t,e,n){let{memoryOffset:o,dtype:s,shape:i,stringBytes:a}=this.dataIdMap.get(t);if(s==="string")return(e==null||e===0)&&(n==null||n>=a.length)?a:a.slice(e,n);e=e||0,n=n||x.sizeFromShape(i);let u=x.bytesPerElement(s),l=this.wasm.HEAPU8.slice(o+e*u,o+n*u);return iat(l.buffer,s)}disposeData(t,e=!1){if(this.dataIdMap.has(t)){let n=this.dataIdMap.get(t);if(n.refCount--,!e&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let e=this.dataIdMap.get(t);e!=null&&e.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,e,n){let o;if(n==null)o=this.write(null,t,e);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:t,dtype:e,refCount:1});let i=x.sizeFromShape(t);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:o,shape:t,dtype:e}}typedArrayFromHeap({shape:t,dtype:e,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),i=x.sizeFromShape(t);switch(e){case"float32":return new Float32Array(o,s,i);case"int32":return new Int32Array(o,s,i);case"bool":return new Uint8Array(o,s,i);default:throw new Error(`Unknown dtype ${e}`)}}};function sat(r){return(t,e)=>(x.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||t.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,t).then(s=>{e(s.instance,s.module)})})}),{})}function yW(r,t,e){if(e0!=null)return e0;let n="tfjs-backend-wasm.wasm";return r&&t?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Rg!=null&&Rg[n]!=null?Rg[n]:e+n}async function wW(){let[r,t]=await Promise.all([V().getAsync("WASM_HAS_SIMD_SUPPORT"),V().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((e,n)=>{let o={};o.locateFile=(a,u)=>{if(a.endsWith(".worker.js")){let l=gW.replace(/\n/g,"\\n"),c=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(c)}return a.endsWith(".wasm")?yW(r,t,Dg!=null?Dg:u):u+a},KT&&(o.instantiateWasm=sat(yW(r,t,Dg!=null?Dg:"")));let s=!1;o.onAbort=()=>{if(s||Fg)return;Fg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;t&&r&&e0==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+HT.default.toString()],{type:"text/javascript"}),i=(0,HT.default)(o)):i=(0,bW.default)(o),i.then(a=>{s=!0,Fg=!1;let u=null;a.tfjs={init:a.cwrap("init",null,[]),initWithThreadsCount:a.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:a.cwrap("get_threads_count","number",[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",u,["number"]),dispose:a.cwrap("dispose",u,[])},e({wasm:a})})})}function iat(r,t){switch(t){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${t}`)}}var aat=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],e0=null,Dg=null,Rg={},Fg=!1,KT=!1;function lat(r,t=!1){if(TI("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Fg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");e0=r,KT=t}function uat(r,t=!1){if(Fg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")Dg=r;else{Rg=r;let e=aat.filter(n=>Rg[n]==null);if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}KT=t}var vW=-1,qT=-1;function cat(r){vW=r}function pat(){if(qT===-1)throw new Error("WASM backend not initialized.");return qT}var mat="3.16.0";var fat=2;dm("wasm",async()=>{let{wasm:r}=await wW();return new Og(r)},fat);var dat="3.16.0",hat="3.16.0",gat="3.16.0",xat="3.16.0",yat="3.16.0",bat="3.16.0",wat="3.16.0",vat="3.16.0",Cat={tfjs:dat,"tfjs-core":hat,"tfjs-data":gat,"tfjs-layers":xat,"tfjs-converter":yat,"tfjs-backend-cpu":bat,"tfjs-backend-webgl":wat,"tfjs-backend-wasm":vat};export{wi as Abs,ea as Acos,ra as Acosh,eu as AdadeltaOptimizer,ru as AdagradOptimizer,nu as AdamOptimizer,ou as AdamaxOptimizer,Xn as Add,Zo as AddN,na as All,oa as Any,Jo as ArgMax,$l as ArgMin,sa as Asin,ia as Asinh,aa as Atan,ua as Atan2,la as Atanh,Qo as AvgPool,Dl as AvgPool3D,_p as AvgPool3DGrad,Tp as AvgPoolGrad,Og as BackendWasm,ts as BatchMatMul,vi as BatchToSpaceND,Ep as Bincount,Ap as BroadcastArgs,v1 as BroadcastTo,lb as Callback,vy as CallbackList,io as Cast,es as Ceil,ao as ClipByValue,$p as Complex,Rl as ComplexAbs,Ci as Concat,rs as Conv2D,Dp as Conv2DBackpropFilter,ns as Conv2DBackpropInput,Fl as Conv3D,Rp as Conv3DBackpropFilterV2,Fp as Conv3DBackpropInputV2,os as Cos,ss as Cosh,pa as CropAndResize,ca as Cumprod,is as Cumsum,Iy as CustomCallback,Qi as DataStorage,Op as DenseBincount,ma as DepthToSpace,as as DepthwiseConv2dNative,Mp as DepthwiseConv2dNativeBackpropFilter,Pp as DepthwiseConv2dNativeBackpropInput,Lp as Diag,Ol as Dilation2D,Hd as Dilation2DBackpropFilter,Ud as Dilation2DBackpropInput,BC as ENV,ub as EarlyStopping,zp as Einsum,us as Elu,Bp as EluGrad,Gd as Environment,da as Equal,fa as Erf,cs as Exp,Ii as ExpandDims,ha as Expm1,Vp as FFT,Ml as Fill,ga as FlipLeftRight,ps as Floor,ms as FloorDiv,qd as FromPixels,fs as FusedBatchNorm,Mi as FusedConv2D,Pi as FusedDepthwiseConv2D,Qc as GPGPUContext,xa as GatherNd,Si as GatherV2,Tb as GraphModel,ya as Greater,ds as GreaterEqual,Cy as History,Gp as IFFT,lo as Identity,Wp as Imag,ve as InputSpec,ba as IsFinite,wa as IsInf,va as IsNan,jo as KernelBackend,Pl as LRN,Hp as LRNGrad,qh as LayerVariable,Vn as LayersModel,hs as LeakyRelu,Ca as Less,Ia as LessEqual,Up as LinSpace,gs as Log,Sa as Log1p,C1 as LogSoftmax,ka as LogicalAnd,Mu as LogicalNot,Pu as LogicalOr,wu as MathBackendWebGL,xs as Max,bs as MaxPool,Ll as MaxPool3D,Kp as MaxPool3DGrad,qp as MaxPoolGrad,jp as MaxPoolWithArgmax,ys as Maximum,ws as Mean,vs as Min,Cs as Minimum,Is as MirrorPad,Na as Mod,su as MomentumOptimizer,Xp as Multinomial,Ss as Multiply,ki as Neg,_a as NonMaxSuppressionV3,Ea as NonMaxSuppressionV4,Aa as NonMaxSuppressionV5,Ta as NotEqual,Y1 as OP_SCOPE_SUFFIX,ks as OneHot,Ni as OnesLike,Vr as Optimizer,oi as OptimizerConstructors,Ti as Pack,Ns as PadV2,_at as Pool,Ts as Pow,_s as Prelu,Es as Prod,iu as RMSPropOptimizer,$n as RNN,zl as Range,ZC as Rank,Yp as Real,ls as RealDiv,$a as Reciprocal,Qe as Reduction,As as Relu,Ds as Relu6,_i as Reshape,$s as ResizeBilinear,Jp as ResizeBilinearGrad,Bl as ResizeNearestNeighbor,Zp as ResizeNearestNeighborGrad,Rs as Reverse,Va as RotateWithOffset,Fs as Round,Os as Rsqrt,Hi as SGDOptimizer,Da as ScatterNd,Ei as Select,Ra as Selu,Yi as Sequential,Ps as Sigmoid,Oa as Sign,Ms as Sin,Fa as Sinh,Ai as Slice,Bs as Softmax,Ma as Softplus,$i as SpaceToBatchND,Vl as SparseFillEmptyRows,Pa as SparseReshape,Gl as SparseSegmentMean,Wl as SparseSegmentSum,Qp as SparseToDense,Di as SplitV,Ls as Sqrt,Ul as Square,Vs as SquaredDifference,uo as Step,La as StridedSlice,tm as StringNGrams,em as StringSplit,rm as StringToHashBucketFast,Gs as Sub,zs as Sum,Qr as SymbolicTensor,Ws as Tan,Us as Tanh,Lt as Tensor,pe as TensorBuffer,Yn as Tile,za as TopK,Ba as Transform,Hs as Transpose,nm as Unique,Ri as Unpack,Hl as UnsortedSegmentSum,Ga as Variable,Fi as ZerosLike,Oi as _FusedMatMul,Ne as abs,ih as acos,ah as acosh,J as add,_I as addN,ju as all,Zl as any,Xs as argMax,lh as argMin,uh as asin,ch as asinh,ph as atan,mh as atan2,fh as atanh,qa as avgPool,dh as avgPool3d,H_ as backend,S as backend_util,zH as basicLSTMCell,xo as batchNorm,DI as batchNorm2d,RI as batchNorm3d,FI as batchNorm4d,Ka as batchToSpaceND,hh as bincount,s1t as booleanMaskAsync,OI as broadcastArgs,ja as broadcastTo,Pr as broadcast_util,Ax as browser,It as buffer,h7 as callbacks,Z as cast,gh as ceil,br as clipByValue,kn as clone,zn as complex,se as concat,MI as concat1d,PI as concat2d,LI as concat3d,zI as concat4d,_$ as constraints,Zu as conv1d,pn as conv2d,Ju as conv2dTranspose,xh as conv3d,BI as conv3dTranspose,Oat as copyRegisteredKernels,Xa as cos,Qu as cosh,qx as cosineWindow,Jl as cumprod,tc as cumsum,mn as customGrad,SR as data,VI as denseBincount,TI as deprecationWarn,yh as depthToSpace,Zs as depthwiseConv2d,b7 as deregisterOp,Xl as device_util,hq as diag,bh as dilation2d,opt as disableDeprecationWarnings,_t as dispose,spt as disposeVariables,ct as div,wh as divNoNan,GI as dot,hE as dropout,WI as einsum,Js as elu,npt as enableDebugMode,rpt as enableProdMode,gE as enclosingPowerOfTwo,go as engine,V as env,Sr as equal,vh as erf,Ze as exp,fr as expandDims,Ch as expm1,xm as eye,ol as fft,Qs as fill,ppt as findBackend,mpt as findBackendFactory,ti as floor,Ku as floorDiv,XP as forceHalfFloat,Co as fused,yo as gather,fE as gatherND,$x as gather_util,upt as getBackend,WC as getGradient,jd as getKernel,gx as getKernelsForBackend,pat as getThreadsCount,dT as gpgpu_util,Uq as grad,Hq as grads,Ge as greater,Tn as greaterEqual,Wi as ifft,ec as imag,dn as image,l_t as inTopKAsync,E$ as initializers,PS as input,Mr as io,dc as irfft,UI as isFinite,HI as isInf,Ih as isNaN,Pe as keep,Gr as kernel_impls,aD as layers,Ya as leakyRelu,rc as less,_n as lessEqual,eA as linalg,qI as linspace,mZ as loadGraphModel,N8 as loadLayersModel,Sh as localResponseNormalization,wr as log,Za as log1p,KI as logSigmoid,nc as logSoftmax,Nh as logSumExp,Nr as logicalAnd,Ja as logicalNot,oc as logicalOr,JI as logicalXor,zFt as losses,zt as matMul,N_ as math,Dr as max,Qa as maxPool,Th as maxPool3d,QI as maxPoolWithArgmax,fn as maximum,xe as mean,sh as memory,fK as meshgrid,lD as metrics,Ql as min,ei as minimum,_h as mirrorPad,Eh as mod,S8 as model,uD as models,ym as moments,E1t as movingAverage,O as mul,vK as multiRNNCell,tS as multinomial,Zt as neg,Vh as nextFrame,vm as norm,vo as notEqual,js as oneHot,lr as ones,dr as onesLike,N as op,NK as outerProduct,Yr as pad,EK as pad1d,$K as pad2d,RK as pad3d,OK as pad4d,eS as pool,Zr as pow,el as prelu,hI as print,sc as prod,ipt as profile,UK as rand,JK as randomGamma,Gx as randomNormal,ri as randomUniform,rl as range,lpt as ready,tu as real,Ah as reciprocal,dm as registerBackend,T8 as registerCallbackConstructor,S1 as registerGradient,Lu as registerKernel,y7 as registerOp,cD as regularizers,Tr as relu,lc as relu6,cpt as removeBackend,M as reshape,ir as reverse,aj as reverse1d,uj as reverse2d,pj as reverse3d,fj as reverse4d,sl as rfft,uc as round,cc as rsqrt,pt as scalar,pE as scatterND,nh as scatter_util,pc as selu,$h as separableConv2d,k8 as sequential,et as serialization,aH as setBackend,fpt as setPlatform,cat as setThreadsCount,lat as setWasmPath,uat as setWasmPaths,_N as setWebGLContext,cS as setdiff1dAsync,Lr as sigmoid,Dh as sign,mFt as signal,mc as sin,fc as sinh,Rt as slice,Rh as slice1d,Wx as slice2d,Fh as slice3d,bm as slice4d,Ve as slice_util,nl as softmax,bo as softplus,tl as spaceToBatchND,Bh as sparse,Hx as sparseToDense,aFt as spectral,ur as split,be as sqrt,Ut as square,hc as squaredDifference,zr as squeeze,Je as stack,ni as step,Oh as stridedSlice,ry as string,lt as sub,mt as sum,Uu as sumOutType,Mh as tan,Ys as tanh,Ar as tensor,Re as tensor1d,Ui as tensor2d,vI as tensor3d,zj as tensor4d,Bj as tensor5d,Vj as tensor6d,fo as tensor_util,W_ as test_util,B as tidy,kr as tile,apt as time,Ph as topk,vc as train,Mt as transpose,gc as truncatedNormal,wm as unique,Fat as unregisterGradient,Rat as unregisterKernel,Lh as unsortedSegmentSum,vr as unstack,ar as upcastType,x as util,qq as valueAndGrad,Kq as valueAndGrads,pS as variable,Mx as variableGrads,Cat as version,WD as version_converter,U_ as version_core,Hm as version_layers,mat as version_wasm,jP as version_webgl,gke as webgl,pd as webgl_util,_e as where,zh as whereAsync,ye as zeros,St as zerosLike};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
