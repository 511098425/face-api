{
  "version": 3,
  "sources": ["src/env/isNodejs.ts", "src/draw/drawContour.ts", "src/classes/Dimensions.ts", "src/utils/index.ts", "src/classes/Point.ts", "src/classes/Box.ts", "src/classes/BoundingBox.ts", "src/classes/ObjectDetection.ts", "src/classes/FaceDetection.ts", "src/ops/iou.ts", "src/ops/minBbox.ts", "src/ops/nonMaxSuppression.ts", "src/ops/normalize.ts", "src/ops/padToSquare.ts", "src/ops/shuffleArray.ts", "src/ops/index.ts", "src/classes/Rect.ts", "src/classes/FaceLandmarks.ts", "src/classes/FaceLandmarks5.ts", "src/classes/FaceLandmarks68.ts", "src/classes/FaceMatch.ts", "src/classes/LabeledBox.ts", "src/classes/LabeledFaceDescriptors.ts", "src/classes/PredictedBox.ts", "src/factories/WithFaceDetection.ts", "src/env/createBrowserEnv.ts", "src/env/createFileSystem.ts", "src/env/createNodejsEnv.ts", "src/env/isBrowser.ts", "src/env/index.ts", "src/dom/resolveInput.ts", "src/dom/getContext2dOrThrow.ts", "src/draw/DrawTextField.ts", "src/draw/DrawBox.ts", "src/draw/drawDetections.ts", "src/dom/isMediaLoaded.ts", "src/dom/awaitMediaLoaded.ts", "src/dom/bufferToImage.ts", "src/dom/getMediaDimensions.ts", "src/dom/createCanvas.ts", "src/dom/imageTensorToCanvas.ts", "src/dom/isMediaElement.ts", "src/dom/imageToSquare.ts", "src/dom/NetInput.ts", "src/dom/toNetInput.ts", "src/dom/extractFaces.ts", "src/dom/extractFaceTensors.ts", "src/dom/fetchOrThrow.ts", "src/dom/fetchImage.ts", "src/dom/fetchJson.ts", "src/dom/fetchNetWeights.ts", "src/common/getModelUris.ts", "src/dom/loadWeightMap.ts", "src/dom/matchDimensions.ts", "src/NeuralNetwork.ts", "src/common/depthwiseSeparableConv.ts", "src/faceFeatureExtractor/denseBlock.ts", "src/common/convLayer.ts", "src/common/disposeUnusedWeightTensors.ts", "src/common/extractConvParamsFactory.ts", "src/common/extractFCParamsFactory.ts", "src/common/types.ts", "src/common/extractSeparableConvParamsFactory.ts", "src/common/extractWeightEntryFactory.ts", "src/common/extractWeightsFactory.ts", "src/faceFeatureExtractor/extractorsFactory.ts", "src/faceFeatureExtractor/extractParams.ts", "src/common/loadConvParamsFactory.ts", "src/faceFeatureExtractor/loadParamsFactory.ts", "src/faceFeatureExtractor/extractParamsFromWeigthMap.ts", "src/faceFeatureExtractor/FaceFeatureExtractor.ts", "src/common/fullyConnectedLayer.ts", "src/faceProcessor/extractParams.ts", "src/faceProcessor/extractParamsFromWeigthMap.ts", "src/faceProcessor/util.ts", "src/faceProcessor/FaceProcessor.ts", "src/faceExpressionNet/FaceExpressions.ts", "src/faceExpressionNet/FaceExpressionNet.ts", "src/factories/WithFaceExpressions.ts", "src/draw/drawFaceExpressions.ts", "src/factories/WithFaceLandmarks.ts", "src/draw/DrawFaceLandmarks.ts", "src/draw/index.ts", "src/xception/extractParams.ts", "src/xception/extractParamsFromWeigthMap.ts", "src/xception/TinyXception.ts", "src/ageGenderNet/extractParams.ts", "src/ageGenderNet/extractParamsFromWeigthMap.ts", "src/ageGenderNet/types.ts", "src/ageGenderNet/AgeGenderNet.ts", "src/faceLandmarkNet/FaceLandmark68NetBase.ts", "src/faceLandmarkNet/FaceLandmark68Net.ts", "src/faceFeatureExtractor/extractParamsFromWeigthMapTiny.ts", "src/faceFeatureExtractor/extractParamsTiny.ts", "src/faceFeatureExtractor/TinyFaceFeatureExtractor.ts", "src/faceLandmarkNet/FaceLandmark68TinyNet.ts", "src/faceLandmarkNet/index.ts", "src/faceRecognitionNet/scaleLayer.ts", "src/faceRecognitionNet/convLayer.ts", "src/faceRecognitionNet/extractParams.ts", "src/faceRecognitionNet/extractParamsFromWeigthMap.ts", "src/faceRecognitionNet/residualLayer.ts", "src/faceRecognitionNet/FaceRecognitionNet.ts", "src/faceRecognitionNet/index.ts", "src/factories/WithFaceDescriptor.ts", "src/factories/WithAge.ts", "src/factories/WithGender.ts", "src/ssdMobilenetv1/extractParams.ts", "src/ssdMobilenetv1/extractParamsFromWeigthMap.ts", "src/ssdMobilenetv1/pointwiseConvLayer.ts", "src/ssdMobilenetv1/mobileNetV1.ts", "src/ssdMobilenetv1/nonMaxSuppression.ts", "src/ssdMobilenetv1/outputLayer.ts", "src/ssdMobilenetv1/boxPredictionLayer.ts", "src/ssdMobilenetv1/predictionLayer.ts", "src/ssdMobilenetv1/SsdMobilenetv1Options.ts", "src/ssdMobilenetv1/SsdMobilenetv1.ts", "src/ssdMobilenetv1/index.ts", "src/tinyYolov2/const.ts", "src/tinyYolov2/config.ts", "src/tinyYolov2/leaky.ts", "src/tinyYolov2/convWithBatchNorm.ts", "src/tinyYolov2/depthwiseSeparableConv.ts", "src/tinyYolov2/extractParams.ts", "src/tinyYolov2/extractParamsFromWeigthMap.ts", "src/tinyYolov2/TinyYolov2Options.ts", "src/tinyYolov2/TinyYolov2Base.ts", "src/tinyYolov2/TinyYolov2.ts", "src/tinyYolov2/index.ts", "src/tinyFaceDetector/TinyFaceDetectorOptions.ts", "src/globalApi/ComposableTask.ts", "src/globalApi/extractFacesAndComputeResults.ts", "src/tinyFaceDetector/const.ts", "src/tinyFaceDetector/TinyFaceDetector.ts", "src/globalApi/nets.ts", "src/globalApi/PredictFaceExpressionsTask.ts", "src/globalApi/PredictAgeAndGenderTask.ts", "src/globalApi/ComputeFaceDescriptorsTasks.ts", "src/globalApi/DetectFaceLandmarksTasks.ts", "src/globalApi/DetectFacesTasks.ts", "src/globalApi/detectFaces.ts", "src/globalApi/allFaces.ts", "src/euclideanDistance.ts", "src/globalApi/FaceMatcher.ts", "src/tinyFaceDetector/index.ts", "src/resizeResults.ts", "src/index.ts"],
  "sourcesContent": ["export function isNodejs(): boolean {\n  return typeof global === 'object'\n    && typeof require === 'function'\n    && typeof module !== 'undefined'\n    // issues with gatsby.js: module.exports is undefined\n    // && !!module.exports\n    && typeof process !== 'undefined' && !!process.version\n}", "import { Point } from '../classes';\n\nexport function drawContour(\n  ctx: CanvasRenderingContext2D,\n  points: Point[],\n  isClosed: boolean = false\n) {\n  ctx.beginPath()\n\n  points.slice(1).forEach(({ x, y }, prevIdx) => {\n    const from = points[prevIdx]\n    ctx.moveTo(from.x, from.y)\n    ctx.lineTo(x, y)\n  })\n\n  if (isClosed) {\n    const from = points[points.length - 1]\n    const to = points[0]\n    if (!from || !to) {\n      return\n    }\n\n    ctx.moveTo(from.x, from.y)\n    ctx.lineTo(to.x, to.y)\n  }\n\n  ctx.stroke()\n}", "import { isValidNumber } from '../utils';\n\nexport interface IDimensions {\n  width: number\n  height: number\n}\n\nexport class Dimensions implements IDimensions {\n\n  private _width: number\n  private _height: number\n\n  constructor(width: number, height: number) {\n    if (!isValidNumber(width) || !isValidNumber(height)) {\n      throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({ width, height })}`)\n    }\n\n    this._width = width\n    this._height = height\n  }\n\n  public get width(): number { return this._width }\n  public get height(): number { return this._height }\n\n  public reverse(): Dimensions {\n    return new Dimensions(1 / this.width, 1 / this.height)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { Point } from '../classes';\nimport { Dimensions, IDimensions } from '../classes/Dimensions';\n\nexport function isTensor(tensor: any, dim: number) {\n  return tensor instanceof tf.Tensor && tensor.shape.length === dim\n}\n\nexport function isTensor1D(tensor: any): tensor is tf.Tensor1D {\n  return isTensor(tensor, 1)\n}\n\nexport function isTensor2D(tensor: any): tensor is tf.Tensor2D {\n  return isTensor(tensor, 2)\n}\n\nexport function isTensor3D(tensor: any): tensor is tf.Tensor3D {\n  return isTensor(tensor, 3)\n}\n\nexport function isTensor4D(tensor: any): tensor is tf.Tensor4D {\n  return isTensor(tensor, 4)\n}\n\nexport function isFloat(num: number) {\n  return num % 1 !== 0\n}\n\nexport function isEven(num: number) {\n  return num % 2 === 0\n}\n\nexport function round(num: number, prec: number = 2) {\n  const f = Math.pow(10, prec)\n  return Math.floor(num * f) / f\n}\n\nexport function isDimensions(obj: any): boolean {\n  return obj && obj.width && obj.height\n}\n\nexport function computeReshapedDimensions({ width, height }: IDimensions, inputSize: number) {\n  const scale = inputSize / Math.max(height, width)\n  return new Dimensions(Math.round(width * scale), Math.round(height * scale))\n}\n\nexport function getCenterPoint(pts: Point[]): Point {\n  return pts.reduce((sum, pt) => sum.add(pt), new Point(0, 0))\n    .div(new Point(pts.length, pts.length))\n}\n\nexport function range(num: number, start: number, step: number): number[] {\n  return Array(num).fill(0).map((_, i) => start + (i * step))\n}\n\nexport function isValidNumber(num: any) {\n  return !!num && num !== Infinity && num !== -Infinity && !isNaN(num) || num === 0\n}\n\nexport function isValidProbablitiy(num: any) {\n  return isValidNumber(num) && 0 <= num && num <= 1.0\n}", "export interface IPoint {\n  x: number\n  y: number\n}\n\nexport class Point implements IPoint {\n  private _x: number\n  private _y: number\n\n  constructor(x: number, y: number) {\n    this._x = x\n    this._y = y\n  }\n\n  get x(): number { return this._x }\n  get y(): number { return this._y }\n\n  public add(pt: IPoint): Point {\n    return new Point(this.x + pt.x, this.y + pt.y)\n  }\n\n  public sub(pt: IPoint): Point {\n    return new Point(this.x - pt.x, this.y - pt.y)\n  }\n\n  public mul(pt: IPoint): Point {\n    return new Point(this.x * pt.x, this.y * pt.y)\n  }\n\n  public div(pt: IPoint): Point {\n    return new Point(this.x / pt.x, this.y / pt.y)\n  }\n\n  public abs(): Point {\n    return new Point(Math.abs(this.x), Math.abs(this.y))\n  }\n\n  public magnitude(): number {\n    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))\n  }\n\n  public floor(): Point {\n    return new Point(Math.floor(this.x), Math.floor(this.y))\n  }\n}", "import { isDimensions, isValidNumber } from '../utils';\nimport { IBoundingBox } from './BoundingBox';\nimport { IDimensions } from './Dimensions';\nimport { Point } from './Point';\nimport { IRect } from './Rect';\n\nexport class Box<BoxType = any> implements IBoundingBox, IRect {\n\n  public static isRect(rect: any): boolean {\n    return !!rect && [rect.x, rect.y, rect.width, rect.height].every(isValidNumber)\n  }\n\n  public static assertIsValidBox(box: any, callee: string, allowNegativeDimensions: boolean = false) {\n    if (!Box.isRect(box)) {\n      throw new Error(`${callee} - invalid box: ${JSON.stringify(box)}, expected object with properties x, y, width, height`)\n    }\n\n    if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {\n      throw new Error(`${callee} - width (${box.width}) and height (${box.height}) must be positive numbers`)\n    }\n  }\n\n  private _x: number\n  private _y: number\n  private _width: number\n  private _height: number\n\n  constructor(_box: IBoundingBox | IRect, allowNegativeDimensions: boolean = true) {\n    const box = (_box || {}) as any\n\n    const isBbox = [box.left, box.top, box.right, box.bottom].every(isValidNumber)\n    const isRect = [box.x, box.y, box.width, box.height].every(isValidNumber)\n\n    if (!isRect && !isBbox) {\n      throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(box)}`)\n    }\n\n    const [x, y, width, height] = isRect\n      ? [box.x, box.y, box.width, box.height]\n      : [box.left, box.top, box.right - box.left, box.bottom - box.top]\n\n    Box.assertIsValidBox({ x, y, width, height }, 'Box.constructor', allowNegativeDimensions)\n\n    this._x = x\n    this._y = y\n    this._width = width\n    this._height = height\n  }\n\n  public get x(): number { return this._x }\n  public get y(): number { return this._y }\n  public get width(): number { return this._width }\n  public get height(): number { return this._height }\n  public get left(): number { return this.x }\n  public get top(): number { return this.y }\n  public get right(): number { return this.x + this.width }\n  public get bottom(): number { return this.y + this.height }\n  public get area(): number { return this.width * this.height }\n  public get topLeft(): Point { return new Point(this.left, this.top) }\n  public get topRight(): Point { return new Point(this.right, this.top) }\n  public get bottomLeft(): Point { return new Point(this.left, this.bottom) }\n  public get bottomRight(): Point { return new Point(this.right, this.bottom) }\n\n  public round(): Box<BoxType> {\n    const [x, y, width, height] = [this.x, this.y, this.width, this.height]\n      .map(val => Math.round(val))\n    return new Box({ x, y, width, height })\n  }\n\n  public floor(): Box<BoxType> {\n    const [x, y, width, height] = [this.x, this.y, this.width, this.height]\n      .map(val => Math.floor(val))\n    return new Box({ x, y, width, height })\n  }\n\n  public toSquare(): Box<BoxType> {\n    let { x, y, width, height } = this\n    const diff = Math.abs(width - height)\n    if (width < height) {\n      x -= (diff / 2)\n      width += diff\n    }\n    if (height < width) {\n      y -= (diff / 2)\n      height += diff\n    }\n\n    return new Box({ x, y, width, height })\n  }\n\n  public rescale(s: IDimensions | number): Box<BoxType> {\n    const scaleX = isDimensions(s) ? (s as IDimensions).width : s as number\n    const scaleY = isDimensions(s) ? (s as IDimensions).height : s as number\n    return new Box({\n      x: this.x * scaleX,\n      y: this.y * scaleY,\n      width: this.width * scaleX,\n      height: this.height * scaleY\n    })\n  }\n\n  public pad(padX: number, padY: number): Box<BoxType> {\n    let [x, y, width, height] = [\n      this.x - (padX / 2),\n      this.y - (padY / 2),\n      this.width + padX,\n      this.height + padY\n    ]\n    return new Box({ x, y, width, height })\n  }\n\n  public clipAtImageBorders(imgWidth: number, imgHeight: number): Box<BoxType> {\n    const { x, y, right, bottom } = this\n    const clippedX = Math.max(x, 0)\n    const clippedY = Math.max(y, 0)\n\n    const newWidth = right - clippedX\n    const newHeight = bottom - clippedY\n    const clippedWidth = Math.min(newWidth, imgWidth - clippedX)\n    const clippedHeight = Math.min(newHeight, imgHeight - clippedY)\n\n    return (new Box({ x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight})).floor()\n  }\n\n  public shift(sx: number, sy: number): Box<BoxType> {\n    const { width, height } = this\n    const x = this.x + sx\n    const y = this.y + sy\n\n    return new Box({ x, y, width, height })\n  }\n\n  public padAtBorders(imageHeight: number, imageWidth: number) {\n    const w = this.width + 1\n    const h = this.height + 1\n\n    let dx = 1\n    let dy = 1\n    let edx = w\n    let edy = h\n\n    let x = this.left\n    let y = this.top\n    let ex = this.right\n    let ey = this.bottom\n\n    if (ex > imageWidth) {\n      edx = -ex + imageWidth + w\n      ex = imageWidth\n    }\n    if (ey > imageHeight) {\n      edy = -ey + imageHeight + h\n      ey = imageHeight\n    }\n    if (x < 1) {\n      edy = 2 - x\n      x = 1\n    }\n    if (y < 1) {\n      edy = 2 - y\n      y = 1\n    }\n\n    return { dy, edy, dx, edx, y, ey, x, ex, w, h }\n  }\n\n  public calibrate(region: Box) {\n    return new Box({\n      left: this.left + (region.left * this.width),\n      top: this.top + (region.top * this.height),\n      right: this.right + (region.right * this.width),\n      bottom: this.bottom + (region.bottom * this.height)\n    }).toSquare().round()\n  }\n}", "import { Box } from './Box';\n\nexport interface IBoundingBox {\n  left: number\n  top: number\n  right: number\n  bottom: number\n}\n\nexport class BoundingBox extends Box<BoundingBox> implements IBoundingBox {\n  constructor(left: number, top: number, right: number, bottom: number, allowNegativeDimensions: boolean = false) {\n    super({ left, top, right, bottom }, allowNegativeDimensions)\n  }\n}", "import { Box } from './Box';\nimport { Dimensions, IDimensions } from './Dimensions';\nimport { IRect, Rect } from './Rect';\n\nexport class ObjectDetection {\n  private _score: number\n  private _classScore: number\n  private _className: string\n  private _box: Rect\n  private _imageDims: Dimensions\n\n  constructor(\n    score: number,\n    classScore: number,\n    className: string,\n    relativeBox: IRect,\n    imageDims: IDimensions\n  ) {\n    this._imageDims = new Dimensions(imageDims.width, imageDims.height)\n    this._score = score\n    this._classScore = classScore\n    this._className = className\n    this._box = new Box(relativeBox).rescale(this._imageDims)\n  }\n\n  public get score(): number { return this._score }\n  public get classScore(): number { return this._classScore }\n  public get className(): string { return this._className }\n  public get box(): Box { return this._box }\n  public get imageDims(): Dimensions { return this._imageDims }\n  public get imageWidth(): number { return this.imageDims.width }\n  public get imageHeight(): number { return this.imageDims.height }\n  public get relativeBox(): Box { return new Box(this._box).rescale(this.imageDims.reverse()) }\n\n  public forSize(width: number, height: number): ObjectDetection {\n    return new ObjectDetection(\n      this.score,\n      this.classScore,\n      this.className,\n      this.relativeBox,\n      { width, height}\n    )\n  }\n}", "import { Box } from './Box';\nimport { IDimensions } from './Dimensions';\nimport { ObjectDetection } from './ObjectDetection';\nimport { Rect } from './Rect';\n\nexport interface IFaceDetecion {\n  score: number\n  box: Box\n}\n\nexport class FaceDetection extends ObjectDetection implements IFaceDetecion {\n  constructor(\n    score: number,\n    relativeBox: Rect,\n    imageDims: IDimensions\n  ) {\n    super(score, score, '', relativeBox, imageDims)\n  }\n\n  public forSize(width: number, height: number): FaceDetection {\n    const { score, relativeBox, imageDims } = super.forSize(width, height)\n    return new FaceDetection(score, relativeBox, imageDims)\n  }\n}", "import { Box } from '../classes/Box';\n\nexport function iou(box1: Box, box2: Box, isIOU: boolean = true) {\n  const width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left))\n  const height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top))\n  const interSection = width * height\n\n  return isIOU\n    ? interSection / (box1.area + box2.area - interSection)\n    : interSection / Math.min(box1.area, box2.area)\n}", "import { BoundingBox, IPoint } from '../classes';\n\nexport function minBbox(pts: IPoint[]): BoundingBox {\n  const xs = pts.map(pt => pt.x)\n  const ys = pts.map(pt => pt.y)\n  const minX = xs.reduce((min, x) => x < min ? x : min, Infinity)\n  const minY = ys.reduce((min, y) => y < min ? y : min, Infinity)\n  const maxX = xs.reduce((max, x) => max < x ? x : max, 0)\n  const maxY = ys.reduce((max, y) => max < y ? y : max, 0)\n\n  return new BoundingBox(minX, minY, maxX, maxY)\n}\n", "import { Box } from '../classes/Box';\nimport { iou } from './iou';\n\nexport function nonMaxSuppression(\n  boxes: Box[],\n  scores: number[],\n  iouThreshold: number,\n  isIOU: boolean = true\n): number[] {\n\n  let indicesSortedByScore = scores\n    .map((score, boxIndex) => ({ score, boxIndex }))\n    .sort((c1, c2) => c1.score - c2.score)\n    .map(c => c.boxIndex)\n\n  const pick: number[] = []\n\n  while(indicesSortedByScore.length > 0) {\n    const curr = indicesSortedByScore.pop() as number\n    pick.push(curr)\n\n    const indices = indicesSortedByScore\n\n    const outputs: number[] = []\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i]\n\n      const currBox = boxes[curr]\n      const idxBox = boxes[idx]\n\n      outputs.push(iou(currBox, idxBox, isIOU))\n    }\n\n    indicesSortedByScore = indicesSortedByScore.filter(\n      (_, j) => outputs[j] <= iouThreshold\n    )\n  }\n\n  return pick\n\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nexport function normalize(x: tf.Tensor4D, meanRgb: number[]): tf.Tensor4D {\n  return tf.tidy(() => {\n    const [r, g, b] = meanRgb\n    const avg_r = tf.fill([...x.shape.slice(0, 3), 1], r)\n    const avg_g = tf.fill([...x.shape.slice(0, 3), 1], g)\n    const avg_b = tf.fill([...x.shape.slice(0, 3), 1], b)\n    const avg_rgb = tf.concat([avg_r, avg_g, avg_b], 3)\n\n    return tf.sub(x, avg_rgb)\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\n/**\n * Pads the smaller dimension of an image tensor with zeros, such that width === height.\n *\n * @param imgTensor The image tensor.\n * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\n * both sides of the minor dimension oof the image.\n * @returns The padded tensor with width === height.\n */\nexport function padToSquare(\n  imgTensor: tf.Tensor4D,\n  isCenterImage: boolean = false\n): tf.Tensor4D {\n  return tf.tidy(() => {\n\n    const [height, width] = imgTensor.shape.slice(1)\n    if (height === width) {\n      return imgTensor\n    }\n\n    const dimDiff = Math.abs(height - width)\n    const paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1))\n    const paddingAxis = height > width ? 2 : 1\n\n    const createPaddingTensor = (paddingAmount: number): tf.Tensor => {\n      const paddingTensorShape = imgTensor.shape.slice()\n      paddingTensorShape[paddingAxis] = paddingAmount\n      return tf.fill(paddingTensorShape, 0)\n    }\n\n    const paddingTensorAppend = createPaddingTensor(paddingAmount)\n    const remainingPaddingAmount = dimDiff - (paddingTensorAppend.shape[paddingAxis] as number)\n\n    const paddingTensorPrepend = isCenterImage && remainingPaddingAmount\n      ? createPaddingTensor(remainingPaddingAmount)\n      : null\n\n    const tensorsToStack = [\n      paddingTensorPrepend,\n      imgTensor,\n      paddingTensorAppend\n    ]\n      .filter(t => !!t)\n      // .map((t: tf.Tensor) => t.toFloat()) as tf.Tensor4D[]\n      .map((t: tf.Tensor) => tf.cast(t, 'float32')) as tf.Tensor4D[]\n    return tf.concat(tensorsToStack, paddingAxis)\n\n  })\n}", "export function shuffleArray(inputArray: any[]) {\n  const array = inputArray.slice()\n  for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1))\n      const x = array[i]\n      array[i] = array[j]\n      array[j] = x\n  }\n  return array\n}", "export * from './iou'\nexport * from './minBbox'\nexport * from './nonMaxSuppression'\nexport * from './normalize'\nexport * from './padToSquare'\nexport * from './shuffleArray'\n\nexport function sigmoid(x: number) {\n  return 1 / (1 + Math.exp(-x))\n}\n\nexport function inverseSigmoid(x: number) {\n  return Math.log(x / (1 - x))\n}", "import { Box } from './Box';\n\nexport interface IRect {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\nexport class Rect extends Box<Rect> implements IRect {\n  constructor(x: number, y: number, width: number, height: number, allowNegativeDimensions: boolean = false) {\n    super({ x, y, width, height }, allowNegativeDimensions)\n  }\n}", "import { minBbox } from '../ops';\nimport { getCenterPoint } from '../utils';\nimport { IBoundingBox } from './BoundingBox';\nimport { Box } from './Box';\nimport { Dimensions, IDimensions } from './Dimensions';\nimport { FaceDetection } from './FaceDetection';\nimport { Point } from './Point';\nimport { IRect, Rect } from './Rect';\n\n// face alignment constants\nconst relX = 0.5\nconst relY = 0.43\nconst relScale = 0.45\n\nexport interface IFaceLandmarks {\n  positions: Point[]\n  shift: Point\n}\n\nexport class FaceLandmarks implements IFaceLandmarks {\n  protected _shift: Point\n  protected _positions: Point[]\n  protected _imgDims: Dimensions\n\n  constructor(\n    relativeFaceLandmarkPositions: Point[],\n    imgDims: IDimensions,\n    shift: Point = new Point(0, 0)\n  ) {\n    const { width, height } = imgDims\n    this._imgDims = new Dimensions(width, height)\n    this._shift = shift\n    this._positions = relativeFaceLandmarkPositions.map(\n      pt => pt.mul(new Point(width, height)).add(shift)\n    )\n  }\n\n  public get shift(): Point { return new Point(this._shift.x, this._shift.y) }\n  public get imageWidth(): number { return this._imgDims.width }\n  public get imageHeight(): number { return this._imgDims.height }\n  public get positions(): Point[] { return this._positions }\n  public get relativePositions(): Point[] {\n    return this._positions.map(\n      pt => pt.sub(this._shift).div(new Point(this.imageWidth, this.imageHeight))\n    )\n  }\n\n  public forSize<T extends FaceLandmarks>(width: number, height: number): T {\n    return new (this.constructor as any)(\n      this.relativePositions,\n      { width, height }\n    )\n  }\n\n  public shiftBy<T extends FaceLandmarks>(x: number, y: number): T {\n    return new (this.constructor as any)(\n      this.relativePositions,\n      this._imgDims,\n      new Point(x, y)\n    )\n  }\n\n  public shiftByPoint<T extends FaceLandmarks>(pt: Point): T {\n    return this.shiftBy(pt.x, pt.y)\n  }\n\n  /**\n   * Aligns the face landmarks after face detection from the relative positions of the faces\n   * bounding box, or it's current shift. This function should be used to align the face images\n   * after face detection has been performed, before they are passed to the face recognition net.\n   * This will make the computed face descriptor more accurate.\n   *\n   * @param detection (optional) The bounding box of the face or the face detection result. If\n   * no argument was passed the position of the face landmarks are assumed to be relative to\n   * it's current shift.\n   * @returns The bounding box of the aligned face.\n   */\n  public align(\n    detection?: FaceDetection | IRect | IBoundingBox | null,\n    options: { useDlibAlignment?: boolean, minBoxPadding?: number } = { }\n  ): Box {\n    if (detection) {\n      const box = detection instanceof FaceDetection\n        ? detection.box.floor()\n        : new Box(detection)\n\n      return this.shiftBy(box.x, box.y).align(null, options)\n    }\n\n    const { useDlibAlignment, minBoxPadding } = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options)\n\n    if (useDlibAlignment) {\n      return this.alignDlib()\n    }\n\n    return this.alignMinBbox(minBoxPadding)\n  }\n\n  private alignDlib(): Box {\n\n    const centers = this.getRefPointsForAlignment()\n\n    const [leftEyeCenter, rightEyeCenter, mouthCenter] = centers\n    const distToMouth = (pt: Point) => mouthCenter.sub(pt).magnitude()\n    const eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2\n\n    const size = Math.floor(eyeToMouthDist / relScale)\n\n    const refPoint = getCenterPoint(centers)\n    // TODO: pad in case rectangle is out of image bounds\n    const x = Math.floor(Math.max(0, refPoint.x - (relX * size)))\n    const y = Math.floor(Math.max(0, refPoint.y - (relY * size)))\n\n    return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y))\n  }\n\n  private alignMinBbox(padding: number): Box {\n    const box = minBbox(this.positions)\n    return box.pad(box.width * padding, box.height * padding)\n  }\n\n  protected getRefPointsForAlignment(): Point[] {\n    throw new Error('getRefPointsForAlignment not implemented by base class')\n  }\n}", "import { getCenterPoint } from '../utils';\nimport { FaceLandmarks } from './FaceLandmarks';\nimport { Point } from './Point';\n\n\nexport class FaceLandmarks5 extends FaceLandmarks {\n\n  protected getRefPointsForAlignment(): Point[] {\n    const pts = this.positions\n    return [\n      pts[0],\n      pts[1],\n      getCenterPoint([pts[3], pts[4]])\n    ]\n  }\n}", "import { getCenterPoint } from '../utils';\nimport { FaceLandmarks } from './FaceLandmarks';\nimport { Point } from './Point';\n\nexport class FaceLandmarks68 extends FaceLandmarks {\n  public getJawOutline(): Point[] {\n    return this.positions.slice(0, 17)\n  }\n\n  public getLeftEyeBrow(): Point[] {\n    return this.positions.slice(17, 22)\n  }\n\n  public getRightEyeBrow(): Point[] {\n    return this.positions.slice(22, 27)\n  }\n\n  public getNose(): Point[] {\n    return this.positions.slice(27, 36)\n  }\n\n  public getLeftEye(): Point[] {\n    return this.positions.slice(36, 42)\n  }\n\n  public getRightEye(): Point[] {\n    return this.positions.slice(42, 48)\n  }\n\n  public getMouth(): Point[] {\n    return this.positions.slice(48, 68)\n  }\n\n  protected getRefPointsForAlignment(): Point[] {\n    return [\n      this.getLeftEye(),\n      this.getRightEye(),\n      this.getMouth()\n    ].map(getCenterPoint)\n  }\n}", "import { round } from '../utils';\n\nexport interface IFaceMatch {\n  label: string\n  distance: number\n}\n\nexport class FaceMatch implements IFaceMatch {\n  private _label: string\n  private _distance: number\n\n  constructor(label: string, distance: number) {\n    this._label = label\n    this._distance = distance\n  }\n\n  public get label(): string { return this._label }\n  public get distance(): number { return this._distance }\n\n  public toString(withDistance: boolean = true): string {\n    return `${this.label}${withDistance ? ` (${round(this.distance)})` : ''}`\n  }\n}", "import { isValidNumber } from '../utils';\nimport { IBoundingBox } from './BoundingBox';\nimport { Box } from './Box';\nimport { IRect } from './Rect';\n\nexport class LabeledBox extends Box<LabeledBox> {\n\n  public static assertIsValidLabeledBox(box: any, callee: string) {\n    Box.assertIsValidBox(box, callee)\n\n    if (!isValidNumber(box.label)) {\n      throw new Error(`${callee} - expected property label (${box.label}) to be a number`)\n    }\n  }\n\n  private _label: number\n\n  constructor(box: IBoundingBox | IRect | any, label: number) {\n    super(box)\n    this._label = label\n  }\n\n  public get label(): number { return this._label }\n\n}", "export class LabeledFaceDescriptors {\n  private _label: string\n  private _descriptors: Float32Array[]\n\n  constructor(label: string, descriptors: Float32Array[]) {\n    if (!(typeof label === 'string')) {\n      throw new Error('LabeledFaceDescriptors - constructor expected label to be a string')\n    }\n\n    if (!Array.isArray(descriptors) || descriptors.some(desc => !(desc instanceof Float32Array))) {\n      throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array')\n    }\n\n    this._label = label\n    this._descriptors = descriptors\n  }\n\n  public get label(): string { return this._label }\n  public get descriptors(): Float32Array[] { return this._descriptors }\n\n  public toJSON(): any {\n    return {\n      label: this.label,\n      descriptors: this.descriptors.map((d) => Array.from(d))\n    };\n  }\n\n  public static fromJSON(json: any): LabeledFaceDescriptors {\n    const descriptors = json.descriptors.map((d: any) => {\n      return new Float32Array(d);\n    });\n    return new LabeledFaceDescriptors(json.label, descriptors);\n  }\n\n}", "import { isValidProbablitiy } from '../utils';\nimport { IBoundingBox } from './BoundingBox';\nimport { LabeledBox } from './LabeledBox';\nimport { IRect } from './Rect';\n\nexport class PredictedBox extends LabeledBox {\n\n  public static assertIsValidPredictedBox(box: any, callee: string) {\n    LabeledBox.assertIsValidLabeledBox(box, callee)\n\n    if (\n      !isValidProbablitiy(box.score)\n      || !isValidProbablitiy(box.classScore)\n    ) {\n      throw new Error(`${callee} - expected properties score (${box.score}) and (${box.classScore}) to be a number between [0, 1]`)\n    }\n  }\n\n  private _score: number\n  private _classScore: number\n\n  constructor(box: IBoundingBox | IRect | any, label: number, score: number, classScore: number) {\n    super(box, label)\n    this._score = score\n    this._classScore = classScore\n  }\n\n  public get score(): number { return this._score }\n  public get classScore(): number { return this._classScore }\n\n}", "import { FaceDetection } from '../classes/FaceDetection';\n\nexport type WithFaceDetection<TSource> = TSource & {\n  detection: FaceDetection\n}\n\nexport function isWithFaceDetection(obj: any): obj is WithFaceDetection<{}> {\n  return obj['detection'] instanceof FaceDetection\n}\n\nexport function extendWithFaceDetection<\n  TSource\n> (\n  sourceObj: TSource,\n  detection: FaceDetection\n): WithFaceDetection<TSource> {\n\n  const extension = { detection }\n  return Object.assign({}, sourceObj, extension)\n}\n", "import { Environment } from './types';\n\nexport function createBrowserEnv(): Environment {\n\n  const fetch = window['fetch'] || function() {\n    throw new Error('fetch - missing fetch implementation for browser environment')\n  }\n\n  const readFile = function() {\n    throw new Error('readFile - filesystem not available for browser environment')\n  }\n\n  return {\n    Canvas: HTMLCanvasElement,\n    CanvasRenderingContext2D: CanvasRenderingContext2D,\n    Image: HTMLImageElement,\n    ImageData: ImageData,\n    Video: HTMLVideoElement,\n    createCanvasElement: () => document.createElement('canvas'),\n    createImageElement: () => document.createElement('img'),\n    fetch,\n    readFile\n  }\n}", "import { FileSystem } from './types';\n\nexport function createFileSystem(fs?: any): FileSystem {\n\n  let requireFsError = ''\n\n  if (!fs) {\n    try {\n      fs = require('fs')\n    } catch (err) {\n      requireFsError = err.toString()\n    }\n  }\n\n  const readFile = fs\n    ? function(filePath: string) {\n      return new Promise<Buffer>((res, rej) => {\n        fs.readFile(filePath, function(err: any, buffer: Buffer) {\n          return err ? rej(err) : res(buffer)\n        })\n      })\n    }\n    : function() {\n      throw new Error(`readFile - failed to require fs in nodejs environment with error: ${requireFsError}`)\n    }\n\n  return {\n    readFile\n  }\n}", "import { createFileSystem } from './createFileSystem';\nimport { Environment } from './types';\n\nexport function createNodejsEnv(): Environment {\n\n  const Canvas = global['Canvas'] || global['HTMLCanvasElement']\n  const Image = global['Image'] || global['HTMLImageElement']\n\n  const createCanvasElement = function() {\n    if (Canvas) {\n      return new Canvas()\n    }\n    throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment')\n  }\n\n  const createImageElement = function() {\n    if (Image) {\n      return new Image()\n    }\n    throw new Error('createImageElement - missing Image implementation for nodejs environment')\n  }\n\n  const fetch = global['fetch'] || function() {\n    throw new Error('fetch - missing fetch implementation for nodejs environment')\n  }\n\n  const fileSystem = createFileSystem()\n\n  return {\n    Canvas: Canvas || class {},\n    CanvasRenderingContext2D: global['CanvasRenderingContext2D'] || class {},\n    Image: Image || class {},\n    ImageData: global['ImageData'] || class {},\n    Video: global['HTMLVideoElement'] || class {},\n    createCanvasElement,\n    createImageElement,\n    fetch,\n    ...fileSystem\n  }\n}", "export function isBrowser(): boolean {\n  return typeof window === 'object'\n    && typeof document !== 'undefined'\n    && typeof HTMLImageElement !== 'undefined'\n    && typeof HTMLCanvasElement !== 'undefined'\n    && typeof HTMLVideoElement !== 'undefined'\n    && typeof ImageData !== 'undefined'\n    && typeof CanvasRenderingContext2D !== 'undefined'\n}", "import { createBrowserEnv } from './createBrowserEnv';\nimport { createFileSystem } from './createFileSystem';\nimport { createNodejsEnv } from './createNodejsEnv';\nimport { isBrowser } from './isBrowser';\nimport { isNodejs } from './isNodejs';\nimport { Environment } from './types';\n\nlet environment: Environment | null\n\nfunction getEnv(): Environment {\n  if (!environment) {\n    throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()')\n  }\n  return environment\n}\n\nfunction setEnv(env: Environment) {\n  environment = env\n}\n\nfunction initialize() {\n  // check for isBrowser() first to prevent electron renderer process\n  // to be initialized with wrong environment due to isNodejs() returning true\n  if (isBrowser()) {\n    return setEnv(createBrowserEnv())\n  }\n  if (isNodejs()) {\n    return setEnv(createNodejsEnv())\n  }\n}\n\nfunction monkeyPatch(env: Partial<Environment>) {\n  if (!environment) {\n    initialize()\n  }\n\n  if (!environment) {\n    throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()')\n  }\n\n  const { Canvas = environment.Canvas, Image = environment.Image } = env\n  environment.Canvas = Canvas\n  environment.Image = Image\n  environment.createCanvasElement = env.createCanvasElement || (() => new Canvas())\n  environment.createImageElement = env.createImageElement || (() => new Image())\n\n  environment.ImageData = env.ImageData || environment.ImageData\n  environment.Video = env.Video || environment.Video\n  environment.fetch = env.fetch || environment.fetch\n  environment.readFile = env.readFile || environment.readFile\n}\n\nexport const env = {\n  getEnv,\n  setEnv,\n  initialize,\n  createBrowserEnv,\n  createFileSystem,\n  createNodejsEnv,\n  monkeyPatch,\n  isBrowser,\n  isNodejs\n}\n\ninitialize()\n\nexport * from './types'\n", "import { env } from '../env';\n\nexport function resolveInput(arg: string | any) {\n  if (!env.isNodejs() && typeof arg === 'string') {\n    return document.getElementById(arg)\n  }\n  return arg\n}", "import { env } from '../env';\nimport { resolveInput } from './resolveInput';\n\nexport function getContext2dOrThrow(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D): CanvasRenderingContext2D {\n\n  const { Canvas, CanvasRenderingContext2D } = env.getEnv()\n\n  if (canvasArg instanceof CanvasRenderingContext2D) {\n    return canvasArg\n  }\n\n  const canvas = resolveInput(canvasArg)\n\n  if (!(canvas instanceof Canvas)) {\n    throw new Error('resolveContext2d - expected canvas to be of instance of Canvas')\n  }\n\n  const ctx = canvas.getContext('2d')\n  if (!ctx) {\n    throw new Error('resolveContext2d - canvas 2d context is null')\n  }\n\n  return ctx\n}", "import { IDimensions, IPoint } from '../classes';\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\nimport { resolveInput } from '../dom/resolveInput';\n\nexport enum AnchorPosition {\n  TOP_LEFT = 'TOP_LEFT',\n  TOP_RIGHT = 'TOP_RIGHT',\n  BOTTOM_LEFT = 'BOTTOM_LEFT',\n  BOTTOM_RIGHT = 'BOTTOM_RIGHT'\n}\n\nexport interface IDrawTextFieldOptions {\n  anchorPosition?: AnchorPosition\n  backgroundColor?: string\n  fontColor?: string\n  fontSize?: number\n  fontStyle?: string\n  padding?: number\n}\n\nexport class DrawTextFieldOptions implements IDrawTextFieldOptions {\n  public anchorPosition: AnchorPosition\n  public backgroundColor: string\n  public fontColor: string\n  public fontSize: number\n  public fontStyle: string\n  public padding: number\n\n  constructor(options: IDrawTextFieldOptions = {}) {\n    const { anchorPosition, backgroundColor, fontColor, fontSize, fontStyle, padding } = options\n    this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT\n    this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)'\n    this.fontColor = fontColor || 'rgba(255, 255, 255, 1)'\n    this.fontSize = fontSize || 14\n    this.fontStyle = fontStyle || 'Georgia'\n    this.padding = padding || 4\n  }\n}\n\nexport class DrawTextField {\n  public text: string[]\n  public anchor : IPoint\n  public options: DrawTextFieldOptions\n\n  constructor(\n    text: string | string[] | DrawTextField,\n    anchor: IPoint,\n    options: IDrawTextFieldOptions = {}\n  ) {\n    this.text = typeof text === 'string'\n      ? [text]\n      : (text instanceof DrawTextField ? text.text : text)\n    this.anchor = anchor\n    this.options = new DrawTextFieldOptions(options)\n  }\n\n  measureWidth(ctx: CanvasRenderingContext2D): number {\n    const { padding } = this.options\n    return this.text.map(l => ctx.measureText(l).width).reduce((w0, w1) => w0 < w1 ? w1 : w0, 0) + (2 * padding)\n  }\n\n  measureHeight(): number {\n    const { fontSize, padding } = this.options\n    return this.text.length * fontSize + (2 * padding)\n  }\n\n  getUpperLeft(ctx: CanvasRenderingContext2D, canvasDims?: IDimensions): IPoint {\n    const { anchorPosition } = this.options\n    const isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT\n    const isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT\n\n    const textFieldWidth = this.measureWidth(ctx)\n    const textFieldHeight = this.measureHeight()\n    const x = (isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x)\n    const y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y\n\n    // adjust anchor if text box exceeds canvas borders\n    if (canvasDims) {\n      const { width, height } = canvasDims\n      const newX = Math.max(Math.min(x, width - textFieldWidth), 0)\n      const newY = Math.max(Math.min(y, height - textFieldHeight), 0)\n      return { x: newX, y: newY }\n    }\n    return { x, y }\n  }\n\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\n    const canvas = resolveInput(canvasArg)\n    const ctx = getContext2dOrThrow(canvas)\n\n    const { backgroundColor, fontColor, fontSize, fontStyle, padding } = this.options\n\n    ctx.font = `${fontSize}px ${fontStyle}`\n    const maxTextWidth = this.measureWidth(ctx)\n    const textHeight = this.measureHeight()\n\n    ctx.fillStyle = backgroundColor\n    const upperLeft = this.getUpperLeft(ctx, canvas)\n    ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight)\n\n    ctx.fillStyle = fontColor;\n    this.text.forEach((textLine, i) => {\n      const x = padding + upperLeft.x\n      const y = padding + upperLeft.y + ((i + 1) * fontSize)\n      ctx.fillText(textLine, x, y)\n    })\n  }\n}", "import { Box, IBoundingBox, IRect } from '../classes';\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\nimport { AnchorPosition, DrawTextField, DrawTextFieldOptions, IDrawTextFieldOptions } from './DrawTextField';\n\nexport interface IDrawBoxOptions {\n  boxColor?: string\n  lineWidth?: number\n  drawLabelOptions?: IDrawTextFieldOptions\n  label?: string\n}\n\nexport class DrawBoxOptions {\n  public boxColor: string\n  public lineWidth: number\n  public drawLabelOptions: DrawTextFieldOptions\n  public label?: string\n\n  constructor(options: IDrawBoxOptions = {}) {\n    const { boxColor, lineWidth, label, drawLabelOptions } = options\n    this.boxColor = boxColor || 'rgba(0, 0, 255, 1)'\n    this.lineWidth = lineWidth || 2\n    this.label = label\n\n    const defaultDrawLabelOptions = {\n      anchorPosition: AnchorPosition.BOTTOM_LEFT,\n      backgroundColor: this.boxColor\n    }\n    this.drawLabelOptions = new DrawTextFieldOptions(Object.assign({}, defaultDrawLabelOptions, drawLabelOptions))\n  }\n}\n\nexport class DrawBox {\n  public box: Box\n  public options: DrawBoxOptions\n\n  constructor(\n    box: IBoundingBox | IRect,\n    options: IDrawBoxOptions = {}\n  ) {\n    this.box = new Box(box)\n    this.options = new DrawBoxOptions(options)\n  }\n\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\n    const ctx = getContext2dOrThrow(canvasArg)\n\n    const { boxColor, lineWidth } = this.options\n\n    const { x, y, width, height } = this.box\n    ctx.strokeStyle = boxColor\n    ctx.lineWidth = lineWidth\n    ctx.strokeRect(x, y, width, height)\n\n    const { label } = this.options\n    if (label) {\n      new DrawTextField([label], { x: x - (lineWidth / 2), y }, this.options.drawLabelOptions).draw(canvasArg)\n    }\n  }\n}", "import { Box, IBoundingBox, IRect } from '../classes';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isWithFaceDetection, WithFaceDetection } from '../factories/WithFaceDetection';\nimport { round } from '../utils';\nimport { DrawBox } from './DrawBox';\n\nexport type TDrawDetectionsInput = IRect | IBoundingBox | FaceDetection | WithFaceDetection<{}>\n\nexport function drawDetections(\n  canvasArg: string | HTMLCanvasElement,\n  detections: TDrawDetectionsInput | Array<TDrawDetectionsInput>\n) {\n  const detectionsArray = Array.isArray(detections) ? detections : [detections]\n\n  detectionsArray.forEach(det => {\n    const score = det instanceof FaceDetection\n      ? det.score\n      : (isWithFaceDetection(det) ? det.detection.score : undefined)\n\n    const box = det instanceof FaceDetection\n      ? det.box\n      : (isWithFaceDetection(det) ? det.detection.box : new Box(det))\n\n    const label = score ? `${round(score)}` : undefined\n    new DrawBox(box, { label }).draw(canvasArg)\n  })\n}", "import { env } from '../env';\n\nexport function isMediaLoaded(media: HTMLImageElement | HTMLVideoElement) : boolean {\n\n  const { Image, Video } = env.getEnv()\n\n  return (media instanceof Image && media.complete)\n    || (media instanceof Video && media.readyState >= 3)\n}\n", "import { env } from '../env';\nimport { isMediaLoaded } from './isMediaLoaded';\n\nexport function awaitMediaLoaded(media: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement) {\n\n  return new Promise((resolve, reject) => {\n    if (media instanceof env.getEnv().Canvas || isMediaLoaded(media)) {\n      return resolve(null)\n    }\n\n    function onLoad(e: Event) {\n      if (!e.currentTarget) return\n      e.currentTarget.removeEventListener('load', onLoad)\n      e.currentTarget.removeEventListener('error', onError)\n      resolve(e)\n    }\n\n    function onError(e: Event) {\n      if (!e.currentTarget) return\n      e.currentTarget.removeEventListener('load', onLoad)\n      e.currentTarget.removeEventListener('error', onError)\n      reject(e)\n    }\n\n    media.addEventListener('load', onLoad)\n    media.addEventListener('error', onError)\n  })\n}", "import { env } from '../env';\n\nexport function bufferToImage(buf: Blob): Promise<HTMLImageElement> {\n  return new Promise((resolve, reject) => {\n    if (!(buf instanceof Blob)) {\n      return reject('bufferToImage - expected buf to be of type: Blob')\n    }\n\n    const reader = new FileReader()\n    reader.onload = () => {\n      if (typeof reader.result !== 'string') {\n        return reject('bufferToImage - expected reader.result to be a string, in onload')\n      }\n\n      const img = env.getEnv().createImageElement()\n      img.onload = () => resolve(img)\n      img.onerror = reject\n      img.src = reader.result\n    }\n    reader.onerror = reject\n    reader.readAsDataURL(buf)\n  })\n}", "import { Dimensions, IDimensions } from '../classes/Dimensions';\nimport { env } from '../env';\n\nexport function getMediaDimensions(input: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | IDimensions): Dimensions {\n\n  const { Image, Video } = env.getEnv()\n\n  if (input instanceof Image) {\n    return new Dimensions(input.naturalWidth, input.naturalHeight)\n  }\n  if (input instanceof Video) {\n    return new Dimensions(input.videoWidth, input.videoHeight)\n  }\n  return new Dimensions(input.width, input.height)\n}\n", "import { IDimensions } from '../classes/Dimensions';\nimport { env } from '../env';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { getMediaDimensions } from './getMediaDimensions';\nimport { isMediaLoaded } from './isMediaLoaded';\n\nexport function createCanvas({ width, height }: IDimensions): HTMLCanvasElement {\n\n  const { createCanvasElement } = env.getEnv()\n  const canvas = createCanvasElement()\n  canvas.width = width\n  canvas.height = height\n  return canvas\n}\n\nexport function createCanvasFromMedia(media: HTMLImageElement | HTMLVideoElement | ImageData, dims?: IDimensions): HTMLCanvasElement {\n\n  const { ImageData } = env.getEnv()\n\n  if (!(media instanceof ImageData) && !isMediaLoaded(media)) {\n    throw new Error('createCanvasFromMedia - media has not finished loading yet')\n  }\n\n  const { width, height } = dims || getMediaDimensions(media)\n  const canvas = createCanvas({ width, height })\n\n  if (media instanceof ImageData) {\n    getContext2dOrThrow(canvas).putImageData(media, 0, 0)\n  } else {\n    getContext2dOrThrow(canvas).drawImage(media, 0, 0, width, height)\n  }\n  return canvas\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { env } from '../env';\nimport { isTensor4D } from '../utils';\n\nexport async function imageTensorToCanvas(\n  imgTensor: tf.Tensor,\n  canvas?: HTMLCanvasElement\n): Promise<HTMLCanvasElement> {\n\n  const targetCanvas = canvas || env.getEnv().createCanvasElement()\n\n  const [height, width, numChannels] = imgTensor.shape.slice(isTensor4D(imgTensor) ? 1 : 0)\n  const imgTensor3D = tf.tidy(() => imgTensor.as3D(height, width, numChannels).toInt())\n  await tf.browser.toPixels(imgTensor3D, targetCanvas)\n\n  imgTensor3D.dispose()\n\n  return targetCanvas\n}", "import { env } from '../env';\n\nexport function isMediaElement(input: any) {\n\n  const { Image, Canvas, Video } = env.getEnv()\n\n  return input instanceof Image\n    || input instanceof Canvas\n    || input instanceof Video\n}", "import { env } from '../env';\nimport { createCanvas, createCanvasFromMedia } from './createCanvas';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { getMediaDimensions } from './getMediaDimensions';\n\nexport function imageToSquare(input: HTMLImageElement | HTMLCanvasElement, inputSize: number, centerImage: boolean = false) {\n\n  const { Image, Canvas } = env.getEnv()\n\n  if (!(input instanceof Image || input instanceof Canvas)) {\n    throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement')\n  }\n\n  const dims = getMediaDimensions(input)\n  const scale = inputSize / Math.max(dims.height, dims.width)\n  const width = scale * dims.width\n  const height = scale * dims.height\n\n  const targetCanvas = createCanvas({ width: inputSize, height: inputSize })\n  const inputCanvas = input instanceof Canvas ? input : createCanvasFromMedia(input)\n\n  const offset = Math.abs(width - height) / 2\n  const dx = centerImage && width < height ? offset : 0\n  const dy = centerImage && height < width ? offset : 0\n  getContext2dOrThrow(targetCanvas).drawImage(inputCanvas, dx, dy, width, height)\n\n  return targetCanvas\n}", "import * as tf from '@tensorflow/tfjs-core';\n\nimport { Dimensions } from '../classes/Dimensions';\nimport { env } from '../env';\nimport { padToSquare } from '../ops/padToSquare';\nimport { computeReshapedDimensions, isTensor3D, isTensor4D, range } from '../utils';\nimport { createCanvasFromMedia } from './createCanvas';\nimport { imageToSquare } from './imageToSquare';\nimport { TResolvedNetInput } from './types';\n\nexport class NetInput {\n  private _imageTensors: Array<tf.Tensor3D | tf.Tensor4D> = []\n  private _canvases: HTMLCanvasElement[] = []\n  private _batchSize: number\n  private _treatAsBatchInput: boolean = false\n\n  private _inputDimensions: number[][] = []\n  private _inputSize: number\n\n  constructor(\n    inputs: Array<TResolvedNetInput>,\n    treatAsBatchInput: boolean = false\n  ) {\n    if (!Array.isArray(inputs)) {\n      throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${inputs}`)\n    }\n\n    this._treatAsBatchInput = treatAsBatchInput\n    this._batchSize = inputs.length\n\n    inputs.forEach((input, idx) => {\n\n      if (isTensor3D(input)) {\n        this._imageTensors[idx] = input\n        this._inputDimensions[idx] = input.shape\n        return\n      }\n\n      if (isTensor4D(input)) {\n        const batchSize = (input as any).shape[0]\n        if (batchSize !== 1) {\n          throw new Error(`NetInput - tf.Tensor4D with batchSize ${batchSize} passed, but not supported in input array`)\n        }\n\n        this._imageTensors[idx] = input\n        this._inputDimensions[idx] = (input as any).shape.slice(1)\n        return\n      }\n\n      const canvas = (input as any) instanceof env.getEnv().Canvas ? input : createCanvasFromMedia(input)\n      this._canvases[idx] = canvas\n      this._inputDimensions[idx] = [canvas.height, canvas.width, 3]\n    })\n  }\n\n  public get imageTensors(): Array<tf.Tensor3D | tf.Tensor4D> {\n    return this._imageTensors\n  }\n\n  public get canvases(): HTMLCanvasElement[] {\n    return this._canvases\n  }\n\n  public get isBatchInput(): boolean {\n    return this.batchSize > 1 || this._treatAsBatchInput\n  }\n\n  public get batchSize(): number {\n    return this._batchSize\n  }\n\n  public get inputDimensions(): number[][] {\n    return this._inputDimensions\n  }\n\n  public get inputSize(): number | undefined {\n    return this._inputSize\n  }\n\n  public get reshapedInputDimensions(): Dimensions[] {\n    return range(this.batchSize, 0, 1).map(\n      (_, batchIdx) => this.getReshapedInputDimensions(batchIdx)\n    )\n  }\n\n  public getInput(batchIdx: number): tf.Tensor3D  | tf.Tensor4D | HTMLCanvasElement {\n    return this.canvases[batchIdx] || this.imageTensors[batchIdx]\n  }\n\n  public getInputDimensions(batchIdx: number): number[] {\n    return this._inputDimensions[batchIdx]\n  }\n\n  public getInputHeight(batchIdx: number): number {\n    return this._inputDimensions[batchIdx][0]\n  }\n\n  public getInputWidth(batchIdx: number): number {\n    return this._inputDimensions[batchIdx][1]\n  }\n\n  public getReshapedInputDimensions(batchIdx: number): Dimensions {\n    if (typeof this.inputSize !== 'number') {\n      throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet')\n    }\n\n    const width = this.getInputWidth(batchIdx)\n    const height = this.getInputHeight(batchIdx)\n    return computeReshapedDimensions({ width, height }, this.inputSize)\n  }\n\n  /**\n   * Create a batch tensor from all input canvases and tensors\n   * with size [batchSize, inputSize, inputSize, 3].\n   *\n   * @param inputSize Height and width of the tensor.\n   * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\n   * both sides of the minor dimension oof the image.\n   * @returns The batch tensor.\n   */\n  public toBatchTensor(inputSize: number, isCenterInputs: boolean = true): tf.Tensor4D {\n\n    this._inputSize = inputSize\n\n    return tf.tidy(() => {\n\n      const inputTensors = range(this.batchSize, 0, 1).map(batchIdx => {\n        const input = this.getInput(batchIdx)\n\n        if (input instanceof tf.Tensor) {\n          // @ts-ignore: error TS2344: Type 'Rank.R4' does not satisfy the constraint 'Tensor<Rank>'.\n          let imgTensor = isTensor4D(input) ? input : input.expandDims<tf.Rank.R4>()\n          // @ts-ignore: error TS2344: Type 'Rank.R4' does not satisfy the constraint 'Tensor<Rank>'.\n          imgTensor = padToSquare(imgTensor, isCenterInputs)\n\n          if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\n            imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize])\n          }\n\n          return imgTensor.as3D(inputSize, inputSize, 3)\n        }\n\n        if (input instanceof env.getEnv().Canvas) {\n          return tf.browser.fromPixels(imageToSquare(input, inputSize, isCenterInputs))\n        }\n\n        throw new Error(`toBatchTensor - at batchIdx ${batchIdx}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${input}`)\n      })\n\n      // const batchTensor = tf.stack(inputTensors.map(t => t.toFloat())).as4D(this.batchSize, inputSize, inputSize, 3)\n      const batchTensor = tf.stack(inputTensors.map(t => tf.cast(t, 'float32'))).as4D(this.batchSize, inputSize, inputSize, 3)\n      // const batchTensor = tf.stack(inputTensors.map(t => tf.Tensor.as4D(tf.cast(t, 'float32'))), this.batchSize, inputSize, inputSize, 3);\n      \n      return batchTensor\n    })\n  }\n}", "import { isTensor3D, isTensor4D } from '../utils';\nimport { awaitMediaLoaded } from './awaitMediaLoaded';\nimport { isMediaElement } from './isMediaElement';\nimport { NetInput } from './NetInput';\nimport { resolveInput } from './resolveInput';\nimport { TNetInput } from './types';\n\n/**\n * Validates the input to make sure, they are valid net inputs and awaits all media elements\n * to be finished loading.\n *\n * @param input The input, which can be a media element or an array of different media elements.\n * @returns A NetInput instance, which can be passed into one of the neural networks.\n */\nexport async function toNetInput(inputs: TNetInput): Promise<NetInput> {\n  if (inputs instanceof NetInput) {\n    return inputs\n  }\n\n  let inputArgArray = Array.isArray(inputs)\n      ? inputs\n      : [inputs]\n\n  if (!inputArgArray.length) {\n    throw new Error('toNetInput - empty array passed as input')\n  }\n\n  const getIdxHint = (idx: number) => Array.isArray(inputs) ? ` at input index ${idx}:` : ''\n\n  const inputArray = inputArgArray.map(resolveInput)\n\n  inputArray.forEach((input, i) => {\n    if (!isMediaElement(input) && !isTensor3D(input) && !isTensor4D(input)) {\n\n      if (typeof inputArgArray[i] === 'string') {\n        throw new Error(`toNetInput -${getIdxHint(i)} string passed, but could not resolve HTMLElement for element id ${inputArgArray[i]}`)\n      }\n\n      throw new Error(`toNetInput -${getIdxHint(i)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`)\n    }\n\n    if (isTensor4D(input)) {\n      // if tf.Tensor4D is passed in the input array, the batch size has to be 1\n      const batchSize = input.shape[0]\n      if (batchSize !== 1) {\n        throw new Error(`toNetInput -${getIdxHint(i)} tf.Tensor4D with batchSize ${batchSize} passed, but not supported in input array`)\n      }\n    }\n  })\n\n  // wait for all media elements being loaded\n  await Promise.all(\n    inputArray.map(input => isMediaElement(input) && awaitMediaLoaded(input))\n  )\n\n  return new NetInput(inputArray, Array.isArray(inputs))\n}", "import { FaceDetection } from '../classes/FaceDetection';\nimport { Rect } from '../classes/Rect';\nimport { env } from '../env';\nimport { createCanvas } from './createCanvas';\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\nimport { imageTensorToCanvas } from './imageTensorToCanvas';\nimport { toNetInput } from './toNetInput';\nimport { TNetInput } from './types';\n\n/**\n * Extracts the image regions containing the detected faces.\n *\n * @param input The image that face detection has been performed on.\n * @param detections The face detection results or face bounding boxes for that image.\n * @returns The Canvases of the corresponding image region for each detected face.\n */\nexport async function extractFaces(\n  input: TNetInput,\n  detections: Array<FaceDetection | Rect>\n): Promise<HTMLCanvasElement[]> {\n\n  const { Canvas } = env.getEnv()\n\n  let canvas = input as HTMLCanvasElement\n\n  if (!(input instanceof Canvas)) {\n    const netInput = await toNetInput(input)\n\n    if (netInput.batchSize > 1) {\n      throw new Error('extractFaces - batchSize > 1 not supported')\n    }\n\n    const tensorOrCanvas = netInput.getInput(0)\n    canvas = tensorOrCanvas instanceof Canvas\n      ? tensorOrCanvas\n      : await imageTensorToCanvas(tensorOrCanvas)\n  }\n\n  const ctx = getContext2dOrThrow(canvas)\n  const boxes = detections.map(\n    det => det instanceof FaceDetection\n      ? det.forSize(canvas.width, canvas.height).box.floor()\n      : det\n  )\n    .map(box => box.clipAtImageBorders(canvas.width, canvas.height))\n\n  return boxes.map(({ x, y, width, height }) => {\n    const faceImg = createCanvas({ width, height })\n    getContext2dOrThrow(faceImg)\n      .putImageData(ctx.getImageData(x, y, width, height), 0, 0)\n    return faceImg\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { Rect } from '../classes';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { isTensor3D, isTensor4D } from '../utils';\n\n/**\n * Extracts the tensors of the image regions containing the detected faces.\n * Useful if you want to compute the face descriptors for the face images.\n * Using this method is faster then extracting a canvas for each face and\n * converting them to tensors individually.\n *\n * @param imageTensor The image tensor that face detection has been performed on.\n * @param detections The face detection results or face bounding boxes for that image.\n * @returns Tensors of the corresponding image region for each detected face.\n */\nexport async function extractFaceTensors(\n  imageTensor: tf.Tensor3D | tf.Tensor4D,\n  detections: Array<FaceDetection | Rect>\n): Promise<tf.Tensor3D[]> {\n\n  if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\n    throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D')\n  }\n\n  if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\n    throw new Error('extractFaceTensors - batchSize > 1 not supported')\n  }\n\n  return tf.tidy(() => {\n    const [imgHeight, imgWidth, numChannels] = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0)\n\n    const boxes = detections.map(\n      det => det instanceof FaceDetection\n        ? det.forSize(imgWidth, imgHeight).box\n        : det\n    )\n      .map(box => box.clipAtImageBorders(imgWidth, imgHeight))\n\n    const faceTensors = boxes.map(({ x, y, width, height }) =>\n      tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels])\n    )\n\n    return faceTensors\n  })\n}", "import { env } from '../env';\n\nexport async function fetchOrThrow(\n  url: string,\n  init?: RequestInit\n): Promise<Response> {\n\n  const fetch = env.getEnv().fetch\n  const res = await fetch(url, init)\n  if (!(res.status < 400)) {\n    throw new Error(`failed to fetch: (${res.status}) ${res.statusText}, from url: ${res.url}`)\n  }\n  return res\n}", "import { bufferToImage } from './bufferToImage';\nimport { fetchOrThrow } from './fetchOrThrow';\n\nexport async function fetchImage(uri: string): Promise<HTMLImageElement> {\n  const res = await fetchOrThrow(uri)\n  const blob = await (res).blob()\n\n  if (!blob.type.startsWith('image/')) {\n    throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${blob.type}, for url: ${res.url}`)\n  }\n  return bufferToImage(blob)\n}\n", "import { fetchOrThrow } from './fetchOrThrow';\n\nexport async function fetchJson<T>(uri: string): Promise<T> {\n  return (await fetchOrThrow(uri)).json()\n}\n", "import { fetchOrThrow } from './fetchOrThrow';\n\nexport async function fetchNetWeights(uri: string): Promise<Float32Array> {\n  return new Float32Array(await (await fetchOrThrow(uri)).arrayBuffer())\n}\n", "export function getModelUris(uri: string | undefined, defaultModelName: string) {\n  const defaultManifestFilename = `${defaultModelName}-weights_manifest.json`\n\n  if (!uri) {\n    return {\n      modelBaseUri: '',\n      manifestUri: defaultManifestFilename\n    }\n  }\n\n  if (uri === '/') {\n    return {\n      modelBaseUri: '/',\n      manifestUri: `/${defaultManifestFilename}`\n    }\n  }\n  const protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';\n  uri = uri.replace(protocol, '');\n\n  const parts = uri.split('/').filter(s => s)\n\n  const manifestFile = uri.endsWith('.json')\n    ? parts[parts.length - 1]\n    : defaultManifestFilename\n\n  let modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/')\n  modelBaseUri = uri.startsWith('/') ? `/${modelBaseUri}` : modelBaseUri\n\n  return {\n    modelBaseUri,\n    manifestUri: modelBaseUri === '/' ? `/${manifestFile}` : `${modelBaseUri}/${manifestFile}`\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { getModelUris } from '../common/getModelUris';\nimport { fetchJson } from './fetchJson';\n\nexport async function loadWeightMap(\n  uri: string | undefined,\n  defaultModelName: string,\n): Promise<tf.NamedTensorMap> {\n  const { manifestUri, modelBaseUri } = getModelUris(uri, defaultModelName)\n  let manifest = await fetchJson<tf.io.WeightsManifestConfig>(manifestUri)\n  // if (manifest['weightsManifest']) manifest = manifest['weightsManifest'];\n  return tf.io.loadWeights(manifest, modelBaseUri)\n}", "import { IDimensions } from '../classes';\nimport { getMediaDimensions } from './getMediaDimensions';\n\nexport function matchDimensions(input: IDimensions, reference: IDimensions, useMediaDimensions: boolean = false) {\n  const { width, height } = useMediaDimensions\n    ? getMediaDimensions(reference)\n    : reference\n  input.width = width\n  input.height = height\n  return { width, height }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ParamMapping } from './common';\nimport { getModelUris } from './common/getModelUris';\nimport { loadWeightMap } from './dom';\nimport { env } from './env';\n\nexport abstract class NeuralNetwork<TNetParams> {\n\n  protected _params: TNetParams | undefined = undefined\n  protected _paramMappings: ParamMapping[] = []\n\n  constructor(protected _name: string) {\n    /*\n    try {\n      const testTensor = tf.tensor([0]);\n      testTensor.toFloat();\n    } catch (err) {\n      throw new Error(`tfjs module not loaded: load '@tensorflow/tfjs' or '@tensorflow/tfjs-core' with appropriate backend explicitly`);\n    }\n    */\n  }\n\n  public get params(): TNetParams | undefined { return this._params }\n  public get paramMappings(): ParamMapping[] { return this._paramMappings }\n  public get isLoaded(): boolean { return !!this.params }\n\n  public getParamFromPath(paramPath: string): tf.Tensor {\n    const { obj, objProp } = this.traversePropertyPath(paramPath)\n    return obj[objProp]\n  }\n\n  public reassignParamFromPath(paramPath: string, tensor: tf.Tensor) {\n    const { obj, objProp } = this.traversePropertyPath(paramPath)\n    obj[objProp].dispose()\n    obj[objProp] = tensor\n  }\n\n  public getParamList() {\n    return this._paramMappings.map(({ paramPath }) => ({\n      path: paramPath,\n      tensor: this.getParamFromPath(paramPath)\n    }))\n  }\n\n  public getTrainableParams() {\n    return this.getParamList().filter(param => param.tensor instanceof tf.Variable)\n  }\n\n  public getFrozenParams() {\n    return this.getParamList().filter(param => !(param.tensor instanceof tf.Variable))\n  }\n\n  public variable() {\n    this.getFrozenParams().forEach(({ path, tensor }) => {\n      this.reassignParamFromPath(path, tensor.variable())\n    })\n  }\n\n  public freeze() {\n    this.getTrainableParams().forEach(({ path, tensor: variable }) => {\n      const tensor = tf.tensor(variable.dataSync())\n      variable.dispose()\n      this.reassignParamFromPath(path, tensor)\n    })\n  }\n\n  public dispose(throwOnRedispose: boolean = true) {\n    this.getParamList().forEach(param => {\n      if (throwOnRedispose && param.tensor.isDisposed) {\n        throw new Error(`param tensor has already been disposed for path ${param.path}`)\n      }\n      param.tensor.dispose()\n    })\n    this._params = undefined\n  }\n\n  public serializeParams(): Float32Array {\n    return new Float32Array(\n      this.getParamList()\n        .map(({ tensor }) => Array.from(tensor.dataSync()) as number[])\n        .reduce((flat, arr) => flat.concat(arr))\n    )\n  }\n\n  public async load(weightsOrUrl: Float32Array | string | undefined): Promise<void> {\n    if (weightsOrUrl instanceof Float32Array) {\n      this.extractWeights(weightsOrUrl)\n      return\n    }\n\n    await this.loadFromUri(weightsOrUrl)\n  }\n\n  public async loadFromUri(uri: string | undefined) {\n    if (uri && typeof uri !== 'string') {\n      throw new Error(`${this._name}.loadFromUri - expected model uri`)\n    }\n\n    const weightMap = await loadWeightMap(uri, this.getDefaultModelName())\n    this.loadFromWeightMap(weightMap)\n  }\n\n  public async loadFromDisk(filePath: string | undefined) {\n    if (filePath && typeof filePath !== 'string') {\n      throw new Error(`${this._name}.loadFromDisk - expected model file path`)\n    }\n\n    const { readFile } = env.getEnv()\n\n    const { manifestUri, modelBaseUri } = getModelUris(filePath, this.getDefaultModelName())\n\n    const fetchWeightsFromDisk = (filePaths: string[]) => Promise.all(\n      filePaths.map(filePath => readFile(filePath).then(buf => buf.buffer))\n    )\n    const loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk)\n    const manifest = JSON.parse((await readFile(manifestUri)).toString())\n    const weightMap = await loadWeights(manifest, modelBaseUri)\n\n    this.loadFromWeightMap(weightMap)\n  }\n\n  public loadFromWeightMap(weightMap: tf.NamedTensorMap) {\n    const {\n      paramMappings,\n      params\n    } = this.extractParamsFromWeigthMap(weightMap)\n\n    this._paramMappings = paramMappings\n    this._params = params\n  }\n\n  public extractWeights(weights: Float32Array) {\n    const {\n      paramMappings,\n      params\n    } = this.extractParams(weights)\n\n    this._paramMappings = paramMappings\n    this._params = params\n  }\n\n  private traversePropertyPath(paramPath: string) {\n    if (!this.params) {\n      throw new Error(`traversePropertyPath - model has no loaded params`)\n    }\n\n    const result = paramPath.split('/').reduce((res: { nextObj: any, obj?: any, objProp?: string }, objProp) => {\n      if (!res.nextObj.hasOwnProperty(objProp)) {\n        throw new Error(`traversePropertyPath - object does not have property ${objProp}, for path ${paramPath}`)\n      }\n\n      return { obj: res.nextObj, objProp, nextObj: res.nextObj[objProp] }\n    }, { nextObj: this.params })\n\n    const { obj, objProp } = result\n    if (!obj || !objProp || !(obj[objProp] instanceof tf.Tensor)) {\n      throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${paramPath}`)\n    }\n\n    return { obj, objProp }\n  }\n\n  protected abstract getDefaultModelName(): string\n  protected abstract extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap): { params: TNetParams, paramMappings: ParamMapping[] }\n  protected abstract extractParams(weights: Float32Array): { params: TNetParams, paramMappings: ParamMapping[] }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { SeparableConvParams } from './types';\n\nexport function depthwiseSeparableConv(\n  x: tf.Tensor4D,\n  params: SeparableConvParams,\n  stride: [number, number]\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    let out = tf.separableConv2d(x, params.depthwise_filter, params.pointwise_filter, stride, 'same')\n    out = tf.add(out, params.bias)\n    return out\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams, SeparableConvParams } from '../common';\nimport { depthwiseSeparableConv } from '../common/depthwiseSeparableConv';\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\n\nexport function denseBlock3(\n  x: tf.Tensor4D,\n  denseBlockParams: DenseBlock3Params,\n  isFirstLayer: boolean = false\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const out1 = tf.relu(\n      isFirstLayer\n        ? tf.add(\n          tf.conv2d(x, (denseBlockParams.conv0 as ConvParams).filters, [2, 2], 'same'),\n          denseBlockParams.conv0.bias\n        )\n        : depthwiseSeparableConv(x, denseBlockParams.conv0 as SeparableConvParams, [2, 2])\n    ) as tf.Tensor4D\n    const out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1])\n\n    const in3 = tf.relu(tf.add(out1, out2)) as tf.Tensor4D\n    const out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1])\n\n    return tf.relu(tf.add(out1, tf.add(out2, out3))) as tf.Tensor4D\n  })\n}\n\nexport function denseBlock4(\n  x: tf.Tensor4D,\n  denseBlockParams: DenseBlock4Params,\n  isFirstLayer: boolean = false,\n  isScaleDown: boolean = true\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const out1 = tf.relu(\n      isFirstLayer\n        ? tf.add(\n          tf.conv2d(x, (denseBlockParams.conv0 as ConvParams).filters, isScaleDown ? [2, 2] : [1, 1], 'same'),\n          denseBlockParams.conv0.bias\n        )\n        : depthwiseSeparableConv(x, denseBlockParams.conv0 as SeparableConvParams, isScaleDown ? [2, 2] : [1, 1])\n    ) as tf.Tensor4D\n    const out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1])\n\n    const in3 = tf.relu(tf.add(out1, out2)) as tf.Tensor4D\n    const out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1])\n\n    const in4 = tf.relu(tf.add(out1, tf.add(out2, out3))) as tf.Tensor4D\n    const out4 = depthwiseSeparableConv(in4, denseBlockParams.conv3, [1, 1])\n\n    return tf.relu(tf.add(out1, tf.add(out2, tf.add(out3, out4)))) as tf.Tensor4D\n  })\n}\n", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams } from './types';\n\nexport function convLayer(\n  x: tf.Tensor4D,\n  params: ConvParams,\n  padding: 'valid' | 'same' = 'same',\n  withRelu: boolean = false\n): tf.Tensor4D {\n  return tf.tidy(() => {\n    const out = tf.add(\n      tf.conv2d(x, params.filters, [1, 1], padding),\n      params.bias\n    ) as tf.Tensor4D\n\n    return withRelu ? tf.relu(out) : out\n  })\n}", "import { ParamMapping } from './types';\n\nexport function disposeUnusedWeightTensors(weightMap: any, paramMappings: ParamMapping[]) {\n  Object.keys(weightMap).forEach(path => {\n    if (!paramMappings.some(pm => pm.originalPath === path)) {\n      weightMap[path].dispose()\n    }\n  })\n}\n", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams, ExtractWeightsFunction, ParamMapping } from './types';\n\nexport function extractConvParamsFactory(\n  extractWeights: ExtractWeightsFunction,\n  paramMappings: ParamMapping[]\n) {\n\n  return function(\n    channelsIn: number,\n    channelsOut: number,\n    filterSize: number,\n    mappedPrefix: string\n  ): ConvParams {\n\n    const filters = tf.tensor4d(\n      extractWeights(channelsIn * channelsOut * filterSize * filterSize),\n      [filterSize, filterSize, channelsIn, channelsOut]\n    )\n    const bias = tf.tensor1d(extractWeights(channelsOut))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/bias` }\n    )\n\n    return { filters, bias }\n  }\n\n}\n", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ExtractWeightsFunction, FCParams, ParamMapping } from './types';\n\n\nexport function extractFCParamsFactory(\n  extractWeights: ExtractWeightsFunction,\n  paramMappings: ParamMapping[]\n) {\n\n  return function(\n    channelsIn: number,\n    channelsOut: number,\n    mappedPrefix: string\n  ): FCParams {\n\n    const fc_weights = tf.tensor2d(extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut])\n    const fc_bias = tf.tensor1d(extractWeights(channelsOut))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/weights` },\n      { paramPath: `${mappedPrefix}/bias` }\n    )\n\n    return {\n      weights: fc_weights,\n      bias: fc_bias\n    }\n  }\n\n}\n", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nexport type ExtractWeightsFunction = (numWeights: number) => Float32Array\n\nexport type ParamMapping = {\n  originalPath?: string\n  paramPath: string\n}\n\nexport type ConvParams = {\n  filters: tf.Tensor4D\n  bias: tf.Tensor1D\n}\n\nexport type FCParams = {\n  weights: tf.Tensor2D\n  bias: tf.Tensor1D\n}\n\nexport class SeparableConvParams {\n  constructor(\n    public depthwise_filter: tf.Tensor4D,\n    public pointwise_filter: tf.Tensor4D,\n    public bias: tf.Tensor1D\n  ) {}\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ExtractWeightsFunction, ParamMapping, SeparableConvParams } from './types';\n\nexport function extractSeparableConvParamsFactory(\n  extractWeights: ExtractWeightsFunction,\n  paramMappings: ParamMapping[]\n) {\n\n  return function(channelsIn: number, channelsOut: number, mappedPrefix: string): SeparableConvParams {\n    const depthwise_filter = tf.tensor4d(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1])\n    const pointwise_filter = tf.tensor4d(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut])\n    const bias = tf.tensor1d(extractWeights(channelsOut))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/depthwise_filter` },\n      { paramPath: `${mappedPrefix}/pointwise_filter` },\n      { paramPath: `${mappedPrefix}/bias` }\n    )\n\n    return new SeparableConvParams(\n      depthwise_filter,\n      pointwise_filter,\n      bias\n    )\n  }\n\n}\n\nexport function loadSeparableConvParamsFactory(\n  extractWeightEntry: <T>(originalPath: string, paramRank: number) => T\n) {\n\n  return function (prefix: string): SeparableConvParams {\n    const depthwise_filter = extractWeightEntry<tf.Tensor4D>(`${prefix}/depthwise_filter`, 4)\n    const pointwise_filter = extractWeightEntry<tf.Tensor4D>(`${prefix}/pointwise_filter`, 4)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1)\n\n    return new SeparableConvParams(\n      depthwise_filter,\n      pointwise_filter,\n      bias\n    )\n  }\n\n}\n", "import { isTensor } from '../utils';\nimport { ParamMapping } from './types';\n\nexport function extractWeightEntryFactory(weightMap: any, paramMappings: ParamMapping[]) {\n\n  return function<T> (originalPath: string, paramRank: number, mappedPath?: string): T {\n    const tensor = weightMap[originalPath]\n\n    if (!isTensor(tensor, paramRank)) {\n      throw new Error(`expected weightMap[${originalPath}] to be a Tensor${paramRank}D, instead have ${tensor}`)\n    }\n\n    paramMappings.push(\n      { originalPath, paramPath: mappedPath || originalPath }\n    )\n\n    return tensor\n  }\n\n}\n", "export function extractWeightsFactory(weights: Float32Array) {\n  let remainingWeights = weights\n\n  function extractWeights(numWeights: number): Float32Array {\n    const ret = remainingWeights.slice(0, numWeights)\n    remainingWeights = remainingWeights.slice(numWeights)\n    return ret\n  }\n\n  function getRemainingWeights(): Float32Array {\n    return remainingWeights\n  }\n\n  return {\n    extractWeights,\n    getRemainingWeights\n  }\n}", "import {\n  extractConvParamsFactory,\n  extractSeparableConvParamsFactory,\n  ExtractWeightsFunction,\n  ParamMapping,\n} from '../common';\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\n\nexport function extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings)\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings)\n\n  function extractDenseBlock3Params(channelsIn: number, channelsOut: number, mappedPrefix: string, isFirstLayer: boolean = false): DenseBlock3Params {\n\n    const conv0 = isFirstLayer\n      ? extractConvParams(channelsIn, channelsOut, 3, `${mappedPrefix}/conv0`)\n      : extractSeparableConvParams(channelsIn, channelsOut, `${mappedPrefix}/conv0`)\n    const conv1 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv1`)\n    const conv2 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv2`)\n\n    return { conv0, conv1, conv2 }\n  }\n\n  function extractDenseBlock4Params(channelsIn: number, channelsOut: number, mappedPrefix: string, isFirstLayer: boolean = false): DenseBlock4Params {\n\n    const { conv0, conv1, conv2 } = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer)\n    const conv3 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv3`)\n\n    return { conv0, conv1, conv2, conv3 }\n  }\n\n  return {\n    extractDenseBlock3Params,\n    extractDenseBlock4Params\n  }\n\n}", "import { extractWeightsFactory, ParamMapping } from '../common';\nimport { extractorsFactory } from './extractorsFactory';\nimport { FaceFeatureExtractorParams } from './types';\n\n\nexport function extractParams(weights: Float32Array): { params: FaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const {\n    extractDenseBlock4Params\n  } = extractorsFactory(extractWeights, paramMappings)\n\n  const dense0 = extractDenseBlock4Params(3, 32, 'dense0', true)\n  const dense1 = extractDenseBlock4Params(32, 64, 'dense1')\n  const dense2 = extractDenseBlock4Params(64, 128, 'dense2')\n  const dense3 = extractDenseBlock4Params(128, 256, 'dense3')\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  return {\n    paramMappings,\n    params: { dense0, dense1, dense2, dense3 }\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams } from './types';\n\nexport function loadConvParamsFactory(extractWeightEntry: <T>(originalPath: string, paramRank: number) => T) {\n  return function(prefix: string): ConvParams {\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/filters`, 4)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1)\n\n    return { filters, bias }\n  }\n}", "import { extractWeightEntryFactory, loadSeparableConvParamsFactory, ParamMapping } from '../common';\nimport { loadConvParamsFactory } from '../common/loadConvParamsFactory';\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\n\nexport function loadParamsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  const extractConvParams = loadConvParamsFactory(extractWeightEntry)\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry)\n\n  function extractDenseBlock3Params(prefix: string, isFirstLayer: boolean = false): DenseBlock3Params {\n    const conv0 = isFirstLayer\n      ? extractConvParams(`${prefix}/conv0`)\n      : extractSeparableConvParams(`${prefix}/conv0`)\n    const conv1 = extractSeparableConvParams(`${prefix}/conv1`)\n    const conv2 = extractSeparableConvParams(`${prefix}/conv2`)\n\n    return { conv0, conv1, conv2 }\n  }\n\n  function extractDenseBlock4Params(prefix: string, isFirstLayer: boolean = false): DenseBlock4Params {\n    const conv0 = isFirstLayer\n      ? extractConvParams(`${prefix}/conv0`)\n      : extractSeparableConvParams(`${prefix}/conv0`)\n    const conv1 = extractSeparableConvParams(`${prefix}/conv1`)\n    const conv2 = extractSeparableConvParams(`${prefix}/conv2`)\n    const conv3 = extractSeparableConvParams(`${prefix}/conv3`)\n\n    return { conv0, conv1, conv2, conv3 }\n  }\n\n  return {\n    extractDenseBlock3Params,\n    extractDenseBlock4Params\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { disposeUnusedWeightTensors, ParamMapping } from '../common';\nimport { loadParamsFactory } from './loadParamsFactory';\nimport { FaceFeatureExtractorParams } from './types';\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap\n): { params: FaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractDenseBlock4Params\n  } = loadParamsFactory(weightMap, paramMappings)\n\n  const params = {\n    dense0: extractDenseBlock4Params('dense0', true),\n    dense1: extractDenseBlock4Params('dense1'),\n    dense2: extractDenseBlock4Params('dense2'),\n    dense3: extractDenseBlock4Params('dense3')\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops';\nimport { denseBlock4 } from './denseBlock';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { FaceFeatureExtractorParams, IFaceFeatureExtractor } from './types';\n\nexport class FaceFeatureExtractor extends NeuralNetwork<FaceFeatureExtractorParams> implements IFaceFeatureExtractor<FaceFeatureExtractorParams> {\n\n  constructor() {\n    super('FaceFeatureExtractor')\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor4D {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error('FaceFeatureExtractor - load model before inference')\n    }\n\n    return tf.tidy(() => {\n      const batchTensor = input.toBatchTensor(112, true)\n      const meanRgb = [122.782, 117.001, 104.298]\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(255)) as tf.Tensor4D\n\n      let out = denseBlock4(normalized, params.dense0, true)\n      out = denseBlock4(out, params.dense1)\n      out = denseBlock4(out, params.dense2)\n      out = denseBlock4(out, params.dense3)\n      out = tf.avgPool(out, [7, 7], [2, 2], 'valid')\n\n      return out\n    })\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_feature_extractor_model'\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap)\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { FCParams } from './types';\n\nexport function fullyConnectedLayer(\n  x: tf.Tensor2D,\n  params: FCParams\n): tf.Tensor2D {\n  return tf.tidy(() =>\n    tf.add(\n      tf.matMul(x, params.weights),\n      params.bias\n    )\n  )\n}", "import { extractFCParamsFactory, extractWeightsFactory, ParamMapping } from '../common';\nimport { NetParams } from './types';\n\nexport function extractParams(weights: Float32Array, channelsIn: number, channelsOut: number): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const extractFCParams = extractFCParamsFactory(extractWeights, paramMappings)\n\n  const fc = extractFCParams(channelsIn, channelsOut, 'fc')\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  return {\n    paramMappings,\n    params: { fc }\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { disposeUnusedWeightTensors, extractWeightEntryFactory, FCParams, ParamMapping } from '../common';\nimport { NetParams } from './types';\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap\n): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  function extractFcParams(prefix: string): FCParams {\n    const weights = extractWeightEntry<tf.Tensor2D>(`${prefix}/weights`, 2)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1)\n    return { weights, bias }\n  }\n\n  const params = {\n    fc: extractFcParams('fc')\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nexport function seperateWeightMaps(weightMap: tf.NamedTensorMap) {\n\n  const featureExtractorMap: tf.NamedTensorMap = {}\n  const classifierMap: tf.NamedTensorMap = {}\n\n  Object.keys(weightMap).forEach(key => {\n    const map = key.startsWith('fc') ? classifierMap : featureExtractorMap\n    map[key] = weightMap[key]\n  })\n\n  return { featureExtractorMap, classifierMap }\n\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { fullyConnectedLayer } from '../common/fullyConnectedLayer';\nimport { NetInput } from '../dom';\nimport {\n  FaceFeatureExtractorParams,\n  IFaceFeatureExtractor,\n  TinyFaceFeatureExtractorParams,\n} from '../faceFeatureExtractor/types';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { NetParams } from './types';\nimport { seperateWeightMaps } from './util';\n\nexport abstract class FaceProcessor<\n  TExtractorParams extends FaceFeatureExtractorParams | TinyFaceFeatureExtractorParams\n>\n  extends NeuralNetwork<NetParams> {\n\n  protected _faceFeatureExtractor: IFaceFeatureExtractor<TExtractorParams>\n\n  constructor(_name: string, faceFeatureExtractor: IFaceFeatureExtractor<TExtractorParams>) {\n    super(_name)\n    this._faceFeatureExtractor = faceFeatureExtractor\n  }\n\n  public get faceFeatureExtractor(): IFaceFeatureExtractor<TExtractorParams> {\n    return this._faceFeatureExtractor\n  }\n\n  protected abstract getDefaultModelName(): string\n  protected abstract getClassifierChannelsIn(): number\n  protected abstract getClassifierChannelsOut(): number\n\n  public runNet(input: NetInput | tf.Tensor4D): tf.Tensor2D {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error(`${this._name} - load model before inference`)\n    }\n\n    return tf.tidy(() => {\n      const bottleneckFeatures = input instanceof NetInput\n        ? this.faceFeatureExtractor.forwardInput(input)\n        : input\n      return fullyConnectedLayer(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc)\n    })\n  }\n\n  public dispose(throwOnRedispose: boolean = true) {\n    this.faceFeatureExtractor.dispose(throwOnRedispose)\n    super.dispose(throwOnRedispose)\n  }\n\n  public loadClassifierParams(weights: Float32Array) {\n    const { params, paramMappings } = this.extractClassifierParams(weights)\n    this._params = params\n    this._paramMappings = paramMappings\n  }\n\n  public extractClassifierParams(weights: Float32Array) {\n    return extractParams(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut())\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n\n    const { featureExtractorMap, classifierMap } = seperateWeightMaps(weightMap)\n\n    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap)\n\n    return extractParamsFromWeigthMap(classifierMap)\n  }\n\n  protected extractParams(weights: Float32Array) {\n\n    const cIn = this.getClassifierChannelsIn()\n    const cOut = this.getClassifierChannelsOut()\n    const classifierWeightSize = (cOut * cIn ) + cOut\n\n    const featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize)\n    const classifierWeights = weights.slice(weights.length - classifierWeightSize)\n\n    this.faceFeatureExtractor.extractWeights(featureExtractorWeights)\n    return this.extractClassifierParams(classifierWeights)\n  }\n}", "export const FACE_EXPRESSION_LABELS = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised']\n\nexport class FaceExpressions {\n  public neutral: number\n  public happy: number\n  public sad: number\n  public angry: number\n  public fearful: number\n  public disgusted: number\n  public surprised: number\n\n  constructor(probabilities: number[] | Float32Array) {\n    if (probabilities.length !== 7) {\n      throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${probabilities.length}`)\n    }\n\n    FACE_EXPRESSION_LABELS.forEach((expression, idx) => {\n      this[expression] = probabilities[idx]\n    })\n  }\n\n  asSortedArray() {\n    return FACE_EXPRESSION_LABELS\n      .map(expression => ({ expression, probability: this[expression] as number }))\n      .sort((e0, e1) => e1.probability - e0.probability)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\nimport { FaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { FaceExpressions } from './FaceExpressions';\n\nexport class FaceExpressionNet extends FaceProcessor<FaceFeatureExtractorParams> {\n\n  constructor(faceFeatureExtractor: FaceFeatureExtractor = new FaceFeatureExtractor()) {\n    super('FaceExpressionNet', faceFeatureExtractor)\n  }\n\n  public forwardInput(input: NetInput | tf.Tensor4D): tf.Tensor2D {\n    return tf.tidy(() => tf.softmax(this.runNet(input)))\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  public async predictExpressions(input: TNetInput) {\n    const netInput = await toNetInput(input)\n    const out = await this.forwardInput(netInput)\n    const probabilitesByBatch = await Promise.all(tf.unstack(out).map(async t => {\n      const data = await t.data()\n      t.dispose()\n      return data\n    }))\n    out.dispose()\n\n    const predictionsByBatch = probabilitesByBatch\n      .map(probabilites => new FaceExpressions(probabilites as Float32Array))\n\n    return netInput.isBatchInput\n      ? predictionsByBatch\n      : predictionsByBatch[0]\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_expression_model'\n  }\n\n  protected getClassifierChannelsIn(): number {\n    return 256\n  }\n\n  protected getClassifierChannelsOut(): number {\n    return 7\n  }\n}", "import { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\n\nexport type WithFaceExpressions<TSource> = TSource & {\n  expressions: FaceExpressions\n}\n\nexport function isWithFaceExpressions(obj: any): obj is WithFaceExpressions<{}> {\n  return obj['expressions'] instanceof FaceExpressions\n}\n\nexport function extendWithFaceExpressions<\n  TSource\n> (\n  sourceObj: TSource,\n  expressions: FaceExpressions\n): WithFaceExpressions<TSource> {\n\n  const extension = { expressions }\n  return Object.assign({}, sourceObj, extension)\n}", "import { IPoint, Point } from '../classes';\nimport { FaceExpressions } from '../faceExpressionNet';\nimport { isWithFaceDetection } from '../factories/WithFaceDetection';\nimport { isWithFaceExpressions, WithFaceExpressions } from '../factories/WithFaceExpressions';\nimport { round } from '../utils';\nimport { DrawTextField } from './DrawTextField';\n\nexport type DrawFaceExpressionsInput = FaceExpressions | WithFaceExpressions<{}>\n\nexport function drawFaceExpressions(\n  canvasArg: string | HTMLCanvasElement,\n  faceExpressions: DrawFaceExpressionsInput | Array<DrawFaceExpressionsInput>,\n  minConfidence = 0.1,\n  textFieldAnchor?: IPoint\n) {\n  const faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions]\n\n  faceExpressionsArray.forEach(e => {\n    const expr = e instanceof FaceExpressions\n      ? e\n      : (isWithFaceExpressions(e) ? e.expressions : undefined)\n    if (!expr) {\n      throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof')\n    }\n\n    const sorted = expr.asSortedArray()\n    const resultsToDisplay = sorted.filter(expr => expr.probability > minConfidence)\n\n    const anchor = isWithFaceDetection(e)\n      ? e.detection.box.bottomLeft\n      : (textFieldAnchor || new Point(0, 0))\n\n    const drawTextField = new DrawTextField(\n      resultsToDisplay.map(expr => `${expr.expression} (${round(expr.probability)})`),\n      anchor\n    )\n    drawTextField.draw(canvasArg)\n  })\n}", "import { FaceDetection } from '../classes/FaceDetection';\nimport { FaceLandmarks } from '../classes/FaceLandmarks';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { isWithFaceDetection, WithFaceDetection } from './WithFaceDetection';\n\nexport type WithFaceLandmarks<\n  TSource extends WithFaceDetection<{}>,\n  TFaceLandmarks extends FaceLandmarks = FaceLandmarks68\n> = TSource & {\n  landmarks: TFaceLandmarks\n  unshiftedLandmarks: TFaceLandmarks\n  alignedRect: FaceDetection\n}\n\nexport function isWithFaceLandmarks(obj: any): obj is WithFaceLandmarks<WithFaceDetection<{}>, FaceLandmarks> {\n  return isWithFaceDetection(obj)\n    && obj['landmarks'] instanceof FaceLandmarks\n    && obj['unshiftedLandmarks'] instanceof FaceLandmarks\n    && obj['alignedRect'] instanceof FaceDetection\n}\n\nexport function extendWithFaceLandmarks<\n  TSource extends WithFaceDetection<{}>,\n  TFaceLandmarks extends FaceLandmarks = FaceLandmarks68\n> (\n  sourceObj: TSource,\n  unshiftedLandmarks: TFaceLandmarks\n): WithFaceLandmarks<TSource, TFaceLandmarks> {\n\n  const { box: shift } = sourceObj.detection\n  const landmarks = unshiftedLandmarks.shiftBy<TFaceLandmarks>(shift.x, shift.y)\n\n  const rect = landmarks.align()\n  const { imageDims } = sourceObj.detection\n  const alignedRect = new FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims)\n\n  const extension = {\n    landmarks,\n    unshiftedLandmarks,\n    alignedRect\n  }\n\n  return Object.assign({}, sourceObj, extension)\n}", "import { IPoint } from '../classes';\nimport { FaceLandmarks } from '../classes/FaceLandmarks';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { isWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { drawContour } from './drawContour';\n\nexport interface IDrawFaceLandmarksOptions {\n  drawLines?: boolean\n  drawPoints?: boolean\n  lineWidth?: number\n  pointSize?: number\n  lineColor?: string\n  pointColor?: string\n}\n\nexport class DrawFaceLandmarksOptions {\n  public drawLines: boolean\n  public drawPoints: boolean\n  public lineWidth: number\n  public pointSize: number\n  public lineColor: string\n  public pointColor: string\n\n  constructor(options: IDrawFaceLandmarksOptions = {}) {\n    const { drawLines = true, drawPoints = true, lineWidth, lineColor, pointSize, pointColor } = options\n    this.drawLines = drawLines\n    this.drawPoints = drawPoints\n    this.lineWidth = lineWidth || 1\n    this.pointSize = pointSize || 2\n    this.lineColor = lineColor || 'rgba(0, 255, 255, 1)'\n    this.pointColor = pointColor || 'rgba(255, 0, 255, 1)'\n  }\n}\n\nexport class DrawFaceLandmarks {\n  public faceLandmarks: FaceLandmarks\n  public options: DrawFaceLandmarksOptions\n\n  constructor(\n    faceLandmarks: FaceLandmarks,\n    options: IDrawFaceLandmarksOptions = {}\n  ) {\n    this.faceLandmarks = faceLandmarks\n    this.options = new DrawFaceLandmarksOptions(options)\n  }\n\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\n    const ctx = getContext2dOrThrow(canvasArg)\n\n    const { drawLines, drawPoints, lineWidth, lineColor, pointSize, pointColor } = this.options\n\n    if (drawLines && this.faceLandmarks instanceof FaceLandmarks68) {\n      ctx.strokeStyle = lineColor\n      ctx.lineWidth = lineWidth\n      drawContour(ctx, this.faceLandmarks.getJawOutline())\n      drawContour(ctx, this.faceLandmarks.getLeftEyeBrow())\n      drawContour(ctx, this.faceLandmarks.getRightEyeBrow())\n      drawContour(ctx, this.faceLandmarks.getNose())\n      drawContour(ctx, this.faceLandmarks.getLeftEye(), true)\n      drawContour(ctx, this.faceLandmarks.getRightEye(), true)\n      drawContour(ctx, this.faceLandmarks.getMouth(), true)\n    }\n\n    if (drawPoints) {\n      ctx.strokeStyle = pointColor\n      ctx.fillStyle = pointColor\n\n      const drawPoint = (pt: IPoint) => {\n        ctx.beginPath()\n        ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI)\n        ctx.fill()\n      }\n      this.faceLandmarks.positions.forEach(drawPoint)\n    }\n  }\n}\n\nexport type DrawFaceLandmarksInput = FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>>\n\nexport function drawFaceLandmarks(\n  canvasArg: string | HTMLCanvasElement,\n  faceLandmarks: DrawFaceLandmarksInput | Array<DrawFaceLandmarksInput>\n) {\n  const faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks]\n  faceLandmarksArray.forEach(f => {\n    const landmarks = f instanceof FaceLandmarks\n      ? f\n      : (isWithFaceLandmarks(f) ? f.landmarks : undefined)\n    if (!landmarks) {\n      throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof')\n    }\n\n    new DrawFaceLandmarks(landmarks).draw(canvasArg)\n  })\n}", "export * from './drawContour'\nexport * from './drawDetections'\nexport * from './drawFaceExpressions'\nexport * from './DrawBox'\nexport * from './DrawFaceLandmarks'\nexport * from './DrawTextField'", "import { extractConvParamsFactory, extractSeparableConvParamsFactory, extractWeightsFactory } from '../common';\nimport { ExtractWeightsFunction, ParamMapping } from '../common/types';\nimport { range } from '../utils';\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings)\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings)\n\n  function extractReductionBlockParams(channelsIn: number, channelsOut: number, mappedPrefix: string): ReductionBlockParams {\n\n    const separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, `${mappedPrefix}/separable_conv0`)\n    const separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/separable_conv1`)\n    const expansion_conv = extractConvParams(channelsIn, channelsOut, 1, `${mappedPrefix}/expansion_conv`)\n\n    return { separable_conv0, separable_conv1, expansion_conv }\n  }\n\n  function extractMainBlockParams(channels: number, mappedPrefix: string): MainBlockParams {\n\n    const separable_conv0 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv0`)\n    const separable_conv1 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv1`)\n    const separable_conv2 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv2`)\n\n    return { separable_conv0, separable_conv1, separable_conv2 }\n  }\n\n  return {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams\n  }\n\n}\n\nexport function extractParams(weights: Float32Array, numMainBlocks: number): { params: TinyXceptionParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams\n  } = extractorsFactory(extractWeights, paramMappings)\n\n  const entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in')\n  const entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0')\n  const entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1')\n\n  const entry_flow = {\n    conv_in: entry_flow_conv_in,\n    reduction_block_0: entry_flow_reduction_block_0,\n    reduction_block_1: entry_flow_reduction_block_1\n  }\n\n  const middle_flow = {}\n  range(numMainBlocks, 0, 1).forEach((idx) => {\n    middle_flow[`main_block_${idx}`] = extractMainBlockParams(128, `middle_flow/main_block_${idx}`)\n  })\n\n  const exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block')\n  const exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv')\n\n  const exit_flow = {\n    reduction_block: exit_flow_reduction_block,\n    separable_conv: exit_flow_separable_conv\n  }\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  return {\n    paramMappings,\n    params: { entry_flow, middle_flow, exit_flow }\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport {\n  disposeUnusedWeightTensors,\n  extractWeightEntryFactory,\n  loadSeparableConvParamsFactory,\n  ParamMapping,\n} from '../common';\nimport { loadConvParamsFactory } from '../common/loadConvParamsFactory';\nimport { range } from '../utils';\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\n\nfunction loadParamsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  const extractConvParams = loadConvParamsFactory(extractWeightEntry)\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry)\n\n  function extractReductionBlockParams(mappedPrefix: string): ReductionBlockParams {\n\n    const separable_conv0 = extractSeparableConvParams(`${mappedPrefix}/separable_conv0`)\n    const separable_conv1 = extractSeparableConvParams(`${mappedPrefix}/separable_conv1`)\n    const expansion_conv = extractConvParams(`${mappedPrefix}/expansion_conv`)\n\n    return { separable_conv0, separable_conv1, expansion_conv }\n  }\n\n  function extractMainBlockParams(mappedPrefix: string): MainBlockParams {\n\n    const separable_conv0 = extractSeparableConvParams(`${mappedPrefix}/separable_conv0`)\n    const separable_conv1 = extractSeparableConvParams(`${mappedPrefix}/separable_conv1`)\n    const separable_conv2 = extractSeparableConvParams(`${mappedPrefix}/separable_conv2`)\n\n    return { separable_conv0, separable_conv1, separable_conv2 }\n  }\n\n  return {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams\n  }\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n  numMainBlocks: number\n): { params: TinyXceptionParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractConvParams,\n    extractSeparableConvParams,\n    extractReductionBlockParams,\n    extractMainBlockParams\n  } = loadParamsFactory(weightMap, paramMappings)\n\n  const entry_flow_conv_in = extractConvParams('entry_flow/conv_in')\n  const entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0')\n  const entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1')\n\n  const entry_flow = {\n    conv_in: entry_flow_conv_in,\n    reduction_block_0: entry_flow_reduction_block_0,\n    reduction_block_1: entry_flow_reduction_block_1\n  }\n\n  const middle_flow = {}\n  range(numMainBlocks, 0, 1).forEach((idx) => {\n    middle_flow[`main_block_${idx}`] = extractMainBlockParams(`middle_flow/main_block_${idx}`)\n  })\n\n  const exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block')\n  const exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv')\n\n  const exit_flow = {\n    reduction_block: exit_flow_reduction_block,\n    separable_conv: exit_flow_separable_conv\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params: { entry_flow, middle_flow, exit_flow }, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams, depthwiseSeparableConv } from '../common';\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops';\nimport { range } from '../utils';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\n\nfunction conv(x: tf.Tensor4D, params: ConvParams, stride: [number, number]): tf.Tensor4D {\n  return tf.add(tf.conv2d(x, params.filters, stride, 'same'), params.bias)\n}\n\nfunction reductionBlock(x: tf.Tensor4D, params: ReductionBlockParams, isActivateInput: boolean = true): tf.Tensor4D {\n  let out = isActivateInput ? tf.relu(x) : x\n  out = depthwiseSeparableConv(out, params.separable_conv0, [1, 1])\n  out = depthwiseSeparableConv(tf.relu(out),  params.separable_conv1, [1, 1])\n  out = tf.maxPool(out, [3, 3], [2, 2], 'same')\n  out = tf.add(out, conv(x,  params.expansion_conv, [2, 2]))\n  return out\n}\n\nfunction mainBlock(x: tf.Tensor4D, params: MainBlockParams): tf.Tensor4D {\n  let out = depthwiseSeparableConv(tf.relu(x), params.separable_conv0, [1, 1])\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv1, [1, 1])\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv2, [1, 1])\n  out = tf.add(out, x)\n  return out\n}\n\nexport class TinyXception extends NeuralNetwork<TinyXceptionParams> {\n\n  private _numMainBlocks: number\n\n  constructor(numMainBlocks: number) {\n    super('TinyXception')\n    this._numMainBlocks = numMainBlocks\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor4D {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error('TinyXception - load model before inference')\n    }\n\n    return tf.tidy(() => {\n      const batchTensor = input.toBatchTensor(112, true)\n      const meanRgb = [122.782, 117.001, 104.298]\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256)) as tf.Tensor4D\n\n      let out = tf.relu(conv(normalized, params.entry_flow.conv_in, [2, 2]))\n      out = reductionBlock(out, params.entry_flow.reduction_block_0, false)\n      out = reductionBlock(out, params.entry_flow.reduction_block_1)\n\n      range(this._numMainBlocks, 0, 1).forEach((idx) => {\n        out = mainBlock(out, params.middle_flow[`main_block_${idx}`])\n      })\n\n      out = reductionBlock(out, params.exit_flow.reduction_block)\n      out = tf.relu(depthwiseSeparableConv(out, params.exit_flow.separable_conv, [1, 1]))\n      return out\n    })\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  protected getDefaultModelName(): string {\n    return 'tiny_xception_model'\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap, this._numMainBlocks)\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights, this._numMainBlocks)\n  }\n}", "import { extractFCParamsFactory, extractWeightsFactory, ParamMapping } from '../common';\nimport { NetParams } from './types';\n\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const extractFCParams = extractFCParamsFactory(extractWeights, paramMappings)\n\n  const age = extractFCParams(512, 1, 'fc/age')\n  const gender = extractFCParams(512, 2, 'fc/gender')\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  return {\n    paramMappings,\n    params: { fc: { age, gender } }\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { disposeUnusedWeightTensors, extractWeightEntryFactory, FCParams, ParamMapping } from '../common';\nimport { NetParams } from './types';\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap\n): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  function extractFcParams(prefix: string): FCParams {\n    const weights = extractWeightEntry<tf.Tensor2D>(`${prefix}/weights`, 2)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1)\n    return { weights, bias }\n  }\n\n  const params = {\n    fc: {\n      age: extractFcParams('fc/age'),\n      gender: extractFcParams('fc/gender')\n    }\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { FCParams } from '../common';\n\nexport type AgeAndGenderPrediction = {\n  age: number\n  gender: Gender\n  genderProbability: number\n}\n\nexport enum Gender {\n  FEMALE = 'female',\n  MALE = 'male'\n}\n\nexport type NetOutput = { age: tf.Tensor1D, gender: tf.Tensor2D }\n\nexport type NetParams = {\n  fc: {\n    age: FCParams\n    gender: FCParams\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { fullyConnectedLayer } from '../common/fullyConnectedLayer';\nimport { seperateWeightMaps } from '../faceProcessor/util';\nimport { TinyXception } from '../xception/TinyXception';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { AgeAndGenderPrediction, Gender, NetOutput, NetParams } from './types';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { NetInput, TNetInput, toNetInput } from '../dom';\n\nexport class AgeGenderNet extends NeuralNetwork<NetParams> {\n\n  private _faceFeatureExtractor: TinyXception\n\n  constructor(faceFeatureExtractor: TinyXception = new TinyXception(2)) {\n    super('AgeGenderNet')\n    this._faceFeatureExtractor = faceFeatureExtractor\n  }\n\n  public get faceFeatureExtractor(): TinyXception {\n    return this._faceFeatureExtractor\n  }\n\n  public runNet(input: NetInput | tf.Tensor4D): NetOutput {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error(`${this._name} - load model before inference`)\n    }\n\n    return tf.tidy(() => {\n      const bottleneckFeatures = input instanceof NetInput\n        ? this.faceFeatureExtractor.forwardInput(input)\n        : input\n\n      const pooled = tf.avgPool(bottleneckFeatures, [7, 7], [2, 2], 'valid').as2D(bottleneckFeatures.shape[0], -1)\n      const age = fullyConnectedLayer(pooled, params.fc.age).as1D()\n      const gender = fullyConnectedLayer(pooled, params.fc.gender)\n      return { age, gender }\n    })\n  }\n\n  public forwardInput(input: NetInput | tf.Tensor4D): NetOutput {\n    return tf.tidy(() => {\n      const { age, gender } = this.runNet(input)\n      return { age, gender: tf.softmax(gender) }\n    })\n  }\n\n  public async forward(input: TNetInput): Promise<NetOutput> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  public async predictAgeAndGender(input: TNetInput): Promise<AgeAndGenderPrediction | AgeAndGenderPrediction[]> {\n    const netInput = await toNetInput(input)\n    const out = await this.forwardInput(netInput)\n\n    const ages = tf.unstack(out.age)\n    const genders = tf.unstack(out.gender)\n    const ageAndGenderTensors = ages.map((ageTensor, i) => ({\n      ageTensor,\n      genderTensor: genders[i]\n    }))\n\n    const predictionsByBatch = await Promise.all(\n      ageAndGenderTensors.map(async ({ ageTensor, genderTensor }) => {\n        const age = (await ageTensor.data())[0]\n        const probMale = (await genderTensor.data())[0]\n        const isMale = probMale > 0.5\n        const gender = isMale ? Gender.MALE : Gender.FEMALE\n        const genderProbability = isMale ? probMale : (1 - probMale)\n\n        ageTensor.dispose()\n        genderTensor.dispose()\n        return { age, gender, genderProbability }\n      })\n    )\n    out.age.dispose()\n    out.gender.dispose()\n\n    return netInput.isBatchInput ? predictionsByBatch as AgeAndGenderPrediction[] : predictionsByBatch[0] as AgeAndGenderPrediction\n  }\n\n  protected getDefaultModelName(): string {\n    return 'age_gender_model'\n  }\n\n  public dispose(throwOnRedispose: boolean = true) {\n    this.faceFeatureExtractor.dispose(throwOnRedispose)\n    super.dispose(throwOnRedispose)\n  }\n\n  public loadClassifierParams(weights: Float32Array) {\n    const { params, paramMappings } = this.extractClassifierParams(weights)\n    this._params = params\n    this._paramMappings = paramMappings\n  }\n\n  public extractClassifierParams(weights: Float32Array) {\n    return extractParams(weights)\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n\n    const { featureExtractorMap, classifierMap } = seperateWeightMaps(weightMap)\n\n    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap)\n\n    return extractParamsFromWeigthMap(classifierMap)\n  }\n\n  protected extractParams(weights: Float32Array) {\n\n    const classifierWeightSize = (512 * 1 + 1) + (512 * 2 + 2)\n\n    const featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize)\n    const classifierWeights = weights.slice(weights.length - classifierWeightSize)\n\n    this.faceFeatureExtractor.extractWeights(featureExtractorWeights)\n    return this.extractClassifierParams(classifierWeights)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { IDimensions, Point } from '../classes';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { FaceFeatureExtractorParams, TinyFaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { isEven } from '../utils';\n\nexport abstract class FaceLandmark68NetBase<\n  TExtractorParams extends FaceFeatureExtractorParams | TinyFaceFeatureExtractorParams\n>\n  extends FaceProcessor<TExtractorParams> {\n\n  public postProcess(output: tf.Tensor2D, inputSize: number, originalDimensions: IDimensions[]): tf.Tensor2D {\n\n    const inputDimensions = originalDimensions.map(({ width, height }) => {\n      const scale = inputSize / Math.max(height, width)\n      return {\n        width: width * scale,\n        height: height * scale\n      }\n    })\n\n    const batchSize = inputDimensions.length\n\n    return tf.tidy(() => {\n      const createInterleavedTensor = (fillX: number, fillY: number) =>\n        tf.stack([\n          tf.fill([68], fillX),\n          tf.fill([68], fillY)\n        ], 1).as2D(1, 136).as1D()\n\n      const getPadding = (batchIdx: number, cond: (w: number, h: number) => boolean): number => {\n        const { width, height } = inputDimensions[batchIdx]\n        return cond(width, height) ? Math.abs(width - height) / 2 : 0\n      }\n      const getPaddingX = (batchIdx: number) => getPadding(batchIdx, (w, h) => w < h)\n      const getPaddingY = (batchIdx: number) => getPadding(batchIdx, (w, h) => h < w)\n\n      const landmarkTensors = output\n        .mul(tf.fill([batchSize, 136], inputSize))\n        .sub(tf.stack(Array.from(Array(batchSize), (_, batchIdx) =>\n          createInterleavedTensor(\n            getPaddingX(batchIdx),\n            getPaddingY(batchIdx)\n          )\n        )))\n        .div(tf.stack(Array.from(Array(batchSize), (_, batchIdx) =>\n          createInterleavedTensor(\n            inputDimensions[batchIdx].width,\n            inputDimensions[batchIdx].height\n          )\n        )))\n\n      return landmarkTensors as tf.Tensor2D\n    })\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor2D {\n    return tf.tidy(() => {\n      const out = this.runNet(input)\n      return this.postProcess(\n        out,\n        input.inputSize as number,\n        input.inputDimensions.map(([height, width]) => ({ height, width }))\n      )\n    })\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  public async detectLandmarks(input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> {\n    const netInput = await toNetInput(input)\n    const landmarkTensors = tf.tidy(\n      () => tf.unstack(this.forwardInput(netInput))\n    )\n\n    const landmarksForBatch = await Promise.all(landmarkTensors.map(\n      async (landmarkTensor, batchIdx) => {\n        const landmarksArray = Array.from(await landmarkTensor.data())\n        const xCoords = landmarksArray.filter((_, i) => isEven(i))\n        const yCoords = landmarksArray.filter((_, i) => !isEven(i))\n\n        return new FaceLandmarks68(\n          Array(68).fill(0).map((_, i) => new Point(xCoords[i] as number, yCoords[i] as number)),\n          {\n            height: netInput.getInputHeight(batchIdx),\n            width : netInput.getInputWidth(batchIdx),\n          }\n        )\n      }\n    ))\n\n    landmarkTensors.forEach(t => t.dispose())\n\n    return netInput.isBatchInput ? landmarksForBatch as FaceLandmarks68[] : landmarksForBatch[0] as FaceLandmarks68;\n  }\n\n  protected getClassifierChannelsOut(): number {\n    return 136\n  }\n}", "import { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\nimport { FaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceLandmark68NetBase } from './FaceLandmark68NetBase';\n\nexport class FaceLandmark68Net extends FaceLandmark68NetBase<FaceFeatureExtractorParams> {\n\n  constructor(faceFeatureExtractor: FaceFeatureExtractor = new FaceFeatureExtractor()) {\n    super('FaceLandmark68Net', faceFeatureExtractor)\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_landmark_68_model'\n  }\n\n  protected getClassifierChannelsIn(): number {\n    return 256\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { disposeUnusedWeightTensors, ParamMapping } from '../common';\nimport { loadParamsFactory } from './loadParamsFactory';\nimport { TinyFaceFeatureExtractorParams } from './types';\n\nexport function extractParamsFromWeigthMapTiny(\n  weightMap: tf.NamedTensorMap\n): { params: TinyFaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractDenseBlock3Params\n  } = loadParamsFactory(weightMap, paramMappings)\n\n  const params = {\n    dense0: extractDenseBlock3Params('dense0', true),\n    dense1: extractDenseBlock3Params('dense1'),\n    dense2: extractDenseBlock3Params('dense2')\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "import { extractWeightsFactory, ParamMapping } from '../common';\nimport { extractorsFactory } from './extractorsFactory';\nimport { TinyFaceFeatureExtractorParams } from './types';\n\n\n\nexport function extractParamsTiny(weights: Float32Array): { params: TinyFaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const {\n    extractDenseBlock3Params\n  } = extractorsFactory(extractWeights, paramMappings)\n\n  const dense0 = extractDenseBlock3Params(3, 32, 'dense0', true)\n  const dense1 = extractDenseBlock3Params(32, 64, 'dense1')\n  const dense2 = extractDenseBlock3Params(64, 128, 'dense2')\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  return {\n    paramMappings,\n    params: { dense0, dense1, dense2 }\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops';\nimport { denseBlock3 } from './denseBlock';\nimport { extractParamsFromWeigthMapTiny } from './extractParamsFromWeigthMapTiny';\nimport { extractParamsTiny } from './extractParamsTiny';\nimport { IFaceFeatureExtractor, TinyFaceFeatureExtractorParams } from './types';\n\nexport class TinyFaceFeatureExtractor extends NeuralNetwork<TinyFaceFeatureExtractorParams> implements IFaceFeatureExtractor<TinyFaceFeatureExtractorParams> {\n\n  constructor() {\n    super('TinyFaceFeatureExtractor')\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor4D {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error('TinyFaceFeatureExtractor - load model before inference')\n    }\n\n    return tf.tidy(() => {\n      const batchTensor = input.toBatchTensor(112, true)\n      const meanRgb = [122.782, 117.001, 104.298]\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(255)) as tf.Tensor4D\n\n      let out = denseBlock3(normalized, params.dense0, true)\n      out = denseBlock3(out, params.dense1)\n      out = denseBlock3(out, params.dense2)\n      out = tf.avgPool(out, [14, 14], [2, 2], 'valid')\n\n      return out\n    })\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_feature_extractor_tiny_model'\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMapTiny(weightMap)\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParamsTiny(weights)\n  }\n}", "import { TinyFaceFeatureExtractor } from '../faceFeatureExtractor/TinyFaceFeatureExtractor';\nimport { TinyFaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\nimport { FaceLandmark68NetBase } from './FaceLandmark68NetBase';\n\nexport class FaceLandmark68TinyNet extends FaceLandmark68NetBase<TinyFaceFeatureExtractorParams> {\n\n  constructor(faceFeatureExtractor: TinyFaceFeatureExtractor = new TinyFaceFeatureExtractor()) {\n    super('FaceLandmark68TinyNet', faceFeatureExtractor)\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_landmark_68_tiny_model'\n  }\n\n  protected getClassifierChannelsIn(): number {\n    return 128\n  }\n}", "import { FaceLandmark68Net } from './FaceLandmark68Net';\n\nexport * from './FaceLandmark68Net';\nexport * from './FaceLandmark68TinyNet';\n\nexport class FaceLandmarkNet extends FaceLandmark68Net {}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ScaleLayerParams } from './types';\n\nexport function scale(x: tf.Tensor4D, params: ScaleLayerParams): tf.Tensor4D {\n  return tf.add(tf.mul(x, params.weights), params.biases)\n}\n", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { scale } from './scaleLayer';\nimport { ConvLayerParams } from './types';\n\n\nfunction convLayer(\n  x: tf.Tensor4D,\n  params: ConvLayerParams,\n  strides: [number, number],\n  withRelu: boolean,\n  padding: 'valid' | 'same' = 'same'\n): tf.Tensor4D {\n  const { filters, bias } = params.conv\n\n  let out = tf.conv2d(x, filters, strides, padding)\n  out = tf.add(out, bias)\n  out = scale(out, params.scale)\n  return withRelu ? tf.relu(out) : out\n}\n\nexport function conv(x: tf.Tensor4D, params: ConvLayerParams) {\n  return convLayer(x, params, [1, 1], true)\n}\n\nexport function convNoRelu(x: tf.Tensor4D, params: ConvLayerParams) {\n  return convLayer(x, params, [1, 1], false)\n}\n\nexport function convDown(x: tf.Tensor4D, params: ConvLayerParams) {\n  return convLayer(x, params, [2, 2], true, 'valid')\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams, extractWeightsFactory, ExtractWeightsFunction, ParamMapping } from '../common';\nimport { isFloat } from '../utils';\nimport { ConvLayerParams, NetParams, ResidualLayerParams, ScaleLayerParams } from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n\n  function extractFilterValues(numFilterValues: number, numFilters: number, filterSize: number): tf.Tensor4D {\n    const weights = extractWeights(numFilterValues)\n    const depth = weights.length / (numFilters * filterSize * filterSize)\n\n    if (isFloat(depth)) {\n      throw new Error(`depth has to be an integer: ${depth}, weights.length: ${weights.length}, numFilters: ${numFilters}, filterSize: ${filterSize}`)\n    }\n\n    return tf.tidy(\n      () => tf.transpose(\n        tf.tensor4d(weights, [numFilters, depth, filterSize, filterSize]),\n        [2, 3, 1, 0]\n      )\n    )\n  }\n\n  function extractConvParams(\n    numFilterValues: number,\n    numFilters: number,\n    filterSize: number,\n    mappedPrefix: string\n  ): ConvParams {\n\n    const filters = extractFilterValues(numFilterValues, numFilters, filterSize)\n    const bias = tf.tensor1d(extractWeights(numFilters))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/bias` }\n    )\n\n    return { filters, bias }\n  }\n\n  function extractScaleLayerParams(numWeights: number, mappedPrefix: string): ScaleLayerParams {\n\n    const weights = tf.tensor1d(extractWeights(numWeights))\n    const biases = tf.tensor1d(extractWeights(numWeights))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/weights` },\n      { paramPath: `${mappedPrefix}/biases` }\n    )\n\n    return {\n      weights,\n      biases\n    }\n  }\n\n  function extractConvLayerParams(\n    numFilterValues: number,\n    numFilters: number,\n    filterSize: number,\n    mappedPrefix: string\n  ): ConvLayerParams {\n\n    const conv = extractConvParams(numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv`)\n    const scale = extractScaleLayerParams(numFilters, `${mappedPrefix}/scale`)\n\n    return { conv, scale }\n  }\n\n  function extractResidualLayerParams(\n    numFilterValues: number,\n    numFilters: number,\n    filterSize: number,\n    mappedPrefix: string,\n    isDown: boolean = false\n  ): ResidualLayerParams {\n\n    const conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv1`)\n    const conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv2`)\n\n    return { conv1, conv2 }\n  }\n\n  return {\n    extractConvLayerParams,\n    extractResidualLayerParams\n  }\n\n}\n\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractConvLayerParams,\n    extractResidualLayerParams\n  } = extractorsFactory(extractWeights, paramMappings)\n\n  const conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down')\n  const conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1')\n  const conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2')\n  const conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3')\n\n  const conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true)\n  const conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1')\n  const conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2')\n  const conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3')\n\n  const conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true)\n  const conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1')\n  const conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2')\n\n  const conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true)\n  const conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1')\n  const conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2')\n  const conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out')\n\n  const fc = tf.tidy(\n    () => tf.transpose(tf.tensor2d(extractWeights(256 * 128), [128, 256]), [1, 0])\n  )\n  paramMappings.push({ paramPath: `fc` })\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  const params = {\n    conv32_down,\n    conv32_1,\n    conv32_2,\n    conv32_3,\n    conv64_down,\n    conv64_1,\n    conv64_2,\n    conv64_3,\n    conv128_down,\n    conv128_1,\n    conv128_2,\n    conv256_down,\n    conv256_1,\n    conv256_2,\n    conv256_down_out,\n    fc\n  }\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { disposeUnusedWeightTensors, extractWeightEntryFactory, ParamMapping } from '../common';\nimport { isTensor2D } from '../utils';\nimport { ConvLayerParams, NetParams, ResidualLayerParams, ScaleLayerParams } from './types';\n\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  function extractScaleLayerParams(prefix: string): ScaleLayerParams {\n\n    const weights = extractWeightEntry<tf.Tensor1D>(`${prefix}/scale/weights`, 1)\n    const biases = extractWeightEntry<tf.Tensor1D>(`${prefix}/scale/biases`, 1)\n\n    return { weights, biases }\n  }\n\n  function extractConvLayerParams(prefix: string): ConvLayerParams {\n\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/conv/filters`, 4)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/conv/bias`, 1)\n    const scale = extractScaleLayerParams(prefix)\n\n    return { conv: { filters, bias }, scale }\n  }\n\n  function extractResidualLayerParams(prefix: string): ResidualLayerParams {\n    return {\n      conv1: extractConvLayerParams(`${prefix}/conv1`),\n      conv2: extractConvLayerParams(`${prefix}/conv2`)\n    }\n  }\n\n  return {\n    extractConvLayerParams,\n    extractResidualLayerParams\n  }\n\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap\n): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractConvLayerParams,\n    extractResidualLayerParams\n  } = extractorsFactory(weightMap, paramMappings)\n\n  const conv32_down = extractConvLayerParams('conv32_down')\n  const conv32_1 = extractResidualLayerParams('conv32_1')\n  const conv32_2 = extractResidualLayerParams('conv32_2')\n  const conv32_3 = extractResidualLayerParams('conv32_3')\n\n  const conv64_down = extractResidualLayerParams('conv64_down')\n  const conv64_1 = extractResidualLayerParams('conv64_1')\n  const conv64_2 = extractResidualLayerParams('conv64_2')\n  const conv64_3 = extractResidualLayerParams('conv64_3')\n\n  const conv128_down = extractResidualLayerParams('conv128_down')\n  const conv128_1 = extractResidualLayerParams('conv128_1')\n  const conv128_2 = extractResidualLayerParams('conv128_2')\n\n  const conv256_down = extractResidualLayerParams('conv256_down')\n  const conv256_1 = extractResidualLayerParams('conv256_1')\n  const conv256_2 = extractResidualLayerParams('conv256_2')\n  const conv256_down_out = extractResidualLayerParams('conv256_down_out')\n\n  const fc = weightMap['fc']\n  paramMappings.push({ originalPath: 'fc', paramPath: 'fc' })\n\n  if (!isTensor2D(fc)) {\n    throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${fc}`)\n  }\n\n  const params = {\n    conv32_down,\n    conv32_1,\n    conv32_2,\n    conv32_3,\n    conv64_down,\n    conv64_1,\n    conv64_2,\n    conv64_3,\n    conv128_down,\n    conv128_1,\n    conv128_2,\n    conv256_down,\n    conv256_1,\n    conv256_2,\n    conv256_down_out,\n    fc\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { conv, convDown, convNoRelu } from './convLayer';\nimport { ResidualLayerParams } from './types';\n\nexport function residual(x: tf.Tensor4D, params: ResidualLayerParams): tf.Tensor4D {\n  let out = conv(x, params.conv1)\n  out = convNoRelu(out, params.conv2)\n  out = tf.add(out, x)\n  out = tf.relu(out)\n  return out\n}\n\nexport function residualDown(x: tf.Tensor4D, params: ResidualLayerParams): tf.Tensor4D {\n  let out = convDown(x, params.conv1)\n  out = convNoRelu(out, params.conv2)\n\n  let pooled = tf.avgPool(x, 2, 2, 'valid') as tf.Tensor4D\n  const zeros = tf.zeros<tf.Rank.R4>(pooled.shape)\n  const isPad = pooled.shape[3] !== out.shape[3]\n  const isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2]\n\n  if (isAdjustShape) {\n    const padShapeX = [...out.shape] as [number, number, number, number]\n    padShapeX[1] = 1\n    const zerosW = tf.zeros<tf.Rank.R4>(padShapeX)\n    out = tf.concat([out, zerosW], 1)\n\n    const padShapeY = [...out.shape] as [number, number, number, number]\n    padShapeY[2] = 1\n    const zerosH = tf.zeros<tf.Rank.R4>(padShapeY)\n    out = tf.concat([out, zerosH], 2)\n  }\n\n  pooled = isPad ? tf.concat([pooled, zeros], 3) : pooled\n  out = tf.add(pooled, out) as tf.Tensor4D\n\n  out = tf.relu(out)\n  return out\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { normalize } from '../ops';\nimport { convDown } from './convLayer';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { residual, residualDown } from './residualLayer';\nimport { NetParams } from './types';\n\n\nexport class FaceRecognitionNet extends NeuralNetwork<NetParams> {\n\n  constructor() {\n    super('FaceRecognitionNet')\n  }\n\n  public forwardInput(input: NetInput): tf.Tensor2D {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error('FaceRecognitionNet - load model before inference')\n    }\n\n    return tf.tidy(() => {\n      // const batchTensor = input.toBatchTensor(150, true).toFloat()\n      const batchTensor = tf.cast(input.toBatchTensor(150, true), 'float32');\n\n      const meanRgb = [122.782, 117.001, 104.298]\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256)) as tf.Tensor4D\n\n      let out = convDown(normalized, params.conv32_down)\n      out = tf.maxPool(out, 3, 2, 'valid')\n\n      out = residual(out, params.conv32_1)\n      out = residual(out, params.conv32_2)\n      out = residual(out, params.conv32_3)\n\n      out = residualDown(out, params.conv64_down)\n      out = residual(out, params.conv64_1)\n      out = residual(out, params.conv64_2)\n      out = residual(out, params.conv64_3)\n\n      out = residualDown(out, params.conv128_down)\n      out = residual(out, params.conv128_1)\n      out = residual(out, params.conv128_2)\n\n      out = residualDown(out, params.conv256_down)\n      out = residual(out, params.conv256_1)\n      out = residual(out, params.conv256_2)\n      out = residualDown(out, params.conv256_down_out)\n\n      const globalAvg = out.mean([1, 2]) as tf.Tensor2D\n      const fullyConnected = tf.matMul(globalAvg, params.fc)\n\n      return fullyConnected\n    })\n  }\n\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  public async computeFaceDescriptor(input: TNetInput): Promise<Float32Array|Float32Array[]> {\n    const netInput = await toNetInput(input)\n\n    const faceDescriptorTensors = tf.tidy(\n      () => tf.unstack(this.forwardInput(netInput))\n    )\n\n    const faceDescriptorsForBatch = await Promise.all(faceDescriptorTensors.map(\n      t => t.data()\n    )) as Float32Array[]\n\n    faceDescriptorTensors.forEach(t => t.dispose())\n\n    return netInput.isBatchInput\n      ? faceDescriptorsForBatch\n      : faceDescriptorsForBatch[0]\n  }\n\n  protected getDefaultModelName(): string {\n    return 'face_recognition_model'\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap)\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights)\n  }\n}", "import { FaceRecognitionNet } from './FaceRecognitionNet';\n\nexport * from './FaceRecognitionNet';\n\nexport function createFaceRecognitionNet(weights: Float32Array) {\n  const net = new FaceRecognitionNet()\n  net.extractWeights(weights)\n  return net\n}", "export type WithFaceDescriptor<TSource> = TSource & {\n  descriptor: Float32Array\n}\n\nexport function extendWithFaceDescriptor<\n  TSource\n> (\n  sourceObj: TSource,\n  descriptor: Float32Array\n): WithFaceDescriptor<TSource> {\n\n  const extension = { descriptor }\n  return Object.assign({}, sourceObj, extension)\n}\n\n", "export type WithAge<TSource> = TSource & {\n  age: number\n}\n\nexport function isWithAge(obj: any): obj is WithAge<{}> {\n  return typeof obj['age'] === 'number'\n}\n\nexport function extendWithAge<\n  TSource\n> (\n  sourceObj: TSource,\n  age: number\n): WithAge<TSource> {\n\n  const extension = { age }\n  return Object.assign({}, sourceObj, extension)\n}", "import { Gender } from '../ageGenderNet/types';\nimport { isValidProbablitiy } from '../utils';\n\nexport type WithGender<TSource> = TSource & {\n  gender: Gender\n  genderProbability: number\n}\n\nexport function isWithGender(obj: any): obj is WithGender<{}> {\n  return (obj['gender'] === Gender.MALE || obj['gender'] === Gender.FEMALE)\n    && isValidProbablitiy(obj['genderProbability'])\n}\n\nexport function extendWithGender<\n  TSource\n> (\n  sourceObj: TSource,\n  gender: Gender,\n  genderProbability: number\n): WithGender<TSource> {\n\n  const extension = { gender, genderProbability }\n  return Object.assign({}, sourceObj, extension)\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ExtractWeightsFunction, ParamMapping, ConvParams, extractWeightsFactory } from '../common';\nimport { MobileNetV1, NetParams, PointwiseConvParams, PredictionLayerParams } from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n\n  function extractDepthwiseConvParams(numChannels: number, mappedPrefix: string): MobileNetV1.DepthwiseConvParams {\n\n    const filters = tf.tensor4d(extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1])\n    const batch_norm_scale = tf.tensor1d(extractWeights(numChannels))\n    const batch_norm_offset = tf.tensor1d(extractWeights(numChannels))\n    const batch_norm_mean = tf.tensor1d(extractWeights(numChannels))\n    const batch_norm_variance = tf.tensor1d(extractWeights(numChannels))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/batch_norm_scale` },\n      { paramPath: `${mappedPrefix}/batch_norm_offset` },\n      { paramPath: `${mappedPrefix}/batch_norm_mean` },\n      { paramPath: `${mappedPrefix}/batch_norm_variance` }\n    )\n\n    return {\n      filters,\n      batch_norm_scale,\n      batch_norm_offset,\n      batch_norm_mean,\n      batch_norm_variance\n    }\n  }\n\n  function extractConvParams(\n    channelsIn: number,\n    channelsOut: number,\n    filterSize: number,\n    mappedPrefix: string,\n    isPointwiseConv?: boolean\n  ): ConvParams {\n\n    const filters = tf.tensor4d(\n      extractWeights(channelsIn * channelsOut * filterSize * filterSize),\n      [filterSize, filterSize, channelsIn, channelsOut]\n    )\n    const bias = tf.tensor1d(extractWeights(channelsOut))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/filters` },\n      { paramPath: `${mappedPrefix}/${isPointwiseConv ? 'batch_norm_offset' : 'bias'}` }\n    )\n\n    return { filters, bias }\n  }\n\n  function extractPointwiseConvParams(\n    channelsIn: number,\n    channelsOut: number,\n    filterSize: number,\n    mappedPrefix: string\n  ): PointwiseConvParams {\n\n    const {\n      filters,\n      bias\n    } = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true)\n\n    return {\n      filters,\n      batch_norm_offset: bias\n    }\n  }\n\n  function extractConvPairParams(\n    channelsIn: number,\n    channelsOut: number,\n    mappedPrefix: string\n  ): MobileNetV1.ConvPairParams {\n\n    const depthwise_conv = extractDepthwiseConvParams(channelsIn, `${mappedPrefix}/depthwise_conv`)\n    const pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, `${mappedPrefix}/pointwise_conv`)\n\n    return { depthwise_conv, pointwise_conv }\n  }\n\n  function extractMobilenetV1Params(): MobileNetV1.Params {\n\n    const conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0')\n\n    const conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1')\n    const conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2')\n    const conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3')\n    const conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4')\n    const conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5')\n    const conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6')\n    const conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7')\n    const conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8')\n    const conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9')\n    const conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10')\n    const conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11')\n    const conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12')\n    const conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13')\n\n    return {\n      conv_0,\n      conv_1,\n      conv_2,\n      conv_3,\n      conv_4,\n      conv_5,\n      conv_6,\n      conv_7,\n      conv_8,\n      conv_9,\n      conv_10,\n      conv_11,\n      conv_12,\n      conv_13\n    }\n  }\n\n  function extractPredictionLayerParams(): PredictionLayerParams {\n    const conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0')\n    const conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1')\n    const conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2')\n    const conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3')\n    const conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4')\n    const conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5')\n    const conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6')\n    const conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7')\n\n    const box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor')\n    const class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor')\n    const box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor')\n    const class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor')\n    const box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor')\n    const class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor')\n    const box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor')\n    const class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor')\n    const box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor')\n    const class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor')\n    const box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor')\n    const class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor')\n\n    const box_predictor_0 = {\n      box_encoding_predictor: box_encoding_0_predictor,\n      class_predictor: class_predictor_0\n    }\n    const box_predictor_1 = {\n      box_encoding_predictor: box_encoding_1_predictor,\n      class_predictor: class_predictor_1\n    }\n    const box_predictor_2 = {\n      box_encoding_predictor: box_encoding_2_predictor,\n      class_predictor: class_predictor_2\n    }\n    const box_predictor_3 = {\n      box_encoding_predictor: box_encoding_3_predictor,\n      class_predictor: class_predictor_3\n    }\n    const box_predictor_4 = {\n      box_encoding_predictor: box_encoding_4_predictor,\n      class_predictor: class_predictor_4\n    }\n    const box_predictor_5 = {\n      box_encoding_predictor: box_encoding_5_predictor,\n      class_predictor: class_predictor_5\n    }\n\n    return {\n      conv_0,\n      conv_1,\n      conv_2,\n      conv_3,\n      conv_4,\n      conv_5,\n      conv_6,\n      conv_7,\n      box_predictor_0,\n      box_predictor_1,\n      box_predictor_2,\n      box_predictor_3,\n      box_predictor_4,\n      box_predictor_5\n    }\n  }\n\n  return {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams\n  }\n\n}\n\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams\n  } = extractorsFactory(extractWeights, paramMappings)\n\n  const mobilenetv1 = extractMobilenetV1Params()\n  const prediction_layer = extractPredictionLayerParams()\n  const extra_dim = tf.tensor3d(\n    extractWeights(5118 * 4),\n    [1, 5118, 4]\n  )\n  const output_layer = {\n    extra_dim\n  }\n\n  paramMappings.push({ paramPath: 'output_layer/extra_dim' })\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n  return {\n    params: {\n      mobilenetv1,\n      prediction_layer,\n      output_layer\n    },\n    paramMappings\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams, disposeUnusedWeightTensors, extractWeightEntryFactory, ParamMapping } from '../common';\nimport { isTensor3D } from '../utils';\nimport { BoxPredictionParams, MobileNetV1, NetParams, PointwiseConvParams, PredictionLayerParams } from './types';\n\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  function extractPointwiseConvParams(prefix: string, idx: number, mappedPrefix: string): PointwiseConvParams {\n\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/Conv2d_${idx}_pointwise/weights`, 4, `${mappedPrefix}/filters`)\n    const batch_norm_offset = extractWeightEntry<tf.Tensor1D>(`${prefix}/Conv2d_${idx}_pointwise/convolution_bn_offset`, 1, `${mappedPrefix}/batch_norm_offset`)\n\n    return { filters, batch_norm_offset }\n  }\n\n  function extractConvPairParams(idx: number): MobileNetV1.ConvPairParams {\n\n    const mappedPrefix = `mobilenetv1/conv_${idx}`\n    const prefixDepthwiseConv = `MobilenetV1/Conv2d_${idx}_depthwise`\n    const mappedPrefixDepthwiseConv = `${mappedPrefix}/depthwise_conv`\n    const mappedPrefixPointwiseConv = `${mappedPrefix}/pointwise_conv`\n\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefixDepthwiseConv}/depthwise_weights`, 4, `${mappedPrefixDepthwiseConv}/filters`)\n    const batch_norm_scale = extractWeightEntry<tf.Tensor1D>(`${prefixDepthwiseConv}/BatchNorm/gamma`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_scale`)\n    const batch_norm_offset = extractWeightEntry<tf.Tensor1D>(`${prefixDepthwiseConv}/BatchNorm/beta`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_offset`)\n    const batch_norm_mean = extractWeightEntry<tf.Tensor1D>(`${prefixDepthwiseConv}/BatchNorm/moving_mean`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_mean`)\n    const batch_norm_variance = extractWeightEntry<tf.Tensor1D>(`${prefixDepthwiseConv}/BatchNorm/moving_variance`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_variance`)\n\n    return {\n      depthwise_conv: {\n        filters,\n        batch_norm_scale,\n        batch_norm_offset,\n        batch_norm_mean,\n        batch_norm_variance\n      },\n      pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv)\n    }\n  }\n\n  function extractMobilenetV1Params(): MobileNetV1.Params {\n    return {\n      conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),\n      conv_1: extractConvPairParams(1),\n      conv_2: extractConvPairParams(2),\n      conv_3: extractConvPairParams(3),\n      conv_4: extractConvPairParams(4),\n      conv_5: extractConvPairParams(5),\n      conv_6: extractConvPairParams(6),\n      conv_7: extractConvPairParams(7),\n      conv_8: extractConvPairParams(8),\n      conv_9: extractConvPairParams(9),\n      conv_10: extractConvPairParams(10),\n      conv_11: extractConvPairParams(11),\n      conv_12: extractConvPairParams(12),\n      conv_13: extractConvPairParams(13)\n    }\n  }\n\n  function extractConvParams(prefix: string, mappedPrefix: string): ConvParams {\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/weights`, 4, `${mappedPrefix}/filters`)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/biases`, 1, `${mappedPrefix}/bias`)\n\n    return { filters, bias }\n  }\n\n  function extractBoxPredictorParams(idx: number): BoxPredictionParams {\n\n    const box_encoding_predictor = extractConvParams(\n      `Prediction/BoxPredictor_${idx}/BoxEncodingPredictor`,\n      `prediction_layer/box_predictor_${idx}/box_encoding_predictor`\n    )\n    const class_predictor = extractConvParams(\n      `Prediction/BoxPredictor_${idx}/ClassPredictor`,\n      `prediction_layer/box_predictor_${idx}/class_predictor`\n    )\n\n    return { box_encoding_predictor, class_predictor }\n  }\n\n  function extractPredictionLayerParams(): PredictionLayerParams {\n    return {\n      conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),\n      conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),\n      conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),\n      conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),\n      conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),\n      conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),\n      conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),\n      conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),\n      box_predictor_0: extractBoxPredictorParams(0),\n      box_predictor_1: extractBoxPredictorParams(1),\n      box_predictor_2: extractBoxPredictorParams(2),\n      box_predictor_3: extractBoxPredictorParams(3),\n      box_predictor_4: extractBoxPredictorParams(4),\n      box_predictor_5: extractBoxPredictorParams(5)\n    }\n  }\n\n  return {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams\n  }\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap\n): { params: NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractMobilenetV1Params,\n    extractPredictionLayerParams\n  } = extractorsFactory(weightMap, paramMappings)\n\n  const extra_dim = weightMap['Output/extra_dim']\n  paramMappings.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' })\n\n  if (!isTensor3D(extra_dim)) {\n    throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${extra_dim}`)\n  }\n\n  const params = {\n    mobilenetv1: extractMobilenetV1Params(),\n    prediction_layer: extractPredictionLayerParams(),\n    output_layer: {\n      extra_dim\n    }\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { PointwiseConvParams } from './types';\n\nexport function pointwiseConvLayer(\n  x: tf.Tensor4D,\n  params: PointwiseConvParams,\n  strides: [number, number]\n) {\n  return tf.tidy(() => {\n\n    let out = tf.conv2d(x, params.filters, strides, 'same')\n    out = tf.add(out, params.batch_norm_offset)\n    return tf.clipByValue(out, 0, 6)\n\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { pointwiseConvLayer } from './pointwiseConvLayer';\nimport { MobileNetV1 } from './types';\n\nconst epsilon = 0.0010000000474974513\n\nfunction depthwiseConvLayer(\n  x: tf.Tensor4D,\n  params: MobileNetV1.DepthwiseConvParams,\n  strides: [number, number]\n) {\n  return tf.tidy(() => {\n\n    let out = tf.depthwiseConv2d(x, params.filters, strides, 'same')\n    out = tf.batchNorm<tf.Rank.R4>(\n      out,\n      params.batch_norm_mean,\n      params.batch_norm_variance,\n      params.batch_norm_offset,\n      params.batch_norm_scale,\n      epsilon\n    )\n    return tf.clipByValue(out, 0, 6)\n\n  })\n}\n\nfunction getStridesForLayerIdx(layerIdx: number): [number, number] {\n  return [2, 4, 6, 12].some(idx => idx === layerIdx) ? [2, 2] : [1, 1]\n}\n\nexport function mobileNetV1(x: tf.Tensor4D, params: MobileNetV1.Params) {\n  return tf.tidy(() => {\n\n    let conv11;\n    let out = pointwiseConvLayer(x, params.conv_0, [2, 2])\n\n    const convPairParams = [\n      params.conv_1,\n      params.conv_2,\n      params.conv_3,\n      params.conv_4,\n      params.conv_5,\n      params.conv_6,\n      params.conv_7,\n      params.conv_8,\n      params.conv_9,\n      params.conv_10,\n      params.conv_11,\n      params.conv_12,\n      params.conv_13\n    ]\n\n    convPairParams.forEach((param, i) => {\n      const layerIdx = i + 1\n      const depthwiseConvStrides = getStridesForLayerIdx(layerIdx)\n      out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides)\n      out = pointwiseConvLayer(out, param.pointwise_conv, [1, 1])\n      if (layerIdx === 11) {\n        conv11 = out\n      }\n    })\n\n    if (conv11 === null) {\n      throw new Error('mobileNetV1 - output of conv layer 11 is null')\n    }\n\n    return {\n      out,\n      conv11: conv11 as any\n    }\n\n  })\n}", "import * as tf from '@tensorflow/tfjs'\n\nexport function nonMaxSuppression(\n  boxes: tf.Tensor2D,\n  scores: number[],\n  maxOutputSize: number,\n  iouThreshold: number,\n  scoreThreshold: number\n): number[] {\n\n  const numBoxes = boxes.shape[0]\n  const outputSize = Math.min(\n    maxOutputSize,\n    numBoxes\n  )\n\n  const candidates = scores\n    .map((score, boxIndex) => ({ score, boxIndex }))\n    .filter(c => c.score > scoreThreshold)\n    .sort((c1, c2) => c2.score - c1.score)\n\n  const suppressFunc = (x: number) => x <= iouThreshold ? 1 : 0\n\n  const selected: number[] = []\n\n  candidates.forEach(c => {\n    if (selected.length >= outputSize) {\n      return\n    }\n    const originalScore = c.score\n\n    for (let j = selected.length - 1; j >= 0; --j) {\n      const iou = IOU(boxes, c.boxIndex, selected[j])\n      if (iou === 0.0) {\n        continue\n      }\n      c.score *= suppressFunc(iou)\n      if (c.score <= scoreThreshold) {\n        break\n      }\n    }\n\n    if (originalScore === c.score) {\n      selected.push(c.boxIndex)\n    }\n  })\n\n  return selected\n}\n\nfunction IOU(boxes: tf.Tensor2D, i: number, j: number) {\n  const boxesData = boxes.arraySync()\n  const yminI = Math.min(boxesData[i][0], boxesData[i][2])\n  const xminI = Math.min(boxesData[i][1], boxesData[i][3])\n  const ymaxI = Math.max(boxesData[i][0], boxesData[i][2])\n  const xmaxI = Math.max(boxesData[i][1], boxesData[i][3])\n  const yminJ = Math.min(boxesData[j][0], boxesData[j][2])\n  const xminJ = Math.min(boxesData[j][1], boxesData[j][3])\n  const ymaxJ = Math.max(boxesData[j][0], boxesData[j][2])\n  const xmaxJ = Math.max(boxesData[j][1], boxesData[j][3])\n  const areaI = (ymaxI - yminI) * (xmaxI - xminI)\n  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ)\n  if (areaI <= 0 || areaJ <= 0) {\n    return 0.0\n  }\n  const intersectionYmin = Math.max(yminI, yminJ)\n  const intersectionXmin = Math.max(xminI, xminJ)\n  const intersectionYmax = Math.min(ymaxI, ymaxJ)\n  const intersectionXmax = Math.min(xmaxI, xmaxJ)\n  const intersectionArea =\n      Math.max(intersectionYmax - intersectionYmin, 0.0) *\n      Math.max(intersectionXmax - intersectionXmin, 0.0)\n  return intersectionArea / (areaI + areaJ - intersectionArea)\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { OutputLayerParams } from './types';\n\n\nfunction getCenterCoordinatesAndSizesLayer(x: tf.Tensor2D) {\n  const vec = tf.unstack(tf.transpose(x, [1, 0]))\n\n  const sizes = [\n    tf.sub(vec[2], vec[0]),\n    tf.sub(vec[3], vec[1])\n  ]\n\n  const centers = [\n    tf.add(vec[0], tf.div(sizes[0], tf.scalar(2))),\n    tf.add(vec[1], tf.div(sizes[1], tf.scalar(2)))\n  ]\n\n  return {\n    sizes,\n    centers\n  }\n}\n\nfunction decodeBoxesLayer(x0: tf.Tensor2D, x1: tf.Tensor2D) {\n  const {\n    sizes,\n    centers\n  } = getCenterCoordinatesAndSizesLayer(x0)\n\n  const vec = tf.unstack(tf.transpose(x1, [1, 0]))\n\n  const div0_out = tf.div(tf.mul(tf.exp(tf.div(vec[2], tf.scalar(5))), sizes[0]), tf.scalar(2))\n  const add0_out = tf.add(tf.mul(tf.div(vec[0], tf.scalar(10)), sizes[0]), centers[0])\n\n  const div1_out = tf.div(tf.mul(tf.exp(tf.div(vec[3], tf.scalar(5))), sizes[1]), tf.scalar(2))\n  const add1_out = tf.add(tf.mul(tf.div(vec[1], tf.scalar(10)), sizes[1]), centers[1])\n\n  return tf.transpose(\n    tf.stack([\n      tf.sub(add0_out, div0_out),\n      tf.sub(add1_out, div1_out),\n      tf.add(add0_out, div0_out),\n      tf.add(add1_out, div1_out)\n    ]),\n    [1, 0]\n  )\n}\n\nexport function outputLayer(\n  boxPredictions: tf.Tensor4D,\n  classPredictions: tf.Tensor4D,\n  params: OutputLayerParams\n) {\n  return tf.tidy(() => {\n\n    const batchSize = boxPredictions.shape[0]\n\n    let boxes = decodeBoxesLayer(\n      tf.reshape(tf.tile(params.extra_dim, [batchSize, 1, 1]), [-1, 4]) as tf.Tensor2D,\n      tf.reshape(boxPredictions, [-1, 4]) as tf.Tensor2D\n    )\n    boxes = tf.reshape(\n      boxes,\n      [batchSize, (boxes.shape[0] / batchSize), 4]\n    )\n\n    const scoresAndClasses = tf.sigmoid(tf.slice(classPredictions, [0, 0, 1], [-1, -1, -1]))\n    let scores = tf.slice(scoresAndClasses, [0, 0, 0], [-1, -1, 1]) as tf.Tensor\n\n    scores = tf.reshape(\n      scores,\n      [batchSize, scores.shape[1] as number]\n    )\n\n    const boxesByBatch = tf.unstack(boxes) as tf.Tensor2D[]\n    const scoresByBatch = tf.unstack(scores) as tf.Tensor1D[]\n\n    return {\n      boxes: boxesByBatch,\n      scores: scoresByBatch\n    }\n\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { convLayer } from '../common';\nimport { BoxPredictionParams } from './types';\n\n\nexport function boxPredictionLayer(\n  x: tf.Tensor4D,\n  params: BoxPredictionParams\n) {\n  return tf.tidy(() => {\n\n    const batchSize = x.shape[0]\n\n    const boxPredictionEncoding = tf.reshape(\n      convLayer(x, params.box_encoding_predictor),\n      [batchSize, -1, 1, 4]\n    )\n    const classPrediction = tf.reshape(\n      convLayer(x, params.class_predictor),\n      [batchSize, -1, 3]\n    )\n\n    return {\n      boxPredictionEncoding,\n      classPrediction\n    }\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { boxPredictionLayer } from './boxPredictionLayer';\nimport { pointwiseConvLayer } from './pointwiseConvLayer';\nimport { PredictionLayerParams } from './types';\n\nexport function predictionLayer(\n  x: tf.Tensor4D,\n  conv11: tf.Tensor4D,\n  params: PredictionLayerParams\n) {\n  return tf.tidy(() => {\n\n    const conv0 = pointwiseConvLayer(x, params.conv_0, [1, 1])\n    const conv1 = pointwiseConvLayer(conv0, params.conv_1, [2, 2])\n    const conv2 = pointwiseConvLayer(conv1, params.conv_2, [1, 1])\n    const conv3 = pointwiseConvLayer(conv2, params.conv_3, [2, 2])\n    const conv4 = pointwiseConvLayer(conv3, params.conv_4, [1, 1])\n    const conv5 = pointwiseConvLayer(conv4, params.conv_5, [2, 2])\n    const conv6 = pointwiseConvLayer(conv5, params.conv_6, [1, 1])\n    const conv7 = pointwiseConvLayer(conv6, params.conv_7, [2, 2])\n\n    const boxPrediction0 = boxPredictionLayer(conv11, params.box_predictor_0)\n    const boxPrediction1 = boxPredictionLayer(x, params.box_predictor_1)\n    const boxPrediction2 = boxPredictionLayer(conv1, params.box_predictor_2)\n    const boxPrediction3 = boxPredictionLayer(conv3, params.box_predictor_3)\n    const boxPrediction4 = boxPredictionLayer(conv5, params.box_predictor_4)\n    const boxPrediction5 = boxPredictionLayer(conv7, params.box_predictor_5)\n\n    const boxPredictions = tf.concat([\n      boxPrediction0.boxPredictionEncoding,\n      boxPrediction1.boxPredictionEncoding,\n      boxPrediction2.boxPredictionEncoding,\n      boxPrediction3.boxPredictionEncoding,\n      boxPrediction4.boxPredictionEncoding,\n      boxPrediction5.boxPredictionEncoding\n    ], 1) as tf.Tensor4D\n\n    const classPredictions = tf.concat([\n      boxPrediction0.classPrediction,\n      boxPrediction1.classPrediction,\n      boxPrediction2.classPrediction,\n      boxPrediction3.classPrediction,\n      boxPrediction4.classPrediction,\n      boxPrediction5.classPrediction\n    ], 1) as tf.Tensor4D\n\n    return {\n      boxPredictions,\n      classPredictions\n    }\n  })\n}", "export interface ISsdMobilenetv1Options {\n  minConfidence?: number\n  maxResults?: number\n}\n\nexport class SsdMobilenetv1Options {\n  protected _name: string = 'SsdMobilenetv1Options'\n\n  private _minConfidence: number\n  private _maxResults: number\n\n  constructor({ minConfidence, maxResults }: ISsdMobilenetv1Options = {}) {\n    this._minConfidence = minConfidence || 0.5\n    this._maxResults = maxResults || 100\n\n    if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {\n      throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`)\n    }\n\n    if (typeof this._maxResults !== 'number') {\n      throw new Error(`${this._name} - expected maxResults to be a number`)\n    }\n  }\n\n  get minConfidence(): number { return this._minConfidence }\n  get maxResults(): number { return this._maxResults }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { Rect } from '../classes';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { NetInput, TNetInput, toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { mobileNetV1 } from './mobileNetV1';\nimport { nonMaxSuppression } from './nonMaxSuppression';\nimport { outputLayer } from './outputLayer';\nimport { predictionLayer } from './predictionLayer';\nimport { ISsdMobilenetv1Options, SsdMobilenetv1Options } from './SsdMobilenetv1Options';\nimport { NetParams } from './types';\n\n\nexport class SsdMobilenetv1 extends NeuralNetwork<NetParams> {\n\n  constructor() {\n    super('SsdMobilenetv1')\n  }\n\n  public forwardInput(input: NetInput) {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error('SsdMobilenetv1 - load model before inference')\n    }\n\n    return tf.tidy(() => {\n      // const batchTensor = input.toBatchTensor(512, false).toFloat()\n      const batchTensor = tf.cast(input.toBatchTensor(512, false), 'float32');\n\n      const x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1)) as tf.Tensor4D\n      const features = mobileNetV1(x, params.mobilenetv1)\n\n      const {\n        boxPredictions,\n        classPredictions\n      } = predictionLayer(features.out, features.conv11, params.prediction_layer)\n\n      return outputLayer(boxPredictions, classPredictions, params.output_layer)\n    })\n  }\n\n  public async forward(input: TNetInput) {\n    return this.forwardInput(await toNetInput(input))\n  }\n\n  public async locateFaces(\n    input: TNetInput,\n    options: ISsdMobilenetv1Options = {}\n  ): Promise<FaceDetection[]> {\n\n    const { maxResults, minConfidence } = new SsdMobilenetv1Options(options)\n\n    const netInput = await toNetInput(input)\n\n    const {\n      boxes: _boxes,\n      scores: _scores\n    } = this.forwardInput(netInput)\n\n\n    // TODO batches\n    const boxes = _boxes[0]\n    const scores = _scores[0]\n    for (let i = 1; i < _boxes.length; i++) {\n      _boxes[i].dispose()\n      _scores[i].dispose()\n    }\n\n    // TODO find a better way to filter by minConfidence\n    const scoresData = Array.from(await scores.data())\n\n    const iouThreshold = 0.5\n    const indices = nonMaxSuppression(\n      boxes,\n      scoresData as number[],\n      maxResults,\n      iouThreshold,\n      minConfidence\n    )\n\n    const reshapedDims = netInput.getReshapedInputDimensions(0)\n    const inputSize = netInput.inputSize as number\n    const padX = inputSize / reshapedDims.width\n    const padY = inputSize / reshapedDims.height\n\n    const boxesData = boxes.arraySync()\n    const results = indices\n      .map(idx => {\n        const [top, bottom] = [\n          Math.max(0, boxesData[idx][0]),\n          Math.min(1.0, boxesData[idx][2])\n        ].map(val => val * padY)\n        const [left, right] = [\n          Math.max(0, boxesData[idx][1]),\n          Math.min(1.0, boxesData[idx][3])\n        ].map(val => val * padX)\n        return new FaceDetection(\n          scoresData[idx] as number,\n          new Rect(\n            left,\n            top,\n            right - left,\n            bottom - top\n          ),\n          {\n            height: netInput.getInputHeight(0),\n            width: netInput.getInputWidth(0)\n          }\n        )\n      })\n\n    boxes.dispose()\n    scores.dispose()\n\n    return results\n  }\n\n  protected getDefaultModelName(): string {\n    return 'ssd_mobilenetv1_model'\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap)\n  }\n\n  protected extractParams(weights: Float32Array) {\n    return extractParams(weights)\n  }\n}", "import { SsdMobilenetv1 } from './SsdMobilenetv1';\n\nexport * from './SsdMobilenetv1';\nexport * from './SsdMobilenetv1Options';\n\nexport function createSsdMobilenetv1(weights: Float32Array) {\n  const net = new SsdMobilenetv1()\n  net.extractWeights(weights)\n  return net\n}\n\nexport function createFaceDetectionNet(weights: Float32Array) {\n  return createSsdMobilenetv1(weights)\n}\n\n// alias for backward compatibily\nexport class FaceDetectionNet extends SsdMobilenetv1 {}", "import { Point } from '../classes';\n\nexport const IOU_THRESHOLD = 0.4\n\nexport const BOX_ANCHORS = [\n  new Point(0.738768, 0.874946),\n  new Point(2.42204, 2.65704),\n  new Point(4.30971, 7.04493),\n  new Point(10.246, 4.59428),\n  new Point(12.6868, 11.8741)\n]\n\nexport const BOX_ANCHORS_SEPARABLE = [\n  new Point(1.603231, 2.094468),\n  new Point(6.041143, 7.080126),\n  new Point(2.882459, 3.518061),\n  new Point(4.266906, 5.178857),\n  new Point(9.041765, 10.66308)\n]\n\nexport const MEAN_RGB_SEPARABLE: [number, number, number] = [117.001, 114.697, 97.404]\n\nexport const DEFAULT_MODEL_NAME = 'tiny_yolov2_model'\nexport const DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model'", "import { Point } from '../classes/Point';\n\nexport type TinyYolov2Config = {\n  withSeparableConvs: boolean\n  iouThreshold: number\n  anchors: Point[]\n  classes: string[]\n  meanRgb?: [number, number, number]\n  withClassScores?: boolean,\n  filterSizes?: number[]\n  isFirstLayerConv2d?: boolean\n}\n\nconst isNumber = (arg: any) => typeof arg === 'number'\n\nexport function validateConfig(config: any) {\n  if (!config) {\n    throw new Error(`invalid config: ${config}`)\n  }\n\n  if (typeof config.withSeparableConvs !== 'boolean') {\n    throw new Error(`config.withSeparableConvs has to be a boolean, have: ${config.withSeparableConvs}`)\n  }\n\n  if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {\n    throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${config.iouThreshold}`)\n  }\n\n  if (\n    !Array.isArray(config.classes)\n    || !config.classes.length\n    || !config.classes.every((c: any) => typeof c === 'string')\n  ) {\n\n    throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(config.classes)}`)\n  }\n\n  if (\n    !Array.isArray(config.anchors)\n    || !config.anchors.length\n    || !config.anchors.map((a: any) => a || {}).every((a: any) => isNumber(a.x) && isNumber(a.y))\n  ) {\n\n    throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(config.anchors)}`)\n  }\n\n  if (config.meanRgb && (\n    !Array.isArray(config.meanRgb)\n    || config.meanRgb.length !== 3\n    || !config.meanRgb.every(isNumber)\n  )) {\n\n    throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(config.meanRgb)}`)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nexport function leaky(x: tf.Tensor4D): tf.Tensor4D {\n  return tf.tidy(() => {\n    const min = tf.mul(x, tf.scalar(0.10000000149011612))\n    return tf.add(tf.relu(tf.sub(x, min)), min)\n    //return tf.maximum(x, min)\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { leaky } from './leaky';\nimport { ConvWithBatchNorm } from './types';\n\nexport function convWithBatchNorm(x: tf.Tensor4D, params: ConvWithBatchNorm): tf.Tensor4D  {\n  return tf.tidy(() => {\n    let out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]) as tf.Tensor4D\n\n    out = tf.conv2d(out, params.conv.filters, [1, 1], 'valid')\n    out = tf.sub(out, params.bn.sub)\n    out = tf.mul(out, params.bn.truediv)\n    out = tf.add(out, params.conv.bias)\n\n    return leaky(out)\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { SeparableConvParams } from '../common/types';\nimport { leaky } from './leaky';\n\nexport function depthwiseSeparableConv(x: tf.Tensor4D, params: SeparableConvParams): tf.Tensor4D  {\n  return tf.tidy(() => {\n    let out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]) as tf.Tensor4D\n\n    out = tf.separableConv2d(out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid')\n    out = tf.add(out, params.bias)\n\n    return leaky(out)\n  })\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { extractConvParamsFactory } from '../common';\nimport { extractSeparableConvParamsFactory } from '../common/extractSeparableConvParamsFactory';\nimport { extractWeightsFactory } from '../common/extractWeightsFactory';\nimport { ExtractWeightsFunction, ParamMapping } from '../common/types';\nimport { TinyYolov2Config } from './config';\nimport { BatchNorm, ConvWithBatchNorm, TinyYolov2NetParams } from './types';\n\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\n\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings)\n\n  function extractBatchNormParams(size: number, mappedPrefix: string): BatchNorm {\n\n    const sub = tf.tensor1d(extractWeights(size))\n    const truediv = tf.tensor1d(extractWeights(size))\n\n    paramMappings.push(\n      { paramPath: `${mappedPrefix}/sub` },\n      { paramPath: `${mappedPrefix}/truediv` }\n    )\n\n    return { sub, truediv }\n  }\n\n  function extractConvWithBatchNormParams(channelsIn: number, channelsOut: number, mappedPrefix: string): ConvWithBatchNorm {\n\n    const conv = extractConvParams(channelsIn, channelsOut, 3, `${mappedPrefix}/conv`)\n    const bn = extractBatchNormParams(channelsOut, `${mappedPrefix}/bn`)\n\n    return { conv, bn }\n  }\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings)\n\n  return {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams\n  }\n\n}\n\nexport function extractParams(\n  weights: Float32Array,\n  config: TinyYolov2Config,\n  boxEncodingSize: number,\n  filterSizes: number[]\n): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n\n  const {\n    extractWeights,\n    getRemainingWeights\n  } = extractWeightsFactory(weights)\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams\n  } = extractorsFactory(extractWeights, paramMappings)\n\n  let params: TinyYolov2NetParams\n\n  if (config.withSeparableConvs) {\n    const [s0, s1, s2, s3, s4, s5, s6, s7, s8] = filterSizes\n\n    const conv0 = config.isFirstLayerConv2d\n      ? extractConvParams(s0, s1, 3, 'conv0')\n      : extractSeparableConvParams(s0, s1, 'conv0')\n    const conv1 = extractSeparableConvParams(s1, s2, 'conv1')\n    const conv2 = extractSeparableConvParams(s2, s3, 'conv2')\n    const conv3 = extractSeparableConvParams(s3, s4, 'conv3')\n    const conv4 = extractSeparableConvParams(s4, s5, 'conv4')\n    const conv5 = extractSeparableConvParams(s5, s6, 'conv5')\n    const conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined\n    const conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined\n    const conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8')\n    params = { conv0, conv1, conv2, conv3, conv4, conv5, conv6, conv7, conv8 }\n  } else {\n    const [s0, s1, s2, s3, s4, s5, s6, s7, s8] = filterSizes\n    const conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0',)\n    const conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1')\n    const conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2')\n    const conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3')\n    const conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4')\n    const conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5')\n    const conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6')\n    const conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7')\n    const conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8')\n    params = { conv0, conv1, conv2, conv3, conv4, conv5, conv6, conv7, conv8 }\n  }\n\n  if (getRemainingWeights().length !== 0) {\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`)\n  }\n\n\n  return { params, paramMappings }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { ConvParams } from '../common';\nimport { disposeUnusedWeightTensors } from '../common/disposeUnusedWeightTensors';\nimport { loadSeparableConvParamsFactory } from '../common/extractSeparableConvParamsFactory';\nimport { extractWeightEntryFactory } from '../common/extractWeightEntryFactory';\nimport { ParamMapping } from '../common/types';\nimport { TinyYolov2Config } from './config';\nimport { BatchNorm, ConvWithBatchNorm, TinyYolov2NetParams } from './types';\n\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\n\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings)\n\n  function extractBatchNormParams(prefix: string): BatchNorm {\n    const sub = extractWeightEntry<tf.Tensor1D>(`${prefix}/sub`, 1)\n    const truediv = extractWeightEntry<tf.Tensor1D>(`${prefix}/truediv`, 1)\n    return { sub, truediv }\n  }\n\n  function extractConvParams(prefix: string): ConvParams {\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/filters`, 4)\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1)\n    return { filters, bias }\n  }\n\n  function extractConvWithBatchNormParams(prefix: string): ConvWithBatchNorm {\n    const conv = extractConvParams(`${prefix}/conv`)\n    const bn = extractBatchNormParams(`${prefix}/bn`)\n    return { conv, bn }\n  }\n\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry)\n\n  return {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams\n  }\n\n}\n\nexport function extractParamsFromWeigthMap(\n  weightMap: tf.NamedTensorMap,\n  config: TinyYolov2Config\n): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n\n  const paramMappings: ParamMapping[] = []\n\n  const {\n    extractConvParams,\n    extractConvWithBatchNormParams,\n    extractSeparableConvParams\n  } = extractorsFactory(weightMap, paramMappings)\n\n  let params: TinyYolov2NetParams\n\n  if (config.withSeparableConvs) {\n    const numFilters = (config.filterSizes && config.filterSizes.length || 9)\n    params = {\n      conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),\n      conv1: extractSeparableConvParams('conv1'),\n      conv2: extractSeparableConvParams('conv2'),\n      conv3: extractSeparableConvParams('conv3'),\n      conv4: extractSeparableConvParams('conv4'),\n      conv5: extractSeparableConvParams('conv5'),\n      conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,\n      conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,\n      conv8: extractConvParams('conv8')\n    }\n  } else {\n    params = {\n      conv0: extractConvWithBatchNormParams('conv0'),\n      conv1: extractConvWithBatchNormParams('conv1'),\n      conv2: extractConvWithBatchNormParams('conv2'),\n      conv3: extractConvWithBatchNormParams('conv3'),\n      conv4: extractConvWithBatchNormParams('conv4'),\n      conv5: extractConvWithBatchNormParams('conv5'),\n      conv6: extractConvWithBatchNormParams('conv6'),\n      conv7: extractConvWithBatchNormParams('conv7'),\n      conv8: extractConvParams('conv8')\n    }\n  }\n\n  disposeUnusedWeightTensors(weightMap, paramMappings)\n\n  return { params, paramMappings }\n}", "export enum TinyYolov2SizeType {\n  XS = 224,\n  SM = 320,\n  MD = 416,\n  LG = 608\n}\n\nexport interface ITinyYolov2Options {\n  inputSize?: number\n  scoreThreshold?: number\n}\n\nexport class TinyYolov2Options {\n  protected _name: string = 'TinyYolov2Options'\n\n  private _inputSize: number\n  private _scoreThreshold: number\n\n  constructor({ inputSize, scoreThreshold }: ITinyYolov2Options = {}) {\n    this._inputSize = inputSize || 416\n    this._scoreThreshold = scoreThreshold || 0.5\n\n    if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {\n      throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`)\n    }\n\n    if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {\n      throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)\n    }\n  }\n\n  get inputSize(): number { return this._inputSize }\n  get scoreThreshold(): number { return this._scoreThreshold }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { BoundingBox } from '../classes/BoundingBox';\nimport { Dimensions } from '../classes/Dimensions';\nimport { ObjectDetection } from '../classes/ObjectDetection';\nimport { convLayer } from '../common';\nimport { ConvParams, SeparableConvParams } from '../common/types';\nimport { toNetInput } from '../dom';\nimport { NetInput } from '../dom/NetInput';\nimport { TNetInput } from '../dom/types';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { sigmoid } from '../ops';\nimport { nonMaxSuppression } from '../ops/nonMaxSuppression';\nimport { normalize } from '../ops/normalize';\nimport { TinyYolov2Config, validateConfig } from './config';\nimport { convWithBatchNorm } from './convWithBatchNorm';\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { leaky } from './leaky';\nimport { ITinyYolov2Options, TinyYolov2Options } from './TinyYolov2Options';\nimport { DefaultTinyYolov2NetParams, MobilenetParams, TinyYolov2NetParams } from './types';\n\nexport class TinyYolov2Base extends NeuralNetwork<TinyYolov2NetParams> {\n\n  public static DEFAULT_FILTER_SIZES = [\n    3, 16, 32, 64, 128, 256, 512, 1024, 1024\n  ]\n\n  private _config: TinyYolov2Config\n\n  constructor(config: TinyYolov2Config) {\n    super('TinyYolov2')\n    validateConfig(config)\n    this._config = config\n  }\n\n  public get config(): TinyYolov2Config {\n    return this._config\n  }\n\n  public get withClassScores(): boolean {\n    return this.config.withClassScores || this.config.classes.length > 1\n  }\n\n  public get boxEncodingSize(): number {\n    return 5 + (this.withClassScores ? this.config.classes.length : 0)\n  }\n\n  public runTinyYolov2(x: tf.Tensor4D, params: DefaultTinyYolov2NetParams): tf.Tensor4D {\n\n    let out = convWithBatchNorm(x, params.conv0)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = convWithBatchNorm(out, params.conv1)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = convWithBatchNorm(out, params.conv2)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = convWithBatchNorm(out, params.conv3)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = convWithBatchNorm(out, params.conv4)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = convWithBatchNorm(out, params.conv5)\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same')\n    out = convWithBatchNorm(out, params.conv6)\n    out = convWithBatchNorm(out, params.conv7)\n\n    return convLayer(out, params.conv8, 'valid', false)\n  }\n\n  public runMobilenet(x: tf.Tensor4D, params: MobilenetParams): tf.Tensor4D {\n\n    let out = this.config.isFirstLayerConv2d\n      ? leaky(convLayer(x, params.conv0 as ConvParams, 'valid', false))\n      : depthwiseSeparableConv(x, params.conv0 as SeparableConvParams)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = depthwiseSeparableConv(out, params.conv1)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = depthwiseSeparableConv(out, params.conv2)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = depthwiseSeparableConv(out, params.conv3)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = depthwiseSeparableConv(out, params.conv4)\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\n    out = depthwiseSeparableConv(out, params.conv5)\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same')\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out\n\n    return convLayer(out, params.conv8, 'valid', false)\n  }\n\n  public forwardInput(input: NetInput, inputSize: number): tf.Tensor4D {\n\n    const { params } = this\n\n    if (!params) {\n      throw new Error('TinyYolov2 - load model before inference')\n    }\n\n    return tf.tidy(() => {\n\n      // let batchTensor = input.toBatchTensor(inputSize, false).toFloat()\n      let batchTensor = tf.cast(input.toBatchTensor(inputSize, false), 'float32');\n      batchTensor = this.config.meanRgb\n        ? normalize(batchTensor, this.config.meanRgb)\n        : batchTensor\n      batchTensor = batchTensor.div(tf.scalar(256)) as tf.Tensor4D\n\n      return this.config.withSeparableConvs\n        ? this.runMobilenet(batchTensor, params as MobilenetParams)\n        : this.runTinyYolov2(batchTensor, params as DefaultTinyYolov2NetParams)\n    })\n  }\n\n  public async forward(input: TNetInput, inputSize: number): Promise<tf.Tensor4D> {\n    return await this.forwardInput(await toNetInput(input), inputSize)\n  }\n\n  public async detect(input: TNetInput, forwardParams: ITinyYolov2Options = {}): Promise<ObjectDetection[]> {\n\n    const { inputSize, scoreThreshold } = new TinyYolov2Options(forwardParams)\n\n    const netInput = await toNetInput(input)\n    const out = await this.forwardInput(netInput, inputSize)\n    const out0 = tf.tidy(() => tf.unstack(out)[0].expandDims()) as tf.Tensor4D\n\n    const inputDimensions = {\n      width: netInput.getInputWidth(0),\n      height: netInput.getInputHeight(0)\n    }\n\n    const results = await this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)\n    out.dispose()\n    out0.dispose()\n\n    const boxes = results.map(res => res.box)\n    const scores = results.map(res => res.score)\n    const classScores = results.map(res => res.classScore)\n    const classNames = results.map(res => this.config.classes[res.label])\n\n    const indices = nonMaxSuppression(\n      boxes.map(box => box.rescale(inputSize)),\n      scores,\n      this.config.iouThreshold,\n      true\n    )\n\n    const detections = indices.map(idx =>\n      new ObjectDetection(\n        scores[idx],\n        classScores[idx],\n        classNames[idx],\n        boxes[idx],\n        inputDimensions\n      )\n    )\n\n    return detections\n  }\n\n  protected getDefaultModelName(): string {\n    return ''\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\n    return extractParamsFromWeigthMap(weightMap, this.config)\n  }\n\n  protected extractParams(weights: Float32Array) {\n    const filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES\n\n    const numFilters = filterSizes ? filterSizes.length : undefined\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n      throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${numFilters} filterSizes in config`)\n    }\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes)\n  }\n\n  protected async extractBoxes(\n    outputTensor: tf.Tensor4D,\n    inputBlobDimensions: Dimensions,\n    scoreThreshold?: number\n  ) {\n\n    const { width, height } = inputBlobDimensions\n    const inputSize = Math.max(width, height)\n    const correctionFactorX = inputSize / width\n    const correctionFactorY = inputSize / height\n\n    const numCells = outputTensor.shape[1]\n    const numBoxes = this.config.anchors.length\n\n    const [boxesTensor, scoresTensor, classScoresTensor] = tf.tidy(() => {\n      const reshaped = outputTensor.reshape([numCells, numCells, numBoxes, this.boxEncodingSize])\n\n      const boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4])\n      const scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1])\n      const classScores = this.withClassScores\n        ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, this.config.classes.length]), 3)\n        : tf.scalar(0)\n      return [boxes, scores, classScores]\n    })\n\n    const results = [] as any;\n\n    const scoresData = await scoresTensor.array()\n    const boxesData = await boxesTensor.array()\n    for (let row = 0; row < numCells; row ++) {\n      for (let col = 0; col < numCells; col ++) {\n        for (let anchor = 0; anchor < numBoxes; anchor ++) {\n\n          const score = sigmoid(scoresData[row][col][anchor][0]);\n          if (!scoreThreshold || score > scoreThreshold) {\n            const ctX = ((col + sigmoid(boxesData[row][col][anchor][0])) / numCells) * correctionFactorX\n            const ctY = ((row + sigmoid(boxesData[row][col][anchor][1])) / numCells) * correctionFactorY\n            const width = ((Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x) / numCells) * correctionFactorX\n            const height = ((Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y) / numCells) * correctionFactorY\n\n            const x = (ctX - (width / 2))\n            const y = (ctY - (height / 2))\n\n            const pos = { row, col, anchor }\n            const { classScore, label } = this.withClassScores\n              ? await this.extractPredictedClass(classScoresTensor as tf.Tensor4D, pos)\n              : { classScore: 1, label: 0 }\n\n            results.push({\n              box: new BoundingBox(x, y, x + width, y + height),\n              score: score,\n              classScore: score * classScore,\n              label,\n              ...pos\n            })\n          }\n        }\n      }\n    }\n\n    boxesTensor.dispose()\n    scoresTensor.dispose()\n    classScoresTensor.dispose()\n\n    return results\n  }\n\n  private async extractPredictedClass(classesTensor: tf.Tensor4D, pos: { row: number, col: number, anchor: number },) {\n    const { row, col, anchor } = pos\n    const classesData = await classesTensor.array()\n    return Array(this.config.classes.length).fill(0)\n      .map((_, i) => classesData[row][col][anchor][i])\n      .map((classScore, label) => ({\n        classScore,\n        label\n      }))\n      .reduce((max, curr) => max.classScore > curr.classScore ? max : curr)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { FaceDetection, Point } from '../classes';\nimport { ParamMapping } from '../common/types';\nimport { TNetInput } from '../dom/types';\nimport {\n  BOX_ANCHORS,\n  BOX_ANCHORS_SEPARABLE,\n  DEFAULT_MODEL_NAME,\n  DEFAULT_MODEL_NAME_SEPARABLE_CONV,\n  IOU_THRESHOLD,\n  MEAN_RGB_SEPARABLE,\n} from './const';\nimport { TinyYolov2Base } from './TinyYolov2Base';\nimport { ITinyYolov2Options } from './TinyYolov2Options';\nimport { TinyYolov2NetParams } from './types';\n\nexport class TinyYolov2 extends TinyYolov2Base {\n\n  constructor(withSeparableConvs: boolean = true) {\n    const config = Object.assign({}, {\n      withSeparableConvs,\n      iouThreshold: IOU_THRESHOLD,\n      classes: ['face']\n    },\n    withSeparableConvs\n      ? {\n        anchors: BOX_ANCHORS_SEPARABLE,\n        meanRgb: MEAN_RGB_SEPARABLE\n      }\n      : {\n        anchors: BOX_ANCHORS,\n        withClassScores: true\n      }\n    )\n\n    super(config)\n  }\n\n  public get withSeparableConvs(): boolean {\n    return this.config.withSeparableConvs\n  }\n\n  public get anchors(): Point[] {\n    return this.config.anchors\n  }\n\n  public async locateFaces(input: TNetInput, forwardParams: ITinyYolov2Options): Promise<FaceDetection[]> {\n    const objectDetections = await this.detect(input, forwardParams)\n    return objectDetections.map(det => new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }))\n  }\n\n  protected getDefaultModelName(): string {\n    return this.withSeparableConvs ? DEFAULT_MODEL_NAME_SEPARABLE_CONV : DEFAULT_MODEL_NAME\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n    return super.extractParamsFromWeigthMap(weightMap)\n  }\n}", "import { TinyYolov2 } from './TinyYolov2';\n\nexport * from './TinyYolov2Options';\n\nexport * from './config'\nexport * from './types'\n\nexport { TinyYolov2 }\n\nexport function createTinyYolov2(weights: Float32Array, withSeparableConvs: boolean = true) {\n  const net = new TinyYolov2(withSeparableConvs)\n  net.extractWeights(weights)\n  return net\n}", "import { ITinyYolov2Options, TinyYolov2Options } from '../tinyYolov2';\n\nexport interface ITinyFaceDetectorOptions extends ITinyYolov2Options {}\n\nexport class TinyFaceDetectorOptions extends TinyYolov2Options {\n  protected _name: string = 'TinyFaceDetectorOptions'\n}", "export class ComposableTask<T> {\n\n  public async then(\n    onfulfilled: (value: T) => T | PromiseLike<T>\n  ): Promise<T> {\n    return onfulfilled(await this.run())\n  }\n\n  public async run(): Promise<T> {\n    throw new Error('ComposableTask - run is not implemented')\n  }\n}\n", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { extractFaces, extractFaceTensors, TNetInput } from '../dom';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { isWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\n\nexport async function extractAllFacesAndComputeResults<TSource extends WithFaceDetection<{}>, TResult>(\n  parentResults: TSource[],\n  input: TNetInput,\n  computeResults: (faces: Array<HTMLCanvasElement | tf.Tensor3D>) => Promise<TResult>,\n  extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D> | null,\n  getRectForAlignment: (parentResult: WithFaceLandmarks<TSource, any>) => FaceDetection = ({ alignedRect }) => alignedRect\n) {\n  const faceBoxes = parentResults.map(parentResult =>\n    isWithFaceLandmarks(parentResult)\n      ? getRectForAlignment(parentResult)\n      : parentResult.detection\n  )\n  const faces: Array<HTMLCanvasElement | tf.Tensor3D> = extractedFaces || (\n    input instanceof tf.Tensor\n      ? await extractFaceTensors(input, faceBoxes)\n      : await extractFaces(input, faceBoxes)\n  )\n\n  const results = await computeResults(faces)\n\n  faces.forEach(f => f instanceof tf.Tensor && f.dispose())\n\n  return results\n}\n\nexport async function extractSingleFaceAndComputeResult<TSource extends WithFaceDetection<{}>, TResult>(\n  parentResult: TSource,\n  input: TNetInput,\n  computeResult: (face: HTMLCanvasElement | tf.Tensor3D) => Promise<TResult>,\n  extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D> | null,\n  getRectForAlignment?: (parentResult: WithFaceLandmarks<TSource, any>) => FaceDetection\n) {\n  return extractAllFacesAndComputeResults<TSource, TResult>(\n    [parentResult],\n    input,\n    async faces => computeResult(faces[0]),\n    extractedFaces,\n    getRectForAlignment\n  )\n}", "import { Point } from '../classes'\n\nexport const IOU_THRESHOLD = 0.4\n\nexport const BOX_ANCHORS = [\n  new Point(1.603231, 2.094468),\n  new Point(6.041143, 7.080126),\n  new Point(2.882459, 3.518061),\n  new Point(4.266906, 5.178857),\n  new Point(9.041765, 10.66308)\n]\n\nexport const MEAN_RGB: [number, number, number] = [117.001, 114.697, 97.404]", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { FaceDetection, Point } from '../classes';\nimport { ParamMapping } from '../common';\nimport { TNetInput } from '../dom';\nimport { ITinyYolov2Options } from '../tinyYolov2';\nimport { TinyYolov2Base } from '../tinyYolov2/TinyYolov2Base';\nimport { TinyYolov2NetParams } from '../tinyYolov2/types';\nimport { BOX_ANCHORS, IOU_THRESHOLD, MEAN_RGB } from './const';\n\nexport class TinyFaceDetector extends TinyYolov2Base {\n\n  constructor() {\n    const config = {\n      withSeparableConvs: true,\n      iouThreshold: IOU_THRESHOLD,\n      classes: ['face'],\n      anchors: BOX_ANCHORS,\n      meanRgb: MEAN_RGB,\n      isFirstLayerConv2d: true,\n      filterSizes: [3, 16, 32, 64, 128, 256, 512]\n    }\n\n    super(config)\n  }\n\n  public get anchors(): Point[] {\n    return this.config.anchors\n  }\n\n  public async locateFaces(input: TNetInput, forwardParams: ITinyYolov2Options): Promise<FaceDetection[]> {\n    const objectDetections = await this.detect(input, forwardParams)\n    return objectDetections.map(det => new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }))\n  }\n\n  protected getDefaultModelName(): string {\n    return 'tiny_face_detector_model'\n  }\n\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\n    return super.extractParamsFromWeigthMap(weightMap)\n  }\n}", "import { AgeGenderNet } from '../ageGenderNet/AgeGenderNet';\nimport { AgeAndGenderPrediction } from '../ageGenderNet/types';\nimport { FaceDetection } from '../classes/FaceDetection';\nimport { FaceLandmarks5 } from '../classes/FaceLandmarks5';\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { TNetInput } from '../dom';\nimport { FaceExpressionNet } from '../faceExpressionNet/FaceExpressionNet';\nimport { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\nimport { FaceLandmark68Net } from '../faceLandmarkNet/FaceLandmark68Net';\nimport { FaceLandmark68TinyNet } from '../faceLandmarkNet/FaceLandmark68TinyNet';\nimport { FaceRecognitionNet } from '../faceRecognitionNet/FaceRecognitionNet';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { SsdMobilenetv1 } from '../ssdMobilenetv1/SsdMobilenetv1';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\nimport { TinyFaceDetector } from '../tinyFaceDetector/TinyFaceDetector';\nimport { TinyFaceDetectorOptions } from '../tinyFaceDetector/TinyFaceDetectorOptions';\nimport { ITinyYolov2Options, TinyYolov2 } from '../tinyYolov2';\n\nexport const nets = {\n  ssdMobilenetv1: new SsdMobilenetv1(),\n  tinyFaceDetector: new TinyFaceDetector(),\n  tinyYolov2: new TinyYolov2(),\n  faceLandmark68Net: new FaceLandmark68Net(),\n  faceLandmark68TinyNet: new FaceLandmark68TinyNet(),\n  faceRecognitionNet: new FaceRecognitionNet(),\n  faceExpressionNet: new FaceExpressionNet(),\n  ageGenderNet: new AgeGenderNet()\n}\n\n/**\n * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.\n *\n * @param input The input image.\n * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).\n * @returns Bounding box of each face with score.\n */\nexport const ssdMobilenetv1 = (input: TNetInput, options: SsdMobilenetv1Options): Promise<FaceDetection[]> =>\n  nets.ssdMobilenetv1.locateFaces(input, options)\n\n/**\n * Attempts to detect all faces in an image using the Tiny Face Detector.\n *\n * @param input The input image.\n * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).\n * @returns Bounding box of each face with score.\n */\nexport const tinyFaceDetector = (input: TNetInput, options: TinyFaceDetectorOptions): Promise<FaceDetection[]> =>\n  nets.tinyFaceDetector.locateFaces(input, options)\n\n/**\n * Attempts to detect all faces in an image using the Tiny Yolov2 Network.\n *\n * @param input The input image.\n * @param options (optional, default: see TinyYolov2Options constructor for default parameters).\n * @returns Bounding box of each face with score.\n */\nexport const tinyYolov2 = (input: TNetInput, options: ITinyYolov2Options): Promise<FaceDetection[]> =>\n  nets.tinyYolov2.locateFaces(input, options)\n\n/**\n * Detects the 68 point face landmark positions of the face shown in an image.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns 68 point face landmarks or array thereof in case of batch input.\n */\nexport const detectFaceLandmarks = (input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> =>\n  nets.faceLandmark68Net.detectLandmarks(input)\n\n/**\n * Detects the 68 point face landmark positions of the face shown in an image\n * using a tinier version of the 68 point face landmark model, which is slightly\n * faster at inference, but also slightly less accurate.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns 68 point face landmarks or array thereof in case of batch input.\n */\nexport const detectFaceLandmarksTiny = (input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]>  =>\n  nets.faceLandmark68TinyNet.detectLandmarks(input)\n\n/**\n * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,\n * which uniquely represents the features of that persons face. The computed face descriptor can\n * be used to measure the similarity between faces, by computing the euclidean distance of two\n * face descriptors.\n *\n * @param inputs The face image extracted from the aligned bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns Face descriptor with 128 entries or array thereof in case of batch input.\n */\nexport const computeFaceDescriptor = (input: TNetInput): Promise<Float32Array | Float32Array[]>  =>\n  nets.faceRecognitionNet.computeFaceDescriptor(input)\n\n\n/**\n * Recognizes the facial expressions from a face image.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns Facial expressions with corresponding probabilities or array thereof in case of batch input.\n */\nexport const recognizeFaceExpressions = (input: TNetInput): Promise<FaceExpressions | FaceExpressions[]> =>\n  nets.faceExpressionNet.predictExpressions(input)\n\n/**\n * Predicts age and gender from a face image.\n *\n * @param inputs The face image extracted from the bounding box of a face. Can\n * also be an array of input images, which will be batch processed.\n * @returns Predictions with age, gender and gender probability or array thereof in case of batch input.\n */\nexport const predictAgeAndGender = (input: TNetInput): Promise<AgeAndGenderPrediction | AgeAndGenderPrediction[]> =>\n  nets.ageGenderNet.predictAgeAndGender(input)\n\nexport const loadSsdMobilenetv1Model = (url: string) => nets.ssdMobilenetv1.load(url)\nexport const loadTinyFaceDetectorModel = (url: string) => nets.tinyFaceDetector.load(url)\nexport const loadTinyYolov2Model = (url: string) => nets.tinyYolov2.load(url)\nexport const loadFaceLandmarkModel = (url: string) => nets.faceLandmark68Net.load(url)\nexport const loadFaceLandmarkTinyModel = (url: string) => nets.faceLandmark68TinyNet.load(url)\nexport const loadFaceRecognitionModel = (url: string) => nets.faceRecognitionNet.load(url)\nexport const loadFaceExpressionModel = (url: string) => nets.faceExpressionNet.load(url)\nexport const loadAgeGenderModel = (url: string) => nets.ageGenderNet.load(url)\n\n// backward compatibility\nexport const loadFaceDetectionModel = loadSsdMobilenetv1Model\nexport const locateFaces = ssdMobilenetv1\nexport const detectLandmarks = detectFaceLandmarks", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { TNetInput } from '../dom';\nimport { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { extendWithFaceExpressions, WithFaceExpressions } from '../factories/WithFaceExpressions';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\nimport { nets } from './nets';\nimport {\n  PredictAllAgeAndGenderTask,\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\n  PredictSingleAgeAndGenderTask,\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\n} from './PredictAgeAndGenderTask';\n\nexport class PredictFaceExpressionsTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    protected input: TNetInput,\n    protected extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D>\n  ) {\n    super()\n  }\n}\n\nexport class PredictAllFaceExpressionsTask<\n  TSource extends WithFaceDetection<{}>\n> extends PredictFaceExpressionsTaskBase<WithFaceExpressions<TSource>[], TSource[]> {\n\n  public async run(): Promise<WithFaceExpressions<TSource>[]> {\n\n    const parentResults = await this.parentTask\n\n    const faceExpressionsByFace = await extractAllFacesAndComputeResults<TSource, FaceExpressions[]>(\n      parentResults,\n      this.input,\n      async faces => await Promise.all(faces.map(\n        face => nets.faceExpressionNet.predictExpressions(face) as Promise<FaceExpressions>\n      )),\n      this.extractedFaces\n    )\n\n    return parentResults.map(\n      (parentResult, i) => extendWithFaceExpressions<TSource>(parentResult, faceExpressionsByFace[i])\n    )\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderTask(this, this.input)\n  }\n}\n\nexport class PredictSingleFaceExpressionsTask<\n  TSource extends WithFaceDetection<{}>\n>  extends PredictFaceExpressionsTaskBase<WithFaceExpressions<TSource> | undefined, TSource | undefined> {\n\n  public async run(): Promise<WithFaceExpressions<TSource> | undefined> {\n\n    const parentResult = await this.parentTask\n    if (!parentResult) {\n      return\n    }\n\n    const faceExpressions = await extractSingleFaceAndComputeResult<TSource, FaceExpressions>(\n      parentResult,\n      this.input,\n      face => nets.faceExpressionNet.predictExpressions(face) as Promise<FaceExpressions>,\n      this.extractedFaces\n    )\n\n    return extendWithFaceExpressions(parentResult, faceExpressions)\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderTask(this, this.input)\n  }\n}\n\nexport class PredictAllFaceExpressionsWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictAllFaceExpressionsTask<TSource> {\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input)\n  }\n\n  withFaceDescriptors() {\n    return new ComputeAllFaceDescriptorsTask(this, this.input)\n  }\n}\n\nexport class PredictSingleFaceExpressionsWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictSingleFaceExpressionsTask<TSource> {\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input)\n  }\n\n  withFaceDescriptor() {\n    return new ComputeSingleFaceDescriptorTask(this, this.input)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { AgeAndGenderPrediction } from '../ageGenderNet/types';\nimport { TNetInput } from '../dom';\nimport { extendWithAge, WithAge } from '../factories/WithAge';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { extendWithGender, WithGender } from '../factories/WithGender';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\nimport { nets } from './nets';\nimport {\n  PredictAllFaceExpressionsTask,\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\n  PredictSingleFaceExpressionsTask,\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\n} from './PredictFaceExpressionsTask';\n\nexport class PredictAgeAndGenderTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    protected input: TNetInput,\n    protected extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D>\n  ) {\n    super()\n  }\n}\n\nexport class PredictAllAgeAndGenderTask<\n  TSource extends WithFaceDetection<{}>\n> extends PredictAgeAndGenderTaskBase<WithAge<WithGender<TSource>>[], TSource[]> {\n\n  public async run(): Promise<WithAge<WithGender<TSource>>[]> {\n\n    const parentResults = await this.parentTask\n\n    const ageAndGenderByFace = await extractAllFacesAndComputeResults<TSource, AgeAndGenderPrediction[]>(\n      parentResults,\n      this.input,\n      async faces => await Promise.all(faces.map(\n        face => nets.ageGenderNet.predictAgeAndGender(face) as Promise<AgeAndGenderPrediction>\n      )),\n      this.extractedFaces\n    )\n\n    return parentResults.map((parentResult, i) => {\n      const { age, gender, genderProbability } = ageAndGenderByFace[i]\n      return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age)\n    })\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsTask(this, this.input)\n  }\n}\n\nexport class PredictSingleAgeAndGenderTask<\n  TSource extends WithFaceDetection<{}>\n>  extends PredictAgeAndGenderTaskBase<WithAge<WithGender<TSource>> | undefined, TSource | undefined> {\n\n  public async run(): Promise<WithAge<WithGender<TSource>> | undefined> {\n\n    const parentResult = await this.parentTask\n    if (!parentResult) {\n      return\n    }\n\n    const { age, gender, genderProbability } = await extractSingleFaceAndComputeResult<TSource, AgeAndGenderPrediction>(\n      parentResult,\n      this.input,\n      face => nets.ageGenderNet.predictAgeAndGender(face) as Promise<AgeAndGenderPrediction>,\n      this.extractedFaces\n    )\n\n    return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age)\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsTask(this, this.input)\n  }\n}\n\nexport class PredictAllAgeAndGenderWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictAllAgeAndGenderTask<TSource> {\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input)\n  }\n\n  withFaceDescriptors() {\n    return new ComputeAllFaceDescriptorsTask(this, this.input)\n  }\n}\n\nexport class PredictSingleAgeAndGenderWithFaceAlignmentTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends PredictSingleAgeAndGenderTask<TSource> {\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input)\n  }\n\n  withFaceDescriptor() {\n    return new ComputeSingleFaceDescriptorTask(this, this.input)\n  }\n}", "import { TNetInput } from '../dom';\nimport { extendWithFaceDescriptor, WithFaceDescriptor } from '../factories/WithFaceDescriptor';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\nimport { nets } from './nets';\nimport {\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\n} from './PredictAgeAndGenderTask';\nimport {\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\n} from './PredictFaceExpressionsTask';\n\nexport class ComputeFaceDescriptorsTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    protected input: TNetInput\n  ) {\n    super()\n  }\n}\n\nexport class ComputeAllFaceDescriptorsTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends ComputeFaceDescriptorsTaskBase<WithFaceDescriptor<TSource>[], TSource[]> {\n\n  public async run(): Promise<WithFaceDescriptor<TSource>[]> {\n\n    const parentResults = await this.parentTask\n\n    const descriptors = await extractAllFacesAndComputeResults<TSource, Float32Array[]>(\n      parentResults,\n      this.input,\n      faces => Promise.all(faces.map(face =>\n        nets.faceRecognitionNet.computeFaceDescriptor(face) as Promise<Float32Array>\n      )),\n      null,\n      parentResult => parentResult.landmarks.align(null, { useDlibAlignment: true })\n    )\n\n    return descriptors.map((descriptor, i) => extendWithFaceDescriptor<TSource>(parentResults[i], descriptor))\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input)\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input)\n  }\n}\n\nexport class ComputeSingleFaceDescriptorTask<\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\n> extends ComputeFaceDescriptorsTaskBase<WithFaceDescriptor<TSource> | undefined, TSource | undefined> {\n\n  public async run(): Promise<WithFaceDescriptor<TSource> | undefined> {\n\n    const parentResult = await this.parentTask\n    if (!parentResult) {\n      return\n    }\n    const descriptor = await extractSingleFaceAndComputeResult<TSource, Float32Array>(\n      parentResult,\n      this.input,\n      face => nets.faceRecognitionNet.computeFaceDescriptor(face) as Promise<Float32Array>,\n      null,\n      parentResult => parentResult.landmarks.align(null, { useDlibAlignment: true })\n    )\n\n    return extendWithFaceDescriptor(parentResult, descriptor)\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input)\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input)\n  }\n}", "import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\nimport { extractFaces, extractFaceTensors, TNetInput } from '../dom';\nimport { FaceLandmark68Net } from '../faceLandmarkNet/FaceLandmark68Net';\nimport { FaceLandmark68TinyNet } from '../faceLandmarkNet/FaceLandmark68TinyNet';\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\nimport { extendWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\nimport { ComposableTask } from './ComposableTask';\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\nimport { nets } from './nets';\nimport {\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\n} from './PredictAgeAndGenderTask';\nimport {\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\n} from './PredictFaceExpressionsTask';\n\nexport class DetectFaceLandmarksTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\n  constructor(\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\n    protected input: TNetInput,\n    protected useTinyLandmarkNet: boolean\n  ) {\n    super()\n  }\n\n  protected get landmarkNet(): FaceLandmark68Net | FaceLandmark68TinyNet {\n    return this.useTinyLandmarkNet\n      ? nets.faceLandmark68TinyNet\n      : nets.faceLandmark68Net\n  }\n}\n\nexport class DetectAllFaceLandmarksTask<\n  TSource extends WithFaceDetection<{}>\n> extends DetectFaceLandmarksTaskBase<WithFaceLandmarks<TSource>[], TSource[]> {\n\n  public async run(): Promise<WithFaceLandmarks<TSource>[]> {\n\n    const parentResults = await this.parentTask\n    const detections = parentResults.map(res => res.detection)\n\n    const faces: Array<HTMLCanvasElement | tf.Tensor3D> = this.input instanceof tf.Tensor\n      ? await extractFaceTensors(this.input, detections)\n      : await extractFaces(this.input, detections)\n\n    const faceLandmarksByFace = await Promise.all(faces.map(\n      face => this.landmarkNet.detectLandmarks(face)\n    )) as FaceLandmarks68[]\n\n    faces.forEach(f => f instanceof tf.Tensor && f.dispose())\n\n    return parentResults.map((parentResult, i) =>\n      extendWithFaceLandmarks<TSource>(parentResult, faceLandmarksByFace[i])\n    )\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input)\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input)\n  }\n\n  withFaceDescriptors() {\n    return new ComputeAllFaceDescriptorsTask(this, this.input)\n  }\n}\n\nexport class DetectSingleFaceLandmarksTask<\n  TSource extends WithFaceDetection<{}>\n>  extends DetectFaceLandmarksTaskBase<WithFaceLandmarks<TSource> | undefined, TSource | undefined> {\n\n  public async run(): Promise<WithFaceLandmarks<TSource> | undefined> {\n\n    const parentResult = await this.parentTask\n    if (!parentResult) {\n      return\n    }\n\n    const { detection } = parentResult\n    const faces: Array<HTMLCanvasElement | tf.Tensor3D> = this.input instanceof tf.Tensor\n      ? await extractFaceTensors(this.input, [detection])\n      : await extractFaces(this.input, [detection])\n\n    const landmarks = await this.landmarkNet.detectLandmarks(faces[0]) as FaceLandmarks68\n\n    faces.forEach(f => f instanceof tf.Tensor && f.dispose())\n\n    return extendWithFaceLandmarks<TSource>(parentResult, landmarks)\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input)\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input)\n  }\n\n  withFaceDescriptor() {\n    return new ComputeSingleFaceDescriptorTask(this, this.input)\n  }\n}", "import { FaceDetection } from '../classes/FaceDetection';\nimport { TNetInput } from '../dom';\nimport { extendWithFaceDetection, WithFaceDetection } from '../factories/WithFaceDetection';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\nimport { TinyFaceDetectorOptions } from '../tinyFaceDetector/TinyFaceDetectorOptions';\nimport { TinyYolov2Options } from '../tinyYolov2';\nimport { ComposableTask } from './ComposableTask';\nimport { DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask } from './DetectFaceLandmarksTasks';\nimport { nets } from './nets';\nimport { PredictAllAgeAndGenderTask, PredictSingleAgeAndGenderTask } from './PredictAgeAndGenderTask';\nimport { PredictAllFaceExpressionsTask, PredictSingleFaceExpressionsTask } from './PredictFaceExpressionsTask';\nimport { FaceDetectionOptions } from './types';\n\nexport class DetectFacesTaskBase<TReturn> extends ComposableTask<TReturn> {\n  constructor(\n    protected input: TNetInput,\n    protected options: FaceDetectionOptions = new SsdMobilenetv1Options()\n  ) {\n    super()\n  }\n}\n\nexport class DetectAllFacesTask extends DetectFacesTaskBase<FaceDetection[]> {\n\n  public async run(): Promise<FaceDetection[]> {\n\n    const { input, options } = this\n\n    const faceDetectionFunction = options instanceof TinyFaceDetectorOptions\n      ? (input: TNetInput) => nets.tinyFaceDetector.locateFaces(input, options)\n      : (\n        options instanceof SsdMobilenetv1Options\n          ? (input: TNetInput) => nets.ssdMobilenetv1.locateFaces(input, options)\n          : (\n            options instanceof TinyYolov2Options\n              ? (input: TNetInput) => nets.tinyYolov2.locateFaces(input, options)\n              : null\n          )\n      )\n\n    if (!faceDetectionFunction) {\n      throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options')\n    }\n\n    return faceDetectionFunction(input)\n  }\n\n  private runAndExtendWithFaceDetections(): Promise<WithFaceDetection<{}>[]> {\n    return new Promise<WithFaceDetection<{}>[]>(async res => {\n      const detections = await this.run()\n      return res(detections.map(detection => extendWithFaceDetection({}, detection)))\n    })\n  }\n\n  withFaceLandmarks(useTinyLandmarkNet: boolean = false) {\n    return new DetectAllFaceLandmarksTask(\n      this.runAndExtendWithFaceDetections(),\n      this.input,\n      useTinyLandmarkNet\n    )\n  }\n\n  withFaceExpressions() {\n    return new PredictAllFaceExpressionsTask (\n      this.runAndExtendWithFaceDetections(),\n      this.input\n    )\n  }\n\n  withAgeAndGender() {\n    return new PredictAllAgeAndGenderTask(\n      this.runAndExtendWithFaceDetections(),\n      this.input\n    )\n  }\n}\n\nexport class DetectSingleFaceTask extends DetectFacesTaskBase<FaceDetection | undefined> {\n\n  public async run(): Promise<FaceDetection | undefined> {\n    const faceDetections = await new DetectAllFacesTask(this.input, this.options);\n    let faceDetectionWithHighestScore = faceDetections[0];\n    faceDetections.forEach(faceDetection => {\n      if (faceDetection.score > faceDetectionWithHighestScore.score) {\n        faceDetectionWithHighestScore = faceDetection;\n      }\n    });\n    return faceDetectionWithHighestScore;\n  }\n\n  private runAndExtendWithFaceDetection(): Promise<WithFaceDetection<{}> | undefined> {\n    return new Promise<WithFaceDetection<{}> | undefined>(async res => {\n      const detection = await this.run()\n      return res(detection ? extendWithFaceDetection<{}>({}, detection) : undefined)\n    })\n  }\n\n  withFaceLandmarks(useTinyLandmarkNet: boolean = false) {\n    return new DetectSingleFaceLandmarksTask(\n      this.runAndExtendWithFaceDetection(),\n      this.input,\n      useTinyLandmarkNet\n    )\n  }\n\n  withFaceExpressions() {\n    return new PredictSingleFaceExpressionsTask(\n      this.runAndExtendWithFaceDetection(),\n      this.input\n    )\n  }\n\n  withAgeAndGender() {\n    return new PredictSingleAgeAndGenderTask(\n      this.runAndExtendWithFaceDetection(),\n      this.input\n    )\n  }\n}", "import { TNetInput } from '../dom';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\nimport { DetectAllFacesTask, DetectSingleFaceTask } from './DetectFacesTasks';\nimport { FaceDetectionOptions } from './types';\n\nexport function detectSingleFace(\n  input: TNetInput,\n  options: FaceDetectionOptions = new SsdMobilenetv1Options()\n): DetectSingleFaceTask {\n  return new DetectSingleFaceTask(input, options)\n}\n\nexport function detectAllFaces(\n  input: TNetInput,\n  options: FaceDetectionOptions = new SsdMobilenetv1Options()\n): DetectAllFacesTask {\n  return new DetectAllFacesTask(input, options)\n}", "import { TNetInput } from '../dom';\nimport { WithFaceDescriptor, WithFaceDetection, WithFaceLandmarks } from '../factories';\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1';\nimport { ITinyYolov2Options, TinyYolov2Options } from '../tinyYolov2';\nimport { detectAllFaces } from './detectFaces';\n\n// export allFaces API for backward compatibility\n\nexport async function allFacesSsdMobilenetv1(\n  input: TNetInput,\n  minConfidence?: number\n): Promise<WithFaceDescriptor<WithFaceLandmarks<WithFaceDetection<{}>>>[]> {\n  console.warn('allFacesSsdMobilenetv1 is deprecated and will be removed soon, use the high level api instead')\n  return await detectAllFaces(input, new SsdMobilenetv1Options(minConfidence ? { minConfidence } : {}))\n    .withFaceLandmarks()\n    .withFaceDescriptors()\n}\n\nexport async function allFacesTinyYolov2(\n  input: TNetInput,\n  forwardParams: ITinyYolov2Options = {}\n): Promise<WithFaceDescriptor<WithFaceLandmarks<WithFaceDetection<{}>>>[]> {\n  console.warn('allFacesTinyYolov2 is deprecated and will be removed soon, use the high level api instead')\n  return await detectAllFaces(input, new TinyYolov2Options(forwardParams))\n    .withFaceLandmarks()\n    .withFaceDescriptors()\n}\n\nexport const allFaces = allFacesSsdMobilenetv1\n", "export function euclideanDistance(arr1: number[] | Float32Array, arr2: number[] | Float32Array) {\n  if (arr1.length !== arr2.length)\n    throw new Error('euclideanDistance: arr1.length !== arr2.length')\n\n  const desc1 = Array.from(arr1)\n  const desc2 = Array.from(arr2)\n\n  return Math.sqrt(\n    desc1\n      .map((val, i) => val - desc2[i])\n      .reduce((res, diff) => res + Math.pow(diff, 2), 0)\n  )\n}", "import { FaceMatch } from '../classes/FaceMatch';\nimport { LabeledFaceDescriptors } from '../classes/LabeledFaceDescriptors';\nimport { euclideanDistance } from '../euclideanDistance';\nimport { WithFaceDescriptor } from '../factories';\n\nexport class FaceMatcher {\n\n  private _labeledDescriptors: LabeledFaceDescriptors[]\n  private _distanceThreshold: number\n\n  constructor(\n    inputs: LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>,\n    distanceThreshold: number = 0.6\n  ) {\n\n    this._distanceThreshold = distanceThreshold\n\n    const inputArray = Array.isArray(inputs) ? inputs : [inputs]\n\n    if (!inputArray.length) {\n      throw new Error(`FaceRecognizer.constructor - expected atleast one input`)\n    }\n\n    let count = 1\n    const createUniqueLabel = () => `person ${count++}`\n\n    this._labeledDescriptors = inputArray.map((desc) => {\n      if (desc instanceof LabeledFaceDescriptors) {\n        return desc\n      }\n\n      if (desc instanceof Float32Array) {\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc])\n      }\n\n      if (desc.descriptor && desc.descriptor instanceof Float32Array) {\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor])\n      }\n\n      throw new Error(`FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>`)\n    })\n  }\n\n  public get labeledDescriptors(): LabeledFaceDescriptors[] { return this._labeledDescriptors }\n  public get distanceThreshold(): number { return this._distanceThreshold }\n\n  public computeMeanDistance(queryDescriptor: Float32Array, descriptors: Float32Array[]): number {\n    return descriptors\n      .map(d => euclideanDistance(d, queryDescriptor))\n      .reduce((d1, d2) => d1 + d2, 0)\n        / (descriptors.length || 1)\n  }\n\n  public matchDescriptor(queryDescriptor: Float32Array): FaceMatch {\n    return this.labeledDescriptors\n      .map(({ descriptors, label }) => new FaceMatch(\n          label,\n          this.computeMeanDistance(queryDescriptor, descriptors)\n      ))\n      .reduce((best, curr) => best.distance < curr.distance ? best : curr)\n  }\n\n  public findBestMatch(queryDescriptor: Float32Array): FaceMatch {\n    const bestMatch = this.matchDescriptor(queryDescriptor)\n    return bestMatch.distance < this.distanceThreshold\n      ? bestMatch\n      : new FaceMatch('unknown', bestMatch.distance)\n  }\n\n  public toJSON(): any {\n    return {\n      distanceThreshold: this.distanceThreshold,\n      labeledDescriptors: this.labeledDescriptors.map((ld) => ld.toJSON())\n    };\n  }\n\n  public static fromJSON(json: any): FaceMatcher {\n    const labeledDescriptors = json.labeledDescriptors\n      .map((ld: any) => LabeledFaceDescriptors.fromJSON(ld));\n    return new FaceMatcher(labeledDescriptors, json.distanceThreshold);\n  }\n\n}", "import { TinyFaceDetector } from './TinyFaceDetector';\n\nexport * from './TinyFaceDetector';\nexport * from './TinyFaceDetectorOptions';\n\nexport function createTinyFaceDetector(weights: Float32Array) {\n  const net = new TinyFaceDetector()\n  net.extractWeights(weights)\n  return net\n}", "import { Dimensions, IDimensions } from './classes';\nimport { FaceDetection } from './classes/FaceDetection';\nimport { FaceLandmarks } from './classes/FaceLandmarks';\nimport { extendWithFaceDetection, isWithFaceDetection } from './factories/WithFaceDetection';\nimport { extendWithFaceLandmarks, isWithFaceLandmarks } from './factories/WithFaceLandmarks';\n\nexport function resizeResults<T>(results: T, dimensions: IDimensions): T {\n\n  const { width, height } = new Dimensions(dimensions.width, dimensions.height)\n\n  if (width <= 0 || height <= 0) {\n    throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({ width, height })}`)\n  }\n\n  if (Array.isArray(results)) {\n    // return results.map(obj => resizeResults(obj, { width, height })) as any as T\n    return (results as Array<any>).map(obj => resizeResults(obj, { width, height } as IDimensions)) as any as T\n  }\n\n  if (isWithFaceLandmarks(results)) {\n    const resizedDetection = results.detection.forSize(width, height)\n    const resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height)\n    return extendWithFaceLandmarks(extendWithFaceDetection(results, resizedDetection), resizedLandmarks)\n  }\n\n  if (isWithFaceDetection(results)) {\n    return extendWithFaceDetection(results, results.detection.forSize(width, height))\n  }\n\n  if (results instanceof FaceLandmarks || results instanceof FaceDetection) {\n    return (results as any).forSize(width, height)\n  }\n\n  return results\n}", "// import * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\nimport * as tf from '@tensorflow/tfjs/dist/tf.es2017.js';\n// const tf = require('@tensorflow/tfjs-core/dist/tf-core.es2017.js');\n// require('@tensorflow/tfjs-backend-cpu/dist/tf-backend-cpu.es2017.js');\n// require('@tensorflow/tfjs-backend-webgl/dist/tf-backend-webgl.es2017.js');\nimport * as draw from './draw';\nimport * as utils from './utils';\nexport { tf, draw, utils };\n\nexport * from './ageGenderNet/index';\nexport * from './classes/index';\nexport * from './dom/index'\nexport * from './env/index';\nexport * from './faceExpressionNet/index';\nexport * from './faceLandmarkNet/index';\nexport * from './faceRecognitionNet/index';\nexport * from './factories/index';\nexport * from './globalApi/index';\nexport * from './ops/index';\nexport * from './ssdMobilenetv1/index';\nexport * from './tinyFaceDetector/index';\nexport * from './tinyYolov2/index';\nexport * from './euclideanDistance';\nexport * from './NeuralNetwork';\nexport * from './resizeResults';\n\nimport * as pkg from '../package.json';\nconst node = (typeof process !== 'undefined');\nconst browser = (typeof navigator !== 'undefined') && (typeof navigator.userAgent !== 'undefined');\nexport const version = { faceapi: pkg.version, node, browser };\n\n// import { PlatformBrowser } from './Platform';\n// if (!tf.env().platform && tf.env().get('IS_BROWSER')) tf.env().setPlatform('browser', new PlatformBrowser);\n// tf.setBackend('cpu');\n\n// import {MathBackendCPU} from '@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js';\n// export {MathBackendCPU};\n// tf.registerBackend('cpu', () => new MathBackendCPU(), 1 /* priority */);\n"],
  "mappings": "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",
  "names": []
}
