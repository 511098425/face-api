var mZ=Object.create,Jm=Object.defineProperty,gZ=Object.getPrototypeOf,vZ=Object.prototype.hasOwnProperty,yZ=Object.getOwnPropertyNames,bZ=Object.getOwnPropertyDescriptor,WD=o=>Jm(o,"__esModule",{value:!0}),Zm=(o,a)=>()=>(a||(a={exports:{}},o(a.exports,a)),a.exports),kf=(o,a)=>{WD(o);for(var i in a)Jm(o,i,{get:a[i],enumerable:!0})},wZ=(o,a,i)=>{if(WD(o),a&&typeof a=="object"||typeof a=="function")for(let c of yZ(a))!vZ.call(o,c)&&c!=="default"&&Jm(o,c,{get:()=>a[c],enumerable:!(i=bZ(a,c))||i.enumerable});return o},se=o=>o&&o.__esModule?o:wZ(Jm(o!=null?mZ(gZ(o)):{},"default",{value:o,enumerable:!0}),o),Nx=Zm(xZ=>{kf(xZ,{FetchError:()=>sr,Headers:()=>jr,Request:()=>Bo,Response:()=>us,default:()=>FZ});var is=se(require("stream")),vx=se(require("http")),Qm=se(require("url")),VD=se(require("https")),$a=se(require("zlib")),TZ=is.default.Readable,Oo=Symbol("buffer"),yx=Symbol("type"),Fi=class{constructor(){this[yx]="";let a=arguments[0],i=arguments[1],c=[],f=0;if(a){let g=a,v=Number(g.length);for(let w=0;w<v;w++){let T=g[w],N;T instanceof Buffer?N=T:ArrayBuffer.isView(T)?N=Buffer.from(T.buffer,T.byteOffset,T.byteLength):T instanceof ArrayBuffer?N=Buffer.from(T):T instanceof Fi?N=T[Oo]:N=Buffer.from(typeof T=="string"?T:String(T)),f+=N.length,c.push(N)}}this[Oo]=Buffer.concat(c);let d=i&&i.type!==void 0&&String(i.type).toLowerCase();d&&!/[^\u0020-\u007E]/.test(d)&&(this[yx]=d)}get size(){return this[Oo].length}get type(){return this[yx]}text(){return Promise.resolve(this[Oo].toString())}arrayBuffer(){let a=this[Oo],i=a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength);return Promise.resolve(i)}stream(){let a=new TZ;return a._read=function(){},a.push(this[Oo]),a.push(null),a}toString(){return"[object Blob]"}slice(){let a=this.size,i=arguments[0],c=arguments[1],f,d;i===void 0?f=0:i<0?f=Math.max(a+i,0):f=Math.min(i,a),c===void 0?d=a:c<0?d=Math.max(a+c,0):d=Math.min(c,a);let g=Math.max(d-f,0),v=this[Oo],w=v.slice(f,f+g),T=new Fi([],{type:arguments[2]});return T[Oo]=w,T}};Object.defineProperties(Fi.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});Object.defineProperty(Fi.prototype,Symbol.toStringTag,{value:"Blob",writable:!1,enumerable:!1,configurable:!0});function sr(o,a,i){Error.call(this,o),this.message=o,this.type=a,i&&(this.code=this.errno=i.code),Error.captureStackTrace(this,this.constructor)}sr.prototype=Object.create(Error.prototype);sr.prototype.constructor=sr;sr.prototype.name="FetchError";var bx;try{bx=require("encoding").convert}catch(o){}var Mo=Symbol("Body internals"),UD=is.default.PassThrough;function Hn(o){var a=this,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},c=i.size;let f=c===void 0?0:c;var d=i.timeout;let g=d===void 0?0:d;o==null?o=null:GD(o)?o=Buffer.from(o.toString()):Sf(o)||(Buffer.isBuffer(o)||(Object.prototype.toString.call(o)==="[object ArrayBuffer]"?o=Buffer.from(o):ArrayBuffer.isView(o)?o=Buffer.from(o.buffer,o.byteOffset,o.byteLength):o instanceof is.default||(o=Buffer.from(String(o))))),this[Mo]={body:o,disturbed:!1,error:null},this.size=f,this.timeout=g,o instanceof is.default&&o.on("error",function(v){let w=v.name==="AbortError"?v:new sr(`Invalid response body while trying to fetch ${a.url}: ${v.message}`,"system",v);a[Mo].error=w})}Hn.prototype={get body(){return this[Mo].body},get bodyUsed(){return this[Mo].disturbed},arrayBuffer(){return bc.call(this).then(function(o){return o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength)})},blob(){let o=this.headers&&this.headers.get("content-type")||"";return bc.call(this).then(function(a){return Object.assign(new Fi([],{type:o.toLowerCase()}),{[Oo]:a})})},json(){var o=this;return bc.call(this).then(function(a){try{return JSON.parse(a.toString())}catch(i){return Hn.Promise.reject(new sr(`invalid json response body at ${o.url} reason: ${i.message}`,"invalid-json"))}})},text(){return bc.call(this).then(function(o){return o.toString()})},buffer(){return bc.call(this)},textConverted(){var o=this;return bc.call(this).then(function(a){return kZ(a,o.headers)})}};Object.defineProperties(Hn.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0}});Hn.mixIn=function(o){for(let a of Object.getOwnPropertyNames(Hn.prototype))if(!(a in o)){let i=Object.getOwnPropertyDescriptor(Hn.prototype,a);Object.defineProperty(o,a,i)}};function bc(){var o=this;if(this[Mo].disturbed)return Hn.Promise.reject(new TypeError(`body used already for: ${this.url}`));if(this[Mo].disturbed=!0,this[Mo].error)return Hn.Promise.reject(this[Mo].error);let a=this.body;if(a===null)return Hn.Promise.resolve(Buffer.alloc(0));if(Sf(a)&&(a=a.stream()),Buffer.isBuffer(a))return Hn.Promise.resolve(a);if(!(a instanceof is.default))return Hn.Promise.resolve(Buffer.alloc(0));let i=[],c=0,f=!1;return new Hn.Promise(function(d,g){let v;o.timeout&&(v=setTimeout(function(){f=!0,g(new sr(`Response timeout while trying to fetch ${o.url} (over ${o.timeout}ms)`,"body-timeout"))},o.timeout)),a.on("error",function(w){w.name==="AbortError"?(f=!0,g(w)):g(new sr(`Invalid response body while trying to fetch ${o.url}: ${w.message}`,"system",w))}),a.on("data",function(w){if(f||w===null)return;if(o.size&&c+w.length>o.size){f=!0,g(new sr(`content size at ${o.url} over limit: ${o.size}`,"max-size"));return}c+=w.length,i.push(w)}),a.on("end",function(){if(f)return;clearTimeout(v);try{d(Buffer.concat(i,c))}catch(w){g(new sr(`Could not create Buffer from response body for ${o.url}: ${w.message}`,"system",w))}})})}function kZ(o,a){if(typeof bx!="function")throw new Error("The package `encoding` must be installed to use the textConverted() function");let i=a.get("content-type"),c="utf-8",f,d;return i&&(f=/charset=([^;]*)/i.exec(i)),d=o.slice(0,1024).toString(),!f&&d&&(f=/<meta.+?charset=(['"])(.+?)\1/i.exec(d)),!f&&d&&(f=/<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(d),f||(f=/<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(d),f&&f.pop()),f&&(f=/charset=(.*)/i.exec(f.pop()))),!f&&d&&(f=/<\?xml.+?encoding=(['"])(.+?)\1/i.exec(d)),f&&(c=f.pop(),(c==="gb2312"||c==="gbk")&&(c="gb18030")),bx(o,"UTF-8",c).toString()}function GD(o){return typeof o!="object"||typeof o.append!="function"||typeof o.delete!="function"||typeof o.get!="function"||typeof o.getAll!="function"||typeof o.has!="function"||typeof o.set!="function"?!1:o.constructor.name==="URLSearchParams"||Object.prototype.toString.call(o)==="[object URLSearchParams]"||typeof o.sort=="function"}function Sf(o){return typeof o=="object"&&typeof o.arrayBuffer=="function"&&typeof o.type=="string"&&typeof o.stream=="function"&&typeof o.constructor=="function"&&typeof o.constructor.name=="string"&&/^(Blob|File)$/.test(o.constructor.name)&&/^(Blob|File)$/.test(o[Symbol.toStringTag])}function HD(o){let a,i,c=o.body;if(o.bodyUsed)throw new Error("cannot clone body after it is used");return c instanceof is.default&&typeof c.getBoundary!="function"&&(a=new UD,i=new UD,c.pipe(a),c.pipe(i),o[Mo].body=a,c=i),c}function qD(o){return o===null?null:typeof o=="string"?"text/plain;charset=UTF-8":GD(o)?"application/x-www-form-urlencoded;charset=UTF-8":Sf(o)?o.type||null:Buffer.isBuffer(o)||(Object.prototype.toString.call(o)==="[object ArrayBuffer]"||ArrayBuffer.isView(o))?null:typeof o.getBoundary=="function"?`multipart/form-data;boundary=${o.getBoundary()}`:o instanceof is.default?null:"text/plain;charset=UTF-8"}function jD(o){let a=o.body;return a===null?0:Sf(a)?a.size:Buffer.isBuffer(a)?a.length:a&&typeof a.getLengthSync=="function"&&(a._lengthRetrievers&&a._lengthRetrievers.length==0||a.hasKnownLength&&a.hasKnownLength())?a.getLengthSync():null}function SZ(o,a){let i=a.body;i===null?o.end():Sf(i)?i.stream().pipe(o):Buffer.isBuffer(i)?(o.write(i),o.end()):i.pipe(o)}Hn.Promise=global.Promise;var KD=/[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/,wx=/[^\t\x20-\x7e\x80-\xff]/;function Cf(o){if(o=`${o}`,KD.test(o)||o==="")throw new TypeError(`${o} is not a legal HTTP header name`)}function XD(o){if(o=`${o}`,wx.test(o))throw new TypeError(`${o} is not a legal HTTP header value`)}function wc(o,a){a=a.toLowerCase();for(let i in o)if(i.toLowerCase()===a)return i;return}var xn=Symbol("map"),jr=class{constructor(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:void 0;if(this[xn]=Object.create(null),a instanceof jr){let i=a.raw(),c=Object.keys(i);for(let f of c)for(let d of i[f])this.append(f,d);return}if(!(a==null))if(typeof a=="object"){let i=a[Symbol.iterator];if(i!=null){if(typeof i!="function")throw new TypeError("Header pairs must be iterable");let c=[];for(let f of a){if(typeof f!="object"||typeof f[Symbol.iterator]!="function")throw new TypeError("Each header pair must be iterable");c.push(Array.from(f))}for(let f of c){if(f.length!==2)throw new TypeError("Each header pair must be a name/value tuple");this.append(f[0],f[1])}}else for(let c of Object.keys(a)){let f=a[c];this.append(c,f)}}else throw new TypeError("Provided initializer must be an object")}get(a){a=`${a}`,Cf(a);let i=wc(this[xn],a);return i===void 0?null:this[xn][i].join(", ")}forEach(a){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:void 0,c=xx(this),f=0;for(;f<c.length;){var d=c[f];let g=d[0],v=d[1];a.call(i,v,g,this),c=xx(this),f++}}set(a,i){a=`${a}`,i=`${i}`,Cf(a),XD(i);let c=wc(this[xn],a);this[xn][c!==void 0?c:a]=[i]}append(a,i){a=`${a}`,i=`${i}`,Cf(a),XD(i);let c=wc(this[xn],a);c!==void 0?this[xn][c].push(i):this[xn][a]=[i]}has(a){return a=`${a}`,Cf(a),wc(this[xn],a)!==void 0}delete(a){a=`${a}`,Cf(a);let i=wc(this[xn],a);i!==void 0&&delete this[xn][i]}raw(){return this[xn]}keys(){return Tx(this,"key")}values(){return Tx(this,"value")}[Symbol.iterator](){return Tx(this,"key+value")}};jr.prototype.entries=jr.prototype[Symbol.iterator];Object.defineProperty(jr.prototype,Symbol.toStringTag,{value:"Headers",writable:!1,enumerable:!1,configurable:!0});Object.defineProperties(jr.prototype,{get:{enumerable:!0},forEach:{enumerable:!0},set:{enumerable:!0},append:{enumerable:!0},has:{enumerable:!0},delete:{enumerable:!0},keys:{enumerable:!0},values:{enumerable:!0},entries:{enumerable:!0}});function xx(o){let a=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"key+value",i=Object.keys(o[xn]).sort();return i.map(a==="key"?function(c){return c.toLowerCase()}:a==="value"?function(c){return o[xn][c].join(", ")}:function(c){return[c.toLowerCase(),o[xn][c].join(", ")]})}var kx=Symbol("internal");function Tx(o,a){let i=Object.create(Sx);return i[kx]={target:o,kind:a,index:0},i}var Sx=Object.setPrototypeOf({next(){if(!this||Object.getPrototypeOf(this)!==Sx)throw new TypeError("Value of `this` is not a HeadersIterator");var o=this[kx];let a=o.target,i=o.kind,c=o.index,f=xx(a,i),d=f.length;return c>=d?{value:void 0,done:!0}:(this[kx].index=c+1,{value:f[c],done:!1})}},Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));Object.defineProperty(Sx,Symbol.toStringTag,{value:"HeadersIterator",writable:!1,enumerable:!1,configurable:!0});function CZ(o){let a=Object.assign({__proto__:null},o[xn]),i=wc(o[xn],"Host");return i!==void 0&&(a[i]=a[i][0]),a}function NZ(o){let a=new jr;for(let i of Object.keys(o)){if(KD.test(i))continue;if(Array.isArray(o[i]))for(let c of o[i]){if(wx.test(c))continue;a[xn][i]===void 0?a[xn][i]=[c]:a[xn][i].push(c)}else wx.test(o[i])||(a[xn][i]=[o[i]])}return a}var Aa=Symbol("Response internals"),IZ=vx.default.STATUS_CODES,us=class{constructor(){let a=arguments.length>0&&arguments[0]!==void 0?arguments[0]:null,i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};Hn.call(this,a,i);let c=i.status||200,f=new jr(i.headers);if(a!=null&&!f.has("Content-Type")){let d=qD(a);d&&f.append("Content-Type",d)}this[Aa]={url:i.url,status:c,statusText:i.statusText||IZ[c],headers:f,counter:i.counter}}get url(){return this[Aa].url||""}get status(){return this[Aa].status}get ok(){return this[Aa].status>=200&&this[Aa].status<300}get redirected(){return this[Aa].counter>0}get statusText(){return this[Aa].statusText}get headers(){return this[Aa].headers}clone(){return new us(HD(this),{url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected})}};Hn.mixIn(us.prototype);Object.defineProperties(us.prototype,{url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});Object.defineProperty(us.prototype,Symbol.toStringTag,{value:"Response",writable:!1,enumerable:!1,configurable:!0});var Lo=Symbol("Request internals"),Cx=Qm.default.parse,EZ=Qm.default.format,DZ="destroy"in is.default.Readable.prototype;function tg(o){return typeof o=="object"&&typeof o[Lo]=="object"}function $Z(o){let a=o&&typeof o=="object"&&Object.getPrototypeOf(o);return!!(a&&a.constructor.name==="AbortSignal")}var Bo=class{constructor(a){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},c;tg(a)?c=Cx(a.url):(a&&a.href?c=Cx(a.href):c=Cx(`${a}`),a={});let f=i.method||a.method||"GET";if(f=f.toUpperCase(),(i.body!=null||tg(a)&&a.body!==null)&&(f==="GET"||f==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");let d=i.body!=null?i.body:tg(a)&&a.body!==null?HD(a):null;Hn.call(this,d,{timeout:i.timeout||a.timeout||0,size:i.size||a.size||0});let g=new jr(i.headers||a.headers||{});if(d!=null&&!g.has("Content-Type")){let w=qD(d);w&&g.append("Content-Type",w)}let v=tg(a)?a.signal:null;if("signal"in i&&(v=i.signal),v!=null&&!$Z(v))throw new TypeError("Expected signal to be an instanceof AbortSignal");this[Lo]={method:f,redirect:i.redirect||a.redirect||"follow",headers:g,parsedURL:c,signal:v},this.follow=i.follow!==void 0?i.follow:a.follow!==void 0?a.follow:20,this.compress=i.compress!==void 0?i.compress:a.compress!==void 0?a.compress:!0,this.counter=i.counter||a.counter||0,this.agent=i.agent||a.agent}get method(){return this[Lo].method}get url(){return EZ(this[Lo].parsedURL)}get headers(){return this[Lo].headers}get redirect(){return this[Lo].redirect}get signal(){return this[Lo].signal}clone(){return new Bo(this)}};Hn.mixIn(Bo.prototype);Object.defineProperty(Bo.prototype,Symbol.toStringTag,{value:"Request",writable:!1,enumerable:!1,configurable:!0});Object.defineProperties(Bo.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0}});function AZ(o){let a=o[Lo].parsedURL,i=new jr(o[Lo].headers);if(i.has("Accept")||i.set("Accept","*/*"),!a.protocol||!a.hostname)throw new TypeError("Only absolute URLs are supported");if(!/^https?:$/.test(a.protocol))throw new TypeError("Only HTTP(S) protocols are supported");if(o.signal&&o.body instanceof is.default.Readable&&!DZ)throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");let c=null;if(o.body==null&&/^(POST|PUT)$/i.test(o.method)&&(c="0"),o.body!=null){let d=jD(o);typeof d=="number"&&(c=String(d))}c&&i.set("Content-Length",c),i.has("User-Agent")||i.set("User-Agent","node-fetch/1.0 (+https://github.com/bitinn/node-fetch)"),o.compress&&!i.has("Accept-Encoding")&&i.set("Accept-Encoding","gzip,deflate");let f=o.agent;return typeof f=="function"&&(f=f(a)),!i.has("Connection")&&!f&&i.set("Connection","close"),Object.assign({},a,{method:o.method,headers:CZ(i),agent:f})}function Nf(o){Error.call(this,o),this.type="aborted",this.message=o,Error.captureStackTrace(this,this.constructor)}Nf.prototype=Object.create(Error.prototype);Nf.prototype.constructor=Nf;Nf.prototype.name="AbortError";var YD=is.default.PassThrough,_Z=Qm.default.resolve;function _a(o,a){if(!_a.Promise)throw new Error("native promise missing, set fetch.Promise to your favorite alternative");return Hn.Promise=_a.Promise,new _a.Promise(function(i,c){let f=new Bo(o,a),d=AZ(f),g=(d.protocol==="https:"?VD.default:vx.default).request,v=f.signal,w=null,T=function(){let G=new Nf("The user aborted a request.");if(c(G),f.body&&f.body instanceof is.default.Readable&&f.body.destroy(G),!w||!w.body)return;w.body.emit("error",G)};if(v&&v.aborted){T();return}let N=function(){T(),$()},E=g(d),k;v&&v.addEventListener("abort",N);function $(){E.abort(),v&&v.removeEventListener("abort",N),clearTimeout(k)}f.timeout&&E.once("socket",function(M){k=setTimeout(function(){c(new sr(`network timeout at: ${f.url}`,"request-timeout")),$()},f.timeout)}),E.on("error",function(M){c(new sr(`request to ${f.url} failed, reason: ${M.message}`,"system",M)),$()}),E.on("response",function(M){clearTimeout(k);let G=NZ(M.headers);if(_a.isRedirect(M.statusCode)){let ct=G.get("Location"),dt=ct===null?null:_Z(f.url,ct);switch(f.redirect){case"error":c(new sr(`uri requested responds with a redirect, redirect mode is set to error: ${f.url}`,"no-redirect")),$();return;case"manual":if(dt!==null)try{G.set("Location",dt)}catch(St){c(St)}break;case"follow":if(dt===null)break;if(f.counter>=f.follow){c(new sr(`maximum redirect reached at: ${f.url}`,"max-redirect")),$();return}let Ct={headers:new jr(f.headers),follow:f.follow,counter:f.counter+1,agent:f.agent,compress:f.compress,method:f.method,body:f.body,signal:f.signal,timeout:f.timeout,size:f.size};if(M.statusCode!==303&&f.body&&jD(f)===null){c(new sr("Cannot follow redirect with body being a readable stream","unsupported-redirect")),$();return}(M.statusCode===303||(M.statusCode===301||M.statusCode===302)&&f.method==="POST")&&(Ct.method="GET",Ct.body=void 0,Ct.headers.delete("content-length")),i(_a(new Bo(dt,Ct))),$();return}}M.once("end",function(){v&&v.removeEventListener("abort",N)});let O=M.pipe(new YD),H={url:f.url,status:M.statusCode,statusText:M.statusMessage,headers:G,size:f.size,timeout:f.timeout,counter:f.counter},K=G.get("Content-Encoding");if(!f.compress||f.method==="HEAD"||K===null||M.statusCode===204||M.statusCode===304){w=new us(O,H),i(w);return}let nt={flush:$a.default.Z_SYNC_FLUSH,finishFlush:$a.default.Z_SYNC_FLUSH};if(K=="gzip"||K=="x-gzip"){O=O.pipe($a.default.createGunzip(nt)),w=new us(O,H),i(w);return}if(K=="deflate"||K=="x-deflate"){let ct=M.pipe(new YD);ct.once("data",function(dt){(dt[0]&15)===8?O=O.pipe($a.default.createInflate()):O=O.pipe($a.default.createInflateRaw()),w=new us(O,H),i(w)});return}if(K=="br"&&typeof $a.default.createBrotliDecompress=="function"){O=O.pipe($a.default.createBrotliDecompress()),w=new us(O,H),i(w);return}w=new us(O,H),i(w)}),SZ(E,f)})}_a.isRedirect=function(o){return o===301||o===302||o===303||o===307||o===308};_a.Promise=global.Promise;var FZ=_a}),he=Zm((eg,JD)=>{(function(o,a){typeof eg=="object"&&typeof JD!="undefined"?a(eg):typeof define=="function"&&define.amd?define(["exports"],a):(o=o||self,a(o.tf=o.tf||{}))})(eg,function(o){"use strict";let a=1e-7,i=1e-4;class c{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class f{time(t){return d("time")}read(t){return d("read")}readSync(t){return d("readSync")}numDataIds(){return d("numDataIds")}disposeData(t){return d("disposeData")}write(t,e,r){return d("write")}move(t,e,r,s){return d("move")}memory(){return d("memory")}floatPrecision(){return d("floatPrecision")}epsilon(){return this.floatPrecision()===32?a:i}batchMatMul(t,e,r,s){return d("batchMatMul")}fusedBatchMatMul({a:t,b:e,transposeA:r,transposeB:s,bias:u,activation:l,preluActivationWeights:h}){return d("fusedBatchMatMul")}slice(t,e,r){return d("slice")}stridedSlice(t,e,r,s){return d("stridedSlice")}unstack(t,e){return d("unstack")}reverse(t,e){return d("reverse")}concat(t,e){return d("concat")}neg(t){return d("neg")}add(t,e){return d("add")}addN(t){return d("addN")}subtract(t,e){return d("subtract")}multiply(t,e){return d("multiply")}realDivide(t,e){return d("realDivide")}floorDiv(t,e){return d("floorDiv")}sum(t,e){return d("sum")}prod(t,e){return d("prod")}unsortedSegmentSum(t,e,r){return d("unsortedSegmentSum")}argMin(t,e){return d("argMin")}argMax(t,e){return d("argMax")}equal(t,e){return d("equal")}notEqual(t,e){return d("notEqual")}less(t,e){return d("less")}lessEqual(t,e){return d("lessEqual")}greater(t,e){return d("greater")}greaterEqual(t,e){return d("greaterEqual")}logicalNot(t){return d("logicalNot")}logicalAnd(t,e){return d("logicalAnd")}logicalOr(t,e){return d("logicalOr")}where(t){return d("where")}select(t,e,r){return d("select")}topk(t,e,r){return d("topk")}min(t,e){return d("min")}minimum(t,e){return d("minimum")}mod(t,e){return d("mod")}max(t,e){return d("max")}maximum(t,e){return d("maximum")}all(t,e){return d("all")}any(t,e){return d("any")}squaredDifference(t,e){return d("squaredDifference")}ceil(t){return d("ceil")}floor(t){return d("floor")}round(t){return d("round")}sign(t){return d("sign")}isNaN(t){return d("isNaN")}isInf(t){return d("isInf")}isFinite(t){return d("isFinite")}pow(t,e){return d("pow")}exp(t){return d("exp")}expm1(t){return d("expm1")}softmax(t,e){return d("softmax")}log(t){return d("log")}log1p(t){return d("log1p")}sqrt(t){return d("sqrt")}rsqrt(t){return d("rsqrt")}square(t){return d("square")}reciprocal(t){return d("reciprocal")}relu(t){return d("relu")}relu6(t){return d("relu6")}prelu(t,e){return d("prelu")}elu(t){return d("elu")}eluDer(t,e){return d("eluDer")}selu(t){return d("selu")}int(t){return d("int")}clip(t,e,r){return d("clip")}abs(t){return d("abs")}complexAbs(t){return d("complexAbs")}sigmoid(t){return d("sigmoid")}softplus(t){return d("softplus")}sin(t){return d("sin")}cos(t){return d("cos")}tan(t){return d("tan")}asin(t){return d("asin")}acos(t){return d("acos")}atan(t){return d("atan")}atan2(t,e){return d("atan2")}sinh(t){return d("sinh")}cosh(t){return d("cosh")}tanh(t){return d("tanh")}asinh(t){return d("asinh")}acosh(t){return d("acosh")}atanh(t){return d("atanh")}erf(t){return d("erf")}step(t,e){return d("step")}fusedConv2d({input:t,filter:e,convInfo:r,bias:s,activation:u,preluActivationWeights:l}){return d("fusedConv2d")}conv2d(t,e,r){return d("conv2d")}conv2dDerInput(t,e,r){return d("conv2dDerInput")}conv2dDerFilter(t,e,r){return d("conv2dDerFilter")}fusedDepthwiseConv2D({input:t,filter:e,convInfo:r,bias:s,activation:u,preluActivationWeights:l}){return d("fusedDepthwiseConv2D")}depthwiseConv2D(t,e,r){return d("depthwiseConv2D")}depthwiseConv2DDerInput(t,e,r){return d("depthwiseConv2DDerInput")}depthwiseConv2DDerFilter(t,e,r){return d("depthwiseConv2DDerFilter")}conv3d(t,e,r){return d("conv3d")}conv3dDerInput(t,e,r){return d("conv3dDerInput")}conv3dDerFilter(t,e,r){return d("conv3dDerFilter")}maxPool(t,e){return d("maxPool")}maxPoolBackprop(t,e,r,s){return d("maxPoolBackprop")}avgPool(t,e){return d("avgPool")}avgPoolBackprop(t,e,r){return d("avgPoolBackprop")}avgPool3d(t,e){return d("avgPool3d")}avgPool3dBackprop(t,e,r){return d("avgPool3dBackprop")}maxPool3d(t,e){return d("maxPool3d")}maxPool3dBackprop(t,e,r,s){return d("maxPool3dBackprop")}reshape(t,e){return d("reshape")}cast(t,e){return d("cast")}tile(t,e){return d("tile")}pad(t,e,r){return d("pad")}transpose(t,e){return d("transpose")}gather(t,e,r){return d("gather")}gatherND(t,e){return d("gatherND")}scatterND(t,e,r){return d("scatterND")}batchToSpaceND(t,e,r){return d("batchToSpaceND")}spaceToBatchND(t,e,r){return d("spaceToBatchND")}resizeBilinear(t,e,r,s){return d("resizeBilinear")}resizeBilinearBackprop(t,e,r){return d("resizeBilinearBackprop")}resizeNearestNeighbor(t,e,r,s){return d("resizeNearestNeighbor")}resizeNearestNeighborBackprop(t,e,r){return d("resizeNearestNeighborBackprop")}batchNorm(t,e,r,s,u,l){return d("batchNorm")}localResponseNormalization4D(t,e,r,s,u){return d("localResponseNormalization4D")}LRNGrad(t,e,r,s,u,l,h){return d("LRNGrad")}multinomial(t,e,r,s){return d("multinomial")}oneHot(t,e,r,s){return d("oneHot")}cumsum(t,e,r,s){return d("cumsum")}nonMaxSuppression(t,e,r,s,u){return d("nonMaxSuppression")}fft(t){return d("fft")}ifft(t){return d("ifft")}complex(t,e){return d("complex")}real(t){return d("real")}imag(t){return d("imag")}cropAndResize(t,e,r,s,u,l){return d("cropAndResize")}depthToSpace(t,e,r){return d("depthToSpace")}split(t,e,r){return d("split")}sparseToDense(t,e,r,s){return d("sparseToDense")}diag(t){return d("diag")}fill(t,e,r){return d("fill")}onesLike(t){return d("onesLike")}zerosLike(t){return d("zerosLike")}linspace(t,e,r){return d("linspace")}dispose(){return d("dispose")}}function d(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function g(n){let t=n.length,e=0,r=0;for(;t>0;)r=Math.random()*t|0,t--,e=n[t],n[t]=n[r],n[r]=e}function v(n,t,e){return Math.max(n,Math.min(t,e))}function w(n){return n%2===0?n:n+1}function T(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function N(n,t){let e=Math.random();return t*e+(1-e)*n}function E(n,t){let e=0;for(let r=0;r<n.length;r++){let s=Number(n[r])-Number(t[r]);e+=s*s}return e}function k(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function $(n,t,e=""){k(K(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function M(n){k(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function G(n,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(n)||Re(n)&&!e)for(let r=0;r<n.length;++r)G(n[r],t,e);else t.push(n);return t}function O(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function H(n){return n.length===0}function K(n,t){if(n===t)return!0;if(n==null||t==null)return!1;if(n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function nt(n){return n%1===0}function ct(n){if(Math.tanh!=null)return Math.tanh(n);if(n===Infinity)return 1;if(n===-Infinity)return-1;{let t=Math.exp(2*n);return(t-1)/(t+1)}}function dt(n){let t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Ct(n){let t=new Uint32Array(n);for(let e=0;e<n;++e)t[e]=e;return g(t),t}function St(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function It(n,t=r=>0,e){return new Promise((r,s)=>{let u=0,l=()=>{if(n()){r();return}u++;let h=t(u);if(e!=null&&u>=e){s();return}setTimeout(l,h)};l()})}function Gt(n,t){let e=1,r=-1;for(let u=0;u<n.length;++u)if(n[u]>=0)e*=n[u];else if(n[u]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${u}`);r=u}else if(n[u]<0)throw Error(`Shapes can not be < 0. Found ${n[u]} at dim ${u}`);if(r===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let s=n.slice();return s[r]=t/e,s}function Et(n,t){let e=t.length;return n=n==null?t.map((r,s)=>s):[].concat(n),k(n.every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),k(n.every(r=>nt(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Wt(n,t){let e=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,u=t==null||s?null:Et(t,n).sort(),l=0;for(let h=0;h<n.length;++h){if(u!=null){if(u[l]===h&&n[h]!==1)throw new Error(`Can't squeeze axis ${h} since its dim '${n[h]}' is not 1`);(u[l]==null||u[l]>h)&&n[h]===1&&(e.push(n[h]),r.push(h)),u[l]<=h&&l++}n[h]!==1&&(e.push(n[h]),r.push(h))}return{newShape:e,keptDims:r}}function _t(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${n}`);return e}function Kt(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function Ne(n,t){for(let e=0;e<n.length;e++){let r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function ce(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function me(n,t){return t==="complex64"||(t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64")?!1:!(t==="bool"&&n==="bool")}function Re(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array}function gn(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function en(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function dn(n){return typeof n=="string"||n instanceof String}function Zn(n){return typeof n=="boolean"}function Or(n){return typeof n=="number"}function Us(n){return Array.isArray(n)?Us(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array?"int32":Or(n)?"float32":dn(n)?"string":Zn(n)?"bool":"float32"}function Ln(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ms(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function Jt(n){let t=n.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function lp(n,t,e){let r=new Array;if(t.length===1){let s=t[0];for(let u=0;u<s;u++)r[u]=e[n+u]}else{let s=t[0],u=t.slice(1),l=u.reduce((h,p)=>h*p);for(let h=0;h<s;h++)r[h]=lp(n+h*l,u,e)}return r}function Mr(n,t){if(n.length===0)return t[0];let e=n.reduce((r,s)=>r*s);if(e===0)return[];if(e!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}.`);return lp(0,n,t)}function Nv(n,t){let e=fu(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function fu(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function Iv(n,t){let e=n.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return Mr(n,new Float32Array(e));if(t==="int32")return Mr(n,new Int32Array(e));if(t==="bool")return Mr(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Ev(n){n.forEach(t=>{k(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Qr(n,t,e){if(t===0)return 0;if(t===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function ei(n,t,e){if(t===0)return[];if(t===1)return[n];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function ni(n){return n&&n.then&&typeof n.then=="function"}let y2="tfjsflags";class b2{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},this.urlFlags[t]!=null){let s=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(ni(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=LR(this.global.location.search);if(y2 in t){let e=t[y2].split(",");e.forEach(r=>{let[s,u]=r.split(":");this.urlFlags[s]=zR(s,u)})}}}function LR(n){let t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(BR(t,r[0],r[1]),r.join("="))),t}function BR(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function zR(n,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}function ft(){return o.ENV}o.ENV=null;function WR(n){o.ENV=n}let Dv;function w2(){if(Dv==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");Dv=n}return Dv}function VR(){let n=w2();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function x2(n,t){let e=VR();if(e.has(n))return e.get(n);{let r=t();return e.set(n,r),e.get(n)}}let hp="Abs",dl="Acos",ml="Acosh",ri="Add",$v="AddN",T2="All",k2="Any",Av="ArgMax",_v="ArgMin",gl="Asin",vl="Asinh",yl="Atan",bl="Atanh",fp="Atan2",wl="AvgPool",pp="AvgPoolBackprop",Fv="AvgPool3D",S2="AvgPool3DBackprop",dp="BatchMatMul",Rv="BatchToSpaceND",Pv="BroadcastTo",pu="Cast",xl="Ceil",Tl="ClipByValue",mp="Complex",kl="Concat",gp="Conv2D",Ov="Conv2DBackpropFilter",vp="Conv2DBackpropInput",yp="Conv3D",Mv="Conv3DBackpropFilterV2",Lv="Conv3DBackpropInputV2",du="Cos",Sl="Cosh",Bv="Cumsum",C2="CropAndResize",N2="DepthToSpace",bp="DepthwiseConv2dNative",zv="DepthwiseConv2dNativeBackpropFilter",Wv="DepthwiseConv2dNativeBackpropInput",I2="Diag",wp="Dilation2D",xp="Dilation2DBackpropInput",Tp="Dilation2DBackpropFilter",mu="Div",Cl="Elu",E2="EluGrad",Nl="Erf",D2="Equal",Il="Exp",El="Expm1",kp="FFT",Vv="Fill",Sp="FlipLeftRight",Dl="Floor",Uv="FloorDiv",$l="FusedBatchNorm",Gv="GatherV2",$2="GatherNd",A2="Greater",Hv="GreaterEqual",Al="Identity",Cp="IFFT",Np="Imag",_l="IsFinite",Fl="IsInf",Rl="IsNan",_2="Less",F2="LessEqual",R2="LinSpace",Pl="Log",Ol="Log1p",P2="LogicalAnd",Ip="LogicalNot",O2="LogicalOr",qv="LogSoftmax",jv="LRN",M2="LRNBackprop",Ml="Max",Kv="Maximum",Ll="MaxPool",Ep="MaxPoolBackprop",Xv="MaxPool3D",L2="MaxPool3DBackprop",Dp="MaxPoolWithArgmax",Yv="Mean",Jv="Min",Zv="Minimum",Bl="MirrorPad",Qv="Mod",gu="Multiply",ty="Negate",zl="NotEqual",ey="NonMaxSuppressionV3",$p="NonMaxSuppressionV4",Ap="NonMaxSuppressionV5",ny="OnesLike",ry="OneHot",_p="PadV2",UR="Pool",sy="Pow",Fp="Prelu",B2="Prod",z2="Range",Rp="Real",Wl="Reciprocal",Vl="Relu",Ul="Reshape",oy="ResizeNearestNeighbor",W2="ResizeNearestNeighborGrad",ay="ResizeBilinear",V2="ResizeBilinearGrad",Gl="Relu6",iy="Reverse",Hl="Round",ql="Rsqrt",U2="ScatterNd",uy="SelectV2",jl="Selu",Pp="Slice",vu="Sin",Kl="Sinh",Xl="Sign",Yl="Sigmoid",Jl="Softplus",Zl="Sqrt",cy="Sum",Op="SpaceToBatchND",ly="SplitV",hy="Softmax",yu="SquaredDifference",Mp="Square",bu="Sub",G2="SparseToDense",H2="StridedSlice",wu="Tan",Ql="Tanh",fy="Tile",q2="TopK",th="Transpose",Lp="Unique",py="Unpack",dy="UnsortedSegmentSum",my="ZerosLike",eh="Step",Bp="FromPixels",zp="RotateWithOffset",Wp="_FusedMatMul",Vp="FusedConv2D",Up="FusedDepthwiseConv2D";let xu=x2("kernelRegistry",()=>new Map),nh=x2("gradRegistry",()=>new Map);function gy(n,t){let e=yy(n,t);return xu.get(e)}function vy(n){return nh.get(n)}function Gp(n){let t=xu.entries(),e=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[u,l]=s,[h]=u.split("_");h===n&&e.push(l)}return e}function Hp(n){let{kernelName:t,backendName:e}=n,r=yy(t,e);xu.has(r)&&console.warn(`The kernel '${t}' for backend '${e}' is already registered`),xu.set(r,n)}function j2(n){let{kernelName:t}=n;nh.has(t)&&(ft().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`)),nh.set(t,n)}function GR(n,t){let e=yy(n,t);if(!xu.has(e))throw new Error(`The kernel '${n}' for backend '${t}' is not registered`);xu.delete(e)}function HR(n){if(!nh.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);nh.delete(n)}function qR(n,t){let e=Gp(n);e.forEach(r=>{let s=Object.assign({},r,{backendName:t});Hp(s)})}function yy(n,t){return`${t}_${n}`}function K2(n,t){return t==="string"?qp(n):na([n],t)}function jR(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function na(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=G(n)),ft().getBool("DEBUG")&&Ne(n,t),jR(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){let e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)Math.round(n[r])!==0&&(e[r]=1);return e}else throw new Error(`Unknown data type ${t}`)}function cr(){return ft().platform.now()}function X2(n,t){return ft().platform.fetch(n,t)}function qp(n,t="utf-8"){return t=t||"utf-8",ft().platform.encode(n,t)}function rh(n,t="utf-8"){return t=t||"utf-8",ft().platform.decode(n,t)}var KR=Object.freeze({__proto__:null,createScalarValue:K2,toTypedArray:na,now:cr,fetch:X2,encodeString:qp,decodeString:rh,shuffle:g,clamp:v,nearestLargerEven:w,sum:T,randUniform:N,distSquared:E,assert:k,assertShapesMatch:$,assertNonNull:M,flatten:G,sizeFromShape:O,isScalarShape:H,arraysEqual:K,isInt:nt,tanh:ct,sizeToSquarishShape:dt,createShuffledIndices:Ct,rightPad:St,repeatedTry:It,inferFromImplicitShape:Gt,parseAxisParam:Et,squeezeShape:Wt,getTypedArrayFromDType:_t,getArrayFromDType:Kt,checkConversionForErrors:Ne,isValidDtype:ce,hasEncodingLoss:me,isTypedArray:Re,bytesPerElement:gn,bytesFromStringArray:en,isString:dn,isBoolean:Zn,isNumber:Or,inferDtype:Us,isFunction:Ln,nearestDivisor:ms,computeStrides:Jt,toNestedArray:Mr,makeOnesTypedArray:Nv,makeZerosTypedArray:fu,makeZerosNestedTypedArray:Iv,assertNonNegativeIntegerDimensions:Ev,locToIndex:Qr,indexToLoc:ei,isPromise:ni});class XR{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new JR)}profileKernel(t,e,r){let s,u=()=>{s=r()},l=this.backendTimer.time(u);for(let p=0;p<s.length;p++){let m=s[p];m.data().then(y=>{YR(y,m.dtype,t)})}let h={kernelName:t,outputs:s,inputs:e,timeMs:l.then(p=>p.kernelMs),extraInfo:l.then(p=>p.getExtraProfileInfo!=null?p.getExtraProfileInfo():"")};return h}logKernelProfile(t){let{kernelName:e,outputs:r,timeMs:s,inputs:u,extraInfo:l}=t;r.forEach(h=>{Promise.all([h.data(),s,l]).then(p=>{this.logger.logKernelProfile(e,h,p[0],p[1],u,p[2])})})}}function YR(n,t,e){if(t!=="float32")return!1;for(let r=0;r<n.length;r++){let s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class JR{logKernelProfile(t,e,r,s,u,l){let h=typeof s=="number"?St(`${s}ms`,9):s.error,p=St(t,25),m=e.rank,y=e.size,b=St(e.shape.toString(),14),x="";for(let S in u){let C=u[S];if(C!=null){let I=C.shape||e.shape,D=I.length;x+=`${S}: ${D}D ${D>0?I:""} `}}console.log(`%c${p}	%c${h}	%c${m}D ${b}	%c${y}	%c${x}	%c${l}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ZR(n,t,e){let r={},s={};for(let p=0;p<t.length;p++)r[t[p].id]=!0;for(let p=0;p<n.length;p++){let m=n[p],y=m.inputs;for(let b in y){let x=y[b],S=!1;for(let C=0;C<t.length;C++)if(r[x.id]){m.outputs.forEach(I=>r[I.id]=!0),S=!0,s[m.id]=!0;break}if(S)break}}let u={};u[e.id]=!0;let l={};for(let p=n.length-1;p>=0;p--){let m=n[p],y=m.inputs;for(let b=0;b<m.outputs.length;b++)if(u[m.outputs[b].id]){for(let x in y)u[y[x].id]=!0,l[m.id]=!0;break}}let h=[];for(let p=0;p<n.length;p++){let m=n[p];if(s[m.id]&&l[m.id]){let y={};for(let x in m.inputs){let S=m.inputs[x];r[S.id]&&(y[x]=S)}let b=Object.assign({},m);b.inputs=y,b.outputs=m.outputs,h.push(b)}}return h}function QR(n,t,e,r){for(let s=t.length-1;s>=0;s--){let u=t[s],l=[];if(u.outputs.forEach(p=>{let m=n[p.id];m!=null?l.push(m):l.push(null)}),u.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${u.kernelName}.`);let h=u.gradient(l);for(let p in u.inputs){if(!(p in h))throw new Error(`Cannot backprop through input ${p}. Available gradients found: ${Object.keys(h)}.`);let m=e(()=>h[p]());if(m.dtype!=="float32")throw new Error(`Error in gradient for op ${u.kernelName}. The gradient of input ${p} must have 'float32' dtype, but has '${m.dtype}'`);let y=u.inputs[p];if(!K(m.shape,y.shape))throw new Error(`Error in gradient for op ${u.kernelName}. The gradient of input '${p}' has shape '${m.shape}', which does not match the shape of the input '${y.shape}'`);if(n[y.id]==null)n[y.id]=m;else{let b=n[y.id];n[y.id]=r(b,m),b.dispose()}}}}let Y2=20,sh=3,by=7;function tP(n,t,e,r){let s=Jt(t),u=eP(n,t,e,s),l=t.length,h=jp(n,t,e,s,u),p=["Tensor"];return r&&(p.push(`  dtype: ${e}`),p.push(`  rank: ${l}`),p.push(`  shape: [${t}]`),p.push("  values:")),p.push(h.map(m=>"    "+m).join(`
`)),p.join(`
`)}function eP(n,t,e,r){let s=O(t),u=r[r.length-1],l=new Array(u).fill(0),h=t.length,p=e==="complex64"?ah(n):n;if(h>1)for(let m=0;m<s/u;m++){let y=m*u;for(let b=0;b<u;b++)l[b]=Math.max(l[b],oh(p[y+b],0,e).length)}return l}function oh(n,t,e){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(by))} + ${parseFloat(n[1].toFixed(by))}j`:dn(n)?r=`'${n}'`:e==="bool"?r=J2(n):r=parseFloat(n.toFixed(by)).toString(),St(r,t)}function J2(n){return n===0?"false":"true"}function jp(n,t,e,r,s,u=!0){let l=e==="complex64"?2:1,h=t[0],p=t.length;if(p===0){if(e==="complex64"){let I=ah(n);return[oh(I[0],0,e)]}return e==="bool"?[J2(n[0])]:[n[0].toString()]}if(p===1){if(h>Y2){let D=sh*l,R=Array.from(n.slice(0,D)),A=Array.from(n.slice((h-sh)*l,h*l));return e==="complex64"&&(R=ah(R),A=ah(A)),["["+R.map((L,_)=>oh(L,s[_],e)).join(", ")+", ..., "+A.map((L,_)=>oh(L,s[h-sh+_],e)).join(", ")+"]"]}let I=e==="complex64"?ah(n):Array.from(n);return["["+I.map((D,R)=>oh(D,s[R],e)).join(", ")+"]"]}let m=t.slice(1),y=r.slice(1),b=r[0]*l,x=[];if(h>Y2){for(let I=0;I<sh;I++){let D=I*b,R=D+b;x.push(...jp(n.slice(D,R),m,e,y,s,!1))}x.push("...");for(let I=h-sh;I<h;I++){let D=I*b,R=D+b;x.push(...jp(n.slice(D,R),m,e,y,s,I===h-1))}}else for(let I=0;I<h;I++){let D=I*b,R=D+b;x.push(...jp(n.slice(D,R),m,e,y,s,I===h-1))}let S=p===2?",":"";x[0]="["+x[0]+S;for(let I=1;I<x.length-1;I++)x[I]=" "+x[I]+S;let C=`,
`;for(let I=2;I<p;I++)C+=`
`;return x[x.length-1]=" "+x[x.length-1]+"]"+(u?"":C),x}function ah(n){let t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class bn{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=O(t),r!=null){let s=r.length;k(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Kt(e,this.size),this.strides=Jt(t)}set(t,...e){e.length===0&&(e=[0]),k(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let r=this.locToIndex(e);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let s of t){if(s<0||s>=this.shape[e]){let u=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(u)}e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Gs().makeTensor(this.values,this.shape,this.dtype)}}let Gs=null,Tu=null,Z2=null;function nP(n){Gs=n}function rP(n){Tu=n}function sP(n){Z2=n}class at{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=O(t),this.strides=Jt(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return Tu.buffer(this.shape,this.dtype,t)}bufferSync(){return Tu.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Mr(this.shape,t)}arraySync(){return Mr(this.shape,this.dataSync())}async data(){this.throwIfDisposed();let t=Gs().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(r=>rh(r))}catch(r){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();let t=Gs().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>rh(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await Gs().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){if(this.isDisposed)return;Gs().disposeTensor(this),this.isDisposedInternal=!0}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Tu.print(this,t)}clone(){return this.throwIfDisposed(),Tu.clone(this)}toString(t=!1){let e=this.dataSync();return tP(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Tu.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),Gs().makeVariable(this,t,e,r)}}Object.defineProperty(at,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});class ih extends at{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!K(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Gs().disposeTensor(this),this.dataId=t.dataId,Gs().incRef(this,null)}dispose(){Gs().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(ih,Symbol.hasInstance,{value:n=>n instanceof at&&n.assign!=null&&n.assign instanceof Function});(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(o.Rank||(o.Rank={}));var wy;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(wy||(wy={}));var xy;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(xy||(xy={}));var Ty;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Ty||(Ty={}));var ky;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(ky||(ky={}));let oP={float32:Ty,int32:wy,bool:xy,complex64:ky};function Qn(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return oP[n][t]}function Kp(n){return Qn(n,"int32")}function nn(n,t){if(n.dtype===t.dtype)return[n,t];let e=Qn(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function Q2(n,t){k(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function Xp(n,t){return t.some(e=>e.id===n.id)}function mo(n){let t=[],e=new Set;return tS(n,t,e),t}function tS(n,t,e){if(n==null)return;if(n instanceof at){t.push(n);return}if(!aP(n))return;let r=n;for(let s in r){let u=r[s];e.has(u)||(e.add(u),tS(u,t,e))}}function aP(n){return Array.isArray(n)||typeof n=="object"}var iP=Object.freeze({__proto__:null,makeTypesMatch:nn,assertTypesMatch:Q2,isTensorInList:Xp,getTensorsInContainer:mo});class eS{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}}class ku{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new eS}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let r=t[e],s=await this.initializeBackend(r).success;if(s){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,r=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:r}=this.initializeBackend(t),s=r?await e:e;if(!s)return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new XR(this.backendInstance),!0}setupRegisteredKernels(){let t=Gp(this.backendName);t.forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){let e=Gp(t);e.forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=e.factory();if(r&&!(r instanceof f)&&typeof r.then=="function"){let s=++this.pendingBackendInitId,u=r.then(l=>s<this.pendingBackendInitId?!1:(this.registry[t]=l,this.pendingBackendInit=null,!0)).catch(l=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(l.stack||l.message)),!1));return this.pendingBackendInit=u,{success:u,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return console.warn(`Initialization of backend ${t} failed`),console.warn(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let r=t[e],{success:s,asyncInit:u}=this.initializeBackend(r);if(u||s)return{name:r,asyncInit:u}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let r=this.state.tensorInfo.get(e),s=r.backend,u=this.readSync(e);s.disposeData(e),r.backend=t,t.move(e,u,r.shape,r.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let r=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=e(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,e,r){t();try{let s=r();return e(),s}catch(s){throw e(),s}}nextTensorId(){return ku.nextTensorId++}nextVariableId(){return ku.nextVariableId++}clone(t){let e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),r={x:t},s=l=>({x:()=>{let h="float32",p={x:l},m={dtype:h};return J.runKernelFunc(y=>y.cast(l,h),p,null,pu,m)}}),u=[];return this.addTapeNode(this.state.activeScope.name,r,[e],s,u,{}),e}runKernel(t,e,r,s,u){let l=null,h=null;return this.runKernelFunc(l,e,h,t,r,s,u)}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,r){let s=this.backend.numDataIds(),u=0;r.forEach(p=>{u+=p.dtype==="complex64"?3:1});let l=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],h=s-e-u-l;if(h>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${h} data ids) after running '${t}'`)}runKernelFunc(t,e,r,s,u,l,h){let p,m=[],y=this.isTapeOn();s==null&&(s=this.state.activeScope!=null?this.state.activeScope.name:"");let b=this.state.numBytes,x=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let S,C=gy(s,this.backendName),I;if(C!=null)S=()=>{let R=this.backend.numDataIds();I=C.kernelFunc({inputs:e,attrs:u,backend:this.backend});let A=Array.isArray(I)?I:[I];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(s,R,A);let L=A.map(({dataId:_,shape:B,dtype:V})=>this.makeTensorFromDataId(_,B,V));if(y){let _=this.getTensorsForGradient(s,e,L);if(_==null){h==null&&(h=[]);let B=L.filter((V,q)=>h[q]);_=(l||[]).slice().concat(B)}m=this.saveTensorsForBackwardMode(_)}return L};else{let R=A=>{if(!y)return;m=A.map(L=>this.keep(this.clone(L)))};S=()=>{let A=this.backend.numDataIds();I=this.tidy(()=>t(this.backend,R));let L=Array.isArray(I)?I:[I];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(s,A,L),L}}let D;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?p=S():(D=this.profiler.profileKernel(s,e,()=>S()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(D),p=D.outputs)}),y&&this.addTapeNode(s,e,p,r,m,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:s,bytesAdded:this.state.numBytes-b,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-x,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map(R=>e[R]!=null?e[R].shape:null),outputShapes:p.map(R=>R.shape),kernelTimeMs:D.timeMs,extraInfo:D.extraInfo}),Array.isArray(I)?p:p[0]}saveTensorsForBackwardMode(t){let e=t.map(r=>this.keep(this.clone(r)));return e}getTensorsForGradient(t,e,r){let s=vy(t);if(s!=null){let u=s.inputsToSave||[],l=s.outputsToSave||[],h;s.saveAllInputs?(k(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),h=Object.keys(e).map(m=>e[m])):h=u.map(m=>e[m]);let p=r.filter((m,y)=>l[y]);return h.concat(p)}return null}makeTensor(t,e,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let u=t;r==="string"&&dn(t[0])&&(u=t.map(p=>qp(p)));let l=s.write(u,e,r),h=new at(e,r,l,this.nextTensorId());if(this.incRef(h,s),r==="string"){let p=this.state.tensorInfo.get(l),m=en(u);this.state.numBytes+=m-p.bytes,p.bytes=m}return h}makeTensorFromDataId(t,e,r,s){r=r||"float32";let u=new at(e,r,t,this.nextTensorId());return this.incRef(u,s),u}makeVariable(t,e=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let u=new ih(t,e,r,this.nextTensorId());if(this.state.registeredVariables[u.name]!=null)throw new Error(`Variable with name ${u.name} was already registered`);return this.state.registeredVariables[u.name]=u,this.incRef(u,this.backend),u}incRef(t,e){let r=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++,r===0){this.state.numDataBuffers++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*gn(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s,refCount:0}),this.state.numBytes+=s}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof ih||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,t.dtype==="string"&&this.state.numStringTensors--;let e=this.state.tensorInfo.get(t.dataId),r=e.refCount;r<=1?(t.dtype!=="complex64"&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,r,s,u,l){let h={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:r,saved:u},p=vy(t);p!=null&&(s=p.gradFunc),s!=null&&(h.gradient=m=>(m=m.map((y,b)=>{if(y==null){let x=r[b],S=fu(x.size,x.dtype);return this.makeTensor(S,x.shape,x.dtype)}return y}),s(m.length>1?m:m[0],u,l))),this.state.activeTape.push(h)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=mo(t),r=new Set(e.map(u=>u.id));for(let u=0;u<this.state.activeScope.track.length;u++){let l=this.state.activeScope.track[u];!l.kept&&!r.has(l.id)&&l.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(u=>{!u.kept&&u.scopeId===s.id&&this.track(u)})}gradients(t,e,r,s=!1){if(k(e.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let u=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));k(u instanceof at,()=>"The result y returned by f() must be a tensor.");let l=ZR(this.state.activeTape,e,u);if(!s&&l.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let h={};h[u.id]=r==null?uP(u.shape):r,QR(h,l,m=>this.tidy(m),cP);let p=e.map(m=>h[m.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(m=>{for(let y of m.saved)y.dispose()}),this.state.activeTape=null),{value:u,grads:p}})}customGrad(t){return k(Ln(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{k(e.every(u=>u instanceof at),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,s={};return e.forEach((u,l)=>{s[l]=u}),this.runKernelFunc((u,l)=>(r=t(...e,l),k(r.value instanceof at,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),k(Ln(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),s,(u,l)=>{let h=r.gradFunc(u,l),p=Array.isArray(h)?h:[h];k(p.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),k(p.every(y=>y instanceof at),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let m={};return p.forEach((y,b)=>{m[b]=()=>y}),m})}}readSync(t){let e=this.state.tensorInfo.get(t);return e.backend.readSync(t)}read(t){let e=this.state.tensorInfo.get(t);return e.backend.read(t)}async time(t){let e=cr(),r=await this.backend.time(t);return r.wallMs=cr()-e,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new eS;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ku.nextTensorId=0,ku.nextVariableId=0;function uP(n){let t=Nv(O(n),"float32");return J.makeTensor(t,n,"float32")}function nS(){let n=w2();if(n._tfengine==null){let t=new b2(n);n._tfengine=new ku(t)}return WR(n._tfengine.ENV),nP(()=>n._tfengine),n._tfengine}let J=nS();function cP(n,t){let e={a:n,b:t};return J.runKernelFunc((r,s)=>{let u=r.add(n,t);return s([n,t]),u},e,null,ri)}function lP(){return typeof navigator!="undefined"&&navigator!=null}function rS(){if(lP()){let n=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return!1}function Sy(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var hP=Object.freeze({__proto__:null,isMobile:rS,isBrowser:Sy});let go=ft();go.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),go.registerFlag("IS_BROWSER",()=>Sy()),go.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined"),go.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),go.registerFlag("PROD",()=>!1),go.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>go.getBool("DEBUG")),go.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),go.registerFlag("IS_TEST",()=>!1);function Hs(n,t){let e=n;if(Re(n))return t==="string"?[]:[n.length];if(!Array.isArray(n))return[];let r=[];for(;Array.isArray(e)||Re(e)&&t!=="string";)r.push(e.length),e=e[0];return Array.isArray(n)&&ft().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&sS(n,r,[]),r}function sS(n,t,e){if(e=e||[],!Array.isArray(n)&&!Re(n)){k(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}k(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),k(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);let r=t.slice(1);for(let s=0;s<n.length;++s)sS(n[s],r,e.concat(s))}function oS(n,t,e,r){if(n==null)return;if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}function z(n,t,e,r="numeric"){if(n instanceof at)return oS(r,n.dtype,t,e),n;let s=Us(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),oS(r,s,t,e),n==null||!Re(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){let p=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${p}'`)}let u=Hs(n,s);!Re(n)&&!Array.isArray(n)&&(n=[n]);let l=!0,h=s!=="string"?na(n,s):G(n,[],l);return J.makeTensor(h,u,s)}function uh(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);let s=n;return s.map((u,l)=>z(u,`${t}[${l}]`,e),r)}let aS="__op";function X(n){let t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+aS;let s=(...u)=>{J.startScope(e);try{let l=r(...u);return ni(l)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(l),l}catch(l){throw J.endScope(null),l}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}function fP(n,t){let e=z(n,"real","complex"),r=z(t,"imag","complex");$(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`);let s=l=>l.complex(e,r),u={real:e,imag:r};return J.runKernelFunc(s,u,null,mp)}let vo=X({complex_:fP});function ra(n,t,e,r){if(r==null&&(r=Us(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Re(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ev(t);let s=O(t),u=O(e);k(s===u,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${u}`);for(let l=0;l<e.length;++l){let h=e[l],p=l===e.length-1?h!==O(t.slice(l)):!0;k(e[l]===t[l]||!p,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Re(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=r!=="string"?na(n,r):G(n,[],!0),J.makeTensor(n,t,r)}function vn(n,t,e){let r=Hs(n,e);return ra(n,t,r,e)}let Cy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};let Yp=4;async function Ny(n,t){let e=[],r=[],s=Array.isArray(n)?n.map(l=>l.name):Object.keys(n);for(let l=0;l<s.length;++l){let h=s[l],p=Array.isArray(n)?n[l].tensor:n[h];if(p.dtype!=="float32"&&p.dtype!=="int32"&&p.dtype!=="bool"&&p.dtype!=="string"&&p.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${h}': ${p.dtype}`);let m={name:h,shape:p.shape,dtype:p.dtype};if(p.dtype==="string"){let y=new Promise(async b=>{let x=await p.bytes(),S=x.reduce((D,R)=>D+R.length,0)+Yp*x.length,C=new Uint8Array(S),I=0;for(let D=0;D<x.length;D++){let R=x[D],A=new Uint8Array(new Uint32Array([R.length]).buffer);C.set(A,I),I+=Yp,C.set(R,I),I+=R.length}b(C)});r.push(y)}else r.push(p.data());t!=null&&(m.group=t),e.push(m)}let u=await Promise.all(r);return{data:pP(u),specs:e}}function Jp(n,t){let e={},r,s=0;for(let u of t){let l=u.name,h=u.dtype,p=u.shape,m=O(p),y;if("quantization"in u){let b=u.quantization;if(b.dtype==="uint8"||b.dtype==="uint16"){if(!("min"in b&&"scale"in b))throw new Error(`Weight ${u.name} with quantization ${b.dtype} doesn't have corresponding metadata min and scale.`)}else if(b.dtype==="float16"){if(h!=="float32")throw new Error(`Weight ${u.name} is quantized with ${b.dtype} which only supports weights of type float32 not ${h}.`)}else throw new Error(`Weight ${u.name} has unknown quantization dtype ${b.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let x=Cy[b.dtype],S=n.slice(s,s+m*x),C=b.dtype==="uint8"?new Uint8Array(S):new Uint16Array(S);if(h==="float32")if(b.dtype==="uint8"||b.dtype==="uint16"){y=new Float32Array(C.length);for(let I=0;I<C.length;I++){let D=C[I];y[I]=D*b.scale+b.min}}else if(b.dtype==="float16")r===void 0&&(r=bP()),y=r(C);else throw new Error(`Unsupported quantization type ${b.dtype} for weight type float32.`);else if(h==="int32"){if(b.dtype!=="uint8"&&b.dtype!=="uint16")throw new Error(`Unsupported quantization type ${b.dtype} for weight type int32.`);y=new Int32Array(C.length);for(let I=0;I<C.length;I++){let D=C[I];y[I]=Math.round(D*b.scale+b.min)}}else throw new Error(`Unsupported dtype in weight '${l}': ${h}`);s+=m*x}else if(h==="string"){let b=O(u.shape);y=[];for(let x=0;x<b;x++){let S=new Uint32Array(n.slice(s,s+Yp))[0];s+=Yp;let C=new Uint8Array(n.slice(s,s+S));y.push(C),s+=S}}else{let b=Cy[h],x=n.slice(s,s+m*b);if(h==="float32")y=new Float32Array(x);else if(h==="int32")y=new Int32Array(x);else if(h==="bool")y=new Uint8Array(x);else if(h==="complex64"){y=new Float32Array(x);let S=new Float32Array(y.length/2),C=new Float32Array(y.length/2);for(let R=0;R<S.length;R++)S[R]=y[R*2],C[R]=y[R*2+1];let I=vn(S,p,"float32"),D=vn(C,p,"float32");e[l]=vo(I,D),I.dispose(),D.dispose()}else throw new Error(`Unsupported dtype in weight '${l}': ${h}`);s+=m*b}h!=="complex64"&&(e[l]=vn(y,p,h))}return e}function pP(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0,e=[];n.forEach(u=>{if(t+=u.byteLength,e.push(u.byteLength===u.buffer.byteLength?u:new u.constructor(u)),!(u instanceof Float32Array||u instanceof Int32Array||u instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${u.constructor.name}`)});let r=new Uint8Array(t),s=0;return e.forEach(u=>{r.set(new Uint8Array(u.buffer),s),s+=u.byteLength}),r.buffer}let Iy=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function iS(n){return Iy?Buffer.byteLength(n):new Blob([n]).size}function dP(n){if(Iy)return Buffer.from(n).toString("base64");let t=new Uint8Array(n),e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}function mP(n){if(Iy){let r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}function Zp(n){if(n.length===1)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});let e=new Uint8Array(t),r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function uS(n){let t="/";for(n=n.trim();n.endsWith(t);)n=n.slice(0,n.length-1);let e=n.split(t);return e[e.length-1]}function ch(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:iS(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:iS(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function gP(){let n=e=>{let r=e<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=~8388608,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function vP(){let n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function yP(){let n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function bP(){let n=gP(),t=vP(),e=yP();return r=>{let s=new ArrayBuffer(4*r.length),u=new Uint32Array(s);for(let l=0;l<r.length;l++){let h=r[l],p=n[e[h>>10]+(h&1023)]+t[h>>10];u[l]=p}return new Float32Array(s)}}class rn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return rn.instance==null&&(rn.instance=new rn),rn.instance}static registerSaveRouter(t){rn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){rn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return rn.getHandlers(t,"save")}static getLoadHandlers(t,e){return rn.getHandlers(t,"load",e)}static getHandlers(t,e,r){let s=[],u=e==="load"?rn.getInstance().loadRouters:rn.getInstance().saveRouters;return u.forEach(l=>{let h=l(t,r);h!==null&&s.push(h)}),s}}let wP=n=>rn.registerSaveRouter(n),xP=n=>rn.registerLoadRouter(n),Ey=n=>rn.getSaveHandlers(n),Dy=(n,t)=>rn.getLoadHandlers(n,t);let Qp="tensorflowjs",$y=1,si="models_store",sa="model_info_store";async function rht(){let n=Ay();return new Promise((t,e)=>{let r=n.deleteDatabase(Qp);r.onsuccess=()=>t(),r.onerror=s=>e(s)})}function Ay(){if(!ft().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let n=typeof window=="undefined"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function _y(n){let t=n.result;t.createObjectStore(si,{keyPath:"modelPath"}),t.createObjectStore(sa,{keyPath:"modelPath"})}class oi{constructor(t){if(this.indexedDB=Ay(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((r,s)=>{let u=this.indexedDB.open(Qp,$y);u.onupgradeneeded=()=>_y(u),u.onsuccess=()=>{let l=u.result;if(e==null){let h=l.transaction(si,"readonly"),p=h.objectStore(si),m=p.get(this.modelPath);m.onsuccess=()=>{if(m.result==null)return l.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(m.result.modelArtifacts)},m.onerror=y=>(l.close(),s(m.error)),h.oncomplete=()=>l.close()}else{let h=ch(e),p=l.transaction(sa,"readwrite"),m=p.objectStore(sa),y=m.put({modelPath:this.modelPath,modelArtifactsInfo:h}),b;y.onsuccess=()=>{b=l.transaction(si,"readwrite");let x=b.objectStore(si),S=x.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:h});S.onsuccess=()=>r({modelArtifactsInfo:h}),S.onerror=C=>{m=p.objectStore(sa);let I=m.delete(this.modelPath);I.onsuccess=()=>(l.close(),s(S.error)),I.onerror=D=>(l.close(),s(S.error))}},y.onerror=x=>(l.close(),s(y.error)),p.oncomplete=()=>{b==null?l.close():b.oncomplete=()=>l.close()}}},u.onerror=l=>s(u.error)})}}oi.URL_SCHEME="indexeddb://";let cS=n=>ft().getBool("IS_BROWSER")&&(!Array.isArray(n)&&n.startsWith(oi.URL_SCHEME))?TP(n.slice(oi.URL_SCHEME.length)):null;rn.registerSaveRouter(cS),rn.registerLoadRouter(cS);function TP(n){return new oi(n)}function kP(n){return n.startsWith(oi.URL_SCHEME)?n.slice(oi.URL_SCHEME.length):n}class SP{constructor(){this.indexedDB=Ay()}async listModels(){return new Promise((t,e)=>{let r=this.indexedDB.open(Qp,$y);r.onupgradeneeded=()=>_y(r),r.onsuccess=()=>{let s=r.result,u=s.transaction(sa,"readonly"),l=u.objectStore(sa),h=l.getAll();h.onsuccess=()=>{let p={};for(let m of h.result)p[m.modelPath]=m.modelArtifactsInfo;t(p)},h.onerror=p=>(s.close(),e(h.error)),u.oncomplete=()=>s.close()},r.onerror=s=>e(r.error)})}async removeModel(t){return t=kP(t),new Promise((e,r)=>{let s=this.indexedDB.open(Qp,$y);s.onupgradeneeded=()=>_y(s),s.onsuccess=()=>{let u=s.result,l=u.transaction(sa,"readwrite"),h=l.objectStore(sa),p=h.get(t),m;p.onsuccess=()=>{if(p.result==null)return u.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let y=h.delete(t),b=()=>{m=u.transaction(si,"readwrite");let x=m.objectStore(si),S=x.delete(t);S.onsuccess=()=>e(p.result.modelArtifactsInfo),S.onerror=C=>r(p.error)};y.onsuccess=b,y.onerror=x=>(b(),u.close(),r(p.error))}},p.onerror=y=>(u.close(),r(p.error)),l.oncomplete=()=>{m==null?u.close():m.oncomplete=()=>u.close()}},s.onerror=u=>r(s.error)})}}let qs="/",ai="tensorflowjs_models",lS="info",CP="model_topology",NP="weight_specs",IP="weight_data",EP="model_metadata";function sht(){if(!ft().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");let n=window.localStorage,t=[];for(let e=0;e<n.length;++e){let r=n.key(e),s=ai+qs;if(r.startsWith(s)&&r.length>s.length){n.removeItem(r);let u=fS(r);t.indexOf(u)===-1&&t.push(u)}}return t}function hS(n){return{info:[ai,n,lS].join(qs),topology:[ai,n,CP].join(qs),weightSpecs:[ai,n,NP].join(qs),weightData:[ai,n,IP].join(qs),modelMetadata:[ai,n,EP].join(qs)}}function fS(n){let t=n.split(qs);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(qs)}function DP(n){return n.startsWith(ii.URL_SCHEME)?n.slice(ii.URL_SCHEME.length):n}class ii{constructor(t){if(!ft().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=hS(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),s=ch(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,dP(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),{modelArtifactsInfo:s}}catch(u){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=r;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=s;let u=this.LS.getItem(this.keys.modelMetadata);if(u!=null){let h=JSON.parse(u);e.format=h.format,e.generatedBy=h.generatedBy,e.convertedBy=h.convertedBy,e.userDefinedMetadata=h.userDefinedMetadata}let l=this.LS.getItem(this.keys.weightData);if(l==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=mP(l),e}}ii.URL_SCHEME="localstorage://";let pS=n=>ft().getBool("IS_BROWSER")&&(!Array.isArray(n)&&n.startsWith(ii.URL_SCHEME))?$P(n.slice(ii.URL_SCHEME.length)):null;rn.registerSaveRouter(pS),rn.registerLoadRouter(pS);function $P(n){return new ii(n)}class AP{constructor(){k(ft().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),k(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=ai+qs,r=qs+lS;for(let s=0;s<this.LS.length;++s){let u=this.LS.key(s);if(u.startsWith(e)&&u.endsWith(r)){let l=fS(u);t[l]=JSON.parse(this.LS.getItem(u))}}return t}async removeModel(t){t=DP(t);let e=hS(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let r=JSON.parse(this.LS.getItem(e.info));return this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),r}}let Su="://";class Sr{constructor(){this.managers={}}static getInstance(){return Sr.instance==null&&(Sr.instance=new Sr),Sr.instance}static registerManager(t,e){k(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Su)&&(t=t.slice(0,t.indexOf(Su))),k(t.length>0,()=>"scheme must not be an empty string.");let r=Sr.getInstance();k(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){let e=this.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function td(n){if(n.indexOf(Su)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Sr.getSchemes().join(",")}`);return{scheme:n.split(Su)[0],path:n.split(Su)[1]}}async function dS(n,t,e=!1){k(n!==t,()=>`Old path and new path are the same: '${n}'`);let r=rn.getLoadHandlers(n);k(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),k(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);let s=r[0],u=rn.getSaveHandlers(t);k(u.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),k(u.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let l=u[0],h=td(n).scheme,p=td(n).path,m=h===td(n).scheme,y=await s.load();e&&m&&await Sr.getManager(h).removeModel(p);let b=await l.save(y);return e&&!m&&await Sr.getManager(h).removeModel(p),b.modelArtifactsInfo}async function _P(){let n=Sr.getSchemes(),t={};for(let e of n){let r=await Sr.getManager(e).listModels();for(let s in r){let u=e+Su+s;t[u]=r[s]}}return t}async function FP(n){let t=td(n),e=Sr.getManager(t.scheme);return e.removeModel(t.path)}async function RP(n,t){let e=!1;return dS(n,t,e)}async function PP(n,t){let e=!0;return dS(n,t,e)}class OP{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if(ft().get("IS_BROWSER")){ft().setPlatform("browser",new OP);try{Sr.registerManager(ii.URL_SCHEME,new AP)}catch(n){}try{Sr.registerManager(oi.URL_SCHEME,new SP)}catch(n){}}let MP={importFetch:()=>Nx()},Cu;function oht(){Cu=null}function aht(n){Cu=n}function iht(){return Cu}class LP{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return ft().global.fetch!=null?ft().global.fetch(t,e):(Cu==null&&(Cu=MP.importFetch()),Cu(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}}ft().get("IS_NODE")&&ft().setPlatform("node",new LP);function Ae(n,t="float32",e){return t=t||"float32",Ev(n),new bn(n,t,e)}function BP(n,t){let e=z(n,"x","cast");if(!ce(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:e},s={dtype:t};return J.runKernelFunc(u=>u.cast(e,t),r,null,pu,s)}let Rt=X({cast_:BP});function zP(n){let t=z(n,"x","clone",null),e=()=>J.makeTensorFromDataId(t.dataId,t.shape,t.dtype),r={x:t};return J.runKernelFunc(e,r,null,Al)}let oa=X({clone_:zP});function mS(n,t=!1){console.log(n.toString(t))}nS();let WP={buffer:Ae,cast:Rt,clone:oa,print:mS};rP(WP);let VP="model",UP=".json",GP=".weights.bin";function gS(n){return new Promise(t=>setTimeout(t)).then(n)}class ui{constructor(t){if(!ft().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ui.URL_SCHEME)&&(t=t.slice(ui.URL_SCHEME.length)),(t==null||t.length===0)&&(t=VP),this.modelTopologyFileName=t+UP,this.weightDataFileName=t+GP}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:r},u=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),l=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;if(l.download=this.modelTopologyFileName,l.href=u,await gS(()=>l.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let h=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;h.download=this.weightDataFileName,h.href=e,await gS(()=>h.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ch(t)}}}}ui.URL_SCHEME="downloads://";class HP{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){let t=this.files[0],e=this.files.slice(1);return new Promise((r,s)=>{let u=new FileReader;u.onload=l=>{let h=JSON.parse(l.target.result),p=h.modelTopology;if(p==null){s(new Error(`modelTopology field is missing from file ${t.name}`));return}e.length===0&&r({modelTopology:p});let m=h.weightsManifest;if(m==null){s(new Error(`weightManifest field is missing from file ${t.name}`));return}let y;try{y=this.checkManifestAndWeightFiles(m,e)}catch(C){s(C);return}let b=[],x=[],S=[];m.forEach(C=>{C.paths.forEach(I=>{x.push(I),S.push(null)}),b.push(...C.weights)}),m.forEach(C=>{C.paths.forEach(I=>{let D=new FileReader;D.onload=R=>{let A=R.target.result,L=x.indexOf(I);S[L]=A,S.indexOf(null)===-1&&r({modelTopology:p,weightSpecs:b,weightData:Zp(S),format:h.format,generatedBy:h.generatedBy,convertedBy:h.convertedBy,userDefinedMetadata:h.userDefinedMetadata})},D.onerror=R=>s(`Failed to weights data from file of path '${I}'.`),D.readAsArrayBuffer(y[I])})})},u.onerror=l=>s(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),u.readAsText(t)})}checkManifestAndWeightFiles(t,e){let r=[],s=e.map(l=>uS(l.name)),u={};for(let l of t)l.paths.forEach(h=>{let p=uS(h);if(r.indexOf(p)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${p}'`);if(r.push(p),s.indexOf(p)===-1)throw new Error(`Weight file with basename '${p}' is not provided.`);u[h]=e[s.indexOf(p)]});if(r.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${r.length}) and the number of weight files provided (${e.length}).`);return u}}let qP=n=>ft().getBool("IS_BROWSER")&&(!Array.isArray(n)&&n.startsWith(ui.URL_SCHEME))?jP(n.slice(ui.URL_SCHEME.length)):null;rn.registerSaveRouter(qP);function jP(n="model"){return new ui(n)}function KP(n){return new HP(n)}function vS(n,t,e,r){l(n),e=e==null?0:e,r=r==null?1:r,h(e,r);let s=0,u=p=>(p.then(m=>{let y=e+ ++s/n.length*(r-e);return t(y),m}),p);function l(p){k(p!=null&&Array.isArray(p)&&p.length>0,()=>"promises must be a none empty array")}function h(p,m){k(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${p}`),k(m>=0&&m<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${m}`),k(m>=p,()=>`startFraction must be no more than endFraction, but got startFraction ${p} and endFraction ${m}`)}return Promise.all(n.map(u))}async function yS(n,t){t==null&&(t={});let e=t.fetchFunc==null?ft().platform.fetch:t.fetchFunc,r=n.map(b=>e(b,t.requestInit,{isBinary:!0})),s=0,u=.5,l=t.onProgress==null?await Promise.all(r):await vS(r,t.onProgress,s,u),h=l.map(b=>b.arrayBuffer()),p=.5,m=1,y=t.onProgress==null?await Promise.all(h):await vS(h,t.onProgress,p,m);return y}async function bS(n,t="",e,r){let s=l=>yS(l,{requestInit:r}),u=wS(s);return u(n,t,e)}function wS(n){return async(t,e="",r)=>{let s=t.map(()=>!1),u={},l=r!=null?r.map(()=>!1):[],h=[];if(t.forEach((S,C)=>{let I=0;S.weights.forEach(D=>{let R="quantization"in D?D.quantization.dtype:D.dtype,A=Cy[R]*O(D.shape),L=()=>{s[C]=!0,u[C]==null&&(u[C]=[]),u[C].push({manifestEntry:D,groupOffset:I,sizeBytes:A})};r!=null?r.forEach((_,B)=>{_===D.name&&(L(),l[B]=!0)}):L(),h.push(D.name),I+=A})}),!l.every(S=>S)){let S=r.filter((C,I)=>!l[I]);throw new Error(`Could not find weights in manifest with names: ${S.join(", ")}. 
Manifest JSON has weights with names: ${h.join(", ")}.`)}let p=s.reduce((S,C,I)=>(C&&S.push(I),S),[]),m=[];p.forEach(S=>{t[S].paths.forEach(C=>{let I=e+(e.endsWith("/")?"":"/")+C;m.push(I)})});let y=await n(m),b={},x=0;return p.forEach(S=>{let C=t[S].paths.length,I=0;for(let _=0;_<C;_++)I+=y[x+_].byteLength;let D=new ArrayBuffer(I),R=new Uint8Array(D),A=0;for(let _=0;_<C;_++){let B=new Uint8Array(y[x+_]);R.set(B,A),A+=B.byteLength}let L=u[S];L.forEach(_=>{let B=D.slice(_.groupOffset,_.groupOffset+_.sizeBytes),V=Jp(B,[_.manifestEntry]);for(let q in V)b[q]=V[q]}),x+=C}),b}}let XP="application/octet-stream",YP="application/json";class Fy{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(k(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=ft().platform.fetch,k(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&k(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let r=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:r};e.body.append("model.json",new Blob([JSON.stringify(s)],{type:YP}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:XP}),"model.weights.bin");let u=await this.fetch(this.path,e);if(u.ok)return{modelArtifactsInfo:ch(t),responses:[u]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${u.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(S){let C=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?C+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":C+=" Please make sure the server is serving valid JSON for this request.",new Error(C)}let r=e.modelTopology,s=e.weightsManifest,u=e.generatedBy,l=e.convertedBy,h=e.format,p=e.userDefinedMetadata;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let m,y;if(s!=null){let S=await this.loadWeights(s);[m,y]=S}let b={modelTopology:r,weightSpecs:m,weightData:y,userDefinedMetadata:p,generatedBy:u,convertedBy:l,format:h},x=e.modelInitializer;return x&&(b.modelInitializer=x),b}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=JP(e),u=this.weightPathPrefix||r,l=[];for(let y of t)l.push(...y.weights);let h=[],p=[];for(let y of t)for(let b of y.paths)this.weightUrlConverter!=null?p.push(this.weightUrlConverter(b)):h.push(u+b+s);this.weightUrlConverter&&h.push(...await Promise.all(p));let m=await yS(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[l,Zp(m)]}}Fy.URL_SCHEME_REGEX=/^https?:\/\//;function JP(n){let t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),r=n.substring(0,t),s=e>t?n.substring(e):"";return[r+"/",s]}function Ry(n){return n.match(Fy.URL_SCHEME_REGEX)!=null}let xS=(n,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(r=>Ry(r)):e=Ry(n),e)return Py(n,t)}return null};rn.registerSaveRouter(xS),rn.registerLoadRouter(xS);function Py(n,t){return new Fy(n,t)}function ed(n,t){return Py(n,t)}class Oy{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class ZP{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function QP(n,t,e,r){if(arguments.length===1){let s=n.modelTopology!=null||n.weightSpecs!=null;return s?new Oy(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Oy({modelTopology:n}))}else return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Oy({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r})}function tO(n){return new ZP(n)}var eO=Object.freeze({__proto__:null,browserFiles:KP,browserHTTPRequest:ed,concatenateArrayBuffers:Zp,decodeWeights:Jp,encodeWeights:Ny,fromMemory:QP,getLoadHandlers:Dy,getModelArtifactsInfoForJSON:ch,getSaveHandlers:Ey,http:Py,isHTTPScheme:Ry,loadWeights:bS,registerLoadRouter:xP,registerSaveRouter:wP,weightsLoaderFactory:wS,withSaveHandler:tO,copyModel:RP,listModels:_P,moveModel:PP,removeModel:FP});function nO(n,t){let e=z(n,"x","reshape",null),r={x:e},s={shape:t},u=(l,h)=>(t=Gt(t,e.size),k(e.size===O(t),()=>"new shape and old shape must have the same number of elements."),h([e]),l.reshape(e,t));return J.runKernelFunc(u,r,null,Ul,s)}let rt=X({reshape_:nO});function rO(n,t,e=!1,r=!1){let s=z(n,"a","matMul"),u=z(t,"b","matMul");[s,u]=nn(s,u);let l=(m,y)=>{y([s,u]);let b=e?s.shape[s.rank-2]:s.shape[s.rank-1],x=r?u.shape[u.rank-1]:u.shape[u.rank-2],S=e?s.shape[s.rank-1]:s.shape[s.rank-2],C=r?u.shape[u.rank-2]:u.shape[u.rank-1],I=s.shape.slice(0,-2),D=u.shape.slice(0,-2),R=O(I),A=O(D),L=R===A||R===1||A===1;k(s.rank>=2&&u.rank>=2&&L,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${I}) and (${D}).`),k(b===x,()=>`Error in matMul: inner shapes (${b}) and (${x}) of Tensors with shapes ${s.shape} and ${u.shape} and transposeA=${e} and transposeB=${r} must match.`);let _=R>A?I:D,B=_.concat([S,C]),V=e?rt(s,[R,b,S]):rt(s,[R,S,b]),q=r?rt(u,[A,C,x]):rt(u,[A,x,C]),j=m.batchMatMul(V,q,e,r);return rt(j,B)},h={a:s,b:u},p={transposeA:e,transposeB:r};return J.runKernelFunc(l,h,null,dp,p)}let xe=X({matMul_:rO});function sO(n,t,e=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s=z(n,"indices","oneHot","int32"),u=[...s.shape,t],l=(m,y)=>(y([s]),rt(m.oneHot(rt(s,[s.size]),t,e,r),u)),h={indices:s},p={depth:t,onValue:e,offValue:r};return J.runKernelFunc(l,h,null,ry,p)}let ci=X({oneHot_:sO});function oO(n,t){let e=z(n,"x","transpose");if(t==null&&(t=e.shape.map((u,l)=>l).reverse()),k(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(u=>{k(u>=0&&u<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1)return e.clone();let r={x:e},s={perm:t};return J.runKernelFunc(u=>u.transpose(e,t),r,null,th,s)}let re=X({transpose_:oO});function aO(n,t,e){let r=z(n,"labels","confusionMatrix"),s=z(t,"predictions","confusionMatrix");k(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),k(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),k(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),k(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),k(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let u=ci(Rt(r,"int32"),e),l=ci(Rt(s,"int32"),e),h=re(u),p=xe(h,l);return Rt(p,"int32")}let iO=X({confusionMatrix_:aO});var uO=Object.freeze({__proto__:null,confusionMatrix:iO});function TS(n,t,e){if(M(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Hs(n,e);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ra(n,t,r,e)}let Nu;function cO(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,u=!1,l=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)u=!0;else if(n.getContext!=null)l=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(s){let S=2;if(s&&n.readyState<S)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}let h=gy(Bp,J.backendName);if(h!=null){let S={pixels:n},C={numChannels:t};return J.runKernel(Bp,S,C)}let[p,m]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height],y;l?y=n.getContext("2d").getImageData(0,0,p,m).data:r||e?y=n.data:(u||s)&&(Nu==null&&(Nu=document.createElement("canvas").getContext("2d")),Nu.canvas.width=p,Nu.canvas.height=m,Nu.drawImage(n,0,0,p,m),y=Nu.getImageData(0,0,p,m).data);let b;if(t===4)b=new Int32Array(y);else{let S=p*m;b=new Int32Array(S*t);for(let C=0;C<S;C++)for(let I=0;I<t;++I)b[C*t+I]=y[C*4+I]}let x=[m,p,t];return TS(b,x,"int32")}async function lO(n,t){let e=z(n,"img","toPixels");if(!(n instanceof at)){let m=e;e=Rt(m,"int32"),m.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[r,s]=e.shape.slice(0,2),u=e.rank===2?1:e.shape[2];if(u>4||u===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${u}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let l=await e.data(),h=e.dtype==="float32"?255:1,p=new Uint8ClampedArray(s*r*4);for(let m=0;m<r*s;++m){let y=[0,0,0,255];for(let x=0;x<u;x++){let S=l[m*u+x];if(e.dtype==="float32"){if(S<0||S>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`)}else if(e.dtype==="int32"&&(S<0||S>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);u===1?(y[0]=S*h,y[1]=S*h,y[2]=S*h):y[x]=S*h}let b=m*4;p[b+0]=Math.round(y[0]),p[b+1]=Math.round(y[1]),p[b+2]=Math.round(y[2]),p[b+3]=Math.round(y[3])}if(t!=null){t.width=s,t.height=r;let m=t.getContext("2d"),y=new ImageData(p,s,r);m.putImageData(y,0,0)}return e!==n&&e.dispose(),p}let kS=X({fromPixels_:cO});var hO=Object.freeze({__proto__:null,toPixels:lO,fromPixels:kS});function nd(n,t){if(n.rank<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[t.rank-1]>n.rank)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[t.rank-1]} vs. ${n.rank}`);if(n.size===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);let e=t.shape,r=e[e.length-1],s=1;for(let m=0;m<e.length-1;++m)s*=e[m];let u=n.shape,l=e.slice();l.pop();let h=1;for(let m=r;m<n.rank;++m)h*=u[m],l.push(u[m]);let p=[...Jt(n.shape).map(m=>m/h),1].slice(0,r);return[l,s,h,p]}var fO=Object.freeze({__proto__:null,prepareAndValidate:nd});function My(n,t,e){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,u=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(u+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(u+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(u+` update.rank != ${s+n.length-r}`);for(let l=0;l<s;++l)if(e.shape[l]!==t.shape[l])throw new Error(u+` updates.shape[${l}] (${e.shape[l]}) != indices.shape[${l}] (${t.shape[l]}).`);for(let l=0;l<e.rank-s;++l)if(e.shape[l+s]!==n[l+r])throw new Error(u+` updates.shape[${l+s}] (${e.shape[l+s]}) != shape[${l+s}] (${n[l+s]})`)}function Ly(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}My(e,t,n)}function Iu(n,t,e){let r=t.shape.length,s=r>1?t.shape[r-1]:1,u=e.length,l=1;for(let b=s;b<u;++b)l*=e[b];let h=s<1?1:s,p=O(t.shape)/h,m=[...Jt(e.slice(0,s)),1],y=O(e);return{sliceRank:s,numUpdates:p,sliceSize:l,strides:m,outputSize:y}}var pO=Object.freeze({__proto__:null,validateUpdateShape:My,validateInput:Ly,calculateShapes:Iu});function By(n,t,e){let r=n.shape.length;k(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),k(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)k(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function rd(n){let t=[],e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function sd(n,t,e){let r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function SS(n,t,e,r){let s=[...n];for(let u=s.length;u<r.length;u++)s.push(1);for(let u=0;u<e;u++)u===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function CS(n,t,e){return e<=n?e:e-(t-1)}function NS(n,t){let e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function IS(n,t,e,r,s,u,l,h,p){let m=n.length,y=new Array(m),b=new Array(m),x=new Array(m);if(t.length&&e>0){let S=t[0],C=e+1;y=ES(l,S,C,r,n),b=DS(h,S,C,s,n),x=SS(u,S,C,n)}else for(let S=0;S<m;S++)y[S]=AS(l,r,u,n,S,p),b[S]=_S(h,s,u,n,S,p),x[S]=$S(u,S,p);return{begin:y,end:b,strides:x}}function ES(n,t,e,r,s){let u=[...s],l=NS(e,t);for(let h=0;h<u.length;h++)if(l.indexOf(h)>-1)u[h]=0;else{let p=CS(t,e,h),m=r[p];n&1<<p&&(m=0),u[h]=m}return u}function DS(n,t,e,r,s){let u=[...s],l=NS(e,t);for(let h=0;h<u.length;h++)if(l.indexOf(h)>-1)u[h]=Number.MAX_SAFE_INTEGER;else{let p=CS(t,e,h),m=r[p];n&1<<p&&(m=Number.MAX_SAFE_INTEGER),u[h]=m}for(let h=0;h<u.length;h++){let p=s[h];u[h]<0&&(u[h]+=p),u[h]=v(0,u[h],s[h])}return u}function $S(n,t,e){let r=n[t];return(e&1<<t||r==null)&&(r=1),r}function AS(n,t,e,r,s,u){let l=t[s],h=e[s]||1;(n&1<<s||u&1<<s||l==null)&&(h>0?l=Number.MIN_SAFE_INTEGER:l=Number.MAX_SAFE_INTEGER);let p=r[s];return l<0&&(l+=p),l=v(0,l,p-1),l}function _S(n,t,e,r,s,u){let l=t[s],h=e[s]||1;(n&1<<s||u&1<<s||l==null)&&(h>0?l=Number.MAX_SAFE_INTEGER:l=Number.MIN_SAFE_INTEGER);let p=r[s];return l<0&&(l+=p),h>0?l=v(0,l,p):l=v(-1,l,p-1),l}function zy(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function Wy(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function od(n,t,e){let r,s=n.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(l=>{k(l!==-1,()=>"slice() does not support negative begin indexing.")});let u;return e==null?u=new Array(s).fill(-1):typeof e=="number"?u=[e,...new Array(s-1).fill(-1)]:e.length<s?u=e.concat(new Array(s-e.length).fill(-1)):u=e,u=u.map((l,h)=>l>=0?l:(k(l===-1,()=>`Negative size values should be exactly -1 but got ${l} for the slice() size at index ${h}.`),n.shape[h]-r[h])),[r,u]}var FS=Object.freeze({__proto__:null,assertParamsValid:By,maskToAxes:rd,computeOutShape:sd,stridesWithElidedDims:SS,getNormalizedAxes:IS,startIndicesWithElidedDims:ES,stopIndicesWithElidedDims:DS,stridesForAxis:$S,startForAxis:AS,stopForAxis:_S,isSliceContinous:zy,computeFlatOffset:Wy,parseSliceParams:od});class li{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Lr{constructor(){this.classNameMap={}}static getMap(){return Lr.instance==null&&(Lr.instance=new Lr),Lr.instance}static register(t){Lr.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function kt(n){k(n.className!=null,()=>"Class being registered does not have the static className property defined."),k(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),k(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Lr.register(n)}var dO=Object.freeze({__proto__:null,Serializable:li,SerializationMap:Lr,registerClass:kt});let mO=.001,RS=.1;function gO(n,t,e){return e==null&&(e=ad()),Vy(n,t,(r,s)=>Gy(r,s,e))}function ad(){return J.backend.floatPrecision()===32?mO:RS}function Vy(n,t,e){let r=!0;if((Re(n)||Re(t))&&(r=!1),Re(n)&&Re(t)&&(r=!0),r){let l=n.constructor.name,h=t.constructor.name;if(l!==h)throw new Error(`Arrays are of different type. Actual: ${l}. Expected: ${h}`)}if(Array.isArray(n)&&Array.isArray(t)){let l=Hs(n),h=Hs(t);if(!K(l,h))throw new Error(`Arrays have different shapes. Actual: [${l}]. Expected: [${h}]`)}let s=Re(n)?n:G(n),u=Re(t)?t:G(t);if(s.length!==u.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${u.length}.
Actual:   ${s}.
Expected: ${u}.`);for(let l=0;l<u.length;++l){let h=s[l],p=u[l];if(!e(h,p))throw new Error(`Arrays differ: actual[${l}] = ${h}, expected[${l}] = ${p}.
Actual:   ${s}.
Expected: ${u}.`)}}function vO(n,t){n().then(()=>t.fail(),()=>t())}function yO(n,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return dn(n)||dn(n[0])||dn(t)||dn(t[0])?Vy(n,e,(r,s)=>r==s):Vy(n,t,(r,s)=>Gy(r,s,0))}function Uy(n,t,e){if(e==null&&(e=ad()),!Gy(n,t,e))throw new Error(`Numbers differ: actual === ${n}, expected === ${t}`)}function Gy(n,t,e){return!isFinite(n)&&!isFinite(t)?!0:!(isNaN(n)||isNaN(t)||Math.abs(n-t)>e)}function bO(n,t,e){for(let r=0;r<n.length;r++)if(n[r]<t||n[r]>e)throw new Error(`Value out of range:${n[r]} low: ${t}, high: ${e}`)}function wO(n,t){expect(new Float32Array(n)).toEqual(new Float32Array(t))}var xO=Object.freeze({__proto__:null,TEST_EPSILON_FLOAT16:RS,expectArraysClose:gO,testEpsilon:ad,expectPromiseToFail:vO,expectArraysEqual:yO,expectNumbersClose:Uy,expectValuesInRange:bO,expectArrayBuffersEqual:wO});let PS="2.7.0";function TO(){ft().set("PROD",!0)}function kO(){ft().set("DEBUG",!0)}function SO(){ft().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Tn(n){ft().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}sP(Tn);function CO(){J.disposeVariables()}function yo(){return J}function id(){return J.memory()}function NO(n){return J.profile(n)}function ot(n,t){return J.tidy(n,t)}function oe(n){let t=mo(n);t.forEach(e=>e.dispose())}function An(n){return J.keep(n)}function IO(n){return J.time(n)}function OS(n){return J.setBackend(n)}function EO(){return J.ready()}function DO(){return J.backendName}function $O(n){J.removeBackend(n)}function AO(n){return J.findBackend(n)}function _O(n){return J.findBackendFactory(n)}function Hy(n,t,e=1){return J.registerBackend(n,t,e)}function MS(){return J.backend}function FO(n,t){ft().setPlatform(n,t)}function RO(n,t){let e=z(n,"a","add"),r=z(t,"b","add");[e,r]=nn(e,r);let s=(l,h)=>{let p=l.add(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,ri)}let Nt=X({add_:RO});function PO(n,t){let e=z(n,"a","floorDiv"),r=z(t,"b","floorDiv");[e,r]=nn(e,r);let s=(l,h)=>{let p=l.floorDiv(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,Uv)}let ud=X({floorDiv_:PO});function OO(n,t){let e=z(n,"a","div"),r=z(t,"b","div");if([e,r]=nn(e,r),e.dtype==="int32"&&r.dtype==="int32")return ud(e,r);let s=(h,p)=>{let m=h.realDivide(e,r);return p([e,r]),m},u={a:e,b:r},l={};return J.runKernelFunc(s,u,null,mu,l)}let Ht=X({div_:OO});function MO(n,t){let e=z(n,"a","mul"),r=z(t,"b","mul");[e,r]=nn(e,r);let s=(l,h)=>{let p=l.multiply(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,gu)}let st=X({mul_:MO});function LO(n){let t=z(n,"x","abs"),e={x:t};return J.runKernelFunc((r,s)=>(s([t]),t.dtype==="complex64"?r.complexAbs(t):r.abs(t)),e,null,hp)}let kn=X({abs_:LO});function BO(n){let t=z(n,"x","acos"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.acos(t);return s([t]),u},e,null,dl)}let qy=X({acos_:BO});function zO(n){let t=z(n,"x","acosh"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.acosh(t);return s([t]),u},e,null,ml)}let jy=X({acosh_:zO});function WO(n){k(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),k(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);let t=n.map((u,l)=>z(u,`tensors${l}`,"addN")),e=t[0];t.forEach(u=>{if(u.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(u=>{if(!K(u.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=(u,l)=>{let h=u.addN(t);return l(t),h},s=t;return J.runKernelFunc(r,s,null,$v)}let LS=X({addN_:WO});function Ky(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function BS(n,t,e){let r=n.length+t.length,s=[],u=0,l=0;for(let h=0;h<r;h++)e.indexOf(h)===-1?s.push(n[u++]):s.push(t[l++]);return s}function Bn(n,t){let e=[],r=n.length;for(let u=0;u<r;u++)t.indexOf(u)===-1&&e.push(n[u]);let s=t.map(u=>n[u]);return[e,s]}function zn(n,t){let e=t.map(r=>1);return BS(n,e,t)}function lr(n,t,e){k(Ky(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function hr(n,t){if(Ky(n,t))return null;let e=[];for(let r=0;r<t;++r)n.indexOf(r)===-1&&e.push(r);return n.forEach(r=>e.push(r)),e}function lh(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Cr(n,t){let e=[];for(let r=t-n;r<t;++r)e.push(r);return e}function VO(n,t=null,e=!1){let r=z(n,"x","all","bool"),s=h=>{let p=Et(t,r.shape),m=p,y=hr(m,r.rank);y!=null&&(r=re(r,y),m=Cr(m.length,r.rank));let b=h.all(r,m);if(e){let x=zn(b.shape,p);return rt(b,x)}return b},u={x:r},l={axis:t,keepDims:e};return J.runKernelFunc(s,u,null,T2,l)}let cd=X({all_:VO});function UO(n,t=null,e=!1){let r=z(n,"x","any","bool"),s=h=>{let p=Et(t,r.shape),m=p,y=hr(m,r.rank);y!=null&&(r=re(r,y),m=Cr(m.length,r.rank));let b=h.any(r,m);if(e){let x=zn(b.shape,p);return rt(b,x)}return b},u={x:r},l={axis:t,keepDims:e};return J.runKernelFunc(s,u,null,k2,l)}let hh=X({any_:UO});function GO(n,t=0){let e=z(n,"x","argMax"),r=(l,h)=>{h([e]);let p=Et(t,e.shape),m=hr(p,e.rank);return m!=null&&(e=re(e,m),p=Cr(p.length,e.rank)),l.argMax(e,p[0])},s={x:e},u={axis:t};return J.runKernelFunc(r,s,null,Av,u)}let fh=X({argMax_:GO});function HO(n,t=0){let e=z(n,"x","argMin"),r=(l,h)=>{h([e]),t==null&&(t=0);let p=Et(t,e.shape),m=hr(p,e.rank);return m!=null&&(e=re(e,m),p=Cr(p.length,e.rank)),l.argMin(e,p[0])},s={x:e},u={axis:t};return J.runKernelFunc(r,s,null,_v,u)}let Xy=X({argMin_:HO});function qO(n){let t=z(n,"x","asin"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.asin(t);return s([t]),u},e,null,gl)}let Yy=X({asin_:qO});function jO(n){let t=z(n,"x","asinh"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.asinh(t);return s([t]),u},e,null,vl)}let Jy=X({asinh_:jO});function KO(n){let t=z(n,"x","atan"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.atan(t);return s([t]),u},e,null,yl)}let Zy=X({atan_:KO});function XO(n,t){let e=z(n,"a","atan2"),r=z(t,"b","atan2");[e,r]=nn(e,r);let s=(l,h)=>{let p=l.atan2(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,fp)}let Qy=X({atan2_:XO});function YO(n){let t=z(n,"x","atanh"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.atanh(t);return s([t]),u},e,null,bl)}let tb=X({atanh_:YO});function ld(n,t,e,r,s="NHWC",u){let l=n[3],h=[...t,l],p=ua(s);return Kn(n,h,e,u,r,null,null,p)}function tr(n,t,e,r,s,u,l="channelsLast"){let[h,p]=hd(t),m;if(l==="channelsLast")m=[h,p,n[3],n[3]];else if(l==="channelsFirst")m=[h,p,n[1],n[1]];else throw new Error(`Unknown dataFormat ${l}`);return Kn(n,m,e,r,s,u,!1,l)}function ph(n,t,e,r,s,u,l="NDHWC"){let[h,p,m]=nb(t),y,b;if(l==="NDHWC")b="channelsLast",y=[h,p,m,n[4],n[4]];else if(l==="NCDHW")b="channelsFirst",y=[h,p,m,n[1],n[1]];else throw new Error(`Unknown dataFormat ${l}`);return aa(n,y,e,r,s,!1,b,u)}function Kn(n,t,e,r,s,u,l=!1,h="channelsLast"){let[p,m,y,b]=[-1,-1,-1,-1];if(h==="channelsLast")[p,m,y,b]=n;else if(h==="channelsFirst")[p,b,m,y]=n;else throw new Error(`Unknown dataFormat ${h}`);let[x,S,,C]=t,[I,D]=hd(e),[R,A]=hd(r),L=Eu(x,R),_=Eu(S,A),{padInfo:B,outHeight:V,outWidth:q}=QO(s,m,y,I,D,L,_,u,h),j=l?C*b:C,et;return h==="channelsFirst"?et=[p,j,V,q]:h==="channelsLast"&&(et=[p,V,q,j]),{batchSize:p,dataFormat:h,inHeight:m,inWidth:y,inChannels:b,outHeight:V,outWidth:q,outChannels:j,padInfo:B,strideHeight:I,strideWidth:D,filterHeight:x,filterWidth:S,effectiveFilterHeight:L,effectiveFilterWidth:_,dilationHeight:R,dilationWidth:A,inShape:n,outShape:et,filterShape:t}}function aa(n,t,e,r,s,u=!1,l="channelsLast",h){let[p,m,y,b,x]=[-1,-1,-1,-1,-1];if(l==="channelsLast")[p,m,y,b,x]=n;else if(l==="channelsFirst")[p,x,m,y,b]=n;else throw new Error(`Unknown dataFormat ${l}`);let[S,C,I,,D]=t,[R,A,L]=nb(e),[_,B,V]=nb(r),q=Eu(S,_),j=Eu(C,B),et=Eu(I,V),{padInfo:tt,outDepth:ht,outHeight:gt,outWidth:vt}=tM(s,m,y,b,R,A,L,q,j,et,h),bt=u?D*x:D,yt;return l==="channelsFirst"?yt=[p,bt,ht,gt,vt]:l==="channelsLast"&&(yt=[p,ht,gt,vt,bt]),{batchSize:p,dataFormat:l,inDepth:m,inHeight:y,inWidth:b,inChannels:x,outDepth:ht,outHeight:gt,outWidth:vt,outChannels:bt,padInfo:tt,strideDepth:R,strideHeight:A,strideWidth:L,filterDepth:S,filterHeight:C,filterWidth:I,effectiveFilterDepth:q,effectiveFilterHeight:j,effectiveFilterWidth:et,dilationDepth:_,dilationHeight:B,dilationWidth:V,inShape:n,outShape:yt,filterShape:t}}function JO(n,t,e,r,s){r==null&&(r=eb(n,t,e));let u=n[0],l=n[1],h=hi((u-t+2*r)/e+1,s);k(nt(h),()=>`The output # of rows (${h}) must be an integer. Change the stride and/or zero pad parameters`);let p=hi((l-t+2*r)/e+1,s);return k(nt(p),()=>`The output # of columns (${p}) must be an integer. Change the stride and/or zero pad parameters`),[h,p]}function ZO(n,t,e,r,s,u){s==null&&(s=eb(n,t,r));let l=n[0],h=n[1],p=n[2],m=hi((l-t+2*s)/r+1,u);k(nt(m),()=>`The output # of depths (${m}) must be an integer. Change the stride and/or zero pad parameters`);let y=hi((h-t+2*s)/r+1,u);k(nt(y),()=>`The output # of rows (${y}) must be an integer. Change the stride and/or zero pad parameters`);let b=hi((p-t+2*s)/r+1,u);return k(nt(b),()=>`The output # of columns (${b}) must be an integer. Change the stride and/or zero pad parameters`),[m,y,b,e]}function eb(n,t,e,r=1){let s=Eu(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function hd(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function nb(n){return typeof n=="number"?[n,n,n]:n}function Eu(n,t){return t<=1?n:n+(n-1)*(t-1)}function QO(n,t,e,r,s,u,l,h,p){let m,y,b;if(typeof n=="number"){let x=n===0?"VALID":"NUMBER";m={top:n,bottom:n,left:n,right:n,type:x};let S=JO([t,e],u,r,n,h);y=S[0],b=S[1]}else if(n==="same"){y=Math.ceil(t/r),b=Math.ceil(e/s);let x=Math.max(0,(y-1)*r+u-t),S=Math.max(0,(b-1)*s+l-e),C=Math.floor(x/2),I=x-C,D=Math.floor(S/2),R=S-D;m={top:C,bottom:I,left:D,right:R,type:"SAME"}}else if(n==="valid")m={top:0,bottom:0,left:0,right:0,type:"VALID"},y=Math.ceil((t-u+1)/r),b=Math.ceil((e-l+1)/s);else if(typeof n=="object"){let x=p==="channelsLast"?n[1][0]:n[2][0],S=p==="channelsLast"?n[1][1]:n[2][1],C=p==="channelsLast"?n[2][0]:n[3][0],I=p==="channelsLast"?n[2][1]:n[3][1],D=x===0&&S===0&&C===0&&I===0?"VALID":"EXPLICIT";m={top:x,bottom:S,left:C,right:I,type:D},y=hi((t-u+x+S)/r+1,h),b=hi((e-l+C+I)/s+1,h)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:m,outHeight:y,outWidth:b}}function tM(n,t,e,r,s,u,l,h,p,m,y){let b,x,S,C;if(typeof n=="number"){let I=n===0?"VALID":"NUMBER";b={top:n,bottom:n,left:n,right:n,front:n,back:n,type:I};let D=ZO([t,e,r,1],h,1,s,n,y);x=D[0],S=D[1],C=D[2]}else if(n==="same"){x=Math.ceil(t/s),S=Math.ceil(e/u),C=Math.ceil(r/l);let I=(x-1)*s+h-t,D=(S-1)*u+p-e,R=(C-1)*l+m-r,A=Math.floor(I/2),L=I-A,_=Math.floor(D/2),B=D-_,V=Math.floor(R/2),q=R-V;b={top:_,bottom:B,left:V,right:q,front:A,back:L,type:"SAME"}}else if(n==="valid")b={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},x=Math.ceil((t-h+1)/s),S=Math.ceil((e-p+1)/u),C=Math.ceil((r-m+1)/l);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:b,outDepth:x,outHeight:S,outWidth:C}}function hi(n,t){if(!t)return n;switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function ia(n){let[t,e,r]=hd(n);return t===1&&e===1&&r===1}function wn(n,t){return ia(n)||ia(t)}function ua(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function eM(n,t,e,r,s){let u=z(n,"x","avgPool","float32"),l=1;k(wn(e,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${l}'`);let h=u,p=!1;u.rank===3&&(p=!0,h=rt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),k(h.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${h.rank}.`),s!=null&&k(nt(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let m=(S,C)=>{let I=tr(h.shape,t,e,1,r,s);return C([h]),I.filterWidth===1&&I.filterHeight===1&&K(I.inShape,I.outShape)?h.clone():S.avgPool(h,I)},y={x:h},b={filterSize:t,strides:e,pad:r,dimRoundingMode:s},x=J.runKernelFunc(m,y,null,wl,b);return x=Rt(x,u.dtype),p?rt(x,[x.shape[1],x.shape[2],x.shape[3]]):x}let dh=X({avgPool_:eM});function nM(n,t,e,r,s,u="NDHWC",l){l==null?l=[1,1,1]:Tn("dilations is deprecated, this field will be gone in v3.0.0.");let h=z(n,"x","avgPool3d","float32"),p=h,m=!1;h.rank===4&&(m=!0,p=rt(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),k(p.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${p.rank}.`),k(u==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${u}`),k(wn(e,l),()=>`Error in avgPool3d: Either strides or dilations must be 1. Got strides ${e} and dilations '${l}'`),s!=null&&k(nt(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let y=(C,I)=>{l==null&&(l=[1,1,1]);let D=ph(p.shape,t,e,l,r,s,u);return I([p]),C.avgPool3d(p,D)},b={x:p},x={filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:u,dilations:l},S=J.runKernelFunc(y,b,null,Fv,x);return S=Rt(S,p.dtype),m?rt(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}let rb=X({avgPool3d_:nM});function fd(n,t){let e=n[0].length;n.forEach((s,u)=>{k(s.length===e,()=>`Error in concat${e}D: rank of tensors[${u}] must be the same as the rank of the rest (${e})`)}),k(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let r=n[0];n.forEach((s,u)=>{for(let l=0;l<e;l++)k(l===t||s[l]===r[l],()=>`Error in concat${e}D: Shape of tensors[${u}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${u}.`)})}function bo(n,t){let e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}function rM(n,t=0){k(n.length>=1,()=>"Pass at least one tensor to concat");let e=uh(n,"tensors","concat");e[0].dtype==="complex64"&&e.forEach(l=>{if(l.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${l.dtype}. `)});let r=(l,h)=>{let p=Et(t,e[0].shape)[0],m=bo(e.map(x=>x.shape),p);if(O(m)===0)return vn([],m);if(e=e.filter(x=>x.size>0),e.length===1)return e[0];let y=e.map(x=>x.shape);fd(y,p);let b=l.concat(e,p);return h(e),b},s=e,u={axis:t};return J.runKernelFunc(r,s,null,kl,u)}let sn=X({concat_:rM});function sM(n){let t=z(n,"x","sigmoid"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.sigmoid(t);return s([u]),u},e,null,Yl)}let js=X({sigmoid_:sM});function oM(n,t,e){let r=z(n,"x","slice");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s=(h,p)=>{let[m,y]=od(r,t,e);return By(r,m,y),p([r]),h.slice(r,m,y)},u={x:r},l={begin:t,size:e};return J.runKernelFunc(s,u,null,Pp,l)}let ge=X({slice_:oM});function aM(n){let t=z(n,"x","tanh"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.tanh(t);return s([u]),u},e,null,Ql)}let Du=X({tanh_:aM});function iM(n,t,e,r,s,u){let l=z(n,"forgetBias","basicLSTMCell"),h=z(t,"lstmKernel","basicLSTMCell"),p=z(e,"lstmBias","basicLSTMCell"),m=z(r,"data","basicLSTMCell"),y=z(s,"c","basicLSTMCell"),b=z(u,"h","basicLSTMCell"),x=sn([m,b],1),S=xe(x,h),C=Nt(S,p),I=C.shape[0],D=C.shape[1]/4,R=[I,D],A=ge(C,[0,0],R),L=ge(C,[0,D],R),_=ge(C,[0,D*2],R),B=ge(C,[0,D*3],R),V=Nt(st(js(A),Du(L)),st(y,js(Nt(l,_)))),q=st(Du(V),js(B));return[V,q]}let uM=X({basicLSTMCell_:iM});function cM(n,t,e){let r=z(n,"x","batchToSpaceND"),s=t.reduce((p,m)=>p*m);k(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),k(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),k(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let u=p=>p.batchToSpaceND(r,t,e),l={x:r},h={blockShape:t,crops:e};return J.runKernelFunc(u,l,null,Rv,h)}let mh=X({batchToSpaceND_:cM});function lM(n){let t;return n.rank===0||n.rank===1?t=rt(n,[1,1,1,n.size]):n.rank===2?t=rt(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=rt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function hM(n,t,e,r,s,u){u==null&&(u=.001);let l=z(n,"x","batchNorm"),h=z(t,"mean","batchNorm"),p=z(e,"variance","batchNorm"),m;s!=null&&(m=z(s,"scale","batchNorm"));let y;r!=null&&(y=z(r,"offset","batchNorm")),k(h.rank===p.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(y==null||h.rank===y.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(m==null||h.rank===m.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let b=lM(l),x=(D,R)=>(R([b,h,p,m]),D.batchNorm(b,pd(h),pd(p),pd(y),pd(m),u)),S={x:b,scale:m,offset:y,mean:h,variance:p},C={varianceEpsilon:u},I=J.runKernelFunc(x,S,null,$l,C);return rt(I,l.shape)}function pd(n){return n==null?null:n.rank===0?rt(n,[n.size]):n.rank===1?n:n.rank===2?rt(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?rt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n}let fi=X({batchNorm_:hM});function fM(n,t,e,r,s,u){let l=z(n,"x","batchNorm"),h=z(t,"mean","batchNorm"),p=z(e,"variance","batchNorm"),m;s!=null&&(m=z(s,"scale","batchNorm"));let y;return r!=null&&(y=z(r,"offset","batchNorm")),k(l.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`),k(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${h.rank}.`),k(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${p.rank}.`),m!=null&&k(m.rank===2||m.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${m.rank}.`),y!=null&&k(y.rank===2||y.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${y.rank}.`),fi(l,h,p,y,m,u)}let zS=X({batchNorm2d_:fM});function pM(n,t,e,r,s,u){let l=z(n,"x","batchNorm"),h=z(t,"mean","batchNorm"),p=z(e,"variance","batchNorm"),m;s!=null&&(m=z(s,"scale","batchNorm"));let y;return r!=null&&(y=z(r,"offset","batchNorm")),k(l.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`),k(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${h.rank}.`),k(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${p.rank}.`),m!=null&&k(m.rank===3||m.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${m.rank}.`),y!=null&&k(y.rank===3||y.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${y.rank}.`),fi(l,h,p,y,m,u)}let WS=X({batchNorm3d_:pM});function dM(n,t,e,r,s,u){let l=z(n,"x","batchNorm"),h=z(t,"mean","batchNorm"),p=z(e,"variance","batchNorm"),m;s!=null&&(m=z(s,"scale","batchNorm"));let y;return r!=null&&(y=z(r,"offset","batchNorm")),k(l.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`),k(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${h.rank}.`),k(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${p.rank}.`),m!=null&&k(m.rank===4||m.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${m.rank}.`),y!=null&&k(y.rank===4||y.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${y.rank}.`),fi(l,h,p,y,m,u)}let VS=X({batchNorm4d_:dM});function mM(n,t){let e=z(n,"broadcastTo","x"),r=e.shape;if(t.some(y=>!(y>0)||y%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let y=e.shape.slice();for(;y.length<t.length;)y.unshift(1);e=rt(e,y)}let s=e.shape,u=Array.from(t);for(let y=t.length-1;y>=0;y--)if(s[y]===t[y])u[y]=1;else if(e.shape[y]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);let l=u.map((y,b)=>y>1?b:-1).filter(y=>y>=0);if(l.length===0)return oa(e);let h=y=>y.tile(e,u),p={x:e},m={shape:t,inputShape:s};return J.runKernelFunc(h,p,null,Pv,m)}let gh=X({broadcastTo_:mM});function gM(n){let t=z(n,"x","ceil"),e={x:t};return J.runKernelFunc(r=>r.ceil(t),e,null,xl)}let sb=X({ceil_:gM});function vM(n,t,e){let r=z(n,"x","clipByValue");k(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let s={x:r},u={clipValueMin:t,clipValueMax:e};return J.runKernelFunc((l,h)=>{let p=l.clip(r,t,e);return h([r]),p},s,null,Tl,u)}let fr=X({clipByValue_:vM});function yM(n){return sn(n,0)}let US=X({concat1d_:yM});function bM(n,t){return sn(n,t)}let GS=X({concat2d_:bM});function wM(n,t){return sn(n,t)}let HS=X({concat3d_:wM});function xM(n,t){return sn(n,t)}let qS=X({concat4d_:xM});function TM(n,t,e,r,s="NHWC",u=[1,1],l){let h=z(n,"x","conv2d"),p=z(t,"filter","conv2d"),m=h,y=!1;h.rank===3&&(y=!0,m=rt(h,[1,h.shape[0],h.shape[1],h.shape[2]])),k(m.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${m.rank}.`),k(p.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${p.rank}.`),l!=null&&k(nt(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${r}.`);let b=s==="NHWC"?m.shape[3]:m.shape[1];k(b===p.shape[2],()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${p.shape[2]}.`),k(wn(e,u),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${u}'`);let x=(D,R)=>{let A=ua(s),L=Kn(m.shape,p.shape,e,u,r,l,!1,A),_=D.conv2d(m,p,L);return R([m,p]),_},S={x:m,filter:p},C={strides:e,pad:r,dataFormat:s,dilations:u,dimRoundingMode:l},I=J.runKernelFunc(x,S,null,gp,C);return y?rt(I,[I.shape[1],I.shape[2],I.shape[3]]):I}let wo=X({conv2d_:TM});function kM(n,t,e,r,s="NWC",u=1,l){let h=z(n,"x","conv1d"),p=z(t,"filter","conv1d"),m=h,y=!1;h.rank===2&&(y=!0,m=rt(h,[1,h.shape[0],h.shape[1]])),k(m.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${m.rank}.`),k(p.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`),l!=null&&k(nt(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${r}.`),k(m.shape[2]===p.shape[1],()=>`Error in conv1d: depth of input (${m.shape[2]}) must match input depth for filter ${p.shape[1]}.`),k(wn(e,u),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${u}'`),k(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let b=rt(p,[1,p.shape[0],p.shape[1],p.shape[2]]),x=rt(m,[m.shape[0],1,m.shape[1],m.shape[2]]),S=[1,e],C=[1,u],I="NHWC",D=wo(x,b,S,r,I,C,l);return y?rt(D,[D.shape[2],D.shape[3]]):rt(D,[D.shape[0],D.shape[2],D.shape[3]])}let dd=X({conv1d_:kM});function SM(n,t,e,r,s,u="NHWC",l){k(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let h=n,p=t,m=!1;t.rank===3&&(m=!0,p=rt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),h=[1,n[0],n[1],n[2]]),k(h.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`),k(p.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${p.rank}`),k(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let y=u==="NHWC"?h[3]:h[1],b=u==="NHWC"?p.shape[3]:p.shape[1];k(y===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${y}) must match input depth for filter ${e.shape[2]}.`),k(b===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${b}) must match output depth for filter ${e.shape[3]}.`),l!=null&&k(nt(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${l} but got pad ${s}.`);let x=(D,R)=>{let A=1,L=ua(u),_=Kn(h,e.shape,r,A,s,l,!1,L),B=D.conv2dDerInput(p,e,_);return R([p,e]),B},S={dy:p,filter:e},C={strides:r,pad:s,dataFormat:u,dimRoundingMode:l,inputShape:h},I=J.runKernelFunc(x,S,null,vp,C);return m?rt(I,[I.shape[1],I.shape[2],I.shape[3]]):I}let ob=X({conv2DBackpropInput_:SM});function CM(n,t,e,r,s,u){let l=z(n,"x","conv2dTranspose"),h=z(t,"filter","conv2dTranspose");return ob(e,l,h,r,s,"NHWC",u)}let md=X({conv2dTranspose_:CM});function NM(n,t,e,r,s="NDHWC",u=[1,1,1]){let l=z(n,"x","conv3d"),h=z(t,"filter","conv3d"),p=l,m=!1;l.rank===4&&(m=!0,p=rt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),k(p.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${p.rank}.`),k(h.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${h.rank}.`),k(p.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${p.shape[4]}) must match input depth for filter ${h.shape[3]}.`),k(wn(e,u),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${u}'`),k(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);let y=(C,I)=>{let D=aa(p.shape,h.shape,e,u,r),R=C.conv3d(p,h,D);return I([p,h]),R},b={x:p,filter:h},x={strides:e,pad:r,dataFormat:s,dilations:u},S=J.runKernelFunc(y,b,null,yp,x);return m?rt(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}let ab=X({conv3d_:NM});function IM(n,t,e,r,s){k(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let u=n,l=t,h=!1;t.rank===4&&(h=!0,l=rt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),u=[1,n[0],n[1],n[2],n[3]]);let p=u[4],m=l.shape[4];k(u.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`),k(l.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${l.rank}`),k(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),k(p===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${p}) must match input depth for filter ${e.shape[3]}.`),k(m===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${m}) must match output depth for filter ${e.shape[4]}.`);let y=C=>{let I=1,D=aa(u,e.shape,r,I,s);return C.conv3dDerInput(l,e,D)},b={dy:l,filter:e},x={pad:s,strides:r,inputShape:u},S=J.runKernelFunc(y,b,null,Lv,x);return h?rt(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}let jS=X({conv3DBackpropInput_:IM});function EM(n,t,e,r,s){let u=z(n,"x","conv3dTranspose"),l=z(t,"filter","conv3dTranspose");return jS(e,u,l,r,s)}let DM=X({conv3dTranspose_:EM});function $M(n){let t=z(n,"x","cos"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.cos(t);return s([t]),u},e,null,du)}let vh=X({cos_:$M});function AM(n){let t=z(n,"x","cosh"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.cosh(t);return s([t]),u},e,null,Sl)}let gd=X({cosh_:AM});function _M(n,t=0,e=!1,r=!1){let s=z(n,"x","cumsum"),u=(p,m)=>{let y=hr([t],s.rank),b=s;y!=null&&(b=re(s,y));let x=Cr(1,s.rank)[0],S=p.cumsum(b,x,e,r);if(m([s]),y!=null){let C=lh(y);S=re(S,C)}return S},l={x:s},h={axis:t,exclusive:e,reverse:r};return J.runKernelFunc(u,l,null,Bv,h)}let vd=X({cumsum_:_M});function FM(n,t,e="NHWC"){let r=z(n,"x","depthToSpace"),s=e==="NHWC"?r.shape[1]:r.shape[2],u=e==="NHWC"?r.shape[2]:r.shape[3],l=e==="NHWC"?r.shape[3]:r.shape[1];k(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),k(u*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${u} and ${t} for depthToSpace with input shape
        ${r.shape}`),k(l%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${l} for depthToSpace with input shape ${r.shape}`);let h=y=>y.depthToSpace(r,t,e),p={x:r},m={blockSize:t,dataFormat:e};return J.runKernelFunc(h,p,null,N2,m)}let ib=X({depthToSpace_:FM});function RM(n,t,e,r,s="NHWC",u=[1,1],l){let h=z(n,"x","depthwiseConv2d"),p=z(t,"filter","depthwiseConv2d"),m=h,y=!1;h.rank===3&&(y=!0,m=rt(h,[1,h.shape[0],h.shape[1],h.shape[2]])),k(m.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),k(p.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),k(m.shape[3]===p.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),l!=null&&k(nt(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${r}.`);let b=(I,D)=>{u==null&&(u=[1,1]),k(wn(e,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${u}'`);let R=Kn(m.shape,p.shape,e,u,r,l,!0),A=I.depthwiseConv2D(m,p,R);return D([m,p]),A},x={x:m,filter:p},S={strides:e,pad:r,dataFormat:s,dilations:u,dimRoundingMode:l},C=J.runKernelFunc(b,x,null,bp,S);return y?rt(C,[C.shape[1],C.shape[2],C.shape[3]]):C}let pi=X({depthwiseConv2d_:RM});function PM(n){let t=z(n,"x","diag"),e=s=>{let u=rt(t,[t.size]),l=s.diag(u),h=[...n.shape,...n.shape];return rt(l,h)},r={x:t};return J.runKernelFunc(e,r,null,I2)}let OM=X({diag_:PM});function MM(n,t,e,r,s=[1,1],u="NHWC"){let l=z(n,"x","dilation2d"),h=z(t,"filter","dilation2d");k(l.rank===3||l.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${l.rank}.`),k(h.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`),k(u==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${u}`);let p=l,m=!1;l.rank===3&&(p=rt(l,[1,l.shape[0],l.shape[1],l.shape[2]]),m=!0);let y={x:p,filter:h},b={strides:e,pad:r,dilations:s},x=J.runKernel(wp,y,b);return m?rt(x,[x.shape[1],x.shape[2],x.shape[3]]):x}let ub=X({dilation2d_:MM});function di(n,t){let e=n.length,r=[];for(let s=0;s<e;s++){let u=e-1-s,l=n[u]||1,h=t[t.length-1-s]||1;h>1&&l===1&&r.unshift(u)}return r}function Sn(n,t){let e=[];for(let r=0;r<t.length;r++){let s=n[n.length-r-1],u=t.length-r-1,l=t[u];(s==null||s===1&&l>1)&&e.unshift(u)}return e}function ve(n,t){let e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let u=n[n.length-s-1];u==null&&(u=1);let l=t[t.length-s-1];if(l==null&&(l=1),u===1)e.unshift(l);else if(l===1)e.unshift(u);else if(u!==l){let h=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(h)}else e.unshift(u)}return e}function LM(n,t){let e=z(n,"a","equal"),r=z(t,"b","equal");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=l=>l.equal(e,r),u={a:e,b:r};return J.runKernelFunc(s,u,null,D2)}let gs=X({equal_:LM});function BM(n,t,e){let r=z(t,"a","where"),s=z(e,"b","where"),u=z(n,"condition","where","bool"),l=ve(r.shape,s.shape),h=gh(r,l),p=gh(s,l);u.rank===1&&k(u.shape[0]===r.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),u.rank!==1&&$(u.shape,p.shape,"Error in where: ");let m=(b,x)=>{let S=b.select(u,h,p);return x([u]),S},y={condition:u,t:h,e:p};return J.runKernelFunc(m,y,null,uy)}let er=X({where_:BM});function zM(n){let t=z(n,"x","zerosLike"),e={x:t};return J.runKernelFunc(r=>r.zerosLike(t),e,null,my)}let fe=X({zerosLike_:zM});function WM(n,t){let e=z(n,"a","div"),r=z(t,"b","div");[e,r]=nn(e,r);let s=Ht(e,r),u=fe(s),l=gs(r,u);return er(l,u,s)}let cb=X({divNoNan_:WM});function VM(n,t){let e=z(n,"t1","dot"),r=z(t,"t2","dot");k((e.rank===1||e.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);let s=e.rank===1?e.size:e.shape[1],u=r.rank===1?r.size:r.shape[0];if(k(s===u,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${u}.`),e.rank===1&&r.rank===1){let l=rt(e,[1,-1]),h=rt(r,[-1,1]),p=xe(l,h);return rt(p,[])}else if(e.rank===1&&r.rank===2){let l=rt(e,[1,-1]),h=rt(r,[r.shape[0],r.shape[1]]),p=xe(l,h);return rt(p,[p.size])}else if(e.rank===2&&r.rank===1){let l=rt(r,[-1,1]),h=xe(e,l);return rt(h,[h.size])}else{let l=rt(r,[r.shape[0],r.shape[1]]),h=xe(e,l);return h}}let KS=X({dot_:VM});function UM(n){let t=z(n,"x","elu"),e=(s,u)=>{let l=s.elu(t);return u([l]),l},r={x:t};return J.runKernelFunc(e,r,null,Cl)}let $u=X({elu_:UM});function GM(n){let t=z(n,"x","erf");k(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Rt(t,"float32"));let e={x:t};return J.runKernelFunc((r,s)=>{let u=r.erf(t);return s([t]),u},e,null,Nl)}let lb=X({erf_:GM});function HM(n){let t=z(n,"x","exp"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.exp(t);return s([u]),u},e,null,Il)}let Br=X({exp_:HM});function qM(n,t=0){let e=null,r=z(n,"x","expandDims",e);k(t<=r.rank,()=>"Axis must be <= rank of the tensor");let s=r.shape.slice();return t<0&&(k(-(r.rank+1)<=t,()=>`Axis must be in the interval [${-(r.rank+1)}, ${r.rank}]`),t=r.rank+t+1),s.splice(t,0,1),rt(r,s)}let pr=X({expandDims_:qM});function jM(n){let t=z(n,"x","expm1"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.expm1(t);return s([t]),u},e,null,El)}let hb=X({expm1_:jM});function KM(n,t){let e=null,r=z(n,"x","tile",e);k(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of reps ${t}.`);let s=(p,m)=>{let y=p.tile(r,t);return m([r]),y},u=[r],l={x:r},h={reps:t};return J.runKernelFunc(s,l,null,fy,h,u)}let ca=X({tile_:KM});function XM(n,t,e,r="float32"){t==null&&(t=n);let s=Ae([n,t],r),u=n<=t?n:t;for(let h=0;h<u;++h)s.set(1,h,h);let l=rt(s.toTensor(),[n,t]);if(e==null)return l;if(e.length===1)return ca(pr(l,0),[e[0],1,1]);if(e.length===2)return ca(pr(pr(l,0),0),[e[0],e[1],1,1]);if(e.length===3)return ca(pr(pr(pr(l,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}let yd=X({eye_:XM});function Au(n,t,e){let r={shape:n,value:t,dtype:e};return J.runKernelFunc(s=>s.fill(n,t,e),{},null,Vv,r)}function YM(n){let t=z(n,"x","floor"),e={x:t};return J.runKernelFunc(r=>r.floor(t),e,null,Dl)}let _u=X({floor_:YM});let fb=30;function yh(n){return n<=fb?n:ms(n,Math.floor(Math.sqrt(n)))}function JM(n,t){let e=!1,r;for(n<=fb?(r=n,e=!0):r=ms(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=ms(n,r+1);return r}function ZM(n,t,e){let r=[],s=n.length;for(let u=0;u<s;u++)u!==t?r.push(n[u]):r.push(e);return r}function XS(n,t,e){let r=n.shape[e],s=[],u=1,l=1;for(let h=0;h<e;h++)s.push(n.shape[h]),u*=n.shape[h];for(let h=0;h<t.rank;h++)s.push(t.shape[h]);for(let h=e+1;h<n.rank;h++)s.push(n.shape[h]),l*=n.shape[h];return{batchSize:u,sliceSize:l,dimSize:r,outputShape:s}}var QM=Object.freeze({__proto__:null,segOpComputeOptimalWindowSize:JM,computeOutShape:ZM,collectGatherOpShapeInfo:XS});function tL(n,t,e=0){let r=z(n,"x","gather"),s=z(t,"indices","gather","int32"),u={x:r,indices:s},l={axis:e},h=(p,m)=>{let y=Et(e,r.shape)[0],b=XS(r,s,y),x=p.gather(r,rt(s,[s.size]),y);return m([r,s]),rt(x,b.outputShape)};return J.runKernelFunc(h,u,null,Gv,l)}let Fu=X({gather_:tL});function eL(n,t){let e=z(n,"a","greater"),r=z(t,"b","greater");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=l=>l.greater(e,r),u={a:e,b:r};return J.runKernelFunc(s,u,null,A2)}let zr=X({greater_:eL});function nL(n,t){let e=z(n,"a","greaterEqual"),r=z(t,"b","greaterEqual");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=(l,h)=>{let p=l.greaterEqual(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,Hv)}let xo=X({greaterEqual_:nL});function rL(n){let t=z(n,"input","imag"),e=s=>s.imag(t),r={input:t};return J.runKernelFunc(e,r,null,Np)}let bh=X({imag_:rL});function sL(n){let t=z(n,"x","isFinite"),e={x:t};return J.runKernelFunc(r=>r.isFinite(t),e,null,_l)}let YS=X({isFinite_:sL});function oL(n){let t=z(n,"x","isInf"),e={x:t};return J.runKernelFunc(r=>r.isInf(t),e,null,Fl)}let JS=X({isInf_:oL});function aL(n){let t=z(n,"x","isNaN"),e={x:t};return J.runKernelFunc(r=>r.isNaN(t),e,null,Rl)}let ZS=X({isNaN_:aL});function iL(n,t){let e=z(n,"a","maximum"),r=z(t,"b","maximum");[e,r]=nn(e,r),e.dtype==="bool"&&(e=Rt(e,"int32"),r=Rt(r,"int32")),ve(e.shape,r.shape);let s=(l,h)=>{let p=l.maximum(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,Kv)}let ts=X({maximum_:iL});function Ot(n,t){if((Re(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Re(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");let e=[],r=[];return ra(n,e,r,t)}function uL(n,t=.2){let e=z(n,"x","leakyRelu");return ts(st(Ot(t),e),e)}let bd=X({leakyRelu_:uL});function cL(n,t){let e=z(n,"a","less"),r=z(t,"b","less");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=l=>l.less(e,r),u={a:e,b:r};return J.runKernelFunc(s,u,null,_2)}let wh=X({less_:cL});function lL(n,t){let e=z(n,"a","lessEqual"),r=z(t,"b","lessEqual");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=(l,h)=>{let p=l.lessEqual(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,F2)}let la=X({lessEqual_:lL});function QS(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");let r={start:n,stop:t,num:e};return J.runKernelFunc(s=>s.linspace(n,t,e),{},null,R2,r)}function hL(n,t=5,e=1,r=1,s=.5){let u=z(n,"x","localResponseNormalization");k(u.rank===4||u.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${u.rank}.`),k(nt(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let l=u,h=!1;u.rank===3&&(h=!0,l=rt(u,[1,u.shape[0],u.shape[1],u.shape[2]]));let p=(x,S)=>{let C=x.localResponseNormalization4D(l,t,e,r,s);return S([l,C]),C},m={x:l},y={depthRadius:t,bias:e,alpha:r,beta:s},b=J.runKernelFunc(p,m,null,jv,y);return h?rt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}let pb=X({localResponseNormalization_:hL});function fL(n){let t=z(n,"x","log"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.log(t);return s([t]),u},e,null,Pl)}let Nr=X({log_:fL});function pL(n){let t=z(n,"x","log1p"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.log1p(t);return s([t]),u},e,null,Ol)}let wd=X({log1p_:pL});function dL(n){return k(Ln(n),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let r=z(t,"x","tf.grad",null),s=e!=null?z(e,"dy","tf.grad"):null;return J.tidy(()=>{let{value:u,grads:l}=J.gradients(()=>n(r),[r],s);return s!=null&&$(u.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),xd(l),l[0]})}}function mL(n){return k(Ln(n),()=>"The f passed in grads(f) must be a function"),(t,e)=>{k(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=uh(t,"args","tf.grads",null),s=e!=null?z(e,"dy","tf.grads"):null;return J.tidy(()=>{let{value:u,grads:l}=J.gradients(()=>n(...r),r,s);return s!=null&&$(u.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xd(l),l})}}function gL(n){return k(Ln(n),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{k(t instanceof at,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),k(e==null||e instanceof at,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=J.gradients(()=>n(t),[t],e);return xd(r),{grad:r[0],value:s}}}function vL(n){return k(Ln(n),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{k(Array.isArray(t)&&t.every(s=>s instanceof at),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),k(e==null||e instanceof at,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=J.gradients(()=>n(...t),t,e);return e!=null&&$(r.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),xd(r.grads),r}}function db(n,t){k(Ln(n),()=>"The f passed in variableGrads(f) must be a function"),k(t==null||Array.isArray(t)&&t.every(m=>m instanceof ih),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let m in J.registeredVariables)t.push(J.registeredVariables[m])}let r=e?t.filter(m=>!m.trainable):null,s=t.length;t=t.filter(m=>m.trainable),k(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let u=!0,{value:l,grads:h}=J.gradients(n,t,null,u);k(h.some(m=>m!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),k(l.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`);let p={};return t.forEach((m,y)=>{h[y]!=null&&(p[m.name]=h[y])}),r!=null&&r.forEach(m=>p[m.name]=null),{value:l,grads:p}}function Ks(n){return J.customGrad(n)}function xd(n){let t=n.filter(e=>e==null).length;if(t>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function yL(n){let t=z(n,"x","neg"),e={x:t};return J.runKernelFunc(r=>r.neg(t),e,null,ty)}let on=X({neg_:yL});function bL(n){let t=z(n,"x","softplus"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.softplus(t);return s([t]),u},e,null,Jl)}let Ru=X({softplus_:bL});function wL(n){let t=z(n,"x","logSigmoid"),e=Ks(r=>{let s=on(Ru(on(r))),u=l=>{let h=st(l,js(on(r)));return h};return{value:s,gradFunc:u}});return e(t)}let tC=X({logSigmoid_:wL});function xL(n,t=null,e=!1){let r=z(n,"x","max"),s=(h,p)=>{let m=Et(t,r.shape),y=m,b=hr(y,r.rank),x=r;b!=null&&(x=re(r,b),y=Cr(y.length,x.rank));let S=h.max(x,y);b!=null&&x.dispose();let C=S;if(e){let I=zn(C.shape,Et(t,r.shape));C=rt(C,I),S.dispose()}return p([r,C]),C},u={x:r},l={reductionIndices:t,keepDims:e};return J.runKernelFunc(s,u,null,Ml,l)}let dr=X({max_:xL});function TL(n,t){let e=z(n,"a","sub"),r=z(t,"b","sub");[e,r]=nn(e,r);let s=(l,h)=>{let p=l.subtract(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,bu)}let Mt=X({sub_:TL});function kL(n,t=null,e=!1){let r=z(n,"x","sum");r.dtype==="bool"&&(r=Rt(r,"int32"));let s=(h,p)=>{p([r]);let m=Et(t,r.shape),y=hr(m,r.rank),b=m,x=r;y!=null&&(x=re(r,y),b=Cr(b.length,r.rank));let S=h.sum(x,b);if(e){let C=zn(S.shape,m);S=rt(S,C)}return S},u={x:r},l={axis:t,keepDims:e};return J.runKernelFunc(s,u,null,cy,l)}let Xt=X({sum_:kL});function SL(n,t=-1){let e=z(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);let r=(l,h)=>{let p=!0,m=dr(n,t,!0),y=Mt(n,m),b=Mt(Rt(y,"float32"),Nr(Xt(Br(y),t,p)));return h([b]),b},s={logits:e},u={axis:t};return J.runKernelFunc(r,s,null,qv,u)}let Td=X({logSoftmax_:SL});function CL(n,t=null,e=!1){let r=z(n,"x","logSumExp"),s=Et(t,r.shape),u=dr(r,s,!0),l=Mt(r,u),h=Br(l),p=Xt(h,s),m=Nr(p),y=Nt(rt(u,m.shape),m);if(e){let b=zn(y.shape,s);return rt(y,b)}return y}let mb=X({logSumExp_:CL});function NL(n,t){let e=z(n,"a","logicalAnd","bool"),r=z(t,"b","logicalAnd","bool");ve(e.shape,r.shape);let s={a:e,b:r};return J.runKernelFunc(u=>u.logicalAnd(e,r),s,null,P2)}let es=X({logicalAnd_:NL});function IL(n){let t=z(n,"x","logicalNot","bool"),e={x:t};return J.runKernelFunc(r=>r.logicalNot(t),e,null,Ip)}let xh=X({logicalNot_:IL});function EL(n,t){let e=z(n,"a","logicalOr","bool"),r=z(t,"b","logicalOr","bool");ve(e.shape,r.shape);let s={a:e,b:r};return J.runKernelFunc(u=>u.logicalOr(e,r),s,null,O2)}let kd=X({logicalOr_:EL});function DL(n,t){let e=z(n,"a","logicalXor","bool"),r=z(t,"b","logicalXor","bool");return ve(e.shape,r.shape),es(kd(n,t),xh(es(n,t)))}let eC=X({logicalXor_:DL});function $L(n,t,e,r,s){let u=z(n,"x","maxPool"),l=1,h=u,p=!1;u.rank===3&&(p=!0,h=rt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),k(h.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`),k(wn(e,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${l}'`),s!=null&&k(nt(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let m=(S,C)=>{let I=tr(h.shape,t,e,1,r,s),D;return I.filterWidth===1&&I.filterHeight===1&&K(I.inShape,I.outShape)?D=h.clone():D=S.maxPool(h,I),C([h,D]),D},y={x:h},b={filterSize:t,strides:e,pad:r,dimRoundingMode:s},x=J.runKernelFunc(m,y,null,Ll,b);return p?rt(x,[x.shape[1],x.shape[2],x.shape[3]]):x}let Th=X({maxPool_:$L});function AL(n,t=[1,1,1],e,r,s,u="NDHWC",l){l==null?l=[1,1,1]:Tn("dilations is deprecated, this field will be gone in v3.0.0.");let h=z(n,"x","maxPool3d"),p=h,m=!1;h.rank===4&&(m=!0,p=rt(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),k(p.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${p.rank}.`),k(u==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${u}`),k(wn(e,l),()=>`Error in maxPool3d: Either strides or dilations must be 1. Got strides ${e} and dilations '${l}'`),s!=null&&k(nt(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let y=(C,I)=>{l==null&&(l=[1,1,1]);let D=ph(p.shape,t,e,l,r,s,u),R=C.maxPool3d(p,D);return I([p,R]),R},b={x:p},x={filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:u,dilations:l},S=J.runKernelFunc(y,b,null,Xv,x);return m?rt(S,[S.shape[1],S.shape[2],S.shape[3],S.shape[4]]):S}let gb=X({maxPool3d_:AL});function _L(n,t,e,r,s=!1){let u=z(n,"x","maxPoolWithArgmax"),l={x:u},h={filterSize:t,strides:e,pad:r,includeBatchInIndex:s},p=J.runKernel(Dp,l,h);return{result:p[0],indexes:p[1]}}let nC=X({maxPoolWithArgmax_:_L});function Se(n,t="float32"){if(t==="complex64"){let r=Se(n,"float32"),s=Se(n,"float32");return vo(r,s)}let e=fu(O(n),t);return J.makeTensor(e,n,t)}function vs(n,t="float32"){if(t==="complex64"){let r=vs(n,"float32"),s=Se(n,"float32");return vo(r,s)}let e=Nv(O(n),t);return J.makeTensor(e,n,t)}function FL(n,t=null,e=!1){let r=z(n,"x","mean"),s=Et(t,r.shape),u=Bn(r.shape,s),l=u[1],h=O(l),p={x:r},m={axis:t,keepDims:e},y=()=>{let x=Ot(h),S=x.dtype===r.dtype?r:Rt(r,x.dtype),C=Ht(S,x);return Xt(C,t,e)},b=Ks(x=>{let S=J.runKernelFunc(y,p,null,Yv,m),C=I=>{let D=x.shape.slice();s.forEach(L=>{D[L]=1});let R=rt(I,D),A=Ht(st(R,vs(x.shape,"float32")),h);return A};return{value:S,gradFunc:C}});return b(r)}let an=X({mean_:FL});function RL(n,t=null,e=!1){let r=z(n,"x","min"),s=(h,p)=>{let m=Et(t,r.shape),y=m,b=hr(y,r.rank),x=r;b!=null&&(x=re(r,b),y=Cr(y.length,r.rank));let S=h.min(x,y);b!=null&&x.dispose();let C=S;if(e){let I=zn(C.shape,m);C=rt(S,I),S.dispose()}return p([r,C]),C},u={x:r},l={axis:t,keepDims:e};return J.runKernelFunc(s,u,null,Jv,l)}let Pu=X({min_:RL});function PL(n,t){let e=z(n,"a","minimum"),r=z(t,"b","minimum");[e,r]=nn(e,r),e.dtype==="bool"&&(e=Rt(e,"int32"),r=Rt(r,"int32")),ve(e.shape,r.shape);let s=(l,h)=>{let p=l.minimum(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,Zv)}let mi=X({minimum_:PL});function OL(n,t,e){k(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let r=z(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");k(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=e==="reflect"?1:0;for(let h=0;h<r.rank;h++)k(t[h].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),k(t[h][0]>=0&&t[h][0]<=r.shape[h]-s&&t[h][1]>=0&&t[h][1]<=r.shape[h]-s,()=>`Padding in dimension ${h} cannot be greater than or equal to ${r.shape[h]-s} or less than 0 for input of shape ${r.shape}`);let u={paddings:t,mode:e},l={x:r};return J.runKernel(Bl,l,u)}let vb=X({mirrorPad_:OL});function ML(n,t){let e=z(n,"a","mod"),r=z(t,"b","mod");[e,r]=nn(e,r);let s=(l,h)=>{let p=l.mod(e,r);return h([e,r]),p},u={a:e,b:r};return J.runKernelFunc(s,u,null,Qv)}let Sd=X({mod_:ML});function LL(n){let t=z(n,"x","square"),e={},r=[t],s=[];return J.runKernelFunc((u,l)=>(l([t]),u.square(t)),{x:t},null,"Square",e,r,s)}let Oe=X({square_:LL});function BL(n,t=null,e=!1){n=z(n,"x","moments");let r=Et(t,n.shape),s=an(n,r,e),u=s.shape;e||(u=zn(s.shape,r));let l=Oe(Mt(Rt(n,"float32"),rt(s,u))),h=an(l,r,e);return{mean:s,variance:h}}let Cd=X({moments_:BL});function zL(n,t,e,r){let s=z(t,"data","multiRNNCell"),u=uh(e,"c","multiRNNCell"),l=uh(r,"h","multiRNNCell"),h=s,p=[];for(let b=0;b<n.length;b++){let x=n[b](h,u[b],l[b]);p.push(x[0]),p.push(x[1]),h=x[1]}let m=[],y=[];for(let b=0;b<p.length;b+=2)m.push(p[b]),y.push(p[b+1]);return[m,y]}let WL=X({multiRNNCell_:zL});function VL(n,t,e,r=!1){let s=z(n,"logits","multinomial"),u=s.size,l=s.rank;if(u<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${u}.`);if(l>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${l}`);e=e||Math.random();let h=l===1?rt(s,[1,-1]):s,p=J.runKernelFunc(m=>m.multinomial(h,r,t,e),{logits2D:h});return l===1?rt(p,[p.size]):p}let rC=X({multinomial_:VL});function UL(n,t){let e=z(n,"a","notEqual"),r=z(t,"b","notEqual");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=l=>l.notEqual(e,r),u={a:e,b:r};return J.runKernelFunc(s,u,null,zl)}let ha=X({notEqual_:UL});function GL(n){let t=z(n,"input","real"),e=s=>s.real(t),r={input:t};return J.runKernelFunc(e,r,null,Rp)}let Ou=X({real_:GL});function HL(n){let t=z(n,"x","onesLike"),e=(s,u)=>{if(t.dtype==="complex64"){let l=Xn(Ou(t)),h=fe(bh(t));return vo(l,h)}return s.onesLike(t)},r={x:t};return J.runKernelFunc(e,r,null,ny)}let Xn=X({onesLike_:HL});function qL(n,t){let e=z(n,"v1","outerProduct"),r=z(t,"v2","outerProduct");k(e.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);let s=rt(e,[-1,1]),u=rt(r,[1,-1]);return xe(s,u)}let jL=X({outerProduct_:qL});function KL(n,t,e=0){let r=z(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s=(h,p)=>(p([r]),h.pad(r,t,e)),u={paddings:t,constantValue:e},l={x:r};return J.runKernelFunc(s,l,null,_p,u)}let Xs=X({pad_:KL});function XL(n,t,e=0){return k(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Xs(n,[t],e)}let YL=X({pad1d_:XL});function JL(n,t,e=0){return k(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Xs(n,t,e)}let ZL=X({pad2d_:JL});function QL(n,t,e=0){return k(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Xs(n,t,e)}let t3=X({pad3d_:QL});function e3(n,t,e=0){return k(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Xs(n,t,e)}let n3=X({pad4d_:e3});function r3(n,t,e){let r=z(n,"x","spaceToBatchND");k(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),k(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),k(r.shape.reduce((h,p,m)=>m>0&&m<=t.length?h&&(p+e[m-1][0]+e[m-1][1])%t[m-1]===0:h,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let s=h=>h.spaceToBatchND(r,t,e),u={x:r},l={blockShape:t,paddings:e};return J.runKernelFunc(s,u,null,Op,l)}let kh=X({spaceToBatchND_:r3});function s3(n,t,e,r,s,u){s==null&&(s=[1,1]),u==null&&(u=1),r===0&&(r="valid");let l=z(n,"x","maxPool"),h=l,p=!1;l.rank===3&&(p=!0,h=rt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),k(wn(u,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${u} and dilations '${s}'`);let m=tr(h.shape,t,u,s,r),y=[m.dilationHeight,m.dilationWidth],b;r==="same"?b=a3([m.filterHeight,m.filterWidth],y):b=[[0,0],[0,0]];let x=y[0]===1&&y[1]===1,[S,C]=o3([m.inHeight,m.inWidth],y,b),I=x?r:"valid",D=x?h:kh(h,y,S),R=e==="avg"?()=>dh(D,t,u,I):()=>Th(D,t,u,I),A=R(),L=x?A:mh(A,y,C);return p?rt(L,[L.shape[1],L.shape[2],L.shape[3]]):L}function o3(n,t,e){let r=e.map(y=>y[0]),s=e.map(y=>y[1]),u=n.concat(r,s),l=t.map((y,b)=>(y-u[b]%y)%y),h=s.map((y,b)=>y+l[b]),p=t.map((y,b)=>[r[b],h[b]]),m=t.map((y,b)=>[0,l[b]]);return[p,m]}function a3(n,t){let e=n.map((l,h)=>l+(l-1)*(t[h]-1)),r=e.map(l=>l-1),s=r.map(l=>Math.floor(l/2)),u=r.map((l,h)=>l-s[h]);return r.map((l,h)=>[s[h],u[h]])}let sC=X({pool_:s3});function i3(n,t){let e=z(n,"base","pow"),r=z(t,"exp","pow");[e,r]=nn(e,r);let s={a:e,b:r},u=(l,h)=>{let p=l.pow(e,r);return h([e,r,p]),p};return J.runKernelFunc(u,s,null,sy)}let ys=X({pow_:i3});function u3(n,t){let e=z(n,"x","prelu"),r=z(t,"alpha","prelu"),s=(l,h)=>{let p=l.prelu(e,r);return h([e,r]),p},u={x:e,alpha:r};return J.runKernelFunc(s,u,null,Fp)}let Sh=X({prelu_:u3});function c3(n,t=null,e=!1){let r=z(n,"x","prod");r.dtype==="bool"&&(r=Rt(r,"int32"));let s=h=>{let p=Et(t,r.shape),m=hr(p,r.rank),y=p,b=r;m!=null&&(b=re(r,m),y=Cr(y.length,r.rank));let x=h.prod(b,y);if(e){let S=zn(x.shape,p);x=rt(x,S)}return x},u={x:r},l={axis:t,keepDims:e};return J.runKernelFunc(s,u,null,B2,l)}let Nd=X({prod_:c3});function l3(n,t,e){let r=O(n),s=null;if(e==null||e==="float32")s=new Float32Array(r);else if(e==="int32")s=new Int32Array(r);else if(e==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${e}`);for(let u=0;u<r;u++)s[u]=t();return J.makeTensor(s,n,e)}let h3=X({rand_:l3});var Mu=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function uht(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function gi(n,t){return t={exports:{}},n(t,t.exports),t.exports}function cht(n){return n&&n.default||n}function lht(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var f3=gi(function(n){(function(t,e,r){function s(p){var m=this,y=h();m.next=function(){var b=2091639*m.s0+m.c*23283064365386963e-26;return m.s0=m.s1,m.s1=m.s2,m.s2=b-(m.c=b|0)},m.c=1,m.s0=y(" "),m.s1=y(" "),m.s2=y(" "),m.s0-=y(p),m.s0<0&&(m.s0+=1),m.s1-=y(p),m.s1<0&&(m.s1+=1),m.s2-=y(p),m.s2<0&&(m.s2+=1),y=null}function u(p,m){return m.c=p.c,m.s0=p.s0,m.s1=p.s1,m.s2=p.s2,m}function l(p,m){var y=new s(p),b=m&&m.state,x=y.next;return x.int32=function(){return y.next()*4294967296|0},x.double=function(){return x()+(x()*2097152|0)*11102230246251565e-32},x.quick=x,b&&(typeof b=="object"&&u(b,y),x.state=function(){return u(y,{})}),x}function h(){var p=4022871197,m=function(y){y=y.toString();for(var b=0;b<y.length;b++){p+=y.charCodeAt(b);var x=.02519603282416938*p;p=x>>>0,x-=p,x*=p,p=x>>>0,x-=p,p+=x*4294967296}return(p>>>0)*23283064365386963e-26};return m}e&&e.exports?e.exports=l:r&&r.amd?r(function(){return l}):this.alea=l})(Mu,n,!1)}),p3=gi(function(n){(function(t,e,r){function s(h){var p=this,m="";p.x=0,p.y=0,p.z=0,p.w=0,p.next=function(){var b=p.x^p.x<<11;return p.x=p.y,p.y=p.z,p.z=p.w,p.w^=p.w>>>19^b^b>>>8},h===(h|0)?p.x=h:m+=h;for(var y=0;y<m.length+64;y++)p.x^=m.charCodeAt(y)|0,p.next()}function u(h,p){return p.x=h.x,p.y=h.y,p.z=h.z,p.w=h.w,p}function l(h,p){var m=new s(h),y=p&&p.state,b=function(){return(m.next()>>>0)/4294967296};return b.double=function(){do var x=m.next()>>>11,S=(m.next()>>>0)/4294967296,C=(x+S)/(1<<21);while(C===0);return C},b.int32=m.next,b.quick=b,y&&(typeof y=="object"&&u(y,m),b.state=function(){return u(m,{})}),b}e&&e.exports?e.exports=l:r&&r.amd?r(function(){return l}):this.xor128=l})(Mu,n,!1)}),d3=gi(function(n){(function(t,e,r){function s(h){var p=this,m="";p.next=function(){var b=p.x^p.x>>>2;return p.x=p.y,p.y=p.z,p.z=p.w,p.w=p.v,(p.d=p.d+362437|0)+(p.v=p.v^p.v<<4^(b^b<<1))|0},p.x=0,p.y=0,p.z=0,p.w=0,p.v=0,h===(h|0)?p.x=h:m+=h;for(var y=0;y<m.length+64;y++)p.x^=m.charCodeAt(y)|0,y==m.length&&(p.d=p.x<<10^p.x>>>4),p.next()}function u(h,p){return p.x=h.x,p.y=h.y,p.z=h.z,p.w=h.w,p.v=h.v,p.d=h.d,p}function l(h,p){var m=new s(h),y=p&&p.state,b=function(){return(m.next()>>>0)/4294967296};return b.double=function(){do var x=m.next()>>>11,S=(m.next()>>>0)/4294967296,C=(x+S)/(1<<21);while(C===0);return C},b.int32=m.next,b.quick=b,y&&(typeof y=="object"&&u(y,m),b.state=function(){return u(m,{})}),b}e&&e.exports?e.exports=l:r&&r.amd?r(function(){return l}):this.xorwow=l})(Mu,n,!1)}),m3=gi(function(n){(function(t,e,r){function s(h){var p=this;p.next=function(){var y=p.x,b=p.i,x,S,C;return x=y[b],x^=x>>>7,S=x^x<<24,x=y[b+1&7],S^=x^x>>>10,x=y[b+3&7],S^=x^x>>>3,x=y[b+4&7],S^=x^x<<7,x=y[b+7&7],x=x^x<<13,S^=x^x<<9,y[b]=S,p.i=b+1&7,S};function m(y,b){var x,S,C=[];if(b===(b|0))S=C[0]=b;else for(b=""+b,x=0;x<b.length;++x)C[x&7]=C[x&7]<<15^b.charCodeAt(x)+C[x+1&7]<<13;for(;C.length<8;)C.push(0);for(x=0;x<8&&C[x]===0;++x);for(x==8?S=C[7]=-1:S=C[x],y.x=C,y.i=0,x=256;x>0;--x)y.next()}m(p,h)}function u(h,p){return p.x=h.x.slice(),p.i=h.i,p}function l(h,p){h==null&&(h=+new Date);var m=new s(h),y=p&&p.state,b=function(){return(m.next()>>>0)/4294967296};return b.double=function(){do var x=m.next()>>>11,S=(m.next()>>>0)/4294967296,C=(x+S)/(1<<21);while(C===0);return C},b.int32=m.next,b.quick=b,y&&(y.x&&u(y,m),b.state=function(){return u(m,{})}),b}e&&e.exports?e.exports=l:r&&r.amd?r(function(){return l}):this.xorshift7=l})(Mu,n,!1)}),g3=gi(function(n){(function(t,e,r){function s(h){var p=this;p.next=function(){var y=p.w,b=p.X,x=p.i,S,C;return p.w=y=y+1640531527|0,C=b[x+34&127],S=b[x=x+1&127],C^=C<<13,S^=S<<17,C^=C>>>15,S^=S>>>12,C=b[x]=C^S,p.i=x,C+(y^y>>>16)|0};function m(y,b){var x,S,C,I,D,R=[],A=128;for(b===(b|0)?(S=b,b=null):(b=b+"\0",S=0,A=Math.max(A,b.length)),C=0,I=-32;I<A;++I)b&&(S^=b.charCodeAt((I+32)%b.length)),I===0&&(D=S),S^=S<<10,S^=S>>>15,S^=S<<4,S^=S>>>13,I>=0&&(D=D+1640531527|0,x=R[I&127]^=S+D,C=x==0?C+1:0);for(C>=128&&(R[(b&&b.length||0)&127]=-1),C=127,I=4*128;I>0;--I)S=R[C+34&127],x=R[C=C+1&127],S^=S<<13,x^=x<<17,S^=S>>>15,x^=x>>>12,R[C]=S^x;y.w=D,y.X=R,y.i=C}m(p,h)}function u(h,p){return p.i=h.i,p.w=h.w,p.X=h.X.slice(),p}function l(h,p){h==null&&(h=+new Date);var m=new s(h),y=p&&p.state,b=function(){return(m.next()>>>0)/4294967296};return b.double=function(){do var x=m.next()>>>11,S=(m.next()>>>0)/4294967296,C=(x+S)/(1<<21);while(C===0);return C},b.int32=m.next,b.quick=b,y&&(y.X&&u(y,m),b.state=function(){return u(m,{})}),b}e&&e.exports?e.exports=l:r&&r.amd?r(function(){return l}):this.xor4096=l})(Mu,n,!1)}),v3=gi(function(n){(function(t,e,r){function s(h){var p=this,m="";p.next=function(){var b=p.b,x=p.c,S=p.d,C=p.a;return b=b<<25^b>>>7^x,x=x-S|0,S=S<<24^S>>>8^C,C=C-b|0,p.b=b=b<<20^b>>>12^x,p.c=x=x-S|0,p.d=S<<16^x>>>16^C,p.a=C-b|0},p.a=0,p.b=0,p.c=2654435769|0,p.d=1367130551,h===Math.floor(h)?(p.a=h/4294967296|0,p.b=h|0):m+=h;for(var y=0;y<m.length+20;y++)p.b^=m.charCodeAt(y)|0,p.next()}function u(h,p){return p.a=h.a,p.b=h.b,p.c=h.c,p.d=h.d,p}function l(h,p){var m=new s(h),y=p&&p.state,b=function(){return(m.next()>>>0)/4294967296};return b.double=function(){do var x=m.next()>>>11,S=(m.next()>>>0)/4294967296,C=(x+S)/(1<<21);while(C===0);return C},b.int32=m.next,b.quick=b,y&&(typeof y=="object"&&u(y,m),b.state=function(){return u(m,{})}),b}e&&e.exports?e.exports=l:r&&r.amd?r(function(){return l}):this.tychei=l})(Mu,n,!1)}),vi=gi(function(n){(function(t,e){var r=this,s=256,u=6,l=52,h="random",p=e.pow(s,u),m=e.pow(2,l),y=m*2,b=s-1,x;function S(_,B,V){var q=[];B=B==!0?{entropy:!0}:B||{};var j=R(D(B.entropy?[_,L(t)]:_==null?A():_,3),q),et=new C(q),tt=function(){for(var ht=et.g(u),gt=p,vt=0;ht<m;)ht=(ht+vt)*s,gt*=s,vt=et.g(1);for(;ht>=y;)ht/=2,gt/=2,vt>>>=1;return(ht+vt)/gt};return tt.int32=function(){return et.g(4)|0},tt.quick=function(){return et.g(4)/4294967296},tt.double=tt,R(L(et.S),t),(B.pass||V||function(ht,gt,vt,bt){return bt&&(bt.S&&I(bt,et),ht.state=function(){return I(et,{})}),vt?(e[h]=ht,gt):ht})(tt,j,"global"in B?B.global:this==e,B.state)}e["seed"+h]=S;function C(_){var B,V=_.length,q=this,j=0,et=q.i=q.j=0,tt=q.S=[];for(V||(_=[V++]);j<s;)tt[j]=j++;for(j=0;j<s;j++)tt[j]=tt[et=b&et+_[j%V]+(B=tt[j])],tt[et]=B;(q.g=function(ht){for(var gt,vt=0,bt=q.i,yt=q.j,mt=q.S;ht--;)gt=mt[bt=b&bt+1],vt=vt*s+mt[b&(mt[bt]=mt[yt=b&yt+gt])+(mt[yt]=gt)];return q.i=bt,q.j=yt,vt})(s)}function I(_,B){return B.i=_.i,B.j=_.j,B.S=_.S.slice(),B}function D(_,B){var V=[],q=typeof _,j;if(B&&q=="object")for(j in _)try{V.push(D(_[j],B-1))}catch(et){}return V.length?V:q=="string"?_:_+"\0"}function R(_,B){for(var V=_+"",q,j=0;j<V.length;)B[b&j]=b&(q^=B[b&j]*19)+V.charCodeAt(j++);return L(B)}function A(){try{var _;return x&&(_=x.randomBytes)?_=_(s):(_=new Uint8Array(s),(r.crypto||r.msCrypto).getRandomValues(_)),L(_)}catch(q){var B=r.navigator,V=B&&B.plugins;return[+new Date,r,V,r.screen,L(t)]}}function L(_){return String.fromCharCode.apply(0,_)}if(R(e.random(),t),n.exports){n.exports=S;try{x=require("crypto")}catch(_){}}})([],Math)});vi.alea=f3,vi.xor128=p3,vi.xorwow=d3,vi.xorshift7=m3,vi.xor4096=g3,vi.tychei=v3;var y3=vi,Lu=y3.alea;class yb{constructor(t,e,r,s,u){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let l=u||Math.random();this.random=Lu(l.toString())}nextValue(){if(!isNaN(this.nextVal)){let s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,u,l;do s=2*this.random()-1,u=2*this.random()-1,l=s*s+u*u;while(l>=1||l===0);let h=Math.sqrt(-2*Math.log(l)/l);t=this.mean+this.stdDev*s*h,e=this.mean+this.stdDev*u*h,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class b3{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;let u=s||Math.random();this.randu=Lu(u.toString()),this.randn=new yb(0,1,r,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,u,l;for(;;){do s=this.randn.nextValue(),l=1+this.c*s;while(l<=0);if(l*=l*l,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-l+Math.log(l)),u=this.randu(),u<e||Math.log(u)<r)break}return l=1/this.beta*this.d*l,this.alpha<1&&(l*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(l)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class w3{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Lu(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function hht(n){let t=n.length,e=k3(n),r=T3(n),s=t/6*(Math.pow(e,2)+.25*Math.pow(r-3,2)),u=5.991;if(s>u)throw new Error(`Invalid p-value for JB: ${s}`)}function fht(n,t,e,r){r==null&&(r=ad());let s=bb(n);Uy(s,t,r),Uy(x3(n,s),e,r)}function bb(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t/n.length}function x3(n,t){let e=0;for(let r=0;r<n.length;r++){let s=n[r]-t;e+=s*s}return Math.sqrt(e/n.length)}function T3(n){let t=bb(n),e=n.length,r=0,s=0;for(let u=0;u<e;u++){let l=n[u]-t;r+=Math.pow(l,2),s+=Math.pow(l,4)}return 1/e*s/Math.pow(1/e*r,2)}function k3(n){let t=bb(n),e=n.length,r=0,s=0;for(let u=0;u<e;u++){let l=n[u]-t;r+=Math.pow(l,2),s+=Math.pow(l,3)}return 1/e*s/Math.pow(1/(e-1)*r,3/2)}function S3(n,t,e=1,r="float32",s){if(e==null&&(e=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let u=new b3(t,e,r,s),l=Ae(n,r);for(let h=0;h<l.values.length;h++)l.values[h]=u.nextValue();return l.toTensor()}let C3=X({randomGamma_:S3});function N3(n,t=0,e=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let u=new yb(t,e,r,!1,s),l=Ae(n,r);for(let h=0;h<l.values.length;h++)l.values[h]=u.nextValue();return l.toTensor()}let wb=X({randomNormal_:N3});function I3(n,t=0,e=1,r="float32",s){let u=Ae(n,r),l=new w3(t,e,null,s);for(let h=0;h<u.values.length;h++)u.values[h]=l.nextValue();return u.toTensor()}let yi=X({randomUniform_:I3});function Ir(n,t){M(n);let e=Hs(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");let r=null;return ra(n,r,e,t)}function Ch(n,t,e=1,r="float32"){if(e===0)throw new Error("Cannot have a step of zero");let s=()=>{let l=n===t,h=n<t&&e<0,p=t<n&&e>1;if(l||h||p)return Se([0],r);let m=Math.abs(Math.ceil((t-n)/e)),y=fu(m,r);t<n&&e===1&&(e=-1),y[0]=n;for(let b=1;b<y.length;b++)y[b]=y[b-1]+e;return Ir(y,r)},u={start:n,stop:t,step:e,dtype:r};return J.runKernelFunc(s,{},null,z2,u)}function E3(n){let t=z(n,"x","reciprocal"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.reciprocal(t);return s([t]),u},e,null,Wl)}let xb=X({reciprocal_:E3});function D3(n){let t=z(n,"x","relu"),e=(s,u)=>(u([t]),t.dtype==="bool"?Rt(t,"int32"):s.relu(t)),r={x:t};return J.runKernelFunc(e,r,null,Vl)}let Ys=X({relu_:D3});function $3(n){let t=z(n,"x","relu6"),e=(s,u)=>(u([t]),t.dtype==="bool"?Rt(t,"int32"):s.relu6(t)),r={x:t};return J.runKernelFunc(e,r,null,Gl)}let Tb=X({relu6_:$3});function A3(n,t){let e=z(n,"x","reverse"),r=l=>{let h=Et(t,e.shape);if(e.rank===0)return oa(e);let p=l.reverse(e,h);return rt(p,e.shape)},s={x:e},u={dims:t};return J.runKernelFunc(r,s,null,iy,u)}let Wr=X({reverse_:A3});function _3(n){let t=z(n,"x","reverse");return k(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Wr(t,0)}let F3=X({reverse1d_:_3});function R3(n,t){let e=z(n,"x","reverse");return k(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Wr(e,t)}let P3=X({reverse2d_:R3});function O3(n,t){let e=z(n,"x","reverse");return k(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Wr(e,t)}let M3=X({reverse3d_:O3});function L3(n,t){let e=z(n,"x","reverse");return k(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Wr(e,t)}let B3=X({reverse4d_:L3});function z3(n){let t=z(n,"x","round"),e={x:t};return J.runKernelFunc(r=>r.round(t),e,null,Hl)}let kb=X({round_:z3});function W3(n){let t=z(n,"x","rsqrt"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.rsqrt(t);return s([t]),u},e,null,ql)}let Id=X({rsqrt_:W3});function V3(n){let t=z(n,"x","selu"),e=(s,u)=>{let l=s.selu(t);return u([t]),l},r={x:t};return J.runKernelFunc(e,r,null,jl)}let Ed=X({selu_:V3});function U3(n,t,e,r,s,u=[1,1],l="NHWC"){let h=z(n,"x","separableConv2d"),p=z(t,"depthwiseFilter","separableConv2d"),m=z(e,"pointwiseFilter","separableConv2d"),y=h,b=!1;if(h.rank===3&&(b=!0,y=rt(h,[1,h.shape[0],h.shape[1],h.shape[2]])),l==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");k(y.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${y.rank}.`),k(p.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`),k(m.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`),k(m.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${m.shape[0]}.`),k(m.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${m.shape[1]}.`);let x=p.shape[2],S=p.shape[3];k(m.shape[2]===x*S,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${x*S}, but got ${m.shape[2]}.`);let C=pi(y,p,r,s,l,u),I=1,D=wo(C,m,I,"valid",l);return b?rt(D,[D.shape[1],D.shape[2],D.shape[3]]):D}let Sb=X({separableConv2d_:U3});async function G3(n,t){let e=z(n,"x","setdiff1d"),r=z(t,"y","setdiff1d");k(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),k(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),k(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await e.data(),u=await r.data(),l=new Set(u),h=0;for(let y=0;y<s.length;y++)l.has(s[y])||h++;let p=new bn([h],e.dtype),m=new bn([h],"int32");for(let y=0,b=0;y<s.length;y++)l.has(s[y])||(p.values[b]=s[y],m.values[b]=y,b++);return[p.toTensor(),m.toTensor()]}let oC=G3;function H3(n){let t=z(n,"x","sign"),e={x:t};return J.runKernelFunc(r=>r.sign(t),e,null,Xl)}let Cb=X({sign_:H3});function q3(n){let t=z(n,"x","sin"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.sin(t);return s([t]),u},e,null,vu)}let Dd=X({sin_:q3});function j3(n){let t=z(n,"x","sinh"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.sinh(t);return s([t]),u},e,null,Kl)}let $d=X({sinh_:j3});function K3(n,t,e){let r=z(n,"x","slice1d");return k(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ge(r,[t],[e])}let Ad=X({slice1d_:K3});function X3(n,t,e){let r=z(n,"x","slice2d");return k(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ge(r,t,e)}let Nb=X({slice2d_:X3});function Y3(n,t,e){let r=z(n,"x","slice3d");return k(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ge(r,t,e)}let _d=X({slice3d_:Y3});function J3(n,t,e){let r=z(n,"x","slice4d");return k(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ge(r,t,e)}let Nh=X({slice4d_:J3});function Z3(n,t=-1){let e=z(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let r={logits:e},s={dim:t};return J.runKernelFunc((u,l)=>{let h=u.softmax(e,t);return l([h]),h},r,null,hy,s)}let bi=X({softmax_:Z3});function Q3(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);let t={input:n};return J.runKernelFunc(e=>{let r=n.shape[n.shape.length-1],s=n.size/r,u=n.as2D(s,r),l=e.fft(u);return l.reshape(n.shape)},t,null,kp)}let Ih=X({fft_:Q3});function tB(n){k(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);let t={input:n};return J.runKernelFunc(e=>{let r=n.shape[n.shape.length-1],s=n.size/r,u=rt(n,[s,r]),l=e.ifft(u);return rt(l,n.shape)},t,null,Cp)}let Bu=X({ifft_:tB});function eB(n){let t=n.shape[n.shape.length-1],e=n.size/t,r;if(t<=2){let s=rt(n,[e,t]);r=Bu(s)}else{let s=[e,2*(t-1)],u=rt(Ou(n),[e,t]),l=rt(bh(n),[e,t]),h=Wr(ge(u,[0,1],[e,t-2]),1),p=st(Wr(ge(l,[0,1],[e,t-2]),1),Ot(-1)),m=sn([u,h],1),y=sn([l,p],1),b=rt(vo(m,y),[s[0],s[1]]);r=Bu(b)}if(r=Ou(r),n.rank===3&&n.shape[0]!==0){let s=r,u=n.shape[0];r=rt(r,[u,r.shape[0]/u,r.shape[1]]),s.dispose()}return r}let Fd=X({irfft_:eB});function aC(n,t,e=0){let r=[];if(typeof t=="number")k(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{let s=t.reduce((l,h)=>(h===-1&&(l+=1),l),0);k(s<=1,()=>"There should be only one negative value in split array.");let u=t.indexOf(-1);if(u!==-1){let l=t.reduce((h,p)=>p>0?h+p:h);t[u]=n.shape[e]-l}k(n.shape[e]===t.reduce((l,h)=>l+h),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function nB(n,t,e=0){let r=z(n,"x","split"),s=(h,p)=>{let m=Et(e,r.shape)[0],y=aC(r,t,m);return h.split(r,y,m)},u={x:r},l={numOrSizeSplits:t,axis:e};return J.runKernelFunc(s,u,null,ly,l)}let Er=X({split_:nB});function rB(n,t){k(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1],r=n.size/e,s;if(t!=null&&t<e){let C=n.shape.map(D=>0),I=n.shape.map(D=>D);I[n.shape.length-1]=t,s=ge(n,C,I),e=t}else if(t!=null&&t>e){let C=n.shape.map(I=>I);C[n.shape.length-1]=t-e,s=sn([n,Se(C)],n.shape.length-1),e=t}else s=n;let u=fe(s),l=rt(vo(s,u),[r,e]),h=Ih(l),p=Math.floor(e/2)+1,m=Ou(h),y=bh(h),b=Er(m,[p,e-p],m.shape.length-1),x=Er(y,[p,e-p],y.shape.length-1),S=s.shape.slice();return S[s.shape.length-1]=p,rt(vo(b[0],x[0]),S)}let Eh=X({rfft_:rB});function sB(n){let t=z(n,"x","sqrt"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.sqrt(t);return s([t]),u},e,null,Zl)}let Wn=X({sqrt_:sB});function oB(n,t){let e=z(n,"a","squaredDifference"),r=z(t,"b","squaredDifference");[e,r]=nn(e,r),ve(e.shape,r.shape);let s=(h,p)=>{let m=h.squaredDifference(e,r);return p([e,r]),m},u={a:e,b:r},l={};return J.runKernelFunc(s,u,null,yu,l)}let Dh=X({squaredDifference_:oB});function aB(n,t){let e=z(n,"x","squeeze");return rt(e,Wt(e.shape,t).newShape)}let fa=X({squeeze_:aB});function iB(n,t=0){let e=uh(n,"tensors","stack");if(k(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length===1)return pr(e[0],t);let r=e[0].rank,s=e[0].shape,u=e[0].dtype;k(t<=r,()=>"Axis must be <= rank of the tensor"),e.forEach(h=>{$(s,h.shape,"All tensors passed to stack must have matching shapes"),k(u===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});let l=e.map(h=>pr(h,t));return sn(l,t)}let mr=X({stack_:iB});function uB(n,t=0){let e=z(n,"x","step"),r={x:e},s={alpha:t};return J.runKernelFunc(u=>u.step(e,t),r,null,eh,s)}let zu=X({step_:uB});function cB(n,t,e,r,s=0,u=0,l=0,h=0,p=0){let m=z(n,"x","stridedSlice"),y=S=>{r==null&&(r=new Array(t.length));let C=rd(l);if(C.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(l!==0&&h!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(l!==0&&p!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let I=m.rank-t.length,D=rd(h),R=m.shape.slice();D.forEach(tt=>{t[tt]=0,e[tt]=1,R.splice(tt,0,1)}),m=rt(m,R);let{begin:A,end:L,strides:_}=IS(m.shape,C,I,t,e,r,s,u,l);t=A,e=L,r=_;let B=rd(p);B.forEach(tt=>{e[tt]=t[tt]+1,r[tt]=1});let V=sd(t,e,r),q=V.filter((tt,ht)=>B.indexOf(ht)===-1),j=r.every(tt=>tt===1);if(j)return rt(ge(m,t,V),q);let et=S.stridedSlice(m,t,e,r);return rt(et,q)},b={x:m},x={begin:t,end:e,strides:r,beginMask:s,endMask:u,ellipsisMask:l,newAxisMask:h,shrinkAxisMask:p};return J.runKernelFunc(y,b,null,H2,x)}let Ib=X({stridedSlice_:cB});function lB(n){let t=z(n,"x","tan"),e={x:t};return J.runKernelFunc((r,s)=>{let u=r.tan(t);return s([t]),u},e,null,wu)}let Eb=X({tan_:lB});function pa(n,t,e){if(M(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Hs(n,e);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ra(n,t,r,e)}function Wu(n,t,e){if(M(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Hs(n,e);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ra(n,t,r,e)}function hB(n,t,e){if(M(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Hs(n,e);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ra(n,t,r,e)}function fB(n,t,e){if(M(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Hs(n,e);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,ra(n,t,r,e)}function pB(n,t=1,e=!0){let r=z(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let u={x:r},l={k:t,sorted:e},[h,p]=J.runKernelFunc(m=>m.topk(r,t,e),u,null,q2,l);return{values:h,indices:p}}let Db=X({topk_:pB});function dB(n,t=0,e=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let u=new yb(t,e,r,!0,s),l=Ae(n,r);for(let h=0;h<l.values.length;h++)l.values[h]=u.nextValue();return l.toTensor()}let $h=X({truncatedNormal_:dB});function mB(n,t=0){let e=z(n,"x","unique",null);k(e.rank>0,()=>"The input tensor must be at least 1D");let r={x:e},s={axis:t},[u,l]=J.runKernel(Lp,r,s);return{values:u,indices:l}}let Rd=X({unique_:mB});function gB(n,t,e){let r=z(n,"x","unsortedSegmentSum"),s=z(t,"segmentIds","unsortedSegmentSum","int32");k(nt(e),()=>"numSegments must be of dtype int");let u={x:r,segmentIds:s},l={numSegments:e},h=(p,m)=>{let y=p.unsortedSegmentSum(r,s,e);return m([s]),y};return J.runKernelFunc(h,u,null,dy,l)}let $b=X({unsortedSegmentSum_:gB});function vB(n,t=0){let e=z(n,"x","unstack");k(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),t<0&&(t+=e.shape.length);let r={value:e},s={axis:t},u=l=>l.unstack(e,t);return J.runKernelFunc(u,r,null,py,s)}let bs=X({unstack_:vB});function iC(n,t=!0,e,r){return J.makeVariable(n,t,e,r)}function Pd(n,t){let e=[];for(let u=0;u<t.length;u++)t[u]&&e.push(u);let r=Ae(n,"int32"),s=Ae([e.length,n.length],"int32");for(let u=0;u<e.length;u++){let l=r.indexToLoc(e[u]),h=u*n.length;s.values.set(l,h)}return s.toTensor()}async function yB(n){let t=z(n,"condition","whereAsync","bool"),e=await t.data(),r=Pd(t.shape,e);return n!==t&&t.dispose(),r}let Ab=yB;async function bB(n,t,e){let r=z(n,"tensor","boolMask"),s=z(t,"mask","boolMask","bool"),u=e==null?0:e,l=s.rank,h=r.shape;k(l>0,()=>"mask cannot be scalar"),$(h.slice(u,u+l),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let p=1;for(let I=u;I<u+l;I++)p*=h[I];let m=h.slice(0,u).concat([p],h.slice(u+l)),y=rt(r,m),b=rt(s,[-1]),x=await Ab(b),S=fa(x,[1]),C=Fu(y,S,u);return n!==r&&r.dispose(),t!==s&&s.dispose(),S.dispose(),y.dispose(),b.dispose(),x.dispose(),C}let wB=bB;function xB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","notEqualStrict"),r=z(t,"b","notEqualStrict");return $(e.shape,r.shape,"Error in notEqualStrict: "),ha(e,r)}function TB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","lessStrict"),r=z(t,"b","lessStrict");return $(e.shape,r.shape,"Error in lessStrict: "),wh(e,r)}function kB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","equalStrict"),r=z(t,"b","equalStrict");return $(e.shape,r.shape,"Error in equalStrict: "),gs(e,r)}function SB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","lessEqualStrict"),r=z(t,"b","lessEqualStrict");return $(e.shape,r.shape,"Error in lessEqualStrict: "),la(e,r)}function CB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","greaterStrict"),r=z(t,"b","greaterStrict");return $(e.shape,r.shape,"Error in greaterStrict: "),zr(e,r)}function NB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","greaterEqualStrict"),r=z(t,"b","greaterEqualStrict");return $(e.shape,r.shape,"Error in greaterEqualStrict: "),xo(e,r)}let uC=X({equalStrict_:kB}),cC=X({greaterEqualStrict_:NB}),lC=X({greaterStrict_:CB}),hC=X({lessEqualStrict_:SB}),fC=X({lessStrict_:TB}),pC=X({notEqualStrict_:xB});function IB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","addStrict"),r=z(t,"b","addStrict");return $(e.shape,r.shape,"Error in addStrict: "),Nt(e,r)}function EB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","subStrict"),r=z(t,"b","subStrict");return $(e.shape,r.shape,"Error in subStrict: "),Mt(e,r)}function DB(n,t){return Tn("strict variants of ops have been deprecated and will be removed in future"),$(n.shape,t.shape,"Error in powStrict: "),ys(n,t)}function $B(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","mul"),r=z(t,"b","mul");return $(e.shape,r.shape,"Error in multiplyStrict: "),st(e,r)}function AB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","div"),r=z(t,"b","div");return $(e.shape,r.shape,"Error in divideStrict: "),Ht(e,r)}function _B(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","modStrict"),r=z(t,"b","modStrict");return $(e.shape,r.shape,"Error in modStrict: "),Sd(e,r)}function FB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","minimumStrict"),r=z(t,"b","minimumStrict");return $(e.shape,r.shape,"Error in minimumStrict: "),mi(e,r)}function RB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","maximumStrict"),r=z(t,"b","maximumStrict");return $(e.shape,r.shape,"Error in maximumStrict: "),ts(e,r)}function PB(n,t){Tn("strict variants of ops have been deprecated and will be removed in future");let e=z(n,"a","squaredDifferenceStrict"),r=z(t,"b","squaredDifferenceStrict");return $(e.shape,r.shape,"Error in squaredDifferenceStrict: "),Dh(e,r)}let dC=X({addStrict_:IB}),mC=X({divStrict_:AB}),gC=X({maximumStrict_:RB}),vC=X({minimumStrict_:FB}),yC=X({modStrict_:_B}),bC=X({mulStrict_:$B}),wC=X({powStrict_:DB}),xC=X({squaredDifferenceStrict_:PB}),TC=X({subStrict_:EB});function OB(n,t="euclidean",e=null,r=!1){n=z(n,"x","norm");let s=kC(n,t,e),u=s.shape;if(r){let l=Et(e,n.shape);u=zn(s.shape,l)}return rt(s,u)}function kC(n,t,e=null){if(n.rank===0)return kn(n);if(n.rank!==1&&e===null)return kC(rt(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return Xt(kn(n),e);if(t===Infinity)return dr(kn(n),e);if(t===-Infinity)return Pu(kn(n),e);if(t==="euclidean"||t===2)return Wn(Xt(ys(kn(n),Ot(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return dr(Xt(kn(n),e[0]),e[1]-1);if(t===Infinity)return dr(Xt(kn(n),e[1]),e[0]);if(t===-Infinity)return Pu(Xt(kn(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Wn(Xt(Oe(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}let Od=X({norm_:OB});function MB(n,t,e,r,s=!0){let u=z(n,"v","movingAverage"),l=z(t,"x","movingAverage"),h=z(e,"decay","movingAverage");Q2(u,l),k(K(u.shape,l.shape),()=>"Shape mismatch in v and x");let p=Ot(1),m=Mt(p,h),y=st(Mt(l,u),m);if(s){k(r!=null,()=>"When using zeroDebias: true, step is required.");let b=z(r,"step","movingAverage");y=Ht(y,Mt(p,ys(h,b)))}return Nt(u,y)}let LB=X({movingAverage_:MB});function BB(n,t,e){let r=z(n,"indices","scatterND","int32"),s=z(t,"updates","scatterND");Ly(s,r,e);let u=p=>p.scatterND(r,s,e),l={indices:r,updates:s},h={shape:e};return J.runKernelFunc(u,l,null,U2,h)}let SC=X({scatterND_:BB});function zB(n,t,e,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);let s=n.rank>0?n.shape[0]:1,u=n.rank>1?n.shape[1]:1;if(e.length!==u)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${u}.`);let l=t.size;if(!(t.rank===0||t.rank===1&&l===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function WB(n,t,e,r=0){let s=z(n,"sparseIndices","sparseToDense","int32"),u=z(t,"sparseValues","sparseToDense"),l=z(r,"defaultValue","sparseToDense",u.dtype);zB(s,u,e,l);let h={sparseIndices:s,sparseValues:u,defaultValue:l},p={outputShape:e};return J.runKernelFunc(m=>m.sparseToDense(s,u,e,l),h,null,G2,p)}let _b=X({sparseToDense_:WB});function VB(n,t){let e=z(t,"indices","gatherND","int32"),r=z(n,"x","gatherND"),s=l=>l.gatherND(r,e),u={params:r,indices:e};return J.runKernelFunc(s,u,null,$2)}let CC=X({gatherND_:VB});function UB(n,t){if(t==null)return n.shape.slice();if(K(n.shape,t))return t;if(n.shape.length===t.length){let e=[];for(let r=0;r<n.shape.length;r++)t[r]==null&&n.shape[r]!=null?e.push(n.shape[r]):e.push(t[r]);return e}return t}function GB(n,t,e,r){let s=z(n,"x","dropout");if(k(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),k(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof at?s.clone():s;let u=UB(s,e),l=1-t,h=Ht(_u(Nt(yi(u,0,1,"float32",r),l)),l);return st(s,h)}let NC=X({dropout_:GB});function IC(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function Fb(n,t,e){let r=1-n%2,s=new Float32Array(n);for(let u=0;u<n;++u){let l=2*Math.PI*u/(n+r-1);s[u]=t-e*Math.cos(l)}return Ir(s,"float32")}async function HB(n,t,e=1){let r=z(n,"predictions","inTopK"),s=z(t,"targets","inTopK");k(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),k(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),$(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let u=r.shape[r.shape.length-1];k(e>0&&e<=u,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${u}), but got ${e}`);let l=await r.data(),h=await s.data(),[p,m]=[l.length/u,u],y=_t("bool",p);for(let b=0;b<p;b++){let x=b*m,S=l.subarray(x,x+m),C=[];for(let I=0;I<S.length;I++)C.push({value:S[I],index:I});C.sort((I,D)=>D.value-I.value),y[b]=0;for(let I=0;I<e;I++)if(C[I].index===h[b]){y[b]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),vn(y,s.shape,"bool")}let qB=HB;function jB(n,t,e,r,s,u="NHWC",l){let h=n;n.rank===3&&(h=rt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let p=t;p.rank===3&&(p=rt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),k(h.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`),k(p.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${p.shape}.`),k(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let m=u==="NHWC"?h.shape[3]:h.shape[1],y=u==="NHWC"?p.shape[3]:p.shape[1];k(m===e[2],()=>`Error in conv2dDerFilter: depth of input ${m}) must match input depth in filter (${e[2]}.`),k(y===e[3],()=>`Error in conv2dDerFilter: depth of dy (${y}) must match output depth for filter (${e[3]}).`),l!=null&&k(nt(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${l} but got pad ${s}.`);let b=C=>{let I=1,D=ua(u),R=Kn(h.shape,e,r,I,s,l,!1,D);return C.conv2dDerFilter(h,p,R)},x={x:h,dy:p},S={strides:r,pad:s,dataFormat:u,dimRoundingMode:l,filterShape:e};return J.runKernelFunc(b,x,null,Ov,S)}let Rb=X({conv2DBackpropFilter_:jB});function Md(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return st(n,zu(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function Ld(n,t){let e=t,r=Sn(n.shape,t.shape);return r.length>0&&(e=Xt(e,r)),rt(e,n.shape)}function Bd(n,t,e){if(t==="linear")return n;if(t==="relu")return Ys(n);if(t==="elu")return $u(n);if(t==="relu6")return Tb(n);if(t==="prelu")return Sh(n,e);throw new Error(`Unknown fused activation ${t}.`)}let zd=(n,t)=>{let e=n>0;return!e||t==="linear"};function KB({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:u=[1,1],dimRoundingMode:l,bias:h,activation:p="linear",preluActivationWeights:m}){if(p=p||"linear",zd(J.state.gradientDepth,p)===!1){let B=wo(n,t,e,r,s,u,l);return h!=null&&(B=Nt(B,h)),Bd(B,p,m)}let y=z(n,"x","conv2d"),b=z(t,"filter","conv2d"),x=y,S=!1;y.rank===3&&(S=!0,x=rt(y,[1,y.shape[0],y.shape[1],y.shape[2]])),k(x.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${x.rank}.`),k(b.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${b.rank}.`),l!=null&&k(nt(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${r}.`),k(x.shape[3]===b.shape[2],()=>`Error in conv2d: depth of input (${x.shape[3]}) must match input depth for filter ${b.shape[2]}.`),k(wn(e,u),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${u}'`),k(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);let C=Kn(x.shape,b.shape,e,u,r,l),I;h!=null&&(I=z(h,"bias","fused conv2d"),[I]=nn(I,y),ve(C.outShape,I.shape));let D;m!=null&&(D=z(m,"prelu weights","fused conv2d"));let R=(B,V)=>{let[q,j,et,tt]=V,ht=Md(B,et,p);k(ia(u),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${u}'`);let gt=ob(j.shape,ht,q,e,r),vt=Rb(j,ht,q.shape,e,r),bt=[gt,vt];if(tt!=null){let yt=Ld(tt,ht);bt.push(yt)}return bt},A=B=>{let V=B.fusedConv2d({input:x,filter:b,convInfo:C,bias:I,activation:p,preluActivationWeights:D});return V},L={x,filter:b,bias:I,preluActivationWeights:D},_={strides:e,pad:r,dataFormat:s,dilations:u,dimRoundingMode:l,activation:p};if(h==null){let B=Ks((V,q,j)=>{let et=J.runKernelFunc(A,L,null,Vp,_);return j([q,V,et]),S&&(et=rt(et,[et.shape[1],et.shape[2],et.shape[3]])),{value:et,gradFunc:R}});return B(x,b)}else{let B=Ks((V,q,j,et)=>{let tt=J.runKernelFunc(A,L,null,Vp,_);return et([q,V,tt,j]),S&&(tt=rt(tt,[tt.shape[1],tt.shape[2],tt.shape[3]])),{value:tt,gradFunc:R}});return B(x,b,I)}}let Pb=X({fusedConv2d_:KB});function XB(n,t,e,r,s,u=[1,1],l){let h=n;n.rank===3&&(h=rt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let p=t;p.rank===3&&(p=rt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let m=x=>{let S=Kn(n.shape,e,r,u,s,l,!0);return x.depthwiseConv2DDerFilter(h,p,S)},y={x:h,dy:p},b={strides:r,pad:s,dimRoundingMode:l,dilations:u,filterShape:e};return J.runKernelFunc(m,y,null,zv,b)}let EC=X({depthwiseConv2dNativeBackpropFilter_:XB});function YB(n,t,e,r,s,u=[1,1],l){let h=t,p=!1;t.rank===3&&(p=!0,h=rt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let m=S=>{let C=Kn(n,e.shape,r,u,s,l,!0);return S.depthwiseConv2DDerInput(h,e,C)},y={dy:h,filter:e},b={strides:r,pad:s,dimRoundingMode:l,dilations:u,inputShape:n},x=J.runKernelFunc(m,y,null,Wv,b);return p?rt(x,[x.shape[1],x.shape[2],x.shape[3]]):x}let DC=X({depthwiseConv2dNativeBackpropInput_:YB});function JB({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:u=[1,1],dimRoundingMode:l,bias:h,activation:p="linear",preluActivationWeights:m}){if(zd(J.state.gradientDepth,p)===!1){let B=pi(n,t,e,r,s,u,l);return h!=null&&(B=Nt(B,h)),Bd(B,p,m)}let y=z(n,"x","depthwiseConv2d"),b=z(t,"filter","depthwiseConv2d"),x=y,S=!1;y.rank===3&&(S=!0,x=rt(y,[1,y.shape[0],y.shape[1],y.shape[2]])),k(x.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x.rank}.`),k(b.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${b.rank}.`),k(x.shape[3]===b.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${x.shape[3]}) must match the inChannels dimension in filter ${b.shape[2]}.`),u==null&&(u=[1,1]),k(wn(e,u),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${u}'`),l!=null&&k(nt(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${l} but got pad ${r}.`);let C=Kn(x.shape,b.shape,e,u,r,l,!0),I;h!=null&&(I=z(h,"bias","fused conv2d"),[I]=nn(I,y),ve(C.outShape,I.shape));let D;m!=null&&(D=z(m,"prelu weights","fused depthwiseConv2d"));let R=(B,V)=>{k(ia(u),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${u}'`);let[q,j,et,tt]=V,ht=Md(B,et,p),gt=DC(j.shape,ht,q,e,r,u,l),vt=EC(j,ht,q.shape,e,r,u,l);if(tt!=null){let bt=Ld(I,ht);return[gt,vt,bt]}return[gt,vt]},A=B=>{let V=B.fusedDepthwiseConv2D({input:x,filter:b,convInfo:C,bias:I,activation:p,preluActivationWeights:D});return V},L={x,filter:b,bias:I,preluActivationWeights:D},_={strides:e,pad:r,dataFormat:s,dilations:u,dimRoundingMode:l,activation:p};if(h==null){let B=Ks((V,q,j)=>{let et=J.runKernelFunc(A,L,null,Up,_);return j([q,V,et]),S&&(et=rt(et,[et.shape[1],et.shape[2],et.shape[3]])),{value:et,gradFunc:R}});return B(x,b)}else{let B=Ks((V,q,j,et)=>{let tt=J.runKernelFunc(A,L,null,Up,_);return et([q,V,tt,j]),S&&(tt=rt(tt,[tt.shape[1],tt.shape[2],tt.shape[3]])),{value:tt,gradFunc:R}});return B(x,b,I)}}let $C=X({fusedDepthwiseConv2d_:JB});function ZB({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:u="linear",preluActivationWeights:l}){if(zd(J.state.gradientDepth,u)===!1){let tt=xe(n,t,e,r);return s!=null&&(tt=Nt(tt,s)),Bd(tt,u,l)}let h=z(n,"a","fused matMul"),p=z(t,"b","fused matMul");[h,p]=nn(h,p);let m=e?h.shape[h.rank-2]:h.shape[h.rank-1],y=r?p.shape[p.rank-1]:p.shape[p.rank-2],b=e?h.shape[h.rank-1]:h.shape[h.rank-2],x=r?p.shape[p.rank-2]:p.shape[p.rank-1],S=h.shape.slice(0,-2),C=p.shape.slice(0,-2),I=O(S),D=O(C);k(h.rank>=2&&p.rank>=2&&h.rank===p.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${h.rank} and ${p.rank}.`),k(K(S,C),()=>`Error in fused matMul: outer dimensions (${S}) and (${C}) of Tensors with shapes ${h.shape} and ${p.shape} must match.`),k(m===y,()=>`Error in fused matMul: inner shapes (${m}) and (${y}) of Tensors with shapes ${h.shape} and ${p.shape} and transposeA=${e} and transposeB=${r} must match.`);let R=h.shape.slice(0,-2).concat([b,x]),A=e?rt(h,[I,m,b]):rt(h,[I,b,m]),L=r?rt(p,[D,x,y]):rt(p,[D,y,x]),_;s!=null&&(_=z(s,"bias","fused matMul"),[_]=nn(_,h),ve(R,_.shape));let B;l!=null&&(B=z(l,"prelu weights","fused matMul"));let V=(tt,ht)=>{let[gt,vt,bt,yt]=ht,mt=Md(rt(tt,bt.shape),bt,u),xt,wt;if(!e&&!r?(xt=xe(mt,vt,!1,!0),wt=xe(gt,mt,!0,!1)):!e&&r?(xt=xe(mt,vt,!1,!1),wt=xe(mt,gt,!0,!1)):e&&!r?(xt=xe(vt,mt,!1,!0),wt=xe(gt,mt,!1,!1)):(xt=xe(vt,mt,!0,!0),wt=xe(mt,gt,!0,!0)),s!=null){let Tt=Ld(yt,mt);return[xt,wt,Tt]}else return[xt,wt]},q=tt=>{let ht=tt.fusedBatchMatMul({a:A,b:L,transposeA:e,transposeB:r,bias:_,activation:u,preluActivationWeights:B});return ht},j={a:A,b:L,bias:_,preluActivationWeights:B},et={transposeA:e,transposeB:r,activation:u};if(s==null){let tt=Ks((ht,gt,vt)=>{let bt=J.runKernelFunc(q,j,null,Wp,et);return vt([ht,gt,bt]),{value:rt(bt,R),gradFunc:V}});return tt(A,L)}else{let tt=Ks((ht,gt,vt,bt)=>{let yt=J.runKernelFunc(q,j,null,Wp,et);return bt([ht,gt,yt,vt]),{value:rt(yt,R),gradFunc:V}});return tt(A,L,_)}}let Wd=X({fusedMatMul_:ZB});var QB=Object.freeze({__proto__:null,conv2d:Pb,depthwiseConv2d:$C,matMul:Wd});function tz(n){return Fb(n,.54,.46)}let ez=X({hammingWindow_:tz});function nz(n){return Fb(n,.5,.5)}let AC=X({hannWindow_:nz});function rz(n,t,e,r=!1,s=0){let u=0,l=[];for(;u+t<=n.size;)l.push(ge(n,u,t)),u+=e;if(r)for(;u<n.size;){let h=u+t-n.size,p=sn([ge(n,u,t-h),Au([h],s)]);l.push(p),u+=e}return l.length===0?pa([],[0,t]):rt(sn(l),[l.length,t])}let _C=X({frame_:rz});function sz(n,t,e,r,s=AC){r==null&&(r=IC(t));let u=_C(n,t,e),l=st(u,s(t)),h=[];for(let p=0;p<u.shape[0];p++)h.push(Eh(ge(l,[p,0],[1,t]),r));return sn(h)}let oz=X({stft_:sz});function az(n,t,e,r,s,u){let l=z(n,"image","cropAndResize"),h=z(t,"boxes","cropAndResize","float32"),p=z(e,"boxInd","cropAndResize","int32");s=s||"bilinear",u=u||0;let m=h.shape[0];k(l.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${l.rank}.`),k(h.rank===2&&h.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${m},4] but had shape ${h.shape}.`),k(p.rank===1&&p.shape[0]===m,()=>`Error in cropAndResize: boxInd must be have size [${m}] but had shape ${h.shape}.`),k(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),k(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),k(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let y=C=>C.cropAndResize(l,h,p,r,s,u),b={image:l,boxes:h,boxInd:p},x={method:s,extrapolationValue:u,cropSize:r},S=J.runKernelFunc(y,b,null,C2,x);return S}let iz=X({cropAndResize_:az});function uz(n){let t=z(n,"image","flipLeftRight","float32");k(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t},r=J.runKernel(Sp,e,{});return r}let cz=X({flipLeftRight_:uz});function lz(n,t,e=0,r=.5){let s=z(n,"image","rotateWithOffset","float32");k(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let u={image:s},l={radians:t,fillValue:e,center:r},h=J.runKernel(zp,u,l);return h}let hz=X({rotateWithOffset_:lz});function Vu(n,t,e,r,s,u){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),u==null&&(u=0);let l=n.shape[0];return e=Math.min(e,l),k(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),k(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),k(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),k(t.rank===1,()=>"scores must be a 1D tensor"),k(t.shape[0]===l,()=>`scores has incompatible shape with boxes. Expected ${l}, but was ${t.shape[0]}`),k(0<=u&&u<=1,()=>`softNmsSigma must be in [0, 1], but was '${u}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:u}}function fz(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){let u=z(n,"boxes","nonMaxSuppression"),l=z(t,"scores","nonMaxSuppression"),h=Vu(u,l,e,r,s);e=h.maxOutputSize,r=h.iouThreshold,s=h.scoreThreshold;let p={maxOutputSize:e,iouThreshold:r,scoreThreshold:s};return J.runKernelFunc(m=>m.nonMaxSuppression(u,l,e,r,s),{boxes:u,scores:l},null,ey,p)}let pz=X({nonMaxSuppression_:fz});function dz(n,t,e){let r=mz(n,t,e),s=r<0?-(r+1):r;n.splice(s,0,t)}function mz(n,t,e){return vz(n,t,e||gz)}function gz(n,t){return n>t?1:n<t?-1:0}function vz(n,t,e){let r=0,s=n.length,u=0,l=!1;for(;r<s;){u=r+(s-r>>>1);let h=e(t,n[u]);h>0?r=u+1:(s=u,l=!h)}return l?r:-r-1}function Vd(n,t,e,r,s){return Ob(n,t,e,r,s,0).selectedIndices}function Ud(n,t,e,r,s,u){return Ob(n,t,e,r,s,0,!1,u,!0)}function Gd(n,t,e,r,s,u){return Ob(n,t,e,r,s,u,!0)}function Ob(n,t,e,r,s,u,l=!1,h=!1,p=!1){let m=[];for(let D=0;D<t.length;D++)t[D]>s&&m.push({score:t[D],boxIndex:D,suppressBeginIndex:0});m.sort(FC);let y=u>0?-.5/u:0,b=[],x=[];for(;b.length<e&&m.length>0;){let D=m.pop(),{score:R,boxIndex:A,suppressBeginIndex:L}=D;if(R<s)break;let _=!1;for(let B=b.length-1;B>=L;--B){let V=yz(n,A,b[B]);if(V>=r){_=!0;break}if(D.score=D.score*bz(r,y,V),D.score<=s)break}D.suppressBeginIndex=b.length,_||(D.score===R?(b.push(A),x.push(D.score)):D.score>s&&dz(m,D,FC))}let S=b.length,C=e-S;h&&C>0&&(b.push(...new Array(C).fill(0)),x.push(...new Array(C).fill(0)));let I={selectedIndices:Ir(b,"int32")};return l&&(I.selectedScores=Ir(x,"float32")),p&&(I.validOutputs=Ot(S,"int32")),I}function yz(n,t,e){let r=n.subarray(t*4,t*4+4),s=n.subarray(e*4,e*4+4),u=Math.min(r[0],r[2]),l=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),m=Math.min(s[0],s[2]),y=Math.min(s[1],s[3]),b=Math.max(s[0],s[2]),x=Math.max(s[1],s[3]),S=(h-u)*(p-l),C=(b-m)*(x-y);if(S<=0||C<=0)return 0;let I=Math.max(u,m),D=Math.max(l,y),R=Math.min(h,b),A=Math.min(p,x),L=Math.max(R-I,0)*Math.max(A-D,0);return L/(S+C-L)}function bz(n,t,e){let r=Math.exp(t*e*e);return e<=n?r:0}function FC(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function wz(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){let u=z(n,"boxes","nonMaxSuppressionAsync"),l=z(t,"scores","nonMaxSuppressionAsync"),h=Vu(u,l,e,r,s);e=h.maxOutputSize,r=h.iouThreshold,s=h.scoreThreshold;let p=await Promise.all([u.data(),l.data()]),m=p[0],y=p[1],b=Vd(m,y,e,r,s);return u!==n&&u.dispose(),l!==t&&l.dispose(),b}let xz=wz;function Tz(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,u=0){let l=z(n,"boxes","nonMaxSuppression"),h=z(t,"scores","nonMaxSuppression"),p=Vu(l,h,e,r,s,u);e=p.maxOutputSize,r=p.iouThreshold,s=p.scoreThreshold,u=p.softNmsSigma;let m={boxes:l,scores:h},y={maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:u},b=J.runKernel(Ap,m,y);return{selectedIndices:b[0],selectedScores:b[1]}}let kz=X({nonMaxSuppressionWithScore_:Tz});async function Sz(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,u=0){let l=z(n,"boxes","nonMaxSuppressionAsync"),h=z(t,"scores","nonMaxSuppressionAsync"),p=Vu(l,h,e,r,s,u);e=p.maxOutputSize,r=p.iouThreshold,s=p.scoreThreshold,u=p.softNmsSigma;let m=await Promise.all([l.data(),h.data()]),y=m[0],b=m[1],x=Gd(y,b,e,r,s,u);return l!==n&&l.dispose(),h!==t&&h.dispose(),x}let Cz=Sz;function Nz(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,u=!1){let l=z(n,"boxes","nonMaxSuppression"),h=z(t,"scores","nonMaxSuppression"),p=Vu(l,h,e,r,s,null),m=p.maxOutputSize,y=p.iouThreshold,b=p.scoreThreshold,x={boxes:l,scores:h},S={maxOutputSize:m,iouThreshold:y,scoreThreshold:b,padToMaxOutputSize:u},C=J.runKernel($p,x,S);return{selectedIndices:C[0],validOutputs:C[1]}}let Iz=X({nonMaxSuppressionPadded_:Nz});async function Ez(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,u=!1){let l=z(n,"boxes","nonMaxSuppressionAsync"),h=z(t,"scores","nonMaxSuppressionAsync"),p=Vu(l,h,e,r,s,null),m=p.maxOutputSize,y=p.iouThreshold,b=p.scoreThreshold,[x,S]=await Promise.all([l.data(),h.data()]),C=Ud(x,S,m,y,b,u);return l!==n&&l.dispose(),h!==t&&h.dispose(),C}let Dz=Ez;function $z(n,t,e=!1){let r=z(n,"images","resizeBilinear");k(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),k(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`);let s=r,u=!1;r.rank===3&&(u=!0,s=rt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[l,h]=t,p=(x,S)=>(S([s]),x.resizeBilinear(s,l,h,e)),m={images:s},y={alignCorners:e,size:t},b=J.runKernelFunc(p,m,null,ay,y);return u?rt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}let RC=X({resizeBilinear_:$z});function Az(n,t,e=!1){let r=z(n,"images","resizeNearestNeighbor");k(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),k(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),k(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype");let s=r,u=!1;r.rank===3&&(u=!0,s=rt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let[l,h]=t,p={images:s},m={alignCorners:e,size:t},y=(x,S)=>(S([s]),x.resizeNearestNeighbor(s,l,h,e)),b=J.runKernelFunc(y,p,null,oy,m);return u?rt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}let PC=X({resizeNearestNeighbor_:Az});function _z(n,t,e){k(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),k(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let r=z(n,"a","bandPart");k(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[u,l]=r.shape.slice(-2);if(!(t<=u))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${u}).`);if(!(e<=l))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${l}).`);t<0&&(t=u),e<0&&(e=l);let h=rt(Ch(0,u,1,"int32"),[-1,1]),p=Ch(0,l,1,"int32"),m=Mt(h,p),y=es(la(m,Ot(+t,"int32")),xo(m,Ot(-e,"int32"))),b=Se([u,l],r.dtype);return rt(mr(bs(rt(r,[-1,u,l])).map(x=>er(y,x,b))),s)}let Fz=X({bandPart_:_z});function Rz(n){let t;if(Array.isArray(n)){t=!1,k(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=n[0].shape[0];for(let u=1;u<n.length;++u)k(n[u].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[u].shape[0]} vs. ${s})`)}else t=!0,n=Er(n,n.shape[0],0).map(s=>fa(s,[0]));k(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);let e=[],r=n;for(let s=0;s<n.length;++s)e.push(J.tidy(()=>{let u=r[s];if(s>0)for(let l=0;l<s;++l){let h=st(Xt(st(e[l],u)),e[l]);u=Mt(u,h)}return Ht(u,Od(u,"euclidean"))}));return t?mr(e,0):e}let Pz=X({gramSchmidt_:Rz});function Oz(n,t=!1){if(k(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return OC(n,t);{let e=n.shape.slice(0,n.shape.length-2).reduce((p,m)=>p*m),r=bs(rt(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],u=[];r.forEach(p=>{let[m,y]=OC(p,t);s.push(m),u.push(y)});let l=rt(mr(s,0),n.shape),h=rt(mr(u,0),n.shape);return[l,h]}}function OC(n,t=!1){return J.tidy(()=>{k(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);let e=n.shape[0],r=n.shape[1],s=yd(e),u=oa(n),l=pa([[1]],[1,1]),h=oa(l),p=e>=r?r:e;for(let m=0;m<p;++m){let y=u,b=h,x=s;[h,u,s]=J.tidy(()=>{let S=ge(u,[m,m],[e-m,1]),C=Od(S),I=ge(u,[m,m],[1,1]),D=er(zr(I,0),pa([[-1]]),pa([[1]])),R=Mt(I,st(D,C)),A=Ht(S,R);A.shape[0]===1?h=oa(l):h=sn([l,ge(A,[1,0],[A.shape[0]-1,A.shape[1]])],0);let L=on(Ht(xe(D,R),C)),_=ge(u,[m,0],[e-m,r]),B=st(L,h),V=re(h);if(m===0)u=Mt(_,xe(B,xe(V,_)));else{let et=Mt(_,xe(B,xe(V,_)));u=sn([ge(u,[0,0],[m,r]),et],0)}let q=re(B),j=ge(s,[0,m],[e,s.shape[1]-m]);if(m===0)s=Mt(j,xe(xe(j,h),q));else{let et=Mt(j,xe(xe(j,h),q));s=sn([ge(s,[0,0],[e,m]),et],1)}return[h,u,s]}),oe([y,b,x])}return!t&&e>r&&(s=ge(s,[0,0],[e,r]),u=ge(u,[0,0],[r,r])),[s,u]})}let Mz=X({qr_:Oz});(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(o.Reduction||(o.Reduction={}));function Lz(n,t,e=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let r=z(n,"losses","computeWeightedLoss"),s=null;t!=null&&(s=z(t,"weights","computeWeightedLoss"));let u=s==null?r:st(r,s);if(e===o.Reduction.NONE)return u;if(e===o.Reduction.SUM)return Xt(u);if(e===o.Reduction.MEAN){if(s==null)return an(u);{let l=r.size/s.size,h=Ht(Xt(u),Xt(s));return l>1?Ht(h,Ot(l)):h}}if(e===o.Reduction.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Ht(Xt(u),Ot(r.size));{let l=st(s,vs(r.shape)),h=Rt(Xt(ha(l,Ot(0))),"float32");return Ht(Xt(u),h)}}throw Error(`Unknown reduction: ${e}`)}let To=X({computeWeightedLoss_:Lz});function Bz(n,t,e,r=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let s=z(n,"labels","absoluteDifference"),u=z(t,"predictions","absoluteDifference"),l=null;e!=null&&(l=z(e,"weights","absoluteDifference")),$(s.shape,u.shape,"Error in absoluteDifference: ");let h=kn(Mt(s,u));return To(h,l,r)}let zz=X({absoluteDifference_:Bz});function Wz(n,t,e,r,s=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=z(n,"labels","cosineDistance"),l=z(t,"predictions","cosineDistance"),h=null;r!=null&&(h=z(r,"weights","cosineDistance")),$(u.shape,l.shape,"Error in cosineDistance: ");let p=Ot(1),m=Mt(p,Xt(st(u,l),e,!0));return To(m,h,s)}let Vz=X({cosineDistance_:Wz});function Uz(n,t,e,r=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let s=z(n,"labels","hingeLoss"),u=z(t,"predictions","hingeLoss"),l=null;e!=null&&(l=z(e,"weights","hingeLoss")),$(s.shape,u.shape,"Error in hingeLoss: ");let h=Ot(1);s=Mt(st(Ot(2),s),h);let p=Ys(Mt(h,st(s,u)));return To(p,l,r)}let Gz=X({hingeLoss_:Uz});function Hz(n,t,e,r=1,s=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=z(n,"labels","huberLoss"),l=z(t,"predictions","huberLoss"),h=null;e!=null&&(h=z(e,"weights","huberLoss")),$(u.shape,l.shape,"Error in huberLoss: ");let p=Ot(r),m=kn(Mt(l,u)),y=mi(m,p),b=Mt(m,y),x=Nt(st(Ot(.5),Oe(y)),st(p,b));return To(x,h,s)}let qz=X({huberLoss_:Hz});function jz(n,t,e,r=1e-7,s=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=z(n,"labels","logLoss"),l=z(t,"predictions","logLoss"),h=null;e!=null&&(h=z(e,"weights","logLoss")),$(u.shape,l.shape,"Error in logLoss: ");let p=Ot(1),m=Ot(r),y=on(st(u,Nr(Nt(l,m)))),b=st(Mt(p,u),Nr(Nt(Mt(p,l),m))),x=Mt(y,b);return To(x,h,s)}let Kz=X({logLoss_:jz});function Xz(n,t,e,r=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let s=z(n,"labels","meanSquaredError"),u=z(t,"predictions","meanSquaredError"),l=null;e!=null&&(l=z(e,"weights","meanSquaredError")),$(s.shape,u.shape,"Error in meanSquaredError: ");let h=Dh(s,u);return To(h,l,r)}let Yz=X({meanSquaredError_:Xz});function Jz(n,t){let e=z(n,"labels","sigmoidCrossEntropyWithLogits"),r=z(t,"logits","sigmoidCrossEntropyWithLogits");$(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=Ys(r),u=st(r,e),l=wd(Br(on(kn(r))));return Nt(Mt(s,u),l)}function Zz(n,t,e,r=0,s=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=z(n,"multiClassLabels","sigmoidCrossEntropy"),l=z(t,"logits","sigmoidCrossEntropy"),h=null;if(e!=null&&(h=z(e,"weights","sigmoidCrossEntropy")),$(u.shape,l.shape,"Error in sigmoidCrossEntropy: "),r>0){let m=Ot(r),y=Ot(1),b=Ot(.5);u=Nt(st(u,Mt(y,m)),st(b,m))}let p=Jz(u,l);return To(p,h,s)}let Qz=X({sigmoidCrossEntropy_:Zz});function t4(n,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);let r=Ks((s,u,l)=>{let h=!0,p=mb(u,[e],h),m=Mt(Rt(u,"float32"),p);l([s,m]);let y=on(st(m,s)),b=Xt(y,[e]),x=(S,C)=>{let[I,D]=C,R=zn(S.shape,[e]);return[st(rt(S,R),Mt(Rt(I,"float32"),Br(D))),st(rt(S,R),Mt(Br(D),Rt(I,"float32")))]};return{value:b,gradFunc:x}});return r(n,t)}function e4(n,t,e,r=0,s=o.Reduction.SUM_BY_NONZERO_WEIGHTS){let u=z(n,"onehotLabels","softmaxCrossEntropy"),l=z(t,"logits","softmaxCrossEntropy"),h=null;if(e!=null&&(h=z(e,"weights","softmaxCrossEntropy")),$(u.shape,l.shape,"Error in softmaxCrossEntropy: "),r>0){let m=Ot(r),y=Ot(1),b=Ot(u.shape[1]);u=Nt(st(u,Mt(y,m)),Ht(m,b))}let p=t4(u,l);return To(p,h,s)}let n4=X({softmaxCrossEntropy_:e4});let r4={fft:Ih,ifft:Bu,rfft:Eh,irfft:Fd},s4={hammingWindow:ez,hannWindow:AC,frame:_C,stft:oz},da={flipLeftRight:cz,resizeNearestNeighbor:PC,resizeBilinear:RC,rotateWithOffset:hz,cropAndResize:iz,nonMaxSuppression:pz,nonMaxSuppressionAsync:xz,nonMaxSuppressionWithScore:kz,nonMaxSuppressionWithScoreAsync:Cz,nonMaxSuppressionPadded:Iz,nonMaxSuppressionPaddedAsync:Dz},MC={bandPart:Fz,gramSchmidt:Pz,qr:Mz},o4={absoluteDifference:zz,computeWeightedLoss:To,cosineDistance:Vz,hingeLoss:Gz,huberLoss:qz,logLoss:Kz,meanSquaredError:Yz,sigmoidCrossEntropy:Qz,softmaxCrossEntropy:n4};class ko extends li{minimize(t,e=!1,r){let{value:s,grads:u}=this.computeGradients(t,r);if(r!=null){let l=r.map(h=>({name:h.name,tensor:u[h.name]}));this.applyGradients(l)}else this.applyGradients(u);return oe(u),e?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return db(t,e)}dispose(){this.iterations_!=null&&oe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ot(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ko,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class Ah extends ko{constructor(t,e,r=null){super();this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);e.forEach((r,s)=>{let u=J.registeredVariables[r],l=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:ot(()=>fe(u).variable(l))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:ot(()=>fe(u).variable(l))});let h=Array.isArray(t)?t[s].tensor:t[r];if(h==null)return;let p=this.accumulatedGrads[s].variable,m=this.accumulatedUpdates[s].variable;ot(()=>{let y=Nt(st(p,this.rho),st(Oe(h),1-this.rho)),b=st(Ht(Wn(Nt(m,this.epsilon)),Wn(Nt(p,this.epsilon))),h),x=Nt(st(m,this.rho),st(Oe(b),1-this.rho));p.assign(y),m.assign(x);let S=Nt(st(b,-this.learningRate),u);u.assign(S)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(oe(this.accumulatedGrads.map(t=>t.variable)),oe(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,e).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=t.slice(e,e*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}Ah.className="Adadelta",kt(Ah);class _h extends ko{constructor(t,e=.1){super();this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);e.forEach((r,s)=>{let u=J.registeredVariables[r];if(this.accumulatedGrads[s]==null){let p=!1;this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:ot(()=>Au(u.shape,this.initialAccumulatorValue).variable(p))}}let l=Array.isArray(t)?t[s].tensor:t[r];if(l==null)return;let h=this.accumulatedGrads[s].variable;ot(()=>{let p=Nt(h,Oe(l));h.assign(p);let m=Nt(st(Ht(l,Wn(Nt(p,J.backend.epsilon()))),-this.learningRate),u);u.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&oe(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}_h.className="Adagrad",kt(_h);class Fh extends ko{constructor(t,e,r,s=null){super();this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ot(()=>{this.accBeta1=Ot(e).variable(),this.accBeta2=Ot(r).variable()}),s==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);ot(()=>{let r=Mt(1,this.accBeta1),s=Mt(1,this.accBeta2);e.forEach((u,l)=>{let h=J.registeredVariables[u],p=!1;this.accumulatedFirstMoment[l]==null&&(this.accumulatedFirstMoment[l]={originalName:`${u}/m`,variable:ot(()=>fe(h).variable(p))}),this.accumulatedSecondMoment[l]==null&&(this.accumulatedSecondMoment[l]={originalName:`${u}/v`,variable:ot(()=>fe(h).variable(p))});let m=Array.isArray(t)?t[l].tensor:t[u];if(m==null)return;let y=this.accumulatedFirstMoment[l].variable,b=this.accumulatedSecondMoment[l].variable,x=Nt(st(y,this.beta1),st(m,1-this.beta1)),S=Nt(st(b,this.beta2),st(Oe(m),1-this.beta2)),C=Ht(x,r),I=Ht(S,s);y.assign(x),b.assign(S);let D=Nt(st(Ht(C,Nt(Wn(I),this.epsilon)),-this.learningRate),h);h.assign(D)}),this.accBeta1.assign(st(this.accBeta1,this.beta1)),this.accBeta2.assign(st(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&oe(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&oe(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),ot(()=>{this.accBeta1.assign(ys(this.beta1,this.iterations_+1)),this.accBeta2.assign(ys(this.beta2,this.iterations_+1))});let e=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,e).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}Fh.className="Adam",kt(Fh);class Rh extends ko{constructor(t,e,r,s=null,u=0){super();this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=s,this.decay=u,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ot(()=>{this.iteration=Ot(0).variable(),this.accBeta1=Ot(e).variable()}),s==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);ot(()=>{let r=Mt(1,this.accBeta1),s=Ht(-this.learningRate,Nt(st(this.iteration,this.decay),1));e.forEach((u,l)=>{let h=J.registeredVariables[u],p=!1;this.accumulatedFirstMoment[l]==null&&(this.accumulatedFirstMoment[l]={originalName:`${u}/m`,variable:fe(h).variable(p)}),this.accumulatedWeightedInfNorm[l]==null&&(this.accumulatedWeightedInfNorm[l]={originalName:`${u}/v`,variable:fe(h).variable(p)});let m=Array.isArray(t)?t[l].tensor:t[u];if(m==null)return;let y=this.accumulatedFirstMoment[l].variable,b=this.accumulatedWeightedInfNorm[l].variable,x=Nt(st(y,this.beta1),st(m,1-this.beta1)),S=st(b,this.beta2),C=kn(m),I=ts(S,C);y.assign(x),b.assign(I);let D=Nt(st(Ht(s,r),Ht(x,Nt(I,this.epsilon))),h);h.assign(D)}),this.iteration.assign(Nt(this.iteration,1)),this.accBeta1.assign(st(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&oe(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&oe(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}Rh.className="Adamax",kt(Rh);class Uu extends ko{constructor(t){super();this.learningRate=t,this.setLearningRate(t)}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);e.forEach((r,s)=>{let u=Array.isArray(t)?t[s].tensor:t[r];if(u==null)return;let l=J.registeredVariables[r];ot(()=>{let h=Nt(st(this.c,u),l);l.assign(h)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=An(Ot(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Uu.className="SGD",kt(Uu);class Ph extends Uu{constructor(t,e,r=!1){super(t);this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Ot(this.momentum)}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);e.forEach((r,s)=>{let u=J.registeredVariables[r];if(this.accumulations[s]==null){let p=!1;this.accumulations[s]={originalName:`${r}/momentum`,variable:ot(()=>fe(u).variable(p))}}let l=this.accumulations[s].variable,h=Array.isArray(t)?t[s].tensor:t[r];if(h==null)return;ot(()=>{let p,m=Nt(st(this.m,l),h);this.useNesterov?p=Nt(st(this.c,Nt(h,st(m,this.m))),u):p=Nt(st(this.c,m),u),l.assign(m),u.assign(p)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&oe(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}Ph.className="Momentum",kt(Ph);class Oh extends ko{constructor(t,e=.9,r=0,s=null,u=!1){super();if(this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=u,s==null&&(this.epsilon=J.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){let e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);e.forEach((r,s)=>{let u=J.registeredVariables[r],l=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:ot(()=>fe(u).variable(l))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:ot(()=>fe(u).variable(l))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:ot(()=>fe(u).variable(l))});let h=Array.isArray(t)?t[s].tensor:t[r];if(h==null)return;let p=this.accumulatedMeanSquares[s].variable,m=this.accumulatedMoments[s].variable;ot(()=>{let y=Nt(st(p,this.decay),st(Oe(h),1-this.decay));if(this.centered){let b=this.accumulatedMeanGrads[s].variable,x=Nt(st(b,this.decay),st(h,1-this.decay)),S=Ht(st(h,this.learningRate),Wn(Mt(y,Nt(Oe(x),this.epsilon)))),C=Nt(st(m,this.momentum),S);p.assign(y),b.assign(x),m.assign(C);let I=Mt(u,C);u.assign(I)}else{let b=Nt(st(p,this.decay),st(Oe(h),1-this.decay)),x=Nt(st(m,this.momentum),Ht(st(h,this.learningRate),Wn(Nt(b,this.epsilon))));p.assign(b),m.assign(x);let S=Mt(u,x);u.assign(S)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&oe(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&oe(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&oe(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,e).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=t.slice(e,e*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}Oh.className="RMSProp",kt(Oh);class wi{static sgd(t){return new Uu(t)}static momentum(t,e,r=!1){return new Ph(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,u=!1){return new Oh(t,e,r,s,u)}static adam(t=.001,e=.9,r=.999,s=null){return new Fh(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new Ah(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,u=0){return new Rh(t,e,r,s,u)}static adagrad(t,e=.1){return new _h(t,e)}}let xi={sgd:wi.sgd,momentum:wi.momentum,adadelta:wi.adadelta,adagrad:wi.adagrad,rmsprop:wi.rmsprop,adamax:wi.adamax,adam:wi.adam};let a4=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:n=>n())();function Hd(){return new Promise(n=>a4(()=>n()))}function Mb(n,t,e){let r=e*(typeof n=="number"?n:n[0]),s=t*(typeof n=="number"?n:n[1]);return[r,s]}function Mh(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);let u=t.length;for(let l=0;l<u;++l)s=s.concat([n[l+1]/t[l],t[l]]);s=s.concat(n.slice(u+1))}return s}function Lh(n,t,e=!0){let r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],u=[];for(let l=1;l<n;++l)l>=t*2+1||l%2===1?u.push(l):s.push(l);r.push(...s),r.push(0),r.push(...u)}return r}function Bh(n,t,e,r=!0){let s=[];r?s.push(n[0]/e):s.push(n[0]*e);for(let u=1;u<n.length;++u)u<=t.length?r?s.push(t[u-1]*n[u]):s.push(n[u]/t[u-1]):s.push(n[u]);return s}function Lb(n,t){let e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function Bb(n,t,e){let r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}let qd=1.7580993408473768,jd=1.0507009873554805;let zb=.3275911,Wb=.254829592,Vb=-.284496736,Ub=1.421413741,Gb=-1.453152027,Hb=1.061405429;function Gu(...n){ft().getBool("IS_TEST")||console.warn(...n)}function i4(...n){ft().getBool("IS_TEST")||console.log(...n)}function So(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);let e=new Float32Array(n.length*2);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function LC(n){let t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function BC(n){let t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function zC(n){let t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function qb(n,t){let e=n[t*2],r=n[t*2+1];return{real:e,imag:r}}function WC(n,t,e,r){n[r*2]=t,n[r*2+1]=e}function VC(n,t){let e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){let u=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(u),r[s]=Math.sin(u)}return{real:e,imag:r}}function UC(n,t,e){let r=(e?2:-2)*Math.PI*(n/t),s=Math.cos(r),u=Math.sin(r);return{real:s,imag:u}}function u4(n,t,e){if(t==="complex64"){if(n.dtype==="complex64")return n.clone();let r=Se(n.shape),s=Rt(n,"float32"),u=e.complex(s,r);return r.dispose(),s.dispose(),u}if(!me(n.dtype,t))return J.makeTensorFromDataId(n.dataId,n.shape,t);if(n.dtype==="complex64"){let r=e.real(n),s=Rt(r,t);return r.dispose(),s}if(t==="int32")return e.int(n);if(t==="bool"){let r=Ot(0,n.dtype),s=e.notEqual(n,r);return r.dispose(),s}else throw new Error(`Error in Cast: failed to cast ${n.dtype} to ${t}`)}function GC(n,t){return J.makeTensorFromDataId(n.dataId,t,n.dtype)}function jb(n,t,e){let r=(t-n)/(e-1),s=fu(e,"float32");s[0]=n;for(let u=1;u<s.length;u++)s[u]=s[u-1]+r;return Ir(s,"float32")}var Kb=Object.freeze({__proto__:null,slice_util:FS,segment_util:QM,castTensor:u4,reshapeTensor:GC,linspaceImpl:jb,upcastType:Qn,axesAreInnerMostDims:Ky,combineLocations:BS,computeOutAndReduceShapes:Bn,expandShapeToKeepDim:zn,assertAxesAreInnerMostDims:lr,getAxesPermutation:hr,getUndoAxesPermutation:lh,getInnerMostAxes:Cr,getBroadcastDims:di,getReductionAxes:Sn,assertAndGetBroadcastShape:ve,assertParamsConsistent:fd,computeOutShape:bo,computeDilation2DInfo:ld,computePool2DInfo:tr,computePool3DInfo:ph,computeConv2DInfo:Kn,computeConv3DInfo:aa,computeDefaultPad:eb,tupleValuesAreOne:ia,eitherStridesOrDilationsAreOne:wn,convertConv2DDataFormat:ua,getFusedDyActivation:Md,getFusedBiasGradient:Ld,applyActivation:Bd,shouldFuse:zd,PARALLELIZE_THRESHOLD:fb,computeOptimalWindowSize:yh,getImageCenter:Mb,getReshaped:Mh,getPermuted:Lh,getReshapedPermuted:Bh,getSliceBeginCoords:Lb,getSliceSize:Bb,prepareAndValidate:nd,validateUpdateShape:My,validateInput:Ly,calculateShapes:Iu,SELU_SCALEALPHA:qd,SELU_SCALE:jd,ERF_P:zb,ERF_A1:Wb,ERF_A2:Vb,ERF_A3:Ub,ERF_A4:Gb,ERF_A5:Hb,warn:Gu,log:i4,mergeRealAndImagArrays:So,splitRealAndImagArrays:LC,complexWithEvenIndex:BC,complexWithOddIndex:zC,getComplexWithIndex:qb,assignToTypedArray:WC,exponents:VC,exponent:UC,prepareSplitSize:aC});function Xb(n,t,e){let r=new Array(n.rank).fill(0),s=n.shape.slice();return t.map(u=>{let l=[...s];l[e]=u;let h=ge(n,r,l);return r[e]+=u,h})}function Yb(n,t){let e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];let r=Ae(e,n.dtype);for(let s=0;s<r.values.length;++s){let u=r.indexToLoc(s),l=new Array(n.rank);for(let p=0;p<l.length;p++)l[p]=u[p]%n.shape[p];let h=n.locToIndex(l);r.values[s]=n.values[h]}return r.toTensor()}function Jb(n,t,e,r,s){let u=t[t.length-1],[l,h]=[n.length/u,u],p=_t(e,l*r),m=_t("int32",l*r);for(let b=0;b<l;b++){let x=b*h,S=n.subarray(x,x+h),C=[];for(let A=0;A<S.length;A++)C.push({value:S[A],index:A});C.sort((A,L)=>L.value-A.value);let I=b*r,D=p.subarray(I,I+r),R=m.subarray(I,I+r);for(let A=0;A<r;A++)D[A]=C[A].value,R[A]=C[A].index}let y=t.slice();return y[y.length-1]=r,[vn(p,y,e),vn(m,y,"int32")]}var c4=Object.freeze({__proto__:null,nonMaxSuppressionV3Impl:Vd,nonMaxSuppressionV4Impl:Ud,nonMaxSuppressionV5Impl:Gd,split:Xb,tile:Yb,topkImpl:Jb,whereImpl:Pd});let l4={kernelName:hp,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,zu(Rt(e,"float32"),-1))}}};let h4={kernelName:dl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=Oe(Rt(e,"float32")),s=Wn(Mt(Ot(1),r));return on(Ht(n,s))}}}};let f4={kernelName:ml,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=Wn(Mt(Oe(Rt(e,"float32")),1));return Ht(n,r)}}}};let p4={kernelName:ri,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=n,p=Sn(e.shape,s);return p.length>0&&(h=Xt(h,p)),rt(h,e.shape)},l=()=>{let h=n,p=Sn(r.shape,s);return p.length>0&&(h=Xt(h,p)),rt(h,r.shape)};return{a:u,b:l}}};let d4={kernelName:$v,saveAllInputs:!0,gradFunc:(n,t)=>{let e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}};let m4={kernelName:Av,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>fe(e)}}};let g4={kernelName:_v,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>fe(e)}}};let v4={kernelName:gl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,Wn(Mt(Ot(1),Oe(Rt(e,"float32")))))}}};let y4={kernelName:vl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=Wn(Nt(Ot(1),Oe(Rt(e,"float32"))));return Ht(n,r)}}}};let b4={kernelName:fp,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=Nt(Oe(e),Oe(r)),p=st(n,Ht(r,h)),m=Sn(e.shape,s);return m.length>0&&(p=Xt(p,m)),rt(p,e.shape)},l=()=>{let h=Nt(Oe(e),Oe(r)),p=on(st(n,Ht(e,h))),m=Sn(r.shape,s);return m.length>0&&(p=Xt(p,m)),rt(p,r.shape)};return{a:u,b:l}}};let w4={kernelName:yl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,Nt(Oe(Rt(e,"float32")),1))}}};let x4={kernelName:bl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,Mt(Ot(1),Oe(Rt(e,"float32"))))}}};function T4(n,t,e,r,s=[1,1,1],u,l){let h=z(n,"dy","avgPool3dBackprop"),p=z(t,"input","avgPool3dBackprop"),m=h,y=p,b=!1;p.rank===4&&(b=!0,m=rt(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),y=rt(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),k(m.rank===5,()=>`Error in avgPool3dBackprop: dy must be rank 5 but got rank ${m.rank}.`),k(y.rank===5,()=>`Error in avgPool3dBackprop: input must be rank 5 but got rank ${y.rank}.`),k(wn(r,s),()=>`Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides ${r} and dilations '${s}'`),l!=null&&k(nt(u),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${l} but got pad ${u}.`);let x=D=>{let R=ph(y.shape,e,r,s,u,l);return D.avgPool3dBackprop(m,y,R)},S={dy:m,input:y},C={filterSize:e,strides:r,dilations:s,pad:u,dimRoundingMode:l},I=J.runKernelFunc(x,S,null,S2,C);return b?rt(I,[I.shape[1],I.shape[2],I.shape[3],I.shape[4]]):I}let k4=X({avgPool3dBackprop_:T4});let S4={kernelName:Fv,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{filterSize:s,strides:u,dilations:l,pad:h,dimRoundingMode:p}=e,m=l==null?[1,1,1]:l;return{x:()=>k4(n,r,s,u,m,h,p)}}};function C4(n,t,e,r,s){let u=z(n,"dy","avgPoolBackprop"),l=z(t,"input","avgPoolBackprop");k(l.rank===u.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${u.rank})`);let h=l,p=u,m=!1;l.rank===3&&(m=!0,h=rt(l,[1,l.shape[0],l.shape[1],l.shape[2]]),p=rt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),k(p.rank===4,()=>`Error in avgPoolBackprop: dy must be rank 4 but got rank ${p.rank}.`),k(h.rank===4,()=>`Error in avgPoolBackprop: input must be rank 4 but got rank ${h.rank}.`);let y=C=>{let I=tr(h.shape,e,r,1,s);return C.avgPoolBackprop(p,h,I)},b={dy:p,input:h},x={filterSize:e,strides:r,pad:s},S=J.runKernelFunc(y,b,null,pp,x);return m?rt(S,[S.shape[1],S.shape[2],S.shape[3]]):S}let N4=X({avgPoolBackprop_:C4});let I4={kernelName:wl,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{filterSize:s,strides:u,pad:l}=e;return{x:()=>N4(n,r,s,u,l)}}};let E4={kernelName:dp,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{let[r,s]=t,{transposeA:u,transposeB:l}=e;return!u&&!l?{a:()=>xe(n,s,!1,!0),b:()=>xe(r,n,!0,!1)}:!u&&l?{a:()=>xe(n,s,!1,!1),b:()=>xe(n,r,!0,!1)}:u&&!l?{a:()=>xe(s,n,!1,!0),b:()=>xe(r,n,!1,!1)}:{a:()=>xe(s,n,!0,!0),b:()=>xe(n,r,!0,!0)}}};let D4={kernelName:Rv,gradFunc:(n,t,e)=>{let{blockShape:r,crops:s}=e;return{x:()=>kh(n,r,s)}}};let $4={kernelName:Pv,gradFunc:(n,t,e)=>{let r=e,s=r.inputShape,u=r.shape,l=Array.from(u);for(let p=s.length-1;p>=0;p--)if(s[p]===u[p])l[p]=1;else if(s[p]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${u}].`);let h=[];for(let p=0;p<l.length;p++)l[p]>1&&h.push(p);return{x:()=>Xt(n,h,!0)}}};let A4={kernelName:pu,gradFunc:n=>({x:()=>n.clone()})};let _4={kernelName:xl,gradFunc:n=>({x:()=>fe(n)})};let F4={kernelName:Tl,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{clipValueMin:s,clipValueMax:u}=e;return{x:()=>er(es(xo(r,s),la(r,u)),n,fe(n))}}};let R4={kernelName:kl,saveAllInputs:!0,gradFunc:(n,t,e)=>{let r=t.map(p=>p.shape),{axis:s}=e,u=Et(s,t[0].shape)[0],l=r.map(p=>p[u]),h=Er(n,l,u);return h.map(p=>()=>p)}};let P4={kernelName:gp,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let[r,s]=t,{dilations:u,strides:l,pad:h,dataFormat:p}=e;return k(ia(u),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${u}'`),{x:()=>ob(r.shape,n,s,l,h,p),filter:()=>Rb(r,n,s.shape,l,h,p)}}};let O4={kernelName:vp,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{let[r,s]=t,{strides:u,pad:l,dataFormat:h,dimRoundingMode:p}=e;return{dy:()=>wo(n,s,u,l,h,1,p),filter:()=>Rb(n,r,s.shape,u,l,h,p)}}};function M4(n,t,e,r,s){let u=n;n.rank===4&&(u=rt(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let l=t;l.rank===4&&(l=rt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),k(u.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${u.shape}.`),k(l.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${l.shape}.`),k(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),k(u.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${u.shape[4]}) must match input depth in filter (${e[3]}.`),k(l.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${l.shape[4]}) must match output depth for filter (${e[4]}).`);let h=y=>{let b=1,x=aa(u.shape,e,r,b,s);return y.conv3dDerFilter(u,l,x)},p={x:u,dy:l},m={strides:r,pad:s,filterShape:e};return J.runKernelFunc(h,p,null,Mv,m)}let L4=X({conv3DBackpropFilter_:M4});let B4={kernelName:yp,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let{dilations:r,strides:s,pad:u}=e;k(ia(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[l,h]=t;return{x:()=>jS(l.shape,n,h,s,u),filter:()=>L4(l,n,h.shape,s,u)}}};let z4={kernelName:du,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(on(Dd(Rt(e,"float32"))),n)}}};let W4={kernelName:Sl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st($d(Rt(e,"float32")),n)}}};let V4={kernelName:Bv,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{axis:s,exclusive:u,reverse:l}=e;return{x:()=>{let h=hr([s],r.rank),p=vd(n,s,u,!l);return h!=null&&(p=re(p,h)),p}}}};let U4={kernelName:bp,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let{dilations:r,strides:s,pad:u,dimRoundingMode:l}=e,h=r==null?[1,1]:r;k(ia(h),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${h}'`);let[p,m]=t;return k(p.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${p.rank}.`),k(m.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${m.rank}.`),k(p.shape[3]===m.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),k(wn(s,h),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${h}'.`),l!=null&&k(nt(u),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${l} but got pad ${u}.`),{x:()=>DC(p.shape,n,m,s,u,r,l),filter:()=>EC(p,n,m.shape,s,u,r,l)}}};let G4={kernelName:wp,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{let[r,s]=t,u={x:r,filter:s,dy:n},l={x:r,filter:s,dy:n};return{x:()=>J.runKernel(xp,u,e),filter:()=>J.runKernel(Tp,l,e)}}};let H4={kernelName:mu,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=Ht(n,Rt(r,"float32")),p=Sn(e.shape,s);return p.length>0?rt(Xt(h,p),e.shape):h},l=()=>{let h=st(n,Rt(e,"float32")),p=Sn(r.shape,s);p.length>0&&(h=rt(Xt(h,p),r.shape));let m=Oe(r);return on(Ht(h,Rt(m,"float32")))};return{a:u,b:l}}};let q4={kernelName:Cl,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t,r=u=>u.eluDer(n,e),s={dy:n,y:e};return{x:()=>J.runKernelFunc(r,s,null,E2)}}};let j4={kernelName:Nl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t,r=st(Br(on(Oe(e))),2/Math.sqrt(Math.PI));return{x:()=>st(n,r)}}};let K4={kernelName:Il,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,e)}}};let X4={kernelName:El,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,Br(e))}}};let Y4={kernelName:Dl,gradFunc:n=>({x:()=>fe(n)})};let J4={kernelName:Uv,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=Ht(n,Rt(r,"float32")),p=Sn(e.shape,s);return p.length>0?rt(Xt(h,p),e.shape):h},l=()=>{let h=st(n,Rt(e,"float32")),p=Sn(r.shape,s);p.length>0&&(h=rt(Xt(h,p),r.shape));let m=Oe(r);return on(Ht(h,Rt(m,"float32")))};return{a:u,b:l}}};let Z4={kernelName:$l,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{let{varianceEpsilon:r}=e,[s,u,l,h]=t,p=h==null?Ot(1):h,m=Sn(u.shape,s.shape),y=[];if(u.rank===1){for(let _=0;_<s.shape.length-1;++_)y.push(s.shape[_]);y.push(1)}let b=Mt(s,u),x=st(n,p),S=Id(Nt(l,Ot(r))),C=st(st(st(S,S),S),Ot(-.5)),I=()=>u.rank===1?rt(st(st(n,ca(rt(S,[1,1,1,u.shape[0]]),y)),p),s.shape):rt(st(st(n,S),p),s.shape),D=()=>{let _=st(st(S,Ot(-1)),x);return u.rank===1&&(_=Xt(_,m)),rt(_,u.shape)},R=()=>{let _=st(st(C,b),x);return u.rank===1&&(_=Xt(_,m)),rt(_,u.shape)},A=()=>{let _=st(b,S),B=st(n,_);return u.rank===1&&(B=Xt(B,m)),rt(B,u.shape)},L=()=>{let _=n;return u.rank===1&&(_=Xt(_,m)),rt(_,u.shape)};return{x:I,mean:D,variance:R,scale:A,offset:L}}};let Q4={kernelName:Gv,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{let[r,s]=t,{axis:u}=e,l=Et(u,r.shape)[0],h=()=>{let p=r.shape,m=s.size,y=p.slice(0,l),b=y.length,x=p.slice(u,p.length).slice(1),S=x.length,C=HC(0,b),I=HC(b+1,b+1+S),D=qC([y,[m],x]),R=rt(n,D),A=rt(s,[m]),L=qC([[b],C,I]),_=re(R,L),B=$b(_,A,r.shape[l]),V=lh(L);return B=re(B,V),B};return{x:h,indices:()=>s}}};function HC(n,t){let e=[];for(let r=n;r<t;++r)e.push(r);return e}function qC(n){let t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}let tW={kernelName:Hv,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t;return{a:()=>fe(e),b:()=>fe(r)}}};let eW={kernelName:Al,gradFunc:n=>({x:()=>Rt(n,"float32")})};let nW={kernelName:_l,gradFunc:n=>({x:()=>fe(n)})};let rW={kernelName:Fl,gradFunc:n=>({x:()=>fe(n)})};let sW={kernelName:Rl,gradFunc:n=>({x:()=>fe(n)})};let oW={kernelName:Ol,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,Nt(e,1))}}};let aW={kernelName:Pl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,Rt(e,"float32"))}}};let iW={kernelName:qv,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r]=t,{axis:s}=e;return{logits:()=>{let u=!0,l=Br(r);return Mt(n,st(Xt(n,s,u),l))}}}};function uW(n,t,e,r=5,s=1,u=1,l=.5){let h=y=>y.LRNGrad(e,n,t,r,s,u,l),p={x:n,y:t,dy:e},m={depthRadius:r,bias:s,alpha:u,beta:l};return J.runKernelFunc(h,p,null,M2,m)}let cW=X({localResponseNormalizationBackprop_:uW});let lW={kernelName:jv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r,s]=t,{depthRadius:u,bias:l,alpha:h,beta:p}=e;return{x:()=>cW(r,s,n,u,l,h,p)}}};function jC(n,t,e,r){return t.rank<e.rank&&(t=rt(t,zn(t.shape,r))),n.rank<e.rank&&(n=rt(n,zn(n.shape,r))),{x:()=>{let s=st(n,Rt(gs(e,t),n.dtype));return s}}}let KC={kernelName:Ml,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let r=e,{reductionIndices:s}=r,u=t[0],l=t[1],h=Et(s,u.shape),p=jC(n,l,u,h);return{x:()=>p.x()}}};let hW={kernelName:Kv,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=()=>st(n,Rt(xo(e,r),"float32")),u=()=>st(n,Rt(wh(e,r),"float32"));return{a:s,b:u}}};function fW(n,t,e,r,s,u=[1,1,1],l,h){let p=z(n,"dy","maxPool3dBackprop"),m=z(t,"input","maxPool3dBackprop"),y=z(e,"output","maxPool3dBackprop"),b=p,x=m,S=y,C=!1;m.rank===4&&(C=!0,b=rt(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]]),x=rt(m,[1,m.shape[0],m.shape[1],m.shape[2],m.shape[3]]),S=rt(y,[1,y.shape[0],y.shape[1],y.shape[2],y.shape[3]])),k(b.rank===5,()=>`Error in maxPool3dBackprop: dy must be rank 5 but got rank ${b.rank}.`),k(x.rank===5,()=>`Error in maxPool3dBackprop: input must be rank 5 but got rank ${x.rank}.`),k(S.rank===5,()=>`Error in maxPool3dBackprop: output must be rank 5 but got rank ${S.rank}.`),k(wn(s,u),()=>`Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`),h!=null&&k(nt(l),()=>`Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode ${h} but got pad ${l}.`);let I=L=>{let _=ph(x.shape,r,s,u,l,h);return L.maxPool3dBackprop(b,x,S,_)},D={dy:b,input:x,output:S},R={filterSize:r,strides:s,dilations:u,pad:l,dimRoundingMode:h},A=J.runKernelFunc(I,D,null,L2,R);return C?rt(A,[A.shape[1],A.shape[2],A.shape[3],A.shape[4]]):A}let pW=X({maxPool3dBackprop_:fW});let dW={kernelName:Xv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r,s]=t,{filterSize:u,strides:l,dilations:h,pad:p,dimRoundingMode:m}=e,y=h==null?[1,1,1]:h;return{x:()=>pW(n,r,s,u,l,y,p,m)}}};function mW(n,t,e,r,s,u,l){let h=z(n,"dy","maxPoolBackprop"),p=z(t,"input","maxPoolBackprop"),m=z(e,"output","maxPoolBackprop");k(p.rank===h.rank,()=>`Rank of input (${p.rank}) does not match rank of dy (${h.rank})`),k(h.rank===4,()=>`Error in maxPoolBackprop: dy must be rank 4 but got rank ${h.rank}.`),k(p.rank===4,()=>`Error in maxPoolBackprop: input must be rank 4 but got rank ${p.rank}.`),l!=null&&k(nt(u),()=>`Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode ${l} but got pad ${u}.`);let y=S=>{let C=tr(p.shape,r,s,1,u,l);return S.maxPoolBackprop(h,p,m,C)},b={dy:h,input:p,output:m},x={filterSize:r,strides:s,pad:u,dimRoundingMode:l};return J.runKernelFunc(y,b,null,Ep,x)}let gW=X({maxPoolBackprop_:mW});let vW={kernelName:Ll,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r,s]=t,{filterSize:u,strides:l,pad:h}=e;return{x:()=>gW(n,r,s,u,l,h)}}};let yW={kernelName:Jv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{let r=e,{axis:s}=r,[u,l]=t,h=Et(s,u.shape),p=jC(n,l,u,h);return{x:()=>p.x()}}};let bW={kernelName:Zv,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=()=>st(n,Rt(la(e,r),"float32")),u=()=>st(n,Rt(zr(e,r),"float32"));return{a:s,b:u}}};let wW={kernelName:Bl,inputsToSave:["x"],gradFunc:(n,t,e)=>{let r=t[0],{paddings:s}=e,u=s.map(l=>l[0]);return{x:()=>ge(n,u,r.shape)}}};let xW={kernelName:Qv,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=Sn(e.shape,s);return h.length>0?rt(Xt(n,h),e.shape):n},l=()=>{let h=st(n,on(_u(Ht(e,r)))),p=Sn(r.shape,s);return p.length>0?rt(Xt(h,p),r.shape):h};return{a:u,b:l}}};let TW={kernelName:gu,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=st(n,Rt(r,"float32")),p=Sn(e.shape,s);return p.length>0?rt(Xt(h,p),e.shape):h},l=()=>{let h=st(n,Rt(e,"float32")),p=Sn(r.shape,s);return p.length>0?rt(Xt(h,p),r.shape):h};return{a:u,b:l}}};let kW={kernelName:ty,gradFunc:n=>({x:()=>on(n)})};let SW={kernelName:ry,inputsToSave:["indices"],gradFunc:(n,t)=>{let e=t[0];return{indices:()=>Se(e.shape,"float32")}}};let CW={kernelName:ny,gradFunc:n=>({x:()=>fe(n)})};let XC={kernelName:_p,inputsToSave:["x"],gradFunc:(n,t,e)=>{let r=t[0],{paddings:s}=e,u=s.map(l=>l[0]);return{x:()=>ge(n,u,r.shape)}}};let NW={kernelName:sy,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{let[e,r,s]=t,u=e,l=r,h=ve(u.shape,l.shape),p=()=>{let y=Rt(l,"float32"),b=st(n,st(y,ys(u,Mt(y,Ot(1))))),x=Sn(u.shape,h);return x.length>0&&(b=Xt(b,x)),rt(b,u.shape)},m=()=>{let y=zr(u,0),b=er(y,Nr(u),fe(u)),x=st(n,st(s,b)),S=Sn(l.shape,h);return S.length>0&&(x=Xt(x,S)),rt(x,l.shape)};return{a:p,b:m}}};let IW={kernelName:Fp,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{let[e,r]=t,s=zr(e,0);return{x:()=>er(s,n,st(n,r)),alpha:()=>{let u=er(s,fe(n),st(n,e)),l=Sn(r.shape,n.shape);return l.length>0&&(u=Xt(u,l)),rt(u,r.shape)}}}};let EW={kernelName:Wl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,on(Oe(e)))}}};let DW={kernelName:Gl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t,r=st(la(e,6),zu(e));return{x:()=>st(n,Rt(r,"float32"))}}};let $W={kernelName:Vl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,Rt(zu(e),"float32"))}}};let AW={kernelName:Ul,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>rt(n,e.shape)}}};let _W={kernelName:ay,inputsToSave:["images"],gradFunc:(n,t,e)=>{let[r]=t,s=h=>{let{alignCorners:p}=e;return h.resizeBilinearBackprop(n,r,p)},u={images:r},l=()=>J.runKernelFunc(s,u,null,V2,e);return{images:l}}};let FW={kernelName:oy,inputsToSave:["images"],gradFunc:(n,t,e)=>{let[r]=t,s=h=>{let{alignCorners:p}=e;return h.resizeNearestNeighborBackprop(n,r,p)},u={images:r},l=()=>J.runKernelFunc(s,u,null,W2,e);return{images:l}}};let RW={kernelName:iy,gradFunc:(n,t,e)=>{let{dims:r}=e,s=Et(r,n.shape);return{x:()=>Wr(n,s)}}};let PW={kernelName:Hl,gradFunc:n=>({x:()=>fe(n)})};let OW={kernelName:ql,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>on(Ht(n,st(ys(e,1.5),2)))}}};let MW={kernelName:uy,inputsToSave:["condition"],gradFunc:(n,t)=>{let[e]=t;return{condition:()=>Rt(fe(e),"float32"),t:()=>st(n,Rt(e,n.dtype)),e:()=>st(n,Rt(xh(e),n.dtype))}}};let LW={kernelName:jl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>{let r=zr(e,Ot(0)),s=Ot(qd),u=Ot(jd),l=st(n,u),h=st(st(n,s),Br(Rt(e,"float32")));return er(r,l,h)}}}};let BW={kernelName:Yl,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,st(e,Mt(Ot(1),e)))}}};let zW={kernelName:Xl,gradFunc:n=>({x:()=>fe(n)})};let WW={kernelName:vu,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(vh(Rt(e,"float32")),n)}}};let VW={kernelName:Kl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(gd(Rt(e,"float32")),n)}}};let UW={kernelName:Pp,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{begin:s,size:u}=e,l=r.shape,[h,p]=od(r,s,u),m=[];for(let y=0;y<n.rank;y++)m.push([h[y],l[y]-h[y]-p[y]]);return{x:()=>Xs(n,m)}}};let GW={kernelName:hy,outputsToSave:[!0],gradFunc:(n,t,e)=>{let[r]=t,{dim:s}=e,u=!0,l=st(n,r);return{logits:()=>Mt(l,st(Xt(l,[s],u),r))}}};let HW={kernelName:Jl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,js(e))}}};let YC={kernelName:Op,gradFunc:(n,t,e)=>{let{blockShape:r,paddings:s}=e;return{x:()=>mh(n,r,s)}}};let JC={kernelName:ly,gradFunc:(n,t,e)=>{let{axis:r}=e;return{x:()=>sn(n,r)}}};let qW={kernelName:Zl,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,st(Wn(Rt(e,"float32")),2))}}};let jW={kernelName:Mp,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(n,st(Rt(e,"float32"),2))}}};let KW={kernelName:yu,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=Ot(2),u=()=>st(n,st(s,Mt(e,r))),l=()=>st(n,st(s,Mt(r,e)));return{a:u,b:l}}};let XW={kernelName:eh,gradFunc:n=>({x:()=>fe(n)})};let YW={kernelName:bu,inputsToSave:["a","b"],gradFunc:(n,t)=>{let[e,r]=t,s=ve(e.shape,r.shape),u=()=>{let h=n,p=Sn(e.shape,s);return p.length>0&&(h=Xt(h,p)),rt(h,e.shape)},l=()=>{let h=n,p=Sn(r.shape,s);return p.length>0&&(h=Xt(h,p)),rt(on(h),r.shape)};return{a:u,b:l}}};let JW={kernelName:cy,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,s=r.shape.slice(),{axis:u}=e,l=Et(u,r.shape);l.forEach(m=>{s[m]=1});let h=rt(n,s),p=st(h,vs(r.shape,"float32"));return{x:()=>p}}};let ZW={kernelName:wu,inputsToSave:["x"],gradFunc:(n,t)=>{let[e]=t;return{x:()=>Ht(n,Oe(vh(e)))}}};let QW={kernelName:Ql,outputsToSave:[!0],gradFunc:(n,t)=>{let[e]=t;return{x:()=>st(Mt(Ot(1),Oe(e)),n)}}};let tV={kernelName:fy,inputsToSave:["x"],gradFunc:(n,t,e)=>{let[r]=t,{reps:s}=e,u=()=>{let l=fe(r);if(r.rank===1)for(let h=0;h<s[0];++h)l=Nt(l,ge(n,[h*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let h=0;h<s[0];++h)for(let p=0;p<s[1];++p)l=Nt(l,ge(n,[h*r.shape[0],p*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let h=0;h<s[0];++h)for(let p=0;p<s[1];++p)for(let m=0;m<s[2];++m)l=Nt(l,ge(n,[h*r.shape[0],p*r.shape[1],m*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let h=0;h<s[0];++h)for(let p=0;p<s[1];++p)for(let m=0;m<s[2];++m)for(let y=0;y<s[3];++y)l=Nt(l,ge(n,[h*r.shape[0],p*r.shape[1],m*r.shape[2],y*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return l};return{x:u}}};let eV={kernelName:th,gradFunc:(n,t,e)=>{let r=e,{perm:s}=r,u=lh(s);return{x:()=>re(n,u)}}};let nV={kernelName:py,gradFunc:(n,t,e)=>{let r=e,{axis:s}=r;return{value:()=>mr(n,s)}}};let rV={kernelName:dy,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{let[e]=t,r=()=>sV(n,e);return{x:r}}};function sV(n,t){let e=ts(t,fe(t)),r=Fu(n,e),s=xo(t,Ot(0,"int32")),u=r.rank-s.rank;for(let h=0;h<u;++h)s=pr(s,h+1);s=es(s,vs(r.shape,"bool"));let l=fe(r);return er(s,r,l)}let oV={kernelName:my,gradFunc:n=>({x:()=>fe(n)})};let aV=[l4,h4,f4,p4,d4,m4,g4,v4,y4,b4,w4,x4,S4,I4,E4,D4,$4,A4,_4,F4,R4,O4,P4,B4,z4,W4,V4,U4,G4,H4,q4,j4,K4,X4,J4,Y4,Z4,Q4,tW,eW,nW,rW,sW,oW,aW,iW,lW,KC,KC,hW,dW,vW,yW,bW,wW,xW,TW,kW,SW,CW,XC,XC,NW,IW,EW,DW,$W,AW,_W,FW,RW,PW,OW,MW,LW,BW,zW,WW,VW,UW,GW,HW,YC,YC,JC,JC,qW,KW,jW,XW,YW,JW,ZW,QW,tV,eV,nV,rV,oV];for(let n of aV)j2(n);at.prototype.abs=function(){return this.throwIfDisposed(),kn(this)};at.prototype.acos=function(){return this.throwIfDisposed(),qy(this)};at.prototype.acosh=function(){return this.throwIfDisposed(),jy(this)};at.prototype.addStrict=function(n){return this.throwIfDisposed(),dC(this,n)};at.prototype.add=function(n){return this.throwIfDisposed(),Nt(this,n)};at.prototype.all=function(n,t){return this.throwIfDisposed(),cd(this,n,t)};at.prototype.any=function(n,t){return this.throwIfDisposed(),hh(this,n,t)};at.prototype.argMax=function(n){return this.throwIfDisposed(),fh(this,n)};at.prototype.argMin=function(n){return this.throwIfDisposed(),Xy(this,n)};at.prototype.asScalar=function(){return this.throwIfDisposed(),k(this.size===1,()=>"The array must have only 1 element."),rt(this,[])};at.prototype.asType=function(n){return this.throwIfDisposed(),Rt(this,n)};at.prototype.as1D=function(){return this.throwIfDisposed(),rt(this,[this.size])};at.prototype.as2D=function(n,t){return this.throwIfDisposed(),rt(this,[n,t])};at.prototype.as3D=function(n,t,e){return this.throwIfDisposed(),rt(this,[n,t,e])};at.prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),rt(this,[n,t,e,r])};at.prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),rt(this,[n,t,e,r,s])};at.prototype.asin=function(){return this.throwIfDisposed(),Yy(this)};at.prototype.asinh=function(){return this.throwIfDisposed(),Jy(this)};at.prototype.atan=function(){return this.throwIfDisposed(),Zy(this)};at.prototype.atan2=function(n){return this.throwIfDisposed(),Qy(this,n)};at.prototype.atanh=function(){return this.throwIfDisposed(),tb(this)};at.prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),dh(this,n,t,e,r)};at.prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),mh(this,n,t)};at.prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),fi(this,n,t,e,r,s)};at.prototype.broadcastTo=function(n){return this.throwIfDisposed(),gh(this,n)};at.prototype.cast=function(n){return this.throwIfDisposed(),Rt(this,n)};at.prototype.ceil=function(){return this.throwIfDisposed(),sb(this)};at.prototype.clipByValue=function(n,t){return this.throwIfDisposed(),fr(this,n,t)};at.prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof at&&(n=[n]),sn([this,...n],t)};at.prototype.conv1d=function(n,t,e,r,s,u){return this.throwIfDisposed(),dd(this,n,t,e,r,s,u)};at.prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),md(this,n,t,e,r,s)};at.prototype.conv2d=function(n,t,e,r,s,u){return this.throwIfDisposed(),wo(this,n,t,e,r,s,u)};at.prototype.cos=function(){return this.throwIfDisposed(),vh(this)};at.prototype.cosh=function(){return this.throwIfDisposed(),gd(this)};at.prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),vd(this,n,t,e)};at.prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),ib(this,n,t)};at.prototype.depthwiseConv2D=function(n,t,e,r,s,u){return Tn("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),pi(this,n,t,e,r,s,u)};at.prototype.depthwiseConv2d=function(n,t,e,r,s,u){return this.throwIfDisposed(),pi(this,n,t,e,r,s,u)};at.prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),ub(this,n,t,e,r,s)};at.prototype.divNoNan=function(n){return this.throwIfDisposed(),cb(this,n)};at.prototype.divStrict=function(n){return this.throwIfDisposed(),mC(this,n)};at.prototype.div=function(n){return this.throwIfDisposed(),Ht(this,n)};at.prototype.dot=function(n){return this.throwIfDisposed(),KS(this,n)};at.prototype.elu=function(){return this.throwIfDisposed(),$u(this)};at.prototype.equalStrict=function(n){return this.throwIfDisposed(),uC(this,n)};at.prototype.equal=function(n){return this.throwIfDisposed(),gs(this,n)};at.prototype.erf=function(){return this.throwIfDisposed(),lb(this)};at.prototype.exp=function(){return this.throwIfDisposed(),Br(this)};at.prototype.expandDims=function(n){return this.throwIfDisposed(),pr(this,n)};at.prototype.expm1=function(){return this.throwIfDisposed(),hb(this)};at.prototype.fft=function(){return this.throwIfDisposed(),Ih(this)};at.prototype.flatten=function(){return this.throwIfDisposed(),rt(this,[this.size])};at.prototype.floor=function(){return this.throwIfDisposed(),_u(this)};at.prototype.floorDiv=function(n){return this.throwIfDisposed(),ud(this,n)};at.prototype.gather=function(n,t){return this.throwIfDisposed(),Fu(this,n,t)};at.prototype.greaterEqualStrict=function(n){return this.throwIfDisposed(),cC(this,n)};at.prototype.greaterEqual=function(n){return this.throwIfDisposed(),xo(this,n)};at.prototype.greaterStrict=function(n){return this.throwIfDisposed(),lC(this,n)};at.prototype.greater=function(n){return this.throwIfDisposed(),zr(this,n)};at.prototype.ifft=function(){return this.throwIfDisposed(),Bu(this)};at.prototype.irfft=function(){return this.throwIfDisposed(),Fd(this)};at.prototype.isFinite=function(){return this.throwIfDisposed(),YS(this)};at.prototype.isInf=function(){return this.throwIfDisposed(),JS(this)};at.prototype.isNaN=function(){return this.throwIfDisposed(),ZS(this)};at.prototype.leakyRelu=function(n){return this.throwIfDisposed(),bd(this,n)};at.prototype.lessEqualStrict=function(n){return this.throwIfDisposed(),hC(this,n)};at.prototype.lessEqual=function(n){return this.throwIfDisposed(),la(this,n)};at.prototype.lessStrict=function(n){return this.throwIfDisposed(),fC(this,n)};at.prototype.less=function(n){return this.throwIfDisposed(),wh(this,n)};at.prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),pb(this,n,t,e,r)};at.prototype.logSigmoid=function(){return this.throwIfDisposed(),tC(this)};at.prototype.logSoftmax=function(n){return this.throwIfDisposed(),Td(this,n)};at.prototype.logSumExp=function(n,t){return this.throwIfDisposed(),mb(this,n,t)};at.prototype.log=function(){return this.throwIfDisposed(),Nr(this)};at.prototype.log1p=function(){return this.throwIfDisposed(),wd(this)};at.prototype.logicalAnd=function(n){return this.throwIfDisposed(),es(this,n)};at.prototype.logicalNot=function(){return this.throwIfDisposed(),xh(this)};at.prototype.logicalOr=function(n){return this.throwIfDisposed(),kd(this,n)};at.prototype.logicalXor=function(n){return this.throwIfDisposed(),eC(this,n)};at.prototype.matMul=function(n,t,e){return this.throwIfDisposed(),xe(this,n,t,e)};at.prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),Th(this,n,t,e,r)};at.prototype.max=function(n,t){return this.throwIfDisposed(),dr(this,n,t)};at.prototype.maximumStrict=function(n){return this.throwIfDisposed(),gC(this,n)};at.prototype.maximum=function(n){return this.throwIfDisposed(),ts(this,n)};at.prototype.mean=function(n,t){return this.throwIfDisposed(),an(this,n,t)};at.prototype.min=function(n,t){return this.throwIfDisposed(),Pu(this,n,t)};at.prototype.minimumStrict=function(n){return this.throwIfDisposed(),vC(this,n)};at.prototype.minimum=function(n){return this.throwIfDisposed(),mi(this,n)};at.prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),vb(this,n,t)};at.prototype.modStrict=function(n){return this.throwIfDisposed(),yC(this,n)};at.prototype.mod=function(n){return this.throwIfDisposed(),Sd(this,n)};at.prototype.mulStrict=function(n){return this.throwIfDisposed(),bC(this,n)};at.prototype.mul=function(n){return this.throwIfDisposed(),st(this,n)};at.prototype.neg=function(){return this.throwIfDisposed(),on(this)};at.prototype.norm=function(n,t,e){return this.throwIfDisposed(),Od(this,n,t,e)};at.prototype.notEqualStrict=function(n){return this.throwIfDisposed(),pC(this,n)};at.prototype.notEqual=function(n){return this.throwIfDisposed(),ha(this,n)};at.prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),ci(this,n,t,e)};at.prototype.onesLike=function(){return this.throwIfDisposed(),Xn(this)};at.prototype.pad=function(n,t){return this.throwIfDisposed(),Xs(this,n,t)};at.prototype.pool=function(n,t,e,r,s){return this.throwIfDisposed(),sC(this,n,t,e,r,s)};at.prototype.powStrict=function(n){return this.throwIfDisposed(),wC(this,n)};at.prototype.pow=function(n){return this.throwIfDisposed(),ys(this,n)};at.prototype.prelu=function(n){return this.throwIfDisposed(),Sh(this,n)};at.prototype.prod=function(n,t){return this.throwIfDisposed(),Nd(this,n,t)};at.prototype.reciprocal=function(){return this.throwIfDisposed(),xb(this)};at.prototype.relu=function(){return this.throwIfDisposed(),Ys(this)};at.prototype.relu6=function(){return this.throwIfDisposed(),Tb(this)};at.prototype.reshapeAs=function(n){return this.throwIfDisposed(),rt(this,n.shape)};at.prototype.reshape=function(n){return this.throwIfDisposed(),rt(this,n)};at.prototype.resizeBilinear=function(n,t){return this.throwIfDisposed(),RC(this,n,t)};at.prototype.resizeNearestNeighbor=function(n,t){return this.throwIfDisposed(),PC(this,n,t)};at.prototype.reverse=function(n){return this.throwIfDisposed(),Wr(this,n)};at.prototype.rfft=function(){return this.throwIfDisposed(),Eh(this)};at.prototype.round=function(){return this.throwIfDisposed(),kb(this)};at.prototype.rsqrt=function(){return this.throwIfDisposed(),Id(this)};at.prototype.selu=function(){return this.throwIfDisposed(),Ed(this)};at.prototype.separableConv2d=function(n,t,e,r,s,u){return this.throwIfDisposed(),Sb(this,n,t,e,r,s,u)};at.prototype.sigmoid=function(){return this.throwIfDisposed(),js(this)};at.prototype.sign=function(){return this.throwIfDisposed(),Cb(this)};at.prototype.sin=function(){return this.throwIfDisposed(),Dd(this)};at.prototype.sinh=function(){return this.throwIfDisposed(),$d(this)};at.prototype.slice=function(n,t){return this.throwIfDisposed(),ge(this,n,t)};at.prototype.softmax=function(n){return this.throwIfDisposed(),bi(this,n)};at.prototype.softplus=function(){return this.throwIfDisposed(),Ru(this)};at.prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),kh(this,n,t)};at.prototype.split=function(n,t){return this.throwIfDisposed(),Er(this,n,t)};at.prototype.sqrt=function(){return this.throwIfDisposed(),Wn(this)};at.prototype.square=function(){return this.throwIfDisposed(),Oe(this)};at.prototype.squaredDifference=function(n){return this.throwIfDisposed(),Dh(this,n)};at.prototype.squaredDifferenceStrict=function(n){return this.throwIfDisposed(),xC(this,n)};at.prototype.squeeze=function(n){return this.throwIfDisposed(),fa(this,n)};at.prototype.stack=function(n,t){this.throwIfDisposed();let e=n instanceof at?[this,n]:[this,...n];return mr(e,t)};at.prototype.step=function(n){return this.throwIfDisposed(),zu(this,n)};at.prototype.stridedSlice=function(n,t,e,r,s,u,l,h){return this.throwIfDisposed(),Ib(this,n,t,e,r,s,u,l,h)};at.prototype.subStrict=function(n){return this.throwIfDisposed(),TC(this,n)};at.prototype.sub=function(n){return this.throwIfDisposed(),Mt(this,n)};at.prototype.sum=function(n,t){return this.throwIfDisposed(),Xt(this,n,t)};at.prototype.tan=function(){return this.throwIfDisposed(),Eb(this)};at.prototype.tanh=function(){return this.throwIfDisposed(),Du(this)};at.prototype.tile=function(n){return this.throwIfDisposed(),ca(this,n)};at.prototype.toBool=function(){return this.throwIfDisposed(),Rt(this,"bool")};at.prototype.toFloat=function(){return this.throwIfDisposed(),Rt(this,"float32")};at.prototype.toInt=function(){return this.throwIfDisposed(),Rt(this,"int32")};at.prototype.topk=function(n,t){return this.throwIfDisposed(),Db(this,n,t)};at.prototype.transpose=function(n){return this.throwIfDisposed(),re(this,n)};at.prototype.unique=function(n){return this.throwIfDisposed(),Rd(this,n)};at.prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),$b(this,n,t)};at.prototype.unstack=function(n){return this.throwIfDisposed(),bs(this,n)};at.prototype.where=function(n,t){return this.throwIfDisposed(),er(n,this,t)};at.prototype.zerosLike=function(){return this.throwIfDisposed(),fe(this)};let Kd;function Cn(){return Kd==null&&(Kd=MS().epsilon()),Kd}function pht(n){Kd=n}function ws(){return"channelsLast"}class Js extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Js.prototype)}}class ns extends Error{constructor(t){super(t);Object.setPrototypeOf(this,ns.prototype)}}class Q extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Q.prototype)}}class Zt extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Zt.prototype)}}class Zb extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Zb.prototype)}}class ZC extends Error{constructor(t){super(t);Object.setPrototypeOf(this,ZC.prototype)}}function Ti(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}else{let e=new Array(t);return e.fill(n),e}}function Vr(n,t){if(!n)throw new Zb(t)}function QC(n,t){let e=0;for(let r of n)r===t&&e++;return e}function gr(n){return n.length===1?n[0]:n}function Ge(n){return Array.isArray(n)?n:[n]}function dht(n){let t=Ge(n),e="";for(let r of t){if(r.id==null)throw new Q(`Object ${r} passed to objectListUid without an id`);e!==""&&(e=e+", "),e=`${e}${Math.abs(r.id)}`}return e}function Co(n){let t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2"),e=t.replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function ki(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let rs={};function Qb(n){if(n==null)return null;let t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function tw(n){if(n==null||typeof n!="object")return;if(Array.isArray(n))n.forEach(t=>tw(t));else{let t=Object.keys(n);for(let e of t){let r=n[e];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[e]=r.value:tw(r))}}}function zh(n,t={},e={},r="object",s=!1){if(typeof n=="string"){let u=n,l;if(u in e)l=e[u];else if(u in rs)l=rs[u];else if(l=t[u],l==null)throw new Q(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return l}else{let u=n;if(u.className==null||u.config==null)throw new Q(`${r}: Improper config format: ${JSON.stringify(u)}.
'className' and 'config' must set.`);let l=u.className,h,p;if(l in e?[h,p]=e[l]:l in rs?[h,p]=rs.className:l in t&&([h,p]=t[l]),h==null)throw new Q(`Unknown ${r}: ${l}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(p!=null){let m={};for(let S of Object.keys(rs))m[S]=rs[S];for(let S of Object.keys(e))m[S]=e[S];let y=u.config;y.customObjects=m;let b=Object.assign({},rs);for(let S of Object.keys(e))rs[S]=e[S];tw(u.config);let x=p(h,u.config,e,s);return rs=Object.assign({},b),x}else{let m=Object.assign({},rs);for(let b of Object.keys(e))rs[b]=e[b];let y=new h(u.config);return rs=Object.assign({},m),y}}}function iV(n,t){return n<t?-1:n>t?1:0}function Xd(n,t){return-1*iV(n,t)}function mht(n){switch(n){case"float32":return"float32";default:throw new Q(`Invalid dtype: ${n}`)}}function ght(n,t){if(n==null||t==null)return n===t;if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(n[e]!==t[e])return!1;return!0}function ma(n){if(n==null)return n;let t=[];for(let e of n)t.indexOf(e)===-1&&t.push(e);return t}function uV(n){if(n==null)throw new Q(`Invalid value in obj: ${JSON.stringify(n)}`);for(let t in n)if(n.hasOwnProperty(t))return!1;return!0}function Hu(n,t,e){if(e==null)return;if(n.indexOf(e)<0)throw new Q(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function ew(n,t,e=0,r=Infinity){return Vr(e>=0),Vr(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function _n(n,t){Array.isArray(n)?(k(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>_n(e,`element ${r+1} of ${t}`))):k(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${tN(n)}.`)}function tN(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>tN(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function cV(n,t){let e=cr(),r,s=(...u)=>{let l=cr();return l-e<t||(e=l,r=n(...u)),r};return s}function eN(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}function vht(...n){Vr(n.length>0,"arrayOfValues is empty");for(let t of n)Vr(Array.isArray(t),"one of the values is not an array"),Vr(t.length>0,"one of the values is empty");return n.reduce((t,e)=>t.length===0?e.map(r=>[r]):e.map(r=>t.map(s=>[...s,r])).reduce((r,s)=>r.concat(s),[]),[])}function nw(n,t){return ot(()=>Wn(Xt(st(n,n),t,!0)))}class Wh extends li{getConfig(){return{}}}class rw extends Wh{constructor(t){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ot(()=>{let e=nw(t,this.axis),r=fr(e,0,this.maxValue);return st(t,Ht(r,Nt(Cn(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}rw.className="MaxNorm",kt(rw);class sw extends Wh{constructor(t){super();this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ot(()=>Ht(t,Nt(Cn(),nw(t,this.axis))))}getConfig(){return{axis:this.axis}}}sw.className="UnitNorm",kt(sw);class ow extends Wh{apply(t){return Ys(t)}}ow.className="NonNeg",kt(ow);class aw extends Wh{constructor(t){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ot(()=>{let e=nw(t,this.axis),r=Nt(st(this.rate,fr(e,this.minValue,this.maxValue)),st(1-this.rate,e));return st(t,Ht(r,Nt(Cn(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}aw.className="MinMaxNorm",kt(aw);let nN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Nn(n){return Qb(n)}function rN(n,t={}){return zh(n,Lr.getMap().classNameMap,t,"constraint")}function In(n){if(n==null)return null;if(typeof n=="string"){let t=n in nN?nN[n]:n,e={className:t,config:{}};return rN(e)}else return n instanceof Wh?n:rN(n)}function lV(n){return new rw(n)}function hV(n){return new sw(n)}function fV(){return new ow}function pV(n){return new aw(n)}var dV=Object.freeze({__proto__:null,maxNorm:lV,unitNorm:hV,nonNeg:fV,minMaxNorm:pV});let mV=["channelsFirst","channelsLast"],gV=["valid","same","causal"],vV=["max","avg"],yV=["sum","mul","concat","ave"],yht=["temporal"];let qu=new Map;function un(n){Hu(mV,"DataFormat",n)}function Ur(n){Hu(gV,"PaddingMode",n)}function sN(n){Hu(vV,"PoolMode",n)}let Vh=[],oN="/";function Si(n,t){Vh.push(n);try{let e=t();return Vh.pop(),e}catch(e){throw Vh.pop(),e}}function bV(){return Vh.length===0?"":Vh.join(oN)+oN}function aN(n){if(!uN(n))throw new Error("Not a valid tensor name: '"+n+"'");return bV()+n}function iN(n){if(!uN(n))throw new Error("Not a valid tensor name: '"+n+"'");qu.has(n)||qu.set(n,0);let t=qu.get(n);if(qu.set(n,qu.get(n)+1),t>0){let e=`${n}_${t}`;return qu.set(e,1),e}else return n}let wV=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function uN(n){return!!n.match(wV)}function xV(n){return n===parseInt(n.toString(),10)}function ga(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function Yd(n){return n=Array.isArray(n)?new Float32Array(n):n,Ir(n)}function ju(n){return Pu(Yd(n)).dataSync()[0]}function va(n){return dr(Yd(n)).dataSync()[0]}function TV(n){return Xt(Yd(n)).dataSync()[0]}function kV(n){return TV(n)/n.length}function bht(n){let t=Mt(Yd(n),Ot(kV(n))),e=Xt(st(t,t)).dataSync()[0];return e/n.length}function wht(n){let t=n.slice().sort((s,u)=>s-u),e=Math.floor((t.length-1)/2),r=Math.ceil((t.length-1)/2);return e===r?t[e]:(t[e]+t[r])/2}function xs(n,t){if(t<n)throw new Q(`end (${t}) < begin (${n}) is forbidden.`);let e=[];for(let r=n;r<t;++r)e.push(r);return e}let cN="webgl";function xht(n){OS(n),cN=n}function Tht(){return cN}function kht(){return!1}function Sht(n){let t=n.shape;return t.length>0?t.reduce((e,r)=>e*r):1}function Uh(n,t){return n.asType(t)}function Gh(n,t=-1){let e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),n.reshape(e)}function SV(n,t){return ot(()=>{if(n.shape.length!==2)throw new Q(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);let e=Gh(n,1);return cw(e,[1,t,1])})}function CV(n){let t=[ga(n.shape)];return n.reshape(t)}function NV(n){if(n.rank<=1)throw new Q(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);let t=[n.shape[0],ga(n.shape,1)];return n.reshape(t)}function Ci(n,t,e){return ot(()=>{switch(n.rank){case 1:return Ad(n,t,e);case 2:return Nb(n,[t,0],[e,n.shape[1]]);case 3:return _d(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Nh(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ge(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ge(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Q(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function iw(n,t,e){return ot(()=>{switch(n.rank){case 1:return Ad(n,t,e);case 2:return Nb(n,[0,t],[n.shape[0],e]);case 3:return _d(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Nh(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new Q(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Jd(n,t,e,r){return ot(()=>{switch(n.rank){case 1:return Ad(n,t,e);case 2:switch(r){case 1:return Ci(n,t,e);case 2:return iw(n,t,e);default:throw new Q(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ci(n,t,e);case 2:return _d(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return iw(n,t,e);default:throw new Q(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ci(n,t,e);case 2:return Nh(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Nh(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return iw(n,t,e);default:throw new Q(`The axis is not within the rank of the tensor ${r}`)}default:throw new Q(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function uw(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),sn(n,t)}function lN(n,t){switch(n.rank){case 1:return US([n,t]);case 2:return GS([n,t],0);case 3:return HS([n,t],0);case 4:return qS([n,t],0);default:throw new Q(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function cw(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new Q(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return ca(n,t)}function Zd(n,t=0,e=1,r,s){return wb(n,t,e,r,s)}function Zs(n,t,e,r){if(n.rank<2||t.rank<2)throw new Zt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=n.shape.slice(-1)[0],u=t.shape.slice(-2)[0];if(s!==u)throw new Zt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2){let s=!1,u=!1;return Wd({a:n,b:t,transposeA:s,transposeB:u,bias:r?lw(n.rank,r,ws()):null,activation:e})}else{let s=n.shape.slice(),u=s.pop();n=n.reshape([-1,u]);let l=t.shape.slice(),h=l.pop(),p=l.pop(),m=[...l,h],y=Array.from({length:t.rank},(C,I)=>I===0?t.rank-2:I<=t.rank-2?I-1:I);t=t.transpose(y).reshape([p,-1]);let b=[...s,...m],x=!1,S=!1;return Wd({a:n,b:t,transposeA:x,transposeB:S,bias:r?lw(n.rank,r,ws()):null,activation:e}).reshape(b)}}function Cht(n){return ot(()=>{let t=fe(n),e=Xn(n);return er(gs(n,t),t,er(zr(n,fe(n)),e,st(-1,e)))})}function Nht(n,t){return ot(()=>{if(n.rank!==1)throw new Error("Only 1D one-hot tensors are supported in the deeplearn backend, at present.");return n=n.toInt(),ci(n,t).toFloat()})}function hN(n,t,e){return ot(()=>(Array.isArray(t)?t=Ir(t,"int32"):t=t.toInt(),Fu(n,t,e)))}function Hh(n){return st(n,n)}function Iht(n,t){return ot(()=>{if(typeof t=="number"&&(t=Ot(Math.round(t),"int32")),t.dtype!=="int32")throw new Zt(`Non-int32 dtype (${t.dtype}) is not supported by pow() yet`);return ys(n,t)})}function lw(n,t,e){let r=t.shape;if(t.rank!==1&&t.rank!==n)throw new Q(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return r.length===1?t.reshape([1,r[0],1,1,1]):t.reshape([1,r[3],r[0],r[1],r[2]]);if(e==="channelsLast")return r.length===1?t.reshape([1,1,1,1,r[0]]):t.reshape([1].concat(r))}else if(n===4){if(e==="channelsFirst")return r.length===1?t.reshape([1,r[0],1,1]):t.reshape([1,r[2],r[0],r[1]]);if(e==="channelsLast")return r.length===1?t.reshape([1,1,1,r[0]]):t.reshape([1].concat(r))}else if(n===3){if(e==="channelsFirst")return r.length===1?t.reshape([1,r[0],1]):t.reshape([1,r[1],r[0]]);if(e==="channelsLast")return r.length===1?t.reshape([1,1,r[0]]):t.reshape([1].concat(r))}else if(n<3)return t;throw new Q(`Unsupported input rank by biasAdd: ${t.rank}`)}function Qs(n,t,e){return ot(()=>(e==null&&(e=ws()),un(e),n.add(lw(n.rank,t,e))))}function IV(n,t=1){if(t!==1)throw new Zt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return $u(n)}function EV(n){return ot(()=>Ht(n,kn(n).add(1)))}function fN(n,t,e,r){return ot(()=>NC(n,t,e,r))}function DV(n){return ot(()=>{let t=Nt(.5,st(.2,n));return fr(t,0,1)})}function qh(n,t,e=!1){return e?n():t()}let $V=["fanIn","fanOut","fanAvg"],AV=["normal","uniform","truncatedNormal"],Eht=["Zeros","Ones","Constant","RandomNormal","RandomUniform","TruncatedNormal","VarianceScaling","Orthogonal","Identity"];function _V(n){Hu($V,"FanMode",n)}function FV(n){Hu(AV,"Distribution",n)}class ss extends li{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class hw extends ss{apply(t,e){return Se(t,e)}}hw.className="Zeros",kt(hw);class Qd extends ss{apply(t,e){return vs(t,e)}}Qd.className="Ones",kt(Qd);class fw extends ss{constructor(t){super();if(typeof t!="object")throw new Q(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new Q(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return ot(()=>st(Ot(this.value),vs(t,e)))}getConfig(){return{value:this.value}}}fw.className="Constant",kt(fw);class pw extends ss{constructor(t){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return yi(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}pw.className="RandomUniform",kt(pw);class dw extends ss{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Zt(`randomNormal does not support dType ${e}.`);return Zd(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dw.className="RandomNormal",kt(dw);class mw extends ss{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Zt(`truncatedNormal does not support dType ${e}.`);return $h(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}mw.className="TruncatedNormal",kt(mw);class gw extends ss{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,e){return ot(()=>{if(t.length!==2||t[0]!==t[1])throw new Q("Identity matrix initializer can only be used for 2D square matrices.");return st(this.gain,yd(t[0]))})}getConfig(){return{gain:this.gain}}}gw.className="Identity",kt(gw);function RV(n,t="channelsLast"){let e,r;if(un(t),n.length===2)e=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){let s=ga(n,2);e=n[1]*s,r=n[0]*s}else if(t==="channelsLast"){let s=ga(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{let s=ga(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}class vr extends ss{constructor(t){super();if(t.scale<0)throw new Q(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,_V(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,FV(this.distribution),this.seed=t.seed}apply(t,e){let r=RV(t),s=r[0],u=r[1],l=this.scale;if(this.mode==="fanIn"?l/=Math.max(1,s):this.mode==="fanOut"?l/=Math.max(1,u):l/=Math.max(1,(s+u)/2),this.distribution==="normal"){let h=Math.sqrt(l);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new Zt(`${this.getClassName()} does not support dType ${e}.`);return $h(t,0,h,e,this.seed)}else{let h=Math.sqrt(3*l);return yi(t,-h,h,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}vr.className="VarianceScaling",kt(vr);class tm extends vr{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return vr.className}}tm.className="GlorotUniform",kt(tm);class em extends vr{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return vr.className}}em.className="GlorotNormal",kt(em);class nm extends vr{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return vr.className}}nm.className="HeNormal",kt(nm);class rm extends vr{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return vr.className}}rm.className="HeUniform",kt(rm);class sm extends vr{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return vr.className}}sm.className="LeCunNormal",kt(sm);class om extends vr{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return vr.className}}om.className="LeCunNormal",kt(om);class vw extends ss{constructor(t){super();if(this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new Zt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return ot(()=>{if(t.length<2)throw new Zt("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let r=t[0]>t[1]?[t[1],t[0]]:t,s=Zd(r,0,1,"float32"),u=MC.gramSchmidt(s);return t[0]>t[1]&&(u=u.transpose()),st(this.gain,u)})}getConfig(){return{gain:this.gain,seed:this.seed}}}vw.className="Orthogonal",kt(vw);let pN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function dN(n,t={}){return zh(n,Lr.getMap().classNameMap,t,"initializer")}function cn(n){return Qb(n)}function Xe(n){if(typeof n=="string"){let t=n in pN?pN[n]:n;if(t==="GlorotNormal")return new em;if(t==="GlorotUniform")return new tm;if(t==="HeNormal")return new nm;if(t==="HeUniform")return new rm;if(t==="LeCunNormal")return new sm;if(t==="LeCunUniform")return new om;{let e={};return e.className=t,e.config={},dN(e)}}else return n instanceof ss?n:dN(n)}function PV(){return new hw}function OV(){return new Qd}function MV(n){return new fw(n)}function LV(n){return new pw(n)}function BV(n){return new dw(n)}function zV(n){return new mw(n)}function WV(n){return new gw(n)}function VV(n){return new vr(n)}function UV(n){return new tm(n)}function GV(n){return new em(n)}function HV(n){return new nm(n)}function qV(n){return new rm(n)}function jV(n){return new sm(n)}function KV(n){return new om(n)}function XV(n){return new vw(n)}var YV=Object.freeze({__proto__:null,zeros:PV,ones:OV,constant:MV,randomUniform:LV,randomNormal:BV,truncatedNormal:zV,identity:WV,varianceScaling:VV,glorotUniform:UV,glorotNormal:GV,heNormal:HV,heUniform:qV,leCunNormal:jV,leCunUniform:KV,orthogonal:XV});let JV=0;function mN(){return JV++}let am={};function im(n=""){return n in am||(am[n]=0),am[n]+=1,n+am[n].toString()}function yw(n){return Array.isArray(n)&&Array.isArray(n[0])}function um(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function le(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new Q(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Be(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new Q(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function cm(n){let t=0;for(let e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((r,s)=>r*s);return t}let gN="Variable";class Ts{constructor(t,e="float32",r=gN,s=!0,u=null){this.dtype=e==null?"float32":e,this.shape=t.shape,this.id=mN(),r=r==null?gN:r,this.originalName=aN(r),this.name=iN(this.originalName),this.trainable_=s,this.constraint=u,this.val=iC(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),ZV(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function ZV(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function Dht(n,t,e,r){return new Ts(n,t,e,!0,r)}function $ht(n,t,e){return new Ts(Se(n),t,e)}function Aht(n,t,e){return new Ts(fe(n),t,e)}function _ht(n,t,e){let r=vs(n);return new Ts(r,t,e)}function Fht(n,t,e){let r=Xn(n);return new Ts(r,t,e)}function Rht(n,t,e){return new Ts(yd(n),t,e)}function Pht(n,t,e,r,s,u="randomUniform"){return new Ts(yi(n,t,e,r),r,u)}function Oht(n,t=0,e=1,r,s,u="truncatedNormal"){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new Zt(`randomNormal does not support dType ${r}.`);return new Ts($h(n,t,e,r,s),r,u)}function Mht(n,t=0,e=1,r,s,u="randomNormal"){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new Zt(`randomNormalVariable does not support dType ${r}.`);return new Ts(wb(n,t,e,r,s),r,u)}function Lht(n,t){return n.write(t)}function Bht(n,t){return n.write(Nt(n.read(),t))}function zht(n,t){return n.write(Mt(n.read(),t))}function bw(n){return n.map(t=>t.read())}function ww(n){n.forEach(t=>{let e=t[0];e.write(t[1])})}function Wht(n,t){let e=t.map(s=>s.read()),r=db(n,e);return t.map(s=>r.grads[s.name])}class Fn{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class ks{constructor(t,e,r,s,u,l,h){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=u,this.outputTensorIndex=h,this.id=mN(),l!=null&&(this.originalName=aN(l),this.name=iN(this.originalName)),this.rank=e.length}}let QV=0;class lm{constructor(t,e){this.callArgs=e,this.id=QV++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let r of t.inboundLayers)r!=null&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let tU=0;class Te extends li{constructor(t={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tU++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let r=this.getClassName();e=Co(r)+"_"+im(r)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let u=null;t.batchSize!=null&&(u=t.batchSize),r=[u].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new ns(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new Q(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return gr(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return gr(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Js(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Js(`Layer ${this.name} is not connected, no input to return.`);return gr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Js(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Js(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return gr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Ge(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=Ge(this.inputSpec);if(t.length!==e.length)throw new Q(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){let s=t[r],u=e[r];if(u==null)continue;let l=s.rank;if(u.ndim!=null&&l!==u.ndim)throw new Q(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${u.ndim}, found ndim=${l}`);if(u.maxNDim!=null&&l>u.maxNDim)throw new Q(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${u.maxNDim}, found ndim=${l}`);if(u.minNDim!=null&&l<u.minNDim)throw new Q(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${u.minNDim}, found ndim=${l}.`);if(u.dtype!=null&&s.dtype!==u.dtype)throw new Q(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${u.dtype}, found dtype=${s.dtype}.`);if(u.axes){let h=s.shape;for(let p in u.axes){let m=Number(p),y=u.axes[p],b=m>=0?h[m]:h[h.length+m];if(y!=null&&[y,null].indexOf(b)===-1)throw new Q(`Input ${r} is incompatible with layer ${this.name}: expected axis ${m} of input shape to have value ${y} but got shape ${h}.`)}}if(u.shape!=null)for(let h=0;h<u.shape.length;++h){let p=u.shape[h],m=s.shape[h];if(p!=null&&m!=null&&p!==m)throw new Q(`Input ${r} is incompatible with layer ${this.name}: expected shape=${u.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let r=Ge(t),s=!0;for(let l of r)if(!(l instanceof ks)){s=!1;break}let u=!0;for(let l of r)if(l instanceof ks){u=!1;break}if(s===u)throw new Q("Arguments to apply() must be all SymbolicTensors or all Tensors");return Si(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let l=[];for(let h of Ge(t))l.push(h.shape);this.build(gr(l)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&u&&(this._refCount=1)}if(this.assertInputCompatibility(t),u){let l=this.call(t,e),h=Ge(l),p=[];for(let m of h)r.indexOf(m)!==-1&&(m=m.clone()),p.push(m);if(l=gr(p),this.activityRegularizer!=null)throw new Zt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}else{let l=eU(t),h=this.computeOutputShape(l),p,m=nU(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?l[0]:l),h!=null&&h.length>0&&Array.isArray(h[0])?p=h.map((y,b)=>new ks(m,y,this,Ge(t),e,this.name,b)):p=new ks(m,h,this,Ge(t),e,this.name),this.addInboundNode(t,p,null,null,l,h,e),this._refCount++,this.activityRegularizer!=null)throw new Zt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return p}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape==null)return;if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&t[s]!=null&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Js(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let r=JSON.stringify(e.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Js(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ns(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return cm(this.weights)}build(t){this.built=!0}getWeights(t=!1){return bw(t?this.trainableWeights:this.weights)}setWeights(t){ot(()=>{let e=this.weights;if(e.length!==t.length)throw new Q(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let r=[],s=bw(e);for(let u=0;u<s.length;++u){let l=s[u],h=e[u],p=t[u];if(!K(l.shape,p.shape))throw new Q(`Layer weight shape ${l.shape} not compatible with provided weight shape ${p.shape}`);r.push([h,p])}ww(r)})}addWeight(t,e,r,s,u,l,h){if(this._addedWeightNames.indexOf(t)!==-1)throw new Q(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=Xe("zeros"));let p=s.apply(e,r),m=new Ts(p,r,t,l,h);return p.dispose(),u!=null&&this.addLoss(()=>u.apply(m.read())),l==null&&(l=!0),l?this._trainableWeights.push(m):this._nonTrainableWeights.push(m),m}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){if(t==null||Array.isArray(t)&&t.length===0)return;t=Ge(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t)}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,r,s,u,l,h=null){let p=Ge(t);e=Ge(e),r=Ge(r),s=Ge(s),u=um(u),l=um(l);let m=[],y=[],b=[];for(let x of p)m.push(x.sourceLayer),y.push(x.nodeIndex),b.push(x.tensorIndex);new lm({outboundLayer:this,inboundLayers:m,nodeIndices:y,tensorIndices:b,inputTensors:p,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:u,outputShapes:l},h);for(let x=0;x<e.length;x++)e[x].sourceLayer=this,e[x].nodeIndex=this.inboundNodes.length-1,e[x].tensorIndex=x}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function eU(n){n=Ge(n);let t=[];for(let e of n)t.push(e.shape);return gr(t)}function nU(n){return"float32"}function vN(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{let r=t.inboundNodes[e];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let u=0;u<r.inboundLayers.length;u++){let l=r.inputTensors[u],h=r.inboundLayers[u],p=r.nodeIndices[u],m=vN(l,h,p);for(let y of m)s.indexOf(y)===-1&&s.push(y)}return s}}}class Ku extends Te{constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:im("input").toString()});if(t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new Q("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new Q("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new Q("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let r=t.dtype||"float32";this.batchInputShape=e,this.dtype=r,this.inputSpec=[{shape:e}];let s=new ks(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new lm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new Q(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Ku.className="InputLayer",kt(Ku);function yN(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new Q("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;e==null&&(e="float32");let r=new Ku({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}),s=r.inboundNodes[0].outputTensors;return s[0]}async function ya(n){if(n==null)return;let t=[],e=[],r=[];for(let s in n){let u=n[s];if(typeof u!="number"){let l=u;t.push(l.data()),e.push(s),r.push(l)}}if(t.length>0){let s=await Promise.all(t);for(let u=0;u<s.length;++u)n[e[u]]=s[u][0];oe(r)}}function bN(n){if(n==null)return;for(let t in n){let e=n[t];typeof e!="number"&&e.dispose()}}var wN;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(wN||(wN={}));let rU=125;class Xu{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class xN{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let r of this.callbacks)await r.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let r of this.callbacks)await r.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let r of this.callbacks)await r.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let r of this.callbacks)await r.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}}class sU extends Xu{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let r=e.size==null?0:e.size;this.seen+=r;for(let s in e){let u=e[s];if(typeof u=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+u*r;else{let l;s in this.totals?l=this.totals[s]:this.totals[s]=0;let h=ot(()=>Nt(this.totals[s],st(u,r)));this.totals[s]=h,l!=null&&l.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let r of this.params.metrics){if(this.totals[r]==null)continue;typeof this.totals[r]=="number"?e[r]=this.totals[r]/this.seen:ot(()=>{let s=st(Ht(1,this.seen),this.totals[r]);e[r]=s,this.totals[r].dispose(),An(e[r])})}}}class TN extends Xu{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let r in e)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(e[r])}async syncData(){let t=[],e=[],r=[];for(let u in this.history){let l=this.history[u];for(let h=0;h<l.length;++h)if(typeof l[h]!="number"){let p=l[h];t.push(p.data()),e.push(u),r.push(h)}}let s=await Promise.all(t);for(let u=0;u<s.length;++u){let l=this.history[e[u]][r[u]];l.dispose(),this.history[e[u]][r[u]]=s[u][0]}}}class kN extends Xu{constructor(t,e){super();if(this.currentEpoch=0,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=rU),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Or(this.yieldEvery)&&(this.maybeWait=cV(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,r){let s=[];this.yield!=null&&(await ya(r),s.push(this.yield(t,e,r))),s.push(Hd()),await Promise.all(s)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await ya(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let r=[];this.epochEnd!=null&&(await ya(e),r.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&r.push(Hd()),await Promise.all(r)}async onBatchBegin(t,e){this.batchBegin!=null&&(await ya(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let r=[];this.batchEnd!=null&&(await ya(e),r.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?r.push(Hd()):Or(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await ya(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await ya(t),await this.trainEnd(t))}}function SN(n,t){if(n==null&&(n={}),n instanceof Xu)return[n];if(Array.isArray(n)&&n[0]instanceof Xu)return n;let e=Ge(n);return e.map(r=>new kN(r,t))}class Gr{constructor(){}static registerCallbackConstructor(t,e){k(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Gr.checkForDuplicate(e),Gr.constructors[t]==null&&(Gr.constructors[t]=[]),Gr.constructors[t].push(e)}static checkForDuplicate(t){for(let e in Gr.constructors){let r=Gr.constructors[+e];r.forEach(s=>{if(s===t)throw new Q("Duplicate callback constructor.")})}}static clear(){Gr.constructors={}}static createCallbacks(t){let e=[];for(let r in Gr.constructors){let s=+r;t>=s&&e.push(...Gr.constructors[s])}return e.map(r=>new r)}}Gr.constructors={};function CN(n,t,e,r,s,u,l,h,p){let m=new TN,y=[new sU,...Gr.createCallbacks(t)];n!=null&&y.push(...n),y.push(m);let b=new xN(y);return b.setParams({epochs:e,initialEpoch:r,samples:s,steps:u,batchSize:l,verbose:t,doValidation:h,metrics:p}),{callbackList:b,history:m}}function Ss(n,t={},e=!1){return zh(n,Lr.getMap().classNameMap,t,"layer",e)}function hm(n,t){return ot(()=>{n.dtype!=="float32"&&(n=n.asType("float32"));let e=Xt(Hh(n),t,!0),r=Au(e.shape,Cn()),s=Wn(ts(e,r));return Ht(n,s)})}function No(n,t){return ot(()=>an(Hh(Mt(t,n)),-1))}function Yu(n,t){return ot(()=>an(kn(Mt(t,n)),-1))}function ba(n,t){return ot(()=>{let e=Mt(n,t),r=fr(kn(n),Cn(),Number.MAX_VALUE),s=kn(Ht(e,r));return st(100,an(s,-1))})}function xw(n,t){return ot(()=>{let e=fr(t,Cn(),Number.MAX_VALUE),r=Nr(Nt(1,e)),s=fr(n,Cn(),Number.MAX_VALUE),u=Nr(Nt(1,s));return an(Hh(Mt(r,u)),-1)})}function oU(n,t){return ot(()=>{let e=ts(0,Mt(1,st(n,t)));return an(Hh(e),-1)})}function aU(n,t){return ot(()=>{let e=ts(0,Mt(1,st(n,t)));return an(e,-1)})}function iU(n,t){return ot(()=>{let e=Xt(st(n,t),-1),r=dr(st(Mt(1,n),t),-1);return ts(0,Nt(1,Mt(r,e)))})}function uU(n,t){return ot(()=>{let e=Math.log(2),r=Mt(t,n),s=Mt(Nt(r,Ru(st(-2,r))),e);return an(s,-1)})}function jh(n,t,e=!1){return ot(()=>{if(e)t=bi(t);else{let r=Xt(t,t.shape.length-1,!0);t=Ht(t,r)}return t=fr(t,Cn(),1-Cn()),on(Xt(st(n.toFloat(),Nr(t)),t.shape.length-1))})}function fm(n,t,e=!1){return ot(()=>{let r=_u(CV(n)).toInt();t=fr(t,Cn(),1-Cn());let s=t.shape,u=ci(r,s[s.length-1]).reshape(s);return jh(u,t,e)})}function cU(n,t){if(!K(n.shape,t.shape))throw new Q(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return ot(()=>{let e=t.relu(),r=t.abs().neg();return e.sub(t.mul(n)).add(r.exp().log1p())})}function pm(n,t){return ot(()=>{let e;return e=fr(t,Cn(),1-Cn()),e=Nr(Ht(e,Mt(1,e))),an(cU(n,e),-1)})}function Tw(n,t){return ot(()=>{let e=fr(n,Cn(),1),r=fr(t,Cn(),1);return Xt(st(n,Nr(Ht(e,r))),-1)})}function lU(n,t){return ot(()=>{let e=Nr(Nt(Cn(),t));return an(Mt(t,st(n,e)),-1)})}function dm(n,t){return ot(()=>{let e=hm(n,-1),r=hm(t,-1),s=st(e,r);return on(Xt(s,-1))})}let Vht=No,Uht=No,Ght=Yu,Hht=Yu,qht=ba,jht=ba,Kht=xw,Xht=xw,Yht=Tw,Jht=Tw,Zht=dm,mm={meanSquaredError:No,meanAbsoluteError:Yu,meanAbsolutePercentageError:ba,meanSquaredLogarithmicError:xw,squaredHinge:oU,hinge:aU,categoricalHinge:iU,logcosh:uU,categoricalCrossentropy:jh,sparseCategoricalCrossentropy:fm,binaryCrossentropy:pm,kullbackLeiblerDivergence:Tw,poisson:lU,cosineProximity:dm};function kw(n){if(typeof n=="string"){if(n in mm)return mm[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Q(t)}else return n}function Sw(n,t){return ot(()=>{let e=st(.5,Xn(t)),r=Uh(zr(t,e),n.dtype);return an(gs(n,r),-1)})}function Cw(n,t){return ot(()=>Uh(gs(fh(n,-1),fh(t,-1)),"float32"))}function NN(n,t){return ot(()=>es(n.equal(1),t.equal(1)).sum().cast("float32"))}function hU(n,t){return ot(()=>es(n.equal(1),t.equal(0)).sum().cast("float32"))}function fU(n,t){return ot(()=>es(n.equal(0),t.equal(1)).sum().cast("float32"))}function IN(n,t){return ot(()=>{let e=NN(n,t),r=fU(n,t),s=e.add(r);return er(zr(s,0),e.div(s),0).cast("float32")})}function pU(n,t){return ot(()=>{let e=NN(n,t),r=hU(n,t),s=e.add(r);return er(zr(s,0),e.div(s),0).cast("float32")})}function EN(n,t){return pm(n,t)}function DN(n,t){return n.rank===t.rank&&(n=n.squeeze([n.rank-1])),t=t.argMax(-1),t.dtype!==n.dtype&&(t=t.asType(n.dtype)),gs(n,t).asType("float32")}function Qht(n,t){throw new Zt}function tft(n,t){throw new Zt}let dU=No,mU=No,gU=Yu,vU=Yu,yU=ba,bU=ba,Nw=jh,wU=dm,$N=fm,gm={binaryAccuracy:Sw,categoricalAccuracy:Cw,precision:IN,categoricalCrossentropy:Nw,sparseCategoricalCrossentropy:$N,mse:dU,MSE:mU,mae:gU,MAE:vU,mape:yU,MAPE:bU,cosine:wU};function xU(n){if(typeof n=="string"&&n in gm)return gm[n];if(typeof n!="string"&&n!=null)return n;throw new Q(`Unknown metric ${n}`)}function vm(n){if(Vr(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(let e of Object.keys(mm))if(mm[e]===n){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(gm))if(gm[e]===n){t=e;break}return t!==void 0?t:n.name}}function TU(n){let t={Adagrad:()=>xi.adagrad(.01),Adadelta:()=>xi.adadelta(1,.95,Cn()),Adam:()=>xi.adam(.001,.9,.999,Cn()),Adamax:()=>xi.adamax(.002,.9,.999,Cn(),0),RMSProp:()=>xi.rmsprop(.001,.9,0,Cn()),SGD:()=>xi.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new Q(`Unknown Optimizer ${n}`)}let AN=1*1024*1024;function _N(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!Iw(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let r=JSON.stringify(n);r.length>AN&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${AN}.`)}}function Iw(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){let t=Object.keys(n);for(let e of t){if(typeof e!="string")return!1;if(!Iw(n[e]))return!1}return!0}else if(Array.isArray(n)){for(let t of n)if(!Iw(t))return!1;return!0}else return!1;else{let t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function kU(n,t,e,r=console.log){let s=CU(n),u=["Layer (type)","Output shape","Param #"];s?(t=t||65,e=e||[.45,.85,1]):(t=t||98,e=e||[.33,.55,.67,1]),e[e.length-1]<=1&&(e=e.map(y=>Math.floor(t*y)));let l;if(!s){u.push("Receives inputs"),l=[];for(let y in n.nodesByDepth)l.push(...n.nodesByDepth[y])}r("_".repeat(t)),ym(u,e,r),r("=".repeat(t));let h=n.layers;for(let y=0;y<h.length;++y)s?NU(h[y],e,r):IU(h[y],e,l,r),r((y===h.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();let p=SU(n),m=cm(n.nonTrainableWeights);r(`Total params: ${p+m}`),r(`Trainable params: ${p}`),r(`Non-trainable params: ${m}`),r("_".repeat(t))}function SU(n){let t;return n.collectedTrainableWeights!=null?t=cm(n.collectedTrainableWeights):t=cm(n.trainableWeights),t}function CU(n){let t=!0,e=[],r=[];for(let s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(let s of e){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of n.layers){let u=!1;for(let l of s.inboundNodes)if(r.indexOf(l)!==-1)if(u){t=!1;break}else u=!0;if(!t)break}return t}function ym(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function NU(n,t,e){let r;try{r=JSON.stringify(n.outputShape)}catch(h){r="multiple"}let s=n.name,u=n.getClassName(),l=[`${s} (${u})`,r,n.countParams().toString()];ym(l,t,e)}function IU(n,t,e,r){let s;try{s=JSON.stringify(n.outputShape)}catch(y){s="multiple"}let u=[];for(let y of n.inboundNodes){if(e!=null&&e.length>0&&e.indexOf(y)===-1)continue;for(let b=0;b<y.inboundLayers.length;++b){let x=y.inboundLayers[b].name,S=y.nodeIndices[b],C=y.tensorIndices[b];u.push(`${x}[${S}][${C}]`)}}let l=n.name,h=n.getClassName(),p=u.length===0?"":u[0],m=[`${l} (${h})`,s,n.countParams().toString(),p];ym(m,t,r);for(let y=1;y<u.length;++y)ym(["","","",u[y]],t,r)}function FN(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function Kh(n,t){if(n===null)return null;if(typeof n=="string")return ki(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){let e=[],r=n.length;for(let s=0;s<r;++s){let u=n[s];FN(t,s,u)?e.push(u):e.push(Kh(u,t))}return e}else{let e={};for(let r of Object.keys(n)){let s=n[r];if(r==="name"&&typeof s=="string")e[r]=s;else{let u=ki(r);e[u]=Kh(s,u)}}return e}}function Ew(n,t){if(n==null)return null;if(typeof n=="string")return Co(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){let e=[],r=n.length;for(let s=0;s<r;++s){let u=n[s];FN(t,s,u)?e.push(u):e.push(Ew(u,t))}return e}else{let e={};for(let r of Object.keys(n)){let s=n[r],u=Co(r);(r==="name"||r==="className")&&typeof s=="string"?e[u]=s:e[u]=Ew(s,r)}return e}}let bm="2.7.0";function EU(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return Rt(t,n.dtype)}catch(e){throw new Q(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class wa{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof wa)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=EU(t,e),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new Q(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ks){if(this.id2Value[t.id]==null)throw new Q(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new Q(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof ks){if(this.id2Value[t.id]==null)throw new Q(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new Q(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&oe(this.id2Mask)}}let Dw={},RN={};function Xh(n,t,e,r){let s=e==null?!1:e.training,u=Array.isArray(n),l=u?n:[n],h=l.map(C=>C.name),p=[],m=t.names();for(let C of h)m.indexOf(C)!==-1?p.push(t.getValue(C)):p.push(null);r!=null&&(r.maxNumTensors=-Infinity,r.minNumTensors=Infinity);let y=h.join(",")+"|"+t.names().join(","),b,x;if(Dw[y]==null){let C=DU(l,t);b=C.sorted,x=C.recipientCounts,Dw[y]=b,RN[y]=x}b=Dw[y],x={},s||Object.assign(x,RN[y]);let S=new wa(t);for(let C=0;C<b.length;++C){if(r!=null){let et=id().numTensors;et>r.maxNumTensors&&(r.maxNumTensors=et),et<r.minNumTensors&&(r.minNumTensors=et)}let I=b[C],D=I.sourceLayer;if(D instanceof Ku)continue;let R=[],A=[],L=[],_=!1;for(let et of I.inputs){let tt=S.getValue(et),ht=S.getMask(et);R.push(tt),A.push(ht),ht!=null&&(_=!0),s||(x[et.name]--,x[et.name]===0&&!t.hasKey(et)&&h.indexOf(et.name)===-1&&!tt.isDisposed&&et.sourceLayer.stateful!==!0&&L.push(tt))}_&&(e=e||{},e.mask=A[0]);let B=Ge(D.apply(R,e)),V=null;D.supportsMasking&&(V=D.computeMask(R,A));let q=AU(I),j=Array.isArray(q)?q:[q];for(let et=0;et<j.length;++et){S.hasKey(j[et])||S.add(j[et],B[et],Array.isArray(V)?V[0]:V);let tt=h.indexOf(j[et].name);tt!==-1&&(p[tt]=B[et])}s||oe(L)}return S.disposeMasks(),u?p:p[0]}function DU(n,t){k(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(n.length===1){let s=PN(n[0],t);e=s.sorted,r=s.recipientMap}else{let s=new Set;for(let u of n){let{sorted:l,recipientMap:h}=PN(u,t);for(let p of l)s.has(p.name)||(e.push(p),s.add(p.name));for(let p in h)r[p]==null&&(r[p]=new Set),h[p].forEach(m=>r[p].add(m))}}return{sorted:e,recipientCounts:$U(r)}}function $U(n){let t={};for(let e in n)t[e]=n[e].size;return t}function PN(n,t){let e=new Set,r=[],s={};for(let h of t.names())e.add(h);let u=[],l=[];for(u.push(n);u.length>0;){let h=u[u.length-1];if(e.has(h.name)){u.pop();continue}let p=l[l.length-1]===u.length-1;if(h.inputs.length===0||p)u.pop(),r.push(h),e.add(h.name),p&&l.pop();else{l.push(u.length-1);for(let m of h.inputs){if(s[m.name]==null&&(s[m.name]=new Set),s[m.name].add(h.name),e.has(m.name))continue;u.push(m)}}}return{sorted:r,recipientMap:s}}function AU(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(let s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}class Cs extends Te{constructor(t){super({});if(this.containerNodes=new Set,this.name=t.name,this.name==null){let A=this.getClassName().toLowerCase();this.name=im(A)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ma(this.inputs).length!==this.inputs.length)throw new Q(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(A=>A.name)}`);ma(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(A=>A.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let A of this.outputs){let L=A.sourceLayer,_=A.nodeIndex,B=A.tensorIndex;this.outputLayers.push(L),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(B)}for(let A of this.inputs){let L=A.sourceLayer,_=A.nodeIndex,B=A.tensorIndex;Vr(_===0,"input layer has >1 nodes"),Vr(B===0,"input layer has >1 tensors"),this.inputLayers.push(L),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(B)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let A=0;A<this.inputLayers.length;A++){let L=this.inputLayers[A];if(!(L instanceof Ku))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${A} (0-based) originates from layer type ${L.getClassName()}.`);this.inputNames.push(L.name),this.feedInputShapes.push(L.batchInputShape),this.feedInputNames.push(L.name)}for(let A of this.outputLayers)this.outputNames.push(A.name);this.internalInputShapes=this.inputs.map(A=>A.shape),this.internalOutputShapes=this.outputs.map(A=>A.shape);let e={},r={},s={},u={},l={},h=[],p=(A,L,_,B,V,q)=>{(B==null||V==null||q==null)&&(B=A.sourceLayer,V=A.nodeIndex,q=A.tensorIndex);let j=B.inboundNodes[V];if(_.indexOf(j)!==-1)throw new ns(`The tensor ${A.name} at layer "${B.name}" is part of a cycle.`);if(L.indexOf(j)!==-1)return;this.containerNodes.add(Cs.nodeKey(B,V)),B.id in l||(l[B.id]=Object.keys(l).length),_.indexOf(j)===-1&&_.push(j);let et=j.inboundLayers.length;for(let tt=0;tt<et;tt++){let ht=j.inputTensors[tt],gt=j.inboundLayers[tt],vt=j.nodeIndices[tt],bt=j.tensorIndices[tt];p(ht,L,_,gt,vt,bt)}for(L.push(j);_.indexOf(j)>=0;)_.splice(_.indexOf(j),1);h.push(j)},m=[],y=[];for(let A of this.outputs)p(A,m,y);let b=h.slice().reverse();for(let A of b){r[A.id]=A,A.id in e||(e[A.id]=0);let L=e[A.id],_=s[A.outboundLayer.id]==null?0:s[A.outboundLayer.id];L=Math.max(L,_),s[A.outboundLayer.id]=L,u[A.outboundLayer.id]=A.outboundLayer,e[A.id]=L;for(let B=0;B<A.inboundLayers.length;B++){let V=A.inboundLayers[B],q=A.nodeIndices[B],j=V.inboundNodes[q],et=e[j.id]==null?0:e[j.id];e[j.id]=Math.max(L+1,et),r[j.id]=j}}let x={};for(let A in e){let L=e[A];L in x||(x[L]=[]),x[L].push(r[A])}let S={};for(let A in s){let L=s[A];L in S||(S[L]=[]),S[L].push(u[A])}let C=Object.keys(S).map(A=>parseInt(A,10)).sort(Xd);this.layers=[];for(let A of C){let L=S[A];L.sort((_,B)=>{let V=l[_.id],q=l[B.id];return V<q?-1:V>q?1:0});for(let _ of L)_ instanceof Cs&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=S,C=Object.keys(x).map(A=>parseInt(A,10)).sort(Xd);let I=this.inputs.slice(),D=[];for(let A of C)for(let L of x[A]){let _=L.outboundLayer;if(_!=null){for(let B of L.inputTensors)if(I.indexOf(B)===-1)throw new ns(`Graph disconnected: cannot obtain value for tensor ${B} at layer "${_.name}". The following previous layers were accessed without issue: ${D}`);for(let B of L.outputTensors)I.push(B);D.push(_.name)}}this.nodesByDepth=x;let R=this.layers.map(A=>A.name);for(let A of R){let L=R.filter(_=>_===A).length;if(L!==1)throw new ns(`The name "${A}" is used ${L} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(R))}this.outboundNodes=[],this.inboundNodes=[],new lm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(A=>null),outputMasks:this.outputs.map(A=>null),inputShapes:this.inputs.map(A=>A.shape),outputShapes:this.outputs.map(A=>A.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new Q("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let r={},s=0;for(let l of this.layers)for(let h of l.weights){if(r[h.originalName]!=null)throw new Q(`Duplicate weight name: ${h.originalName}`);r[h.originalName]=h,s++}let u=[];for(let l in t){let h=l;if(r[l]==null){let p=l.split("/"),m=p.slice(0,-2).concat([p[p.length-1]]);h=m.join("/")}if(r[h]!=null)u.push([r[h],t[l]]);else if(e)throw new Q(`Provided weight data has no target variable: ${l}`);delete r[h]}if(e){let l=[];for(let h in r)l.push(h);if(l.length>0)throw new Q(`${l.length} of ${s} weights are not set: ${l}`)}ww(u)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${bm}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let r=Ew(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return ot(()=>{t=Ge(t);let r=new wa;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Xh(this.outputs,r,e)})}computeMask(t,e){return ot(()=>{t=Ge(t);let r;return e==null?r=Ti(null,t.length):r=Ge(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let e=um(t);if(e.length!==this.inputLayers.length)throw new Q(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let h=0;h<e.length;h++){let p=this.inputLayers[h],m=e[h],y=p.name+"_0_0";r[y]=m}let s=Object.keys(this.nodesByDepth).map(h=>parseInt(h,10)).sort(Xd);if(s.length>1)for(let h of s){let p=this.nodesByDepth[h];for(let m of p){let y=m.outboundLayer;if(this.inputLayers.map(I=>I.id).indexOf(y.id)!==-1)continue;let b=[];for(let I=0;I<m.inboundLayers.length;I++){let D=m.inboundLayers[I],R=m.nodeIndices[I],A=m.tensorIndices[I],L=`${D.name}_${R}_${A}`,_=r[L];b.push(_)}let x=y.computeOutputShape(gr(b)),S=um(x),C=y.inboundNodes.indexOf(m);for(let I=0;I<S.length;I++){let D=`${y.name}_${C}_${I}`;r[D]=S[I]}}}let u=[],l=[];for(let h=0;h<this.outputLayers.length;h++){let p=this.outputLayers[h],m=this.outputLayersNodeIndices[h],y=this.outputLayersTensorIndices[h],b=`${p.name}_${m}_${y}`;l.push(b)}for(let h=0;h<l.length;h++){let p=l[h];Vr(p in r),u.push(r[p])}return gr(u)}runInternalGraph(t,e){e==null&&(e=Ti(null,t.length));let r={};for(let p=0;p<this.inputs.length;++p){let m=this.inputs[p],y=t[p],b=e[p];r[m.id]=[y,b]}let s=Object.keys(this.nodesByDepth).map(p=>parseInt(p,10)).sort(Xd);for(let p of s){let m=this.nodesByDepth[p];for(let y of m){let b=y.outboundLayer,x=y.inputTensors,S=y.outputTensors,C=new Array;for(let I of x)I.id in r&&C.push(r[I.id]);if(C.length===x.length){let I={},D,R,A,L;if(y.callArgs!=null&&(I=y.callArgs),C.length===1){let[_,B]=C[0];I.mask==null&&(I.mask=B),A=Ge(b.call(_,I)),L=Ge(b.computeMask(_,B)),D=[_],R=[B]}else D=C.map(_=>_[0]),R=C.map(_=>_[1]),I.mask==null&&(I.mask=R),A=Ge(b.call(D,I)),L=Ge(b.computeMask(D,R));if(b.activityRegularizer)throw new Zt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<S.length;++_){let B=S[_],V=A[_],q=L[_];r[B.id]=[V,q]}}}}let u=[],l=[],h=[];for(let p of this.outputs){Vr(p.id in r,`Could not compute output ${p.name} : ${p.id}`);let[m,y]=r[p.id];h.push(m.shape),u.push(m),l.push(y)}return[u,l,h]}buildNodeConversionMap(t){let e={},r;for(let s of this.layers){r=s instanceof Cs?1:0;for(let u=0;u<s.inboundNodes.length;u++){let l=Cs.nodeKey(s,u);this.containerNodes.has(l)&&(e[l]=r,r+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new Q(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new Q("Provide either a layer name or layer index");for(let r of this.layers)if(r.name===t)return r;throw new Q(`No such layer: ${t}`)}calculateLosses(){return ot(()=>{let t=[];for(let e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){let s=Cs.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(let l of this.layers){let h=l.getClassName(),p=l.getConfig(),m=[];for(let b=0;b<l.inboundNodes.length;b++){let x=l.inboundNodes[b],S=Cs.nodeKey(l,b),C={};if(this.containerNodes.has(S)){if(x.callArgs)try{JSON.stringify(x.callArgs),C=x.callArgs}catch(I){console.warn(`Layer ${l.name} was passed non-serializable keyword arguments: ${x.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),C={}}if(x.inboundLayers.length>0){let I=[];for(let D=0;D<x.inboundLayers.length;D++){let R=x.inboundLayers[D],A=x.nodeIndices[D],L=x.tensorIndices[D],_=Cs.nodeKey(R,A),B=e[_];B==null&&(B=0),I.push([R.name,B,L,C])}m.push(I)}}}let y={};y.name=l.name,y.className=h,y.config=p,y.inboundNodes=m,r.push(y)}t.layers=r;let s=[];for(let l=0;l<this.inputLayers.length;l++){let h=this.inputLayers[l],p=this.inputLayersNodeIndices[l],m=Cs.nodeKey(h,p);if(!this.containerNodes.has(m))continue;let y=e[m];y==null&&(y=0);let b=this.inputLayersTensorIndices[l];s.push([h.name,y,b])}t.inputLayers=s;let u=[];for(let l=0;l<this.outputLayers.length;l++){let h=this.outputLayers[l],p=this.outputLayersNodeIndices[l],m=Cs.nodeKey(h,p);if(!this.containerNodes.has(m))continue;let y=e[m];y==null&&(y=0);let b=this.outputLayersTensorIndices[l];u.push([h.name,y,b])}return t.outputLayers=u,t}static fromConfig(t,e,r={},s=!1){let u={},l={};function h(D,R){D.name in l?l[D.name].push(R):l[D.name]=[R]}function p(D,R){let A=[],L;for(let _ of R){let B=_[0],V=_[1],q=_[2];if(L=_[3]==null?{}:_[3],!(B in u)){h(D,R);return}let j=u[B];if(j.inboundNodes.length<=V){h(D,R);return}let et=j.inboundNodes[V];A.push(et.outputTensors[q])}A.length>0&&D.apply(gr(A),L)}function m(D){let R=D.name,A=Ss(D,e.customObjects!=null?e.customObjects:{});A.setFastWeightInitDuringBuild(s),u[R]=A;let L=D.inboundNodes;L.forEach(_=>{if(!(_ instanceof Array))throw new Q(`Corrupted configuration, expected array for nodeData: ${_}`);h(A,_)})}let y=e.name,b=e.layers;for(let D of b)m(D);for(;!uV(l);)for(let D of b){let R=u[D.name];if(R.name in l){let A=l[R.name];delete l[R.name];for(let L of A)p(R,L)}}let x=[],S=[],C=e.inputLayers;for(let D of C){let R=D[0],A=D[1],L=D[2];Vr(R in u);let _=u[R],B=_.inboundNodes[A].outputTensors;x.push(B[L])}let I=e.outputLayers;for(let D of I){let R=D[0],A=D[1],L=D[2];Vr(R in u);let _=u[R],B=_.inboundNodes[A].outputTensors;S.push(B[L])}return new t({inputs:x,outputs:S,name:y})}get stateful(){if(this._stateful)throw new Q("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ot(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function ON(n,t,e){let r=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(s=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){let s=[];return t.forEach(u=>{u in n?s.push(n[u]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function MN(n,t){return ON(n,t,"classWeight")}function eft(n,t){return ON(n,t,"sampleWeight")}async function LN(n,t,e,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let s=ot(()=>{if(n.shape.length===1)return n.clone();if(n.shape.length===2)if(n.shape[1]>1){let h=1;return n.argMax(h)}else{if(n.shape[1]===1)return n.reshape([n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),u=Array.from(await s.data());oe(s);let l=[];return u.forEach(h=>{if(e[h]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${h} exists in the data but not in classWeight`);l.push(e[h])}),Ir(l,"float32")}else return null}function _U(n,t){return st(n,t)}let FU=32;function BN(n,t){let e,r,s=t;e=s.xs,r=s.ys,k(e!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let u=zN("input",n.inputNames,e),l=zN("output",n.outputNames,r),h=u[0].shape[0];k(u.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${u.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),k(l.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${l.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let p=0;p<u.length;p++)k(u[p].shape[0]===h,()=>`Batch size mismatch: input ${n.inputNames[p]} has ${u[p].shape[0]}; expected  ${h} based on input ${n.inputNames[0]}.`);for(let p=0;p<l.length;p++)k(l[p].shape[0]===h,()=>`Batch size mismatch: output ${n.outputNames[p]} has ${l[p].shape[0]}; expected  ${h} based on input ${n.inputNames[0]}.`);return{xs:u,ys:l}}function zN(n,t,e){if(e instanceof at)return[e];if(Array.isArray(e))return k(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{let r=[];for(let s of t){if(e[s]==null)throw new Q(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function RU(n){if(n.length===3)throw new Zt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function PU(n,t,e){let r=e.batchesPerEpoch!=null;if(k(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),k(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),k(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),k(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),k(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{let s=e.validationData!=null,u,l;if(s)if(WN(e.validationData))k(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let D=RU(e.validationData);u=D.xs,l=D.ys}let h=n.makeTrainFunction(),p=n.getDedupedMetricsNames(),m;s?m=p.slice().concat(p.map(D=>"val_"+D)):m=p.slice();let y=SN(e.callbacks,e.yieldEvery),b=e.verbose==null?1:e.verbose,{callbackList:x,history:S}=CN(y,b,e.epochs,null,null,OU(t,e),null,s,m);x.setModel(n),n.history=S,await x.onTrainBegin(),n.stopTraining_=!1;let C=e.initialEpoch==null?0:e.initialEpoch,I=await t.iterator();for(;C<e.epochs;){let D={};await x.onEpochBegin(C);let R=0,A=0;for(r||(I=await t.iterator());r?R<e.batchesPerEpoch:!0;){let L=await I.next();if(r&&L.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${R} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(L.value!=null){let{xs:_,ys:B}=BN(n,L.value),V={};V.batch=A,V.size=_[0].shape[0],await x.onBatchBegin(A,V);let q=[];if(e.classWeight!=null){let tt=MN(e.classWeight,n.outputNames);for(let ht=0;ht<tt.length;++ht)q.push(await LN(B[ht],null,tt[ht]))}let j=_.concat(B).concat(q),et=h(j);oe(j);for(let tt=0;tt<p.length;++tt){let ht=p[tt],gt=et[tt];V[ht]=gt,An(gt)}await x.onBatchEnd(A,V),bN(V),A++,R++}if(r?R>=e.batchesPerEpoch:L.done){if(s){let _;WN(e.validationData)?_=Ge(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):_=Ge(n.evaluate(u,l,{batchSize:e.validationBatchSize==null?FU:e.validationBatchSize,verbose:0}));for(let B=0;B<n.metricsNames.length;++B)D[`val_${n.metricsNames[B]}`]=_[B]}break}if(n.stopTraining_)break}if(await x.onEpochEnd(C,D),C++,n.stopTraining_)break}return await x.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function OU(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function WN(n){return typeof n.iterator=="function"}function MU(n){return typeof n.next=="function"}async function LU(n,t,e){e=e||{};let r=e.batches!=null,s=n.testFunction,u=[];if(e.verbose>0)throw new Zt("Verbose mode is not implemented yet.");k(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let l=MU(t)?t:await t.iterator(),h=0,p=0;for(;r?p<e.batches:!0;){let m=await l.next();if(u=ot(()=>{if(m.value){let{xs:y,ys:b}=BN(n,m.value),x=y.concat(b),S=ot(()=>s(x));if(oe(x),p===0)for(let I=0;I<S.length;++I)u.push(Ot(0));let C=x[0].shape[0];for(let I=0;I<S.length;++I){let D=S[I],R=u[I];u[I]=ot(()=>Nt(u[I],st(C,D))),p>0&&oe(R)}oe(S),h+=C,++p}return u}),m.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let m=0;m<u.length;++m){let y=u[m];u[m]=Ht(u[m],h),oe(y)}return gr(u)}function $w(n){k(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Yh(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(r=>Ci(r,t,e-t)):Ci(n,t,e-t)}function Aw(n,t){return ot(()=>n==null?null:Array.isArray(n)?n.map(e=>Aw(e,t)):hN(n,t.dtype==="int32"?t:t.toInt()))}function _w(n,t){let e=[],r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}async function BU(n,t,e,r,s,u,l,h,p,m,y,b,x,S,C){s==null&&(s=32),u==null&&(u=1),y==null&&(y=!0),x==null&&(x=0);let I=!1;if(p!=null&&m!=null&&(I=!0),C!=null&&(I=!0,S==null))throw new Q("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let D=n.checkNumSamples(e,s,S,"steps_per_epoch"),R;D!=null&&(R=xs(0,D)),l==null&&(l=1);let{callbackList:A,history:L}=CN(h,l,u,x,D,S,s,I,b);A.setModel(n),n.history=L,await A.onTrainBegin(),n.stopTraining_=!1;for(let _=x;_<u;++_){await A.onEpochBegin(_);let B={};if(S!=null)throw new Zt("stepsPerEpoch mode is not implemented yet.");{if(y==="batch")throw new Zt("batch shuffling is not implemneted yet");y&&g(R);let V=Ir(R),q=_w(D,s);for(let j=0;j<q.length;++j){let et={};if(await A.onBatchBegin(j,et),ot(()=>{let tt=q[j][0],ht=q[j][1],gt=Ci(V,tt,ht-tt);et.batch=j,et.size=ht-tt;let vt=Aw(e,gt),bt=t(vt);for(let yt=0;yt<r.length;++yt){let mt=r[yt],xt=bt[yt];et[mt]=xt,An(xt)}if(j===q.length-1&&I){let yt=n.testLoop(p,m,s);for(let mt=0;mt<r.length;++mt){let xt=r[mt],wt=yt[mt];An(wt),B["val_"+xt]=wt}}}),await A.onBatchEnd(j,et),bN(et),n.stopTraining_)break}V.dispose()}if(await A.onEpochEnd(_,B),n.stopTraining_)break}return await A.onTrainEnd(),await n.history.syncData(),n.history}async function zU(n,t,e,r={}){if(n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;let s,u,l,h,p,m,y;try{let b=r.batchSize==null?32:r.batchSize;$w(b);let x=!1,S=await n.standardizeUserData(t,e,r.sampleWeight,r.classWeight,x,b);s=S[0],u=S[1],y=S[2];let C=!1,I;if(r.validationData!=null&&r.validationData.length>0){if(C=!0,r.validationData.length===2)l=r.validationData[0],h=r.validationData[1];else throw r.validationData.length===3?new Zt("validationData including sample weights is not supported yet."):new Q(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);let q=!0,j=await n.standardizeUserData(l,h,null,null,q,b);p=j[0],m=j[1],I=p.concat(m)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){C=!0;let q=Math.floor(s[0].shape[0]*(1-r.validationSplit)),j=s[0].shape[0];p=Yh(s,q,j),s=Yh(s,0,q),m=Yh(u,q,j),u=Yh(u,0,q),I=p.concat(m)}else r.validationSteps!=null&&(C=!0);let D=s.concat(u).concat(y);n.checkTrainableWeightsConsistency();let R=n.makeTrainFunction(),A=n.getDedupedMetricsNames(),L,_;C?(n.makeTestFunction(),L=n.testFunction,_=A.slice().concat(A.map(q=>"val_"+q))):(L=null,I=[],_=A.slice());let B=SN(r.callbacks,r.yieldEvery),V=await BU(n,R,D,A,b,r.epochs,r.verbose,B,L,I,r.shuffle,_,r.initialEpoch,null,null);return V}finally{n.isTraining=!1,Ni(s,t),Ni(u,e),Ni(p,l),Ni(m,h),y!=null&&oe(y)}}function VN(n){let t=[];n instanceof at&&(n=[n]);for(let e=0;e<n.length;++e){let r=n[e];if(r.rank===1)t.push(Gh(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ni(n,t){if(n==null)return;let e=[];if(t instanceof at)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(t!=null)for(let s in t){let u=t[s];e.push(u.id)}let r=[];if(n instanceof at)e.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{e.indexOf(s.id)===-1&&r.push(s)});else if(n!=null)for(let s in n){let u=n[s];e.indexOf(u.id)===-1&&r.push(u)}r.forEach(s=>{s.isDisposed||s.dispose()})}function WU(n){return n instanceof at}function Fw(n){return Array.isArray(n)}function UN(n){return!WU(n)&&!Fw(n)}function GN(n,t,e,r=!0,s=""){if(t==null||t.length===0){if(n!=null){let l=!1;if(Fw(n)&&n.length>0)l=!0;else if(UN(n)){for(let h in n)if(n.hasOwnProperty(h)){l=!0;break}}else l=!0;if(l)throw new Q(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(l=>null);let u;if(UN(n)){n=n,u=[];for(let l of t){if(n[l]==null)throw new Q(`No data provided for "${l}". Need data for each key in: ${t}`);u.push(n[l])}}else if(Fw(n)){if(n=n,n.length!==t.length)throw new Q(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);u=n}else{if(n=n,t.length>1)throw new Q(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);u=[n]}if(u=VN(u),e!=null)for(let l=0;l<t.length;++l){if(e[l]==null)continue;let h=u[l];if(h.shape.length!==e[l].length)throw new Q(`Error when checking ${s}: expected ${t[l]} to have ${e[l].length} dimension(s). but got array with shape ${h.shape}`);for(let p=0;p<e[l].length;++p){if(p===0&&!r)continue;let m=h.shape[p],y=e[l][p];if(y!=null&&y>=0&&m!==y)throw new Q(`Error when checking ${s}: expected ${t[l]} to have shape [${e[l]}], but got array with shape [${h.shape}].`)}}return u}function VU(n,t,e){let r=ma(n.map(u=>u.shape[0]));r.sort();let s=ma(t.map(u=>u.shape[0]));if(s.sort(),r.length>1)throw new Q(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(u=>u.shape))}`);if(s.length>1)throw new Q(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(u=>u.shape))}`);if(r.length>0&&s.length>0&&!K(r,s))throw new Q(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function UU(n,t,e){let r=[No,pm,jh];for(let s=0;s<n.length;++s){let u=n[s],l=t[s],h=e[s];if(l==null)continue;if(l===jh&&u.shape[u.shape.length-1]===1)throw new Q(`You are passing a target array of shape ${u.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(l)!==-1){let p=u.shape.slice(1),m=h.slice(1);for(let y=0;y<p.length;++y){let b=p[y],x=m[y];if(x!=null&&b!==x)throw new Q(`A target Tensor with shape ${u.shape} was passed for an output of shape ${h}, while using a loss function that expects targets to have the same shape as the output.`)}}}}function HN(n,t,e,r=!0,s=""){let u;if(Array.isArray(n)){if(n.length!==t.length)throw new Q(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);u=n}else{if(t.length>1)throw new Q(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);u=[n]}if(e!=null)for(let l=0;l<t.length;++l){if(e[l]==null)continue;let h=u[l];if(h.shape.length!==e[l].length)throw new Q(`Error when checking ${s}: expected ${t[l]} to have ${e[l].length} dimension(s), but got array with shape ${JSON.stringify(h.shape)}`);for(let p=0;p<e[l].length;++p){if(p===0&&!r)continue;let m=h.shape[p],y=e[l][p];if(y!=null&&y!==m)throw new Q(`Error when checking ${s}: expected ${t[l]} to have shape ${JSON.stringify(e[l])} but got array with shape ${JSON.stringify(h.shape)}.`)}}}function GU(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(r=>e);{let r=[];for(let s of t){let u=e.hasOwnProperty(s)?e[s]:[];Array.isArray(u)||(u=[u]),r.push(u)}return r}}let HU="layers-model";class Io extends Cs{constructor(t){super(t);this.isTraining=!1}summary(t,e,r=console.log){if(!this.built)throw new Q("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");kU(this,t,e,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=TU(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof ko))throw new Q("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let l in t.loss)if(this.outputNames.indexOf(l)===-1)throw new Q(`Unknown entry in loss dictionary: "${l}". Only expected the following keys: ${this.outputNames}`);for(let l of this.outputNames)t.loss[l]==null&&console.warn(`Output "${l}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${l} during training`),e.push(kw(t.loss[l]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new Q(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);let l=t.loss;e=l.map(h=>kw(h))}else{let l=kw(t.loss);this.outputs.forEach(h=>{e.push(l)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let l=0;l<this.outputs.length;++l){let h=this.internalOutputShapes[l],p=this.outputNames[l];this.feedOutputNames.push(p),this.feedOutputShapes.push(h),this.feedLossFns.push(this.lossFunctions[l])}let r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Si("loss",()=>{for(let l=0;l<this.outputs.length;++l){if(r.indexOf(l)!==-1)continue;let h=this.lossFunctions[l];this.outputs.length>1&&(this.metricsTensors.push([h,l]),this.metricsNames.push(this.outputNames[l]+"_loss"))}});let s=GU(t.metrics,this.outputNames),u=(l,h,p)=>{this.outputNames.length>1&&(h=this.outputNames[l]+"_"+h),this.metricsNames.push(h),this.metricsTensors.push([p,l])};Si("metric",()=>{for(let l=0;l<this.outputs.length;++l){if(r.indexOf(l)!==-1)continue;let h=s[l],p=m=>{let y="",b,x,S;for(let C of m){if(typeof C=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(C)!==-1){let D=this.internalOutputShapes[l];D[D.length-1]===1||this.lossFunctions[l]===pm?["accuracy","acc"].indexOf(C)!==-1?x=Sw:["crossentropy","ce"].indexOf(C)!==-1&&(x=EN):this.lossFunctions[l]===fm?["accuracy","acc"].indexOf(C)!==-1?x=DN:["crossentropy","ce"].indexOf(C)!==-1&&(x=$N):["accuracy","acc"].indexOf(C)!==-1?x=Cw:["crossentropy","ce"].indexOf(C)!==-1&&(x=Nw);let R;["accuracy","acc"].indexOf(C)!==-1?R="acc":["crossentropy","ce"].indexOf(C)!==-1&&(R="ce"),S=x,b=y+R}else{let D=xU(C);S=D,b=y+vm(C)}let I;Si(b,()=>{I=S}),u(l,b,I)}};p(h)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){if(this.collectedTrainableWeights==null)return;this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,r={}){let s=r.batchSize==null?32:r.batchSize;$w(s);let u=!0,l=this.standardizeUserDataXY(t,e,u,s);try{let h=l[0].concat(l[1]);this.makeTestFunction();let p=this.testFunction,m=this.testLoop(p,h,s,r.verbose,r.steps);return gr(m)}finally{Ni(l[0],t),Ni(l[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),LU(this,t,e)}checkNumSamples(t,e,r,s="steps"){let u;if(r!=null){if(u=null,e!=null)throw new Q(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?u=t[0].shape[0]:u=t.shape[0];else throw new Q(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return u}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new Q("`outputs` is an empty Array, which is not allowed.");let r=Array.isArray(e),s=r?e:[e],u=this.retrieveSymbolicTensors(s),l=new wa;if(t instanceof at&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new Q(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let p=0;p<this.inputs.length;++p)l.add(this.inputs[p],t[p])}else for(let p of this.inputs){let m=t[p.name];if(m==null)throw new Q(`No value is provided for the model's input ${p.name}`);l.add(p,m)}let h=Xh(u,l);return r?h:h[0]}retrieveSymbolicTensors(t){let e=Ti(null,t.length),r=t.length;for(let s of this.layers){let u=Array.isArray(s.output)?s.output:[s.output],l=u.map(h=>h.name);for(let h=0;h<t.length;++h){let p=l.indexOf(t[h]);if(p!==-1&&(e[h]=u[p],r--),r===0)break}if(r===0)break}if(r>0){let s=[];throw e.forEach((u,l)=>{u==null&&s.push(t[l])}),new Q(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return e}predictLoop(t,e=32,r=!1){return ot(()=>{let s=this.checkNumSamples(t);if(r)throw new Zt("Verbose predictLoop() is not implemented yet.");let u=_w(s,e),l=this.outputs.map(h=>[]);for(let h=0;h<u.length;++h){let p=ot(()=>{let m=u[h][0],y=u[h][1],b=Yh(t,m,y),x=[];if(Array.isArray(b))for(let C=0;C<b.length;++C)x.push({key:this.inputs[C],value:b[C]});else x.push({key:this.inputs[0],value:b});let S=new wa(x);return Xh(this.outputs,S)});p.forEach((m,y)=>l[y].push(m))}return gr(l.map(h=>sn(h,0)))})}predict(t,e={}){let r=VN(t);HN(r,this.inputNames,this.feedInputShapes,!1);try{let s=e.batchSize==null?32:e.batchSize;return $w(s),this.predictLoop(r,s)}finally{Ni(r,t)}}predictOnBatch(t){HN(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,r=!0,s){if(this.optimizer_==null)throw new ns("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let u=[];for(let l=0;l<this.feedOutputShapes.length;++l){let h=this.feedOutputShapes[l],p=this.feedLossFns[l];p===fm?u.push(h.slice(0,h.length-1).concat([1])):u.push(h)}if(t=GN(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=GN(e,this.feedOutputNames,u,!1,"target"),VU(t,e,null),UU(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!==0)throw new Q(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,r,s,u=!0,l){let[h,p]=this.standardizeUserDataXY(t,e,u,l);if(r!=null)throw new Error("sample weight is not supported yet.");let m=null;if(s!=null){let y=MN(s,this.outputNames);m=[];for(let b=0;b<y.length;++b)m.push(await LN(p[b],null,y[b]))}return[h,p,m]}testLoop(t,e,r,s=0,u){return ot(()=>{let l=this.checkNumSamples(e,r,u,"steps"),h=[];if(s>0)throw new Zt("Verbose mode is not implemented yet.");if(u!=null)throw new Zt("steps mode in testLoop() is not implemented yet");{let p=_w(l,r),m=Ir(xs(0,l));for(let y=0;y<p.length;++y){let b=p[y][0],x=p[y][1],S=Ci(m,b,x-b),C=Aw(e,S),I=t(C);if(y===0)for(let D=0;D<I.length;++D)h.push(Ot(0));for(let D=0;D<I.length;++D){let R=I[D];h[D]=Nt(h[D],st(x-b,R))}}for(let y=0;y<h.length;++y)h[y]=Ht(h[y],l)}return h})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let r=0;r<t.length;++r){let s=t[r],u=s;if(QC(t,s)>1){let l=QC(t.slice(0,r),s);u+=`_${l}`}e.push(u)}return e}makeTrainFunction(){return t=>{let e=[],r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),u=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),l=[],h=()=>{let b=[];for(let I=0;I<this.inputs.length;++I)b.push({key:this.inputs[I],value:r[I]});let x=new wa(b),S=Xh(this.outputs,x,{training:!0}),C;for(let I=0;I<this.lossFunctions.length;++I){let D=this.lossFunctions[I],R=D(s[I],S[I]);u[I]!=null&&(R=_U(R,u[I]));let A=an(R);e.push(A),I===0?C=R:C=Nt(C,R)}for(let I=0;I<this.metricsTensors.length;++I){let D;if(this.outputs.length>1&&I<this.outputs.length)D=e[I];else{let R=this.metricsTensors[I][0],A=this.metricsTensors[I][1];D=an(R(s[A],S[A]))}An(D),l.push(D)}return C=an(C),this.calculateLosses().forEach(I=>{C=Nt(C,I)}),C},p=this.collectedTrainableWeights.map(b=>b.read()),m=!0,y=this.optimizer_.minimize(h,m,p);return[y].concat(l)}}makeTestFunction(){this.testFunction=t=>ot(()=>{let e=[],r,s=t.slice(0,this.inputs.length),u=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),l=[];for(let m=0;m<this.inputs.length;++m)l.push({key:this.inputs[m],value:s[m]});let h=new wa(l),p=Xh(this.outputs,h);for(let m=0;m<this.lossFunctions.length;++m){let y=this.lossFunctions[m],b=an(y(u[m],p[m]));m===0?r=b:r=Nt(r,b),e.push(r)}for(let m=0;m<this.metricsTensors.length;++m){let y=this.metricsTensors[m][0],b=this.metricsTensors[m][1],x=an(y(u[b],p[b]));e.push(x)}return e})}async fit(t,e,r={}){return zU(this,t,e,r)}async fitDataset(t,e){return PU(this,t,e)}async trainOnBatch(t,e){let r=await this.standardizeUserData(t,e),s=r[0],u=r[1],l=this.makeTrainFunction(),h=l(s.concat(u)),p=[];for(let m of h){let y=await m.data();p.push(y[0])}return oe(h),gr(p)}getNamedWeights(t){let e=[],r=t!=null&&t.trainableOnly,s=r?this.trainableWeights:this.weights,u=this.getWeights(r);for(let l=0;l<s.length;++l){if(r&&!s[l].trainable)continue;e.push({name:s[l].originalName,tensor:u[l]})}return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=id().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-id().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Co(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Co(e))}else{let e=Object.keys(this.loss);t={};let r=this.loss;for(let s of e)if(typeof r[s]=="string")t[s]=Co(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Co(vm(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Co(vm(t)));{let t={};for(let e in this.metrics)t[e]=Co(vm(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=Kh(t.optimizer_config),r=Ss(e),s;if(typeof t.loss=="string")s=ki(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(l=>ki(l));else if(t.loss!=null){s={};for(let l in t.loss)s[l]=ki(t.loss[l])}let u;if(Array.isArray(t.metrics))u=t.metrics.map(l=>ki(l));else if(t.metrics!=null){u={};for(let l in t.metrics)u[l]=ki(t.metrics[l])}this.compile({loss:s,metrics:u,optimizer:r})}async save(t,e){if(typeof t=="string"){let m=Ey(t);if(m.length===0)throw new Q(`Cannot find any save handlers for URL '${t}'`);if(m.length>1)throw new Q(`Found more than one (${m.length}) save handlers for URL '${t}'`);t=m[0]}if(t.save==null)throw new Q("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let r=await Ny(this.getNamedWeights(e)),s=!1,u=null,l=this.toJSON(u,s),h={modelTopology:l,format:HU,generatedBy:`TensorFlow.js tfjs-layers v${bm}`,convertedBy:null},p=e==null?!1:e.includeOptimizer;if(p&&this.optimizer!=null){h.trainingConfig=this.getTrainingConfig();let m="optimizer",{data:y,specs:b}=await Ny(await this.optimizer.getWeights(),m);r.specs.push(...b),r.data=Zp([r.data,y])}if(this.userDefinedMetadata!=null){let m=!0;_N(this.userDefinedMetadata,this.name,m),h.userDefinedMetadata=this.userDefinedMetadata}return h.weightData=r.data,h.weightSpecs=r.specs,t.save(h)}setUserDefinedMetadata(t){_N(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Io.className="Model",kt(Io);class qN extends Io{}qN.className="Functional",kt(qN);async function qU(n,t){"modelTopology"in n||(n={modelTopology:n}),n=n;let e=n.modelTopology;e.model_config!=null&&(e=e.model_config);let r=Kh(e),s=Ss(r,t);if(n.weightsManifest!=null){let u=await bS(n.weightsManifest,n.pathPrefix,s.weights.map(h=>h.originalName)),l={};for(let h of s.weights)l[h.originalName]=u[h.originalName];s.loadWeights(l),oe(u)}return s}async function jU(n,t){if(t==null&&(t={}),typeof n=="string"){let e=Dy(n,t);if(e.length===0)e.push(ed(n,t));else if(e.length>1)throw new Q(`Found more than one (${e.length}) load handlers for URL '${n}'`);n=e[0]}return KU(n,void 0,t)}async function KU(n,t,e){if(e==null&&(e={}),n.load==null)throw new Q("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await n.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let u=e.strict==null?!0:e.strict,l=r.weightData!=null&&r.weightSpecs!=null&&u,h=Ss(Kh(s),t,l),p=r.trainingConfig;if(p!=null&&h.loadTrainingConfig(p),r.userDefinedMetadata!=null&&h.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new Q("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:m,optimizerWeights:y}=XU(r.weightData,r.weightSpecs);h.loadWeights(m,u),h.optimizer!=null&&y.length>0&&await h.optimizer.setWeights(y),oe(m),oe(y.map(b=>b.tensor))}return h}function XU(n,t){let e=Jp(n,t),r={},s=[];return t.forEach(u=>{u.group==="optimizer"?s.push({name:u.name,tensor:e[u.name]}):r[u.name]=e[u.name]}),{modelWeights:r,optimizerWeights:s}}class Ii extends Io{constructor(t){super({inputs:[],outputs:[]});if(t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:im("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){let e=t.inboundNodes[0].outputTensors[0].shape;if(e.some(r=>r<0))throw new Q(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Ii||t instanceof Io,r;if(e){if(r=t,r.outputs.length!==1)throw new Q("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new Q("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new Q("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=yN({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(e)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new Q(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new Q("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=vN(this.outputs[0])}this.inboundNodes=[],new lm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ti(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(Be(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Io({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,r=console.log){this.built||this.build(),super.summary(t,e,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,r={}){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.evaluate(t,e,r)}async evaluateDataset(t,e){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,r={}){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.fit(t,e,r)}async fitDataset(t,e){if(!this.built)throw new ns("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,r={},s=!1){let u,l={};if(e instanceof Array){if(!(e[0].className!=null)||e[0].className==="Merge")throw new Q("Legacy serialization format not supported yet.");u=e}else k(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),u=e.layers,delete e.layers,l=e;let h=new t(l);if(!(h instanceof Ii))throw new Zt(`Sequential.fromConfig called on non-Sequential input: ${h}`);for(let p of u){let m=void 0,y=Ss(p,m,s);s&&y.setFastWeightInitDuringBuild(!0),h.add(y)}return h}set stopTraining(t){if(this.model==null)throw new Q("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new Q("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let r={};r.className=e.getClassName(),r.config=e.getConfig(),t.push(r)}return{name:this.name,layers:t}}}Ii.className="Sequential",kt(Ii);function YU(n){return new Io(n)}function JU(n){return new Ii(n)}function ZU(n,t){return t==null&&(t={}),jU(n,t)}function jN(n){return yN(n)}function QU(n,t){Gr.registerCallbackConstructor(n,t)}class Dr extends li{getConfig(){return{}}}class KN extends Dr{apply(t,e=1){return IV(t,e)}}KN.className="elu",kt(KN);class XN extends Dr{apply(t){return Ed(t)}}XN.className="selu",kt(XN);class YN extends Dr{apply(t){return Ys(t)}}YN.className="relu",kt(YN);class JN extends Dr{apply(t){return ot(()=>mi(6,Ys(t)))}}JN.className="relu6",kt(JN);class ZN extends Dr{apply(t){return t}}ZN.className="linear",kt(ZN);class QN extends Dr{apply(t){return js(t)}}QN.className="sigmoid",kt(QN);class tI extends Dr{apply(t){return DV(t)}}tI.className="hardSigmoid",kt(tI);class eI extends Dr{apply(t){return Ru(t)}}eI.className="softplus",kt(eI);class nI extends Dr{apply(t){return EV(t)}}nI.className="softsign",kt(nI);class rI extends Dr{apply(t){return Du(t)}}rI.className="tanh",kt(rI);class Rw extends Dr{apply(t,e=-1){return bi(t,e)}}Rw.className="softmax",kt(Rw);class sI extends Dr{apply(t,e=-1){return Td(t,e)}}sI.className="logSoftmax",kt(sI);class oI extends Dr{apply(t,e=1){return ot(()=>js(t.mul(e)).mul(t))}}oI.className="swish",kt(oI);function xa(n){return n.getClassName()}function Pw(n,t={}){return zh(n,Lr.getMap().classNameMap,t,"activation")}function Ta(n){if(n==null){let t={};return t.className="linear",t.config={},Pw(t)}if(typeof n=="string"){let t={};return t.className=n,t.config={},Pw(t)}else return n instanceof Dr?n:Pw(n)}function Ow(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class aI extends li{}class Jh extends aI{constructor(t){super();Ow(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return ot(()=>{let e=Se([1]);return this.hasL1&&(e=Nt(e,Xt(st(this.l1,kn(t))))),this.hasL2&&(e=Nt(e,Xt(st(this.l2,Hh(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}Jh.className="L1L2",kt(Jh);function tG(n){return Ow(n),new Jh({l1:n!=null?n.l1:null,l2:0})}function eG(n){return Ow(n),new Jh({l2:n!=null?n.l2:null,l1:0})}let iI={l1l2:"L1L2"};function ze(n){return Qb(n)}function uI(n,t={}){return zh(n,Lr.getMap().classNameMap,t,"regularizer")}function Ye(n){if(n==null)return null;if(typeof n=="string"){let t=n in iI?iI[n]:n,e={className:t,config:{}};return uI(e)}else return n instanceof aI?n:uI(n)}class Mw extends Te{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=le(t);let r=Ys(t);return this.maxValue!=null&&(r=fr(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}Mw.className="ReLU",kt(Mw);class Lw extends Te{constructor(t){super(t==null?{}:t);this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let r=le(t);return bd(r,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}Lw.className="LeakyReLU",kt(Lw);class Bw extends Te{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Xe(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ye(t.alphaRegularizer),this.alphaConstraint=In(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new Q(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=Be(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let r={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)r[s]=t[s];this.inputSpec=[new Fn({ndim:t.length,axes:r})],this.built=!0}call(t,e){return t=le(t),Sh(t,this.alpha.read())}getConfig(){let t={alphaInitializer:cn(this.alphaInitializer),alphaRegularizer:ze(this.alphaRegularizer),alphaConstraint:Nn(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}Bw.className="PReLU",kt(Bw);class zw extends Te{constructor(t){super(t==null?{}:t);if(this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Zt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let r=le(t);return $u(r)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}zw.className="ELU",kt(zw);class Ww extends Te{constructor(t){super(t==null?{}:t);this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let r=le(t);return r.mul(Uh(r.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}Ww.className="ThresholdedReLU",kt(Ww);class Vw extends Te{constructor(t){super(t==null?{}:t);this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new Rw().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let r=le(t);return this.softmax(r,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}Vw.className="Softmax",kt(Vw);function Ju(n,t,e){if(typeof n=="number")return Ti(n,t);if(n.length!==t)throw new Q(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){let s=n[r];if(!xV(s))throw new Q(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function Ns(n,t,e,r,s=1){if(n==null)return n;let u=t+(t-1)*(s-1),l;return e==="same"?l=n:l=n-u+1,Math.floor((l+r-1)/r)}function wm(n,t,e,r){if(n==null)return null;if(r==="valid")n=n*t+va([e-t,0]);else if(r==="same")n=n*t;else throw new Q(`Unsupport padding mode: ${r}.`);return n}function Uw(n,t){return ot(()=>(un(t),t==="channelsFirst"?re(n,[0,2,3,1]):n))}function cI(n,t){return ot(()=>(un(t),t==="channelsFirst"?re(n,[0,2,3,4,1]):n))}function lI(n,t,e,r=1,s="valid",u,l=1){return ot(()=>{if(u==null&&(u=ws()),un(u),n.shape.length!==3)throw new Q(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new Q(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new Q(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(u==="channelsFirst"&&(n=re(n,[0,2,1])),s==="causal")throw new Zt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let h=dd(n,t,r,s==="same"?"same":"valid","NWC",l);return e!=null&&(h=Qs(h,e)),h})}function nft(n,t,e=1,r="valid",s,u=1){return ot(()=>(un(s),lI(n,t,null,e,r,s,u)))}function rft(n,t,e=[1,1],r="valid",s,u){return ot(()=>(un(s),Gw(n,t,null,e,r,s,u)))}function Gw(n,t,e,r=[1,1],s="valid",u,l,h=null){return ot(()=>{if(u==null&&(u=ws()),un(u),n.rank!==3&&n.rank!==4)throw new Q(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new Q(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let p=Uw(n,u);if(s==="causal")throw new Zt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return p=Pb({x:p,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:l,dataFormat:"NHWC",bias:e,activation:h}),u==="channelsFirst"&&(p=re(p,[0,3,1,2])),p})}function sft(n,t,e=[1,1,1],r="valid",s,u){return ot(()=>(un(s),hI(n,t,null,e,r,s,u)))}function hI(n,t,e,r=[1,1,1],s="valid",u,l){return ot(()=>{if(u==null&&(u=ws()),un(u),n.rank!==4&&n.rank!==5)throw new Q(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new Q(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let h=cI(n,u);if(s==="causal")throw new Zt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return h=ab(h,t,r,s==="same"?"same":"valid","NDHWC",l),e!=null&&(h=Qs(h,e)),u==="channelsFirst"&&(h=re(h,[0,4,1,2,3])),h})}class xm extends Te{constructor(t,e){super(e);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",xm.verifyArgs(e),this.rank=t,_n(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Zt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ju(e.kernelSize,t,"kernelSize"),this.strides=Ju(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,Ur(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,un(this.dataFormat),this.activation=Ta(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Xe(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=In(e.biasConstraint),this.biasRegularizer=Ye(e.biasRegularizer),this.activityRegularizer=Ye(e.activityRegularizer),this.dilationRate=Ju(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Q(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Q(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Q(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Vr("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!ew(t.kernelSize,"number",1,3))throw new Q(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:xa(this.activation),useBias:this.useBias,biasInitializer:cn(this.biasInitializer),biasRegularizer:ze(this.biasRegularizer),activityRegularizer:ze(this.activityRegularizer),biasConstraint:Nn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Zu extends xm{constructor(t,e){super(t,e);this.kernel=null,Zu.verifyArgs(e),this.filters=e.filters,_n(this.filters,"filters"),this.kernelInitializer=Xe(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=In(e.kernelConstraint),this.kernelRegularizer=Ye(e.kernelRegularizer)}build(t){t=Be(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new Q(`The channel dimension of the input should be defined. Found ${t[e]}`);let r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return ot(()=>{t=le(t);let r,s=this.bias==null?null:this.bias.read(),u=eN(this.activation.getClassName());if(u!=null&&this.rank===2)r=Gw(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,u);else{if(this.rank===1)r=lI(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=Gw(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=hI(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Zt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Be(t);let e=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let u=0;u<r.length;++u){let l=Ns(r[u],this.kernelSize[u],this.padding,this.strides[u],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[u]);e.push(l)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){let t={filters:this.filters,kernelInitializer:cn(this.kernelInitializer),kernelRegularizer:ze(this.kernelRegularizer),kernelConstraint:Nn(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new Q(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class Qu extends Zu{constructor(t){super(2,t);Qu.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!ew(t.kernelSize,"number",1,2))throw new Q(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}Qu.className="Conv2D",kt(Qu);class Zh extends Zu{constructor(t){super(3,t);Zh.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new Q(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}Zh.className="Conv3D",kt(Zh);class Hw extends Qu{constructor(t){super(t);if(this.inputSpec=[new Fn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Q(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=Be(t),t.length!==4)throw new Q("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new Q("The channel dimension of the inputs should be defined. Found `None`.");let r=t[e],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Fn({ndim:4,axes:{[e]:r}})],this.built=!0}call(t,e){return ot(()=>{let r=le(t);if(r.shape.length!==4)throw new Q(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);let s=r.shape,u=s[0],l,h;this.dataFormat==="channelsFirst"?(l=2,h=3):(l=1,h=2);let p=s[l],m=s[h],y=this.kernelSize[0],b=this.kernelSize[1],x=this.strides[0],S=this.strides[1],C=wm(p,x,y,this.padding),I=wm(m,S,b,this.padding),D=[u,C,I,this.filters];this.dataFormat!=="channelsLast"&&(r=re(r,[0,2,3,1]));let R=md(r,this.kernel.read(),D,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(R=re(R,[0,3,1,2])),this.bias!=null&&(R=Qs(R,this.bias.read(),this.dataFormat)),this.activation!=null&&(R=this.activation.apply(R)),R})}computeOutputShape(t){t=Be(t);let e=t.slice(),r,s,u;this.dataFormat==="channelsFirst"?(r=1,s=2,u=3):(r=3,s=1,u=2);let l=this.kernelSize[0],h=this.kernelSize[1],p=this.strides[0],m=this.strides[1];return e[r]=this.filters,e[s]=wm(e[s],p,l,this.padding),e[u]=wm(e[u],m,h,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}}Hw.className="Conv2DTranspose",kt(Hw);class fI extends Zu{constructor(t,e){super(t,e);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new Q("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new Q("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new Q(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Xe(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ye(e.depthwiseRegularizer),this.depthwiseConstraint=In(e.depthwiseConstraint),this.pointwiseInitializer=Xe(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ye(e.pointwiseRegularizer),this.pointwiseConstraint=In(e.pointwiseConstraint)}build(t){if(t=Be(t),t.length<this.rank+2)throw new Q(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new Q(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let r=t[e],s=this.kernelSize.concat([r,this.depthMultiplier]),u=[];for(let h=0;h<this.rank;++h)u.push(1);u.push(r*this.depthMultiplier,this.filters);let l=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,l,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",u,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,l,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,l,this.biasConstraint):this.bias=null,this.inputSpec=[new Fn({ndim:this.rank+2,axes:{[e]:r}})],this.built=!0}call(t,e){return ot(()=>{t=le(t);let r;if(this.rank===1)throw new Zt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=re(t,[0,2,3,1])),r=Sb(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Qs(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=re(r,[0,3,1,2])),r})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=cn(this.depthwiseInitializer),t.pointwiseInitializer=cn(this.pointwiseInitializer),t.depthwiseRegularizer=ze(this.depthwiseRegularizer),t.pointwiseRegularizer=ze(this.pointwiseRegularizer),t.depthwiseConstraint=Nn(this.depthwiseConstraint),t.pointwiseConstraint=Nn(this.pointwiseConstraint),t}}fI.className="SeparableConv";class qw extends fI{constructor(t){super(2,t)}}qw.className="SeparableConv2D",kt(qw);class Qh extends Zu{constructor(t){super(1,t);Qh.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!ew(t.kernelSize,"number",1,1))throw new Q(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}Qh.className="Conv1D",kt(Qh);class jw extends Te{constructor(t){super(t);typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return ot(()=>{if(t=le(t),this.dataFormat==="channelsLast"){let r=Jd(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Jd(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let r=Jd(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Jd(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}jw.className="Cropping2D",kt(jw);class Kw extends Te{constructor(t){super(t);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,r]}else{let e=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],e,r,t[3]]}}call(t,e){return ot(()=>{let r=le(t),s=r.shape;if(this.dataFormat==="channelsFirst"){r=re(r,[0,2,3,1]);let u=this.size[0]*s[2],l=this.size[1]*s[3],h=r.resizeNearestNeighbor([u,l]);return re(h,[0,3,1,2])}else{let u=this.size[0]*s[1],l=this.size[1]*s[2];return r.resizeNearestNeighbor([u,l])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}Kw.className="UpSampling2D",kt(Kw);function nG(n,t,e=[1,1],r="valid",s,u){return ot(()=>{s==null&&(s=ws()),un(s);let l=Uw(n,s);if(n.rank!==4)throw new Q(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new Q(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return l=pi(l,t,e,r==="same"?"same":"valid","NHWC",u),s==="channelsFirst"&&(l=re(l,[0,3,1,2])),l})}class Xw extends xm{constructor(t){super(2,t);this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Xe(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=In(t.depthwiseConstraint),this.depthwiseRegularizer=Ye(t.depthwiseRegularizer)}build(t){if(t=Be(t),t.length<4)throw new Q(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new Q(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let r=t[e],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return ot(()=>{t=le(t);let r=nG(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Qs(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=Be(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,u=Ns(e,this.kernelSize[0],this.padding,this.strides[0]),l=Ns(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,u,l]:[t[0],u,l,s]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=cn(this.depthwiseInitializer),t.depthwiseRegularizer=ze(this.depthwiseRegularizer),t.depthwiseConstraint=Nn(this.depthwiseRegularizer),t}}Xw.className="DepthwiseConv2D",kt(Xw);function pI(n,t,e,r){if(Array.isArray(n)){if(t!=null||e!=null)throw new Q("When inputs is an array, neither initialState or constants should be provided");r!=null&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(u){return u==null||Array.isArray(u)?u:[u]}return t=s(t),e=s(e),{inputs:n,initialState:t,constants:e}}function dI(n,t,e,r=!1,s,u,l=!1,h=!1){return ot(()=>{let p=t.shape.length;if(p<3)throw new Q(`Input should be at least 3D, but is ${p}D.`);let m=[1,0].concat(xs(2,p));if(t=re(t,m),u!=null)throw new Zt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");l&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=s.asType("bool").asType("float32"),s.rank===p-1&&(s=pr(s,-1)),s=re(s,m)),r&&(t=Wr(t,0),s!=null&&(s=Wr(s,0)));let y=[],b,x=e,S=t.shape[0],C=bs(t),I;s!=null&&(I=bs(s));for(let R=0;R<S;++R){let A=C[R],L=ot(()=>n(A,x));if(s==null)b=L[0],x=L[1];else{let _=ot(()=>{let B=I[R],V=Xn(B).sub(B),q=L[0].mul(B).add(x[0].mul(V)),j=x.map((et,tt)=>L[1][tt].mul(B).add(et.mul(V)));return{output:q,newStates:j}});b=_.output,x=_.newStates}h&&y.push(b)}let D;if(h){let R=1;D=mr(y,R)}return[b,D,x]})}class Is extends Te{constructor(t){super(t);let e;if(t.cell==null)throw new Q("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Sm({cells:t.cell}):e=t.cell,e.stateSize==null)throw new Q("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Fn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return xs(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){yw(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let r=e[0],s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){let u=[];for(let l of e)u.push([t[0],l]);return[s].concat(u)}else return s}computeMask(t,e){return ot(()=>{Array.isArray(e)&&(e=e[0]);let r=this.returnSequences?e:null;if(this.returnState){let s=this.states.map(u=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let r=0;r<t;++r)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){let e=null;if(this.numConstants!=null)throw new Zt("Constants support is not implemented in RNN yet.");yw(t)&&(t=t[0]),t=t;let r=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new Fn({shape:[r,null,...s]});let u=[t[0]].concat(t.slice(2));if(e!=null)throw new Zt("Constants support is not implemented in RNN yet.");this.cell.build(u);let l;if(Array.isArray(this.cell.stateSize)?l=this.cell.stateSize:l=[this.cell.stateSize],this.stateSpec!=null){if(!K(this.stateSpec.map(h=>h.shape[h.shape.length-1]),l))throw new Q(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=l.map(h=>new Fn({shape:[null,h]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){ot(()=>{if(!this.stateful)throw new Js("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new Q("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Se([r,s])):this.states_=[Se([r,this.cell.stateSize])];else if(t==null)oe(this.states_),this.keptStates!=null&&(oe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Se([r,s])):this.states_[0]=Se([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new Q(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):oe(this.states_);for(let s=0;s<this.states_.length;++s){let u=t[s],l=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,h=[r,l];if(!K(u.shape,h))throw new Q(`State ${s} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${u.shape}`);this.states_[s]=u}}this.states_=this.states_.map(s=>An(s.clone()))})}apply(t,e){let r=e==null?null:e.initialState,s=e==null?null:e.constants;e==null&&(e={});let u=pI(t,r,s,this.numConstants);t=u.inputs,r=u.initialState,s=u.constants;let l=[],h=[];if(r!=null){e.initialState=r,l=l.concat(r),this.stateSpec=[];for(let m of r)this.stateSpec.push(new Fn({shape:m.shape}));h=h.concat(this.stateSpec)}s!=null&&(e.constants=s,l=l.concat(s),this.numConstants=s.length);let p=l[0]instanceof ks;if(p){let m=[t].concat(l),y=this.inputSpec.concat(h),b=this.inputSpec;this.inputSpec=y;let x=super.apply(m,e);return this.inputSpec=b,x}else return super.apply(t,e)}call(t,e){return ot(()=>{let r=e==null?null:e.mask,s=e==null?null:e.training,u=e==null?null:e.initialState;t=le(t),u==null&&(this.stateful?u=this.states_:u=this.getInitialState(t));let l=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(u.length!==l)throw new Q(`RNN Layer has ${l} state(s) but was passed ${u.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let h={training:s},p=(C,I)=>{let D=this.cell.call([C].concat(I),h);return[D[0],D.slice(1)]},m=dI(p,t,u,this.goBackwards,r,null,this.unroll,this.returnSequences),y=m[0],b=m[1],x=m[2];this.stateful&&this.resetStates(x,s);let S=this.returnSequences?b:y;return this.returnState?[S].concat(x):S})}getInitialState(t){return ot(()=>{let e=Se(t.shape);return e=Xt(e,[1,2]),e=Gh(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?cw(e,[1,r]):e):this.cell.stateSize>1?[cw(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===Is.className&&(e.cell={className:this.cell.getClassName(),config:r}),Object.assign({},r,t,e)}static fromConfig(t,e,r={}){let s=e.cell,u=Ss(s,r);return new t(Object.assign(e,{cell:u}))}}Is.className="RNN",kt(Is);class tc extends Te{}class Tm extends tc{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_n(this.units,"units"),this.activation=Ta(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Xe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ye(t.kernelRegularizer),this.recurrentRegularizer=Ye(t.recurrentRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.kernelConstraint=In(t.kernelConstraint),this.recurrentConstraint=In(t.recurrentConstraint),this.biasConstraint=In(t.biasConstraint),this.dropout=ju([1,va([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ju([1,va([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Be(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return ot(()=>{if(t=t,t.length!==2)throw new Q(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];let s=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ka({ones:()=>Xn(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ka({ones:()=>Xn(r),rate:this.recurrentDropout,training:s}));let u,l=this.dropoutMask,h=this.recurrentDropoutMask;l!=null?u=Zs(st(t,l),this.kernel.read()):u=Zs(t,this.kernel.read()),this.bias!=null&&(u=Qs(u,this.bias.read())),h!=null&&(r=st(r,h));let p=Nt(u,Zs(r,this.recurrentKernel.read()));return this.activation!=null&&(p=this.activation.apply(p)),[p,p]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:xa(this.activation),useBias:this.useBias,kernelInitializer:cn(this.kernelInitializer),recurrentInitializer:cn(this.recurrentInitializer),biasInitializer:cn(this.biasInitializer),kernelRegularizer:ze(this.kernelRegularizer),recurrentRegularizer:ze(this.recurrentRegularizer),biasRegularizer:ze(this.biasRegularizer),activityRegularizer:ze(this.activityRegularizer),kernelConstraint:Nn(this.kernelConstraint),recurrentConstraint:Nn(this.recurrentConstraint),biasConstraint:Nn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}}Tm.className="SimpleRNNCell",kt(Tm);class Yw extends Is{constructor(t){t.cell=new Tm(t),super(t)}call(t,e){return ot(()=>{this.cell.dropoutMask!=null&&(oe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(oe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=e==null?null:e.mask,s=e==null?null:e.training,u=e==null?null:e.initialState;return super.call(t,{mask:r,training:s,initialState:u})})}static fromConfig(t,e){return new t(e)}}Yw.className="SimpleRNN",kt(Yw);class km extends tc{constructor(t){super(t);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new Q("GRUCell does not support reset_after parameter set to true.");this.units=t.units,_n(this.units,"units"),this.activation=Ta(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Ta(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Xe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ye(t.kernelRegularizer),this.recurrentRegularizer=Ye(t.recurrentRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.kernelConstraint=In(t.kernelConstraint),this.recurrentConstraint=In(t.recurrentConstraint),this.biasConstraint=In(t.biasConstraint),this.dropout=ju([1,va([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ju([1,va([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Be(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return ot(()=>{if(t=t,t.length!==2)throw new Q(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let r=e.training==null?!1:e.training,s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ka({ones:()=>Xn(t),rate:this.dropout,training:r,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ka({ones:()=>Xn(s),rate:this.recurrentDropout,training:r,count:3}));let u=this.dropoutMask,l=this.recurrentDropoutMask,h,p,m;0<this.dropout&&this.dropout<1&&(t=st(t,u[0]));let y=Zs(t,this.kernel.read());this.useBias&&(y=Qs(y,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=st(s,l[0]));let b=this.recurrentKernel.read(),[x,S]=Er(b,[2*this.units,this.units],b.rank-1),C=Zs(s,x),[I,D,R]=Er(y,3,y.rank-1),[A,L]=Er(C,2,C.rank-1);h=this.recurrentActivation.apply(Nt(I,A)),p=this.recurrentActivation.apply(Nt(D,L));let _=Zs(st(p,s),S);m=this.activation.apply(Nt(R,_));let B=Nt(st(h,s),st(Nt(1,on(h)),m));return[B,B]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:xa(this.activation),recurrentActivation:xa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:cn(this.kernelInitializer),recurrentInitializer:cn(this.recurrentInitializer),biasInitializer:cn(this.biasInitializer),kernelRegularizer:ze(this.kernelRegularizer),recurrentRegularizer:ze(this.recurrentRegularizer),biasRegularizer:ze(this.biasRegularizer),activityRegularizer:ze(this.activityRegularizer),kernelConstraint:Nn(this.kernelConstraint),recurrentConstraint:Nn(this.recurrentConstraint),biasConstraint:Nn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}}km.className="GRUCell",kt(km);class Jw extends Is{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new km(t),super(t)}call(t,e){return ot(()=>{this.cell.dropoutMask!=null&&(oe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(oe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=e==null?null:e.mask,s=e==null?null:e.training,u=e==null?null:e.initialState;return super.call(t,{mask:r,training:s,initialState:u})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}Jw.className="GRU",kt(Jw);class tf extends tc{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_n(this.units,"units"),this.activation=Ta(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Ta(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Xe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xe(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ye(t.kernelRegularizer),this.recurrentRegularizer=Ye(t.recurrentRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.kernelConstraint=In(t.kernelConstraint),this.recurrentConstraint=In(t.recurrentConstraint),this.biasConstraint=In(t.biasConstraint),this.dropout=ju([1,va([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=ju([1,va([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=Be(t);let r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let u=this.biasInitializer,l=this.units;s=new(e=class extends ss{apply(p,m){let y=u.apply([l]),b=new Qd().apply([l]),x=u.apply([l*2]);return lN(lN(y,b),x)}},e.className="CustomInit",e)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return ot(()=>{let r=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new Q(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1],u=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ka({ones:()=>Xn(t),rate:this.dropout,training:r,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ka({ones:()=>Xn(s),rate:this.recurrentDropout,training:r,count:4}));let l=this.dropoutMask,h=this.recurrentDropoutMask,p,m,y,b;0<this.dropout&&this.dropout<1&&(t=st(t,l[0]));let x=Zs(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=st(s,h[0])),x=Nt(x,Zs(s,this.recurrentKernel.read())),this.useBias&&(x=Qs(x,this.bias.read()));let[S,C,I,D]=Er(x,4,x.rank-1);p=this.recurrentActivation.apply(S),m=this.recurrentActivation.apply(C),y=Nt(st(m,u),st(p,this.activation.apply(I))),b=this.recurrentActivation.apply(D);let R=st(b,this.activation.apply(y));return[R,R,y]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:xa(this.activation),recurrentActivation:xa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:cn(this.kernelInitializer),recurrentInitializer:cn(this.recurrentInitializer),biasInitializer:cn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ze(this.kernelRegularizer),recurrentRegularizer:ze(this.recurrentRegularizer),biasRegularizer:ze(this.biasRegularizer),activityRegularizer:ze(this.activityRegularizer),kernelConstraint:Nn(this.kernelConstraint),recurrentConstraint:Nn(this.recurrentConstraint),biasConstraint:Nn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}}tf.className="LSTMCell",kt(tf);class Zw extends Is{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new tf(t),super(t)}call(t,e){return ot(()=>{this.cell.dropoutMask!=null&&(oe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(oe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let r=e==null?null:e.mask,s=e==null?null:e.training,u=e==null?null:e.initialState;return super.call(t,{mask:r,training:s,initialState:u})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}Zw.className="LSTM",kt(Zw);class Sm extends tc{constructor(t){super(t);this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return ot(()=>{t=t;let r=t.slice(1),s=[];for(let h of this.cells.slice().reverse())Array.isArray(h.stateSize)?s.push(r.splice(0,h.stateSize.length)):s.push(r.splice(0,1));s.reverse();let u=[],l;for(let h=0;h<this.cells.length;++h){let p=this.cells[h];r=s[h],h===0?l=[t[0]].concat(r):l=[l[0]].concat(r),l=p.call(l,e),u.push(l.slice(1))}r=[];for(let h of u.slice().reverse())r.push(...h);return[l[0]].concat(r)})}build(t){yw(t)&&(t=t[0]),t=t;let e;this.cells.forEach((r,s)=>{Si(`RNNCell_${s}`,()=>{r.build(t),Array.isArray(r.stateSize)?e=r.stateSize[0]:e=r.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=u=>({className:u.getClassName(),config:u.getConfig()}),r=this.cells.map(e),s={cells:r};return Object.assign({},t,s)}static fromConfig(t,e,r={}){let s=[];for(let u of e.cells)s.push(Ss(u,r));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let r of this.cells)e.push(...r.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return bw(t)}setWeights(t){let e=[];for(let r of this.cells){let s=r.weights.length,u=t.splice(s);for(let l=0;l<r.weights.length;++l)e.push([r.weights[l],u[l]])}ww(e)}}Sm.className="StackedRNNCells",kt(Sm);function ka(n){let{ones:t,rate:e,training:r=!1,count:s=1}=n,u=()=>fN(t(),e),l=()=>qh(u,t,r);if(!s||s<=1)return An(l().clone());let h=Array(s).fill(void 0).map(l);return h.map(p=>An(p.clone()))}var rG=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]]);return e};class oft extends tc{}class mI extends Is{constructor(t){if(t.unroll)throw new Zt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Zt("It is not possible at the moment to stack convolutional cells.");super(t);this.inputSpec=[new Fn({ndim:5})]}call(t,e){return ot(()=>{if(this.cell.dropoutMask!=null&&(oe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(oe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new Q("ConvRNN2D cell does not support constants");let r=e==null?null:e.mask,s=e==null?null:e.training,u=e==null?null:e.initialState;return super.call(t,{mask:r,training:s,initialState:u})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return ot(()=>{let{stateSize:e}=this.cell,r=t.shape,s=this.computeSingleOutputShape(r),u=[s[0],...s.slice(2)],l=Se(u);return Array.isArray(e)?Array(e.length).fill(l):[l]})}resetStates(t,e=!1){ot(()=>{if(!this.stateful)throw new Js("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),u=[s[0],...s.slice(2)],l=r[0];if(l==null)throw new Q("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Se(u)):this.states_=[Se(u)];else if(t==null)oe(this.states_),this.keptStates!=null&&(oe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Se(u)):this.states_[0]=Se(u);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new Q(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):oe(this.states_);for(let h=0;h<this.states_.length;++h){let p=t[h],m=u;if(!K(p.shape,m))throw new Q(`State ${h} is incompatible with layer ${this.name}: expected shape=${m}, received shape=${p.shape}`);this.states_[h]=p}}this.states_=this.states_.map(h=>An(h.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:r,kernelSize:s,padding:u,strides:l,dilationRate:h}=this.cell,p=e==="channelsFirst",m=t[p?3:2],y=t[p?4:3],b=Ns(m,s[0],u,l[0],h[0]),x=Ns(y,s[1],u,l[1],h[1]),S=[...t.slice(0,2),...p?[r,b,x]:[b,x,r]];return S}}mI.className="ConvRNN2D";class Cm extends tf{constructor(t){let{filters:e,kernelSize:r,strides:s,padding:u,dataFormat:l,dilationRate:h}=t;super(Object.assign({},t,{units:e}));this.filters=e,_n(this.filters,"filters"),this.kernelSize=Ju(r,2,"kernelSize"),this.kernelSize.forEach(p=>_n(p,"kernelSize")),this.strides=Ju(s||1,2,"strides"),this.strides.forEach(p=>_n(p,"strides")),this.padding=u||"valid",Ur(this.padding),this.dataFormat=l||"channelsLast",un(this.dataFormat),this.dilationRate=Ju(h||1,2,"dilationRate"),this.dilationRate.forEach(p=>_n(p,"dilationRate"))}build(t){var e;t=Be(t);let r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new Q(`The channel dimension of the input should be defined. Found ${t[r]}`);let s=t[r],u=4,l=this.kernelSize.concat([s,this.filters*u]);this.kernel=this.addWeight("kernel",l,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let h=this.kernelSize.concat([this.filters,this.filters*u]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",h,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let p;if(this.unitForgetBias){let m=this.biasInitializer,y=this.filters;p=new(e=class extends ss{apply(x,S){let C=m.apply([y]),I=vs([y]),D=m.apply([y*2]);return uw([C,I,D])}},e.className="CustomInit",e)}else p=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*u],null,p,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return ot(()=>{if(t.length!==3)throw new Q(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let r=e.training||!1,s=t[0],u=t[1],l=t[2],h=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ka({ones:()=>Xn(s),rate:this.dropout,training:r,count:h}));let p=this.dropoutMask,m=(Dt,$t,Lt)=>!$t||!$t[Lt]?Dt:st($t[Lt],Dt),y=m(s,p,0),b=m(s,p,1),x=m(s,p,2),S=m(s,p,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ka({ones:()=>Xn(u),rate:this.recurrentDropout,training:r,count:h}));let C=this.recurrentDropoutMask,I=m(u,C,0),D=m(u,C,1),R=m(u,C,2),A=m(u,C,3),L=3,[_,B,V,q]=Er(this.kernel.read(),h,L),[j,et,tt,ht]=this.useBias?Er(this.bias.read(),h):[null,null,null,null];y=this.inputConv(y,_,j,this.padding),b=this.inputConv(b,B,et,this.padding),x=this.inputConv(x,V,tt,this.padding),S=this.inputConv(S,q,ht,this.padding);let[gt,vt,bt,yt]=Er(this.recurrentKernel.read(),h,L);I=this.recurrentConv(I,gt),D=this.recurrentConv(D,vt),R=this.recurrentConv(R,bt),A=this.recurrentConv(A,yt);let mt=this.recurrentActivation.apply(Nt(y,I)),xt=this.recurrentActivation.apply(Nt(b,D)),wt=Nt(st(xt,l),st(mt,this.activation.apply(Nt(x,R)))),Tt=st(this.recurrentActivation.apply(Nt(S,A)),this.activation.apply(wt));return[Tt,Tt,wt]})}getConfig(){let t=super.getConfig(),{units:e}=t,r=rG(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},r,s)}inputConv(t,e,r,s){let u=wo(t,e,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Qs(u,r,this.dataFormat):u}recurrentConv(t,e){let r=1;return wo(t,e,r,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}Cm.className="ConvLSTM2DCell",kt(Cm);class Qw extends mI{constructor(t){let e=new Cm(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}Qw.className="ConvLSTM2D",kt(Qw);class Nm extends Te{constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?e[s]:this.noiseShape[s]);return r}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t);if(0<this.rate&&this.rate<1){let s=e.training==null?!1:e.training,u=this.getNoiseShape(r),l=qh(()=>fN(r,this.rate,u,this.seed),()=>r,s);return l}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}Nm.className="Dropout",kt(Nm);class t0 extends Nm{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}}t0.className="SpatialDropout1D",kt(t0);class e0 extends Te{constructor(t){super(t);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,_n(this.units,"units"),this.activation=Ta(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Xe(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Xe(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=In(t.kernelConstraint),this.biasConstraint=In(t.biasConstraint),this.kernelRegularizer=Ye(t.kernelRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.activityRegularizer=Ye(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=Be(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=Be(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t),s=eN(this.activation.getClassName()),u;return s!=null?u=Zs(r,this.kernel.read(),s,this.bias?this.bias.read():null):(u=Zs(r,this.kernel.read()),this.bias!=null&&(u=Qs(u,this.bias.read())),this.activation!=null&&(u=this.activation.apply(u))),u})}getConfig(){let t={units:this.units,activation:xa(this.activation),useBias:this.useBias,kernelInitializer:cn(this.kernelInitializer),biasInitializer:cn(this.biasInitializer),kernelRegularizer:ze(this.kernelRegularizer),biasRegularizer:ze(this.biasRegularizer),activityRegularizer:ze(this.activityRegularizer),kernelConstraint:Nn(this.kernelConstraint),biasConstraint:Nn(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}e0.className="Dense",kt(e0);class n0 extends Te{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Be(t);for(let e of t.slice(1))if(e==null)throw new Q(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ga(t,1)]}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){let s=[0];for(let u=2;u<r.rank;++u)s.push(u);s.push(1),r=r.transpose(s)}return NV(r)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}}n0.className="Flatten",kt(n0);class r0 extends Te{constructor(t){super(t);this.supportsMasking=!0,this.activation=Ta(t.activation)}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t);return this.activation.apply(r)})}getConfig(){let t={activation:xa(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}r0.className="Activation",kt(r0);class s0 extends Te{constructor(t){super(t);this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return ot(()=>(t=le(t),SV(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}s0.className="RepeatVector",kt(s0);class o0 extends Te{constructor(t){super(t);this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let r="Total size of new array must be unchanged.",s=e.slice(),u=1,l=null;for(let p=0;p<s.length;++p){let m=s[p];if(this.isUnknown(m))if(l===null)l=p;else throw new Q("Can only specifiy one unknown dimension.");else u*=m}let h=ga(t);if(l!==null){if(u===0||h%u!==0)throw new Q(r);s[l]=h/u}else if(h!==u)throw new Q(r);return s}computeOutputShape(t){let e=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t),s=r.shape,u=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return r.reshape(u)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}o0.className="Reshape",kt(o0);class a0 extends Te{constructor(t){super(t);if(t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=xs(1,t.dims.length+1);if(!K(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Fn({ndim:this.dims.length+1})]}computeOutputShape(t){t=Be(t);let e=t.slice();return this.dims.forEach((r,s)=>{e[s+1]=t[r]}),e}call(t,e){return re(le(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}a0.className="Permute",kt(a0);class i0 extends Te{constructor(t){super(t==null?{}:t);this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let r=le(t),s=-1;return hh(ha(r,this.maskValue),s)}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t),s=-1,u=!0,l=hh(ha(r,this.maskValue),s,u),h=r.mul(l.asType(r.dtype));return h})}}i0.className="Masking",kt(i0);class u0 extends Te{constructor(t){super(t);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Ge(t.inputLength))}this.inputDim=t.inputDim,_n(this.inputDim,"inputDim"),this.outputDim=t.outputDim,_n(this.outputDim,"outputDim"),this.embeddingsInitializer=Xe(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ye(t.embeddingsRegularizer),this.activityRegularizer=Ye(t.activityRegularizer),this.embeddingsConstraint=In(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return ot(()=>this.maskZero?(t=le(t),ha(t,fe(t))):null)}computeOutputShape(t){if(t=Be(t),this.inputLength==null)return[...t,this.outputDim];let e=Ge(this.inputLength);if(e.length!==t.length-1)throw new Q(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let s=0;s<e.length;++s){let u=e[s],l=t[s+1];if(u!=null&&l!=null&&u!==l)throw new Q(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);u==null&&(e[r]=l),r++}}return[t[0],...e,this.outputDim]}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t);r.dtype!=="int32"&&(r=Uh(r,"int32"));let s=hN(this.embeddings.read(),r.as1D());return s.reshape(Be(this.computeOutputShape(r.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:cn(this.embeddingsInitializer),embeddingsRegularizer:ze(this.embeddingsRegularizer),activityRegularizer:ze(this.activityRegularizer),embeddingsConstraint:Nn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}u0.className="Embedding",kt(u0);class Ei extends Te{constructor(t){super(t||{});this.supportsMasking=!0}mergeFunction(t){throw new Zt}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){let u=t[t.length-e.length+s],l=e[s];if(u==null||l==null||u<0||l<0)r.push(null);else if(u===1)r.push(l);else if(l===1)r.push(u);else{if(u!==l)throw new Q("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(u)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Be(t)]),t=t,t.length<2)throw new Q(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let u of t)u!=null&&u[0]!==null&&e.push(u[0]);if(e=ma(e),e.length>1)throw new Q(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let u=1;u<t.length;++u){let l=t[u]==null?null:t[u].slice(1);r=this.computeElementwiseOpOutputShape(r,l)}let s=t.map(u=>u.length);t.indexOf(null)===-1&&ma(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return ot(()=>{if(t=t,this.reshapeRequired){let r=[],s=t.map(u=>u.rank);if(s.indexOf(null)===-1){let u=va(s);for(let l of t){let h=l.rank;for(let p=0;p<u-h;++p)l=Gh(l,1);r.push(l)}return this.mergeFunction(r)}else{let u=!1;for(let p of t){let m=p.rank;if(m==null){let y=p.shape,b=y[0],x=y.slice(1).concat([b]),S=p.reshape([b].concat(ga(y.slice(1))));S=re(S,[1,0]),S=S.reshape(x),r.push(S),u=!0}else if(m>1){let y=xs(1,m).concat([0]);r.push(re(p,y)),u=!0}else r.push(p)}let l=this.mergeFunction(r),h=l.rank;if(u){if(h==null){let p=l.shape,m=p.length,y=p[m-1],b=[y].concat(p.slice(0,p.length-1));l=re(l.reshape([-1,y]),[1,0]).reshape(b)}else if(h>1){let p=[h-1].concat(xs(0,h-1));l=re(l,p)}}return l}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let s=1;s<t.length;++s){let u=t[s]==null?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,u)}let r=[];for(let s of t)s!=null&&s[0]!==null&&r.push(s[0]);return r=ma(r),r.length===1?e=r.concat(e):e=[null].concat(e),e}computeMask(t,e){return ot(()=>{if(e==null)return null;if(!Array.isArray(e))throw new Q("`mask` should be an Array");if(!Array.isArray(t))throw new Q("`inputs` should be an Array");if(e.length!==t.length)throw new Q(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>s==null))return null;e=e.map(s=>s==null?s:pr(s,0));let r=e[0];for(let s=1;s<e.length-1;++s)r=es(r,e[s]);return r})}}class ef extends Ei{constructor(t){super(t)}mergeFunction(t){return ot(()=>{let e=t[0].clone();for(let r=1;r<t.length;++r)e=Nt(e,t[r]);return e})}}ef.className="Add",kt(ef);function aft(n){if(Array.isArray(n)){let t=new ef({});return t.apply(n)}else return new ef(n)}class nf extends Ei{constructor(t){super(t)}mergeFunction(t){return ot(()=>{let e=t[0].clone();for(let r=1;r<t.length;++r)e=st(e,t[r]);return e})}}nf.className="Multiply",kt(nf);function ift(n){if(Array.isArray(n)){let t=new nf({});return t.apply(n)}else return new nf(n)}class rf extends Ei{constructor(t){super(t)}mergeFunction(t){return ot(()=>{let e=t[0].clone();for(let r=1;r<t.length;++r)e=Nt(e,t[r]);return st(1/t.length,e)})}}rf.className="Average",kt(rf);function uft(n){if(Array.isArray(n)){let t=new rf({});return t.apply(n)}else return new rf(n)}class sf extends Ei{constructor(t){super(t)}mergeFunction(t){return ot(()=>{let e=t[0];for(let r=1;r<t.length;++r)e=ts(e,t[r]);return e})}}sf.className="Maximum",kt(sf);function cft(n){if(Array.isArray(n)){let t=new sf({});return t.apply(n)}else return new sf(n)}class of extends Ei{constructor(t){super(t)}mergeFunction(t){return ot(()=>{let e=t[0];for(let r=1;r<t.length;++r)e=mi(e,t[r]);return e})}}of.className="Minimum",kt(of);function lft(n){if(Array.isArray(n)){let t=new of({});return t.apply(n)}else return new of(n)}class af extends Ei{constructor(t){super(t);this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new Q("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let s of t)if(s!=null){e=!1;break}if(e)return;let r=[];for(let s=0;s<t.length;++s){let u=t[s].slice();u.splice(this.axis,1);let l=!1;for(let h of r)if(K(h,u)){l=!0;break}l||r.push(u)}if(r.length>1)throw new Q("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return ot(()=>uw(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new Q("A `Concatenate` layer should be called on a list of inputs.");let e=t,r=e[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(let u of e.slice(1)){if(r[s]==null||u[s]==null){r[s]=null;break}r[s]+=u[s]}return r}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new Q("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new Q("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new Q(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return ot(()=>{let r=!0;if(e.forEach(l=>{if(l!=null){r=!1;return}}),r)return null;let s=[];for(let l=0;l<t.length;++l)e[l]==null?s.push(Xn(t[l]).asType("bool")):e[l].rank<t[l].rank?s.push(pr(e[l],-1)):s.push(e[l]);let u=sn(s,this.axis);return cd(u,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}af.className="Concatenate",kt(af);function hft(n){if(Array.isArray(n)){let t=new af({});return t.apply(n)}else return new af(n)}function uf(n,t){for(;n<0;)n+=t;return n}function sG(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Zt("batchDot is not implemented for tensors of 4D or higher rank yet");if(k(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),k(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new Zt("batchDot is not implemented for complex64-type Tensors yet.");let r=n.shape.length,s=t.shape.length;e==null&&(e=[r-1,s-2]);let u=e;return ot(()=>{let l;if(r>s){l=r-s;let p=[];for(let m=0;m<l;++m)p.push(1);t=t.reshape(t.shape.concat(p))}else if(s>r){l=s-r;let p=[];for(let m=0;m<l;++m)p.push(1);n=n.reshape(n.shape.concat(p))}else l=0;let h;if(n.shape.length===2&&t.shape.length===2)u[0]===u[1]?h=n.mul(t).sum(u[0]):h=n.transpose([1,0]).mul(t).sum(u[1]);else{let p=u[0]!==n.shape.length-1,m=u[1]===t.shape.length-1;h=n.matMul(t,p,m)}if(l>0){let p;r>s?p=r+s-3:p=r-1;let m=[];for(let y=p;y<p+l;++y)m.push(y);h=h.squeeze(m)}return h.shape.length===1&&(h=h.expandDims(1)),h})}class c0 extends Ei{constructor(t){super(t);this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){k(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],r=t[1];if(e.length>3||r.length>3)throw new Zt("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(e,r);if(e[s[0]]!==r[s[1]])throw new Q(`Dimension incompatibility: ${e[s[0]]} !== ${r[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new Q(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],r=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((u,l)=>uf(u,t[l].shape.length)):s=[uf(this.axes,e.shape.length),uf(this.axes,r.shape.length)],this.normalize&&(e=hm(e,s[0]),r=hm(r,s[1])),sG(e,r,s)}interpretAxes(t,e){let r;return Array.isArray(this.axes)?r=this.axes:r=[uf(this.axes,t.length),uf(this.axes,e.length)],r}computeOutputShape(t){k(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),r=t[1].slice();if(e.length>3||r.length>3)throw new Zt("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(e,r);e.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);let u=e.concat(r);return u.length===1&&u.push(1),u}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}c0.className="Dot",kt(c0);class l0 extends Te{constructor(t){super(t);this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t),s=()=>Zd(r.shape,0,this.stddev).add(r),u=qh(s,()=>r,e.training||!1);return u})}}l0.className="GaussianNoise",kt(l0);class h0 extends Te{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return ot(()=>{this.invokeCallHook(t,e);let r=le(t);if(this.rate>0&&this.rate<1){let s=()=>{let u=Math.sqrt(this.rate/(1-this.rate));return r.mul(Zd(r.shape,1,u))};return qh(s,()=>r,e.training||!1)}return r})}}h0.className="GaussianDropout",kt(h0);class f0 extends Te{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||le(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return ot(()=>{if(this.rate<1&&this.rate>0){let r=this._getNoiseShape(t),s=()=>{let u=le(t),l=1.6732632423543772,h=1.0507009873554805,p=-l*h,m=xo(yi(r),this.rate);m=Uh(m,"float32");let y=((1-this.rate)*(1+this.rate*p**2))**-.5,b=-y*p*this.rate,x=u.mul(m).add(m.add(-1).mul(p));return x.mul(y).add(b)};return qh(s,()=>le(t),e.training||!1)}return t})}}f0.className="AlphaDropout",kt(f0);function cf(n,t,e,r,s,u=.001){let l;if(n.rank===2)l=zS(n,t,e,r,s,u);else if(n.rank===3)l=WS(n,t,e,r,s,u);else if(n.rank===4)l=VS(n,t,e,r,s,u);else throw new Zt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return l}function oG(n,t,e,r,s=.001){return ot(()=>{let u=Cd(n,r),l=u.mean,h=u.variance,p=cf(n,l,h,e,t,s);return[p,l,h]})}function aG(n,t,e,r,s=.001){return ot(()=>{let u=Cd(n,r),l=u.mean,h=u.variance,p=[];for(let C of xs(0,n.rank))r.indexOf(C)!==-1?p.push(1):p.push(n.shape[C]);let m=l.reshape(p),y=h.reshape(p),b=t==null?null:t.reshape(p),x=e==null?null:e.reshape(p),S=cf(n,m,y,x,b,s);return[S,l,h]})}function iG(n,t,e,r,s=.001){return K(r.slice().sort(),xs(0,n.rank-1))?oG(n,t,e,r,s):aG(n,t,e,r,s)}class p0 extends Te{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Xe(t.betaInitializer||"zeros"),this.gammaInitializer=Xe(t.gammaInitializer||"ones"),this.movingMeanInitializer=Xe(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Xe(t.movingVarianceInitializer||"ones"),this.betaConstraint=In(t.betaConstraint),this.gammaConstraint=In(t.gammaConstraint),this.betaRegularizer=Ye(t.betaRegularizer),this.gammaRegularizer=Ye(t.gammaRegularizer)}build(t){t=Be(t);let e=this.axis>=0?this.axis:this.axis+t.length,r=t[e];if(r==null)throw new Q(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Fn({ndim:t.length,axes:{[e]:r}})];let s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return ot(()=>{let r=e.training==null?!1:e.training,s=le(t),u=s.shape,l=u.length,h=xs(0,l),p=this.axis>=0?this.axis:this.axis+l;h.splice(p,1);let m=Ti(1,l);m[p]=u[p];let y=h.slice();y.sort();let b=!K(y,xs(0,l).slice(0,l-1)),x=()=>{if(b){let A=this.movingMean.read().reshape(m),L=this.movingVariance.read().reshape(m),_=this.center?this.beta.read().reshape(m):null,B=this.scale?this.gamma.read().reshape(m):null;return cf(s,A,L,_,B,this.epsilon)}else return cf(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return x();let[S,C,I]=iG(s,this.gamma.read(),this.beta.read(),h,this.epsilon),D=(A,L,_)=>{ot(()=>{let B=1-_,V=A.read(),q=V.sub(L).mul(B);A.write(V.sub(q))})},R=()=>{D(this.movingMean,C,this.momentum),D(this.movingVariance,I,this.momentum)};return R(),S})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:cn(this.betaInitializer),gammaInitializer:cn(this.gammaInitializer),movingMeanInitializer:cn(this.movingMeanInitializer),movingVarianceInitializer:cn(this.movingVarianceInitializer),betaRegularizer:ze(this.betaRegularizer),gammaRegularizer:ze(this.gammaRegularizer),betaConstraint:Nn(this.betaConstraint),gammaConstraint:Nn(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}p0.className="BatchNormalization",kt(p0);class d0 extends Te{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Xe(t.betaInitializer||"zeros"),this.gammaInitializer=Xe(t.gammaInitializer||"ones"),this.betaRegularizer=Ye(t.betaRegularizer),this.gammaRegularizer=Ye(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=Be(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let u=0;u<this.axis.length;++u)this.axis[u]<0&&(this.axis[u]+=e);for(let u of this.axis)if(u<0||u>=e)throw new Error(`Invalid axis: ${u}`);if(this.axis.length!==ma(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let r=this.axis.map(u=>t[u]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,e){let r=le(t),s=r.shape,u=s.length;return ot(()=>{let l=!0,{mean:h,variance:p}=Cd(r,this.axis,l),m=Ti(1,u);for(let I of this.axis)m[I]=s[I];let y=I=>I!=null&&I.shape.length!==u&&this.axis!==[u-1]?I.reshape(m):I,b=y(this.gamma.read()),x=y(this.beta.read()),S=[],C=[];for(let I=0;I<u;++I)this.axis.indexOf(I)!==-1?(S.push(s[I]),C.push(1)):(S.push(1),C.push(s[I]));return h=h.tile(S),p=p.tile(S),b=b.tile(C),x=x.tile(C),cf(r,h,p,x,b,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:cn(this.betaInitializer),gammaInitializer:cn(this.gammaInitializer),betaRegularizer:ze(this.betaRegularizer),gammaRegularizer:ze(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}d0.className="LayerNormalization",kt(d0);function fft(n,t){return ot(()=>{if(n.rank!==3)throw new Q(`temporalPadding expects input tensor to be 3-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[1,1]),t.length!==2)throw new Q(`temporalPadding expects input padding pattern to be a length-2 array, but received a length-${t.length} array.`);let e=[[0,0],t,[0,0]];return Xs(n,e)})}function uG(n,t,e){return ot(()=>{if(n.rank!==4)throw new Q(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new Q("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=ws()),e!=="channelsLast"&&e!=="channelsFirst")throw new Q(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return e==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Xs(n,r)})}class m0 extends Te{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?ws():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new Q(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,r;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new Q(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new Q(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[e,r]}this.inputSpec=[new Fn({ndim:4})]}computeOutputShape(t){t=Be(t);let e,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],e,r]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],e,r,t[3]])}call(t,e){return ot(()=>uG(le(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}m0.className="ZeroPadding2D",kt(m0);function Im(n,t,e,r,s,u){return ot(()=>{un(s),sN(u),Ur(r),e==null&&(e=[1,1]),r==null&&(r="valid"),s==null&&(s=ws()),u==null&&(u="max"),n=Uw(n,s);let l,h=r==="same"?"same":"valid";return u==="max"?l=Th(n,t,e,h):l=dh(n,t,e,h),s==="channelsFirst"&&(l=re(l,[0,3,1,2])),l})}function gI(n,t,e,r,s,u){return ot(()=>{un(s),sN(u),Ur(r),e==null&&(e=[1,1,1]),r==null&&(r="valid"),s==null&&(s=ws()),u==null&&(u="max"),n=cI(n,s);let l,h=r==="same"?"same":"valid";return u==="max"?l=gb(n,t,e,h):l=rb(n,t,e,h),s==="channelsFirst"&&(l=re(l,[0,4,1,2,3])),l})}class vI extends Te{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new Q(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(_n(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new Q(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);_n(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,Ur(this.padding),this.inputSpec=[new Fn({ndim:3})]}computeOutputShape(t){t=Be(t);let e=Ns(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return ot(()=>{this.invokeCallHook(t,e),t=Gh(le(t),2);let r=this.poolingFunction(le(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return fa(r,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class g0 extends vI{constructor(t){super(t)}poolingFunction(t,e,r,s,u){return un(u),Ur(s),Im(t,e,r,s,u,"max")}}g0.className="MaxPooling1D",kt(g0);class v0 extends vI{constructor(t){super(t)}poolingFunction(t,e,r,s,u){return un(u),Ur(s),Im(t,e,r,s,u,"avg")}}v0.className="AveragePooling1D",kt(v0);class yI extends Te{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new Q(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];_n(this.poolSize,"poolSize"),_n(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,un(this.dataFormat),Ur(this.padding),this.inputSpec=[new Fn({ndim:4})]}computeOutputShape(t){t=Be(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=Ns(e,this.poolSize[0],this.padding,this.strides[0]),r=Ns(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return ot(()=>(this.invokeCallHook(t,e),this.poolingFunction(le(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class y0 extends yI{constructor(t){super(t)}poolingFunction(t,e,r,s,u){return un(u),Ur(s),Im(t,e,r,s,u,"max")}}y0.className="MaxPooling2D",kt(y0);class b0 extends yI{constructor(t){super(t)}poolingFunction(t,e,r,s,u){return un(u),Ur(s),Im(t,e,r,s,u,"avg")}}b0.className="AveragePooling2D",kt(b0);class bI extends Te{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new Q(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];_n(this.poolSize,"poolSize"),_n(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,un(this.dataFormat),Ur(this.padding),this.inputSpec=[new Fn({ndim:5})]}computeOutputShape(t){t=Be(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=Ns(e,this.poolSize[0],this.padding,this.strides[0]),r=Ns(r,this.poolSize[1],this.padding,this.strides[1]),s=Ns(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return ot(()=>(this.invokeCallHook(t,e),this.poolingFunction(le(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class w0 extends bI{constructor(t){super(t)}poolingFunction(t,e,r,s,u){return un(u),Ur(s),gI(t,e,r,s,u,"max")}}w0.className="MaxPooling3D",kt(w0);class x0 extends bI{constructor(t){super(t)}poolingFunction(t,e,r,s,u){return un(u),Ur(s),gI(t,e,r,s,u,"avg")}}x0.className="AveragePooling3D",kt(x0);class wI extends Te{constructor(t){super(t);this.inputSpec=[new Fn({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Zt}}class T0 extends wI{constructor(t){super(t||{})}call(t,e){return ot(()=>{let r=le(t);return an(r,1)})}}T0.className="GlobalAveragePooling1D",kt(T0);class k0 extends wI{constructor(t){super(t||{})}call(t,e){return ot(()=>{let r=le(t);return dr(r,1)})}}k0.className="GlobalMaxPooling1D",kt(k0);class xI extends Te{constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,un(this.dataFormat),this.inputSpec=[new Fn({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Zt}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class S0 extends xI{call(t,e){return ot(()=>{let r=le(t);return this.dataFormat==="channelsLast"?an(r,[1,2]):an(r,[2,3])})}}S0.className="GlobalAveragePooling2D",kt(S0);class C0 extends xI{call(t,e){return ot(()=>{let r=le(t);return this.dataFormat==="channelsLast"?dr(r,[1,2]):dr(r,[2,3])})}}C0.className="GlobalMaxPooling2D",kt(C0);class TI extends Te{constructor(t){super(t);this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){let s=e.layer,u=Ss(s,r);delete e.layer;let l={layer:u};return Object.assign(l,e),new t(l)}}class N0 extends TI{constructor(t){super(t);this.supportsMasking=!0}build(t){if(t=Be(t),t.length<3)throw new Q(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=Be(t);let e=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(e),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,e){return ot(()=>{t=le(t);let r=(l,h)=>{let p=le(this.layer.call(l,e));return[p,[]]},s=dI(r,t,[],!1,null,null,!1,!0),u=s[1];return u})}}N0.className="TimeDistributed",kt(N0);function cG(n){Hu(yV,"BidirectionalMergeMode",n)}let lG="concat";class I0 extends TI{constructor(t){super(t);let e=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=e,this.forwardLayer=Ss(r),e.goBackwards=!(e.goBackwards===!0);let s={};if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=Ss(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?lG:t.mergeMode,cG(this.mergeMode),t.weights)throw new Zt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,r=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let r,s,u;return this.returnState&&(u=e.slice(1)),r=e[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(u).concat(u.slice()):[r].concat(u).concat(u.slice()):gr(s)}apply(t,e){let r=e==null?null:e.initialState,s=e==null?null:e.constants;e==null&&(e={});let u=pI(t,r,s,this.numConstants);if(t=u.inputs,r=u.initialState,s=u.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&s==null)return super.apply(t,e);let l=[],h=[];if(r!=null){let m=r.length;if(m%2>0)throw new Q("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=r,l.push(...r);let y=r.map(b=>new Fn({shape:b.shape}));this.forwardLayer.stateSpec=y.slice(0,m/2),this.backwardLayer.stateSpec=y.slice(m/2),h.push(...y)}if(s!=null)throw new Zt("Support for constants in Bidirectional layers is not implemented yet.");let p=l[0]instanceof ks;for(let m of l)if(m instanceof ks!==p)throw new Q("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(p){let m=[t].concat(l),y=this.inputSpec.concat(h),b=this.inputSpec;this.inputSpec=y;let x=super.apply(m,e);return this.inputSpec=b,x}else return super.apply(t,e)}call(t,e){return ot(()=>{let r=e.initialState,s,u;if(r==null)s=this.forwardLayer.call(t,e),u=this.backwardLayer.call(t,e);else{let p=r.slice(0,r.length/2),m=r.slice(r.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:p})),u=this.backwardLayer.call(t,Object.assign(e,{initialState:m}))}let l;this.returnState&&(Array.isArray(s)&&(l=s.slice(1).concat(u.slice(1))),s=s[0],u=u[0]),this.returnSequences&&(u=Wr(u,1));let h;return this.mergeMode==="concat"?h=uw([s,u]):this.mergeMode==="sum"?h=Nt(s,u):this.mergeMode==="ave"?h=st(.5,Nt(s,u)):this.mergeMode==="mul"?h=st(s,u):this.mergeMode==null&&(h=[s,u]),this.returnState?this.mergeMode==null?h.concat(l):[h].concat(l):h})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Si(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Si(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[e,e]:r=e:this.mergeMode==null?r=[null,null]:r=null,this.returnState){let s=this.forwardLayer.states,u=s.map(l=>null);return Array.isArray(r)?r.concat(u).concat(u):[r].concat(u).concat(u)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let r=Ss(e.layer);if(delete e.layer,e.numConstants!=null)throw new Zt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=e;return s.layer=r,new t(s)}}I0.className="Bidirectional",kt(I0);function hG(n){return new Ku(n)}function fG(n){return new zw(n)}function pG(n){return new Mw(n)}function dG(n){return new Lw(n)}function mG(n){return new Bw(n)}function gG(n){return new Vw(n)}function vG(n){return new Ww(n)}function yG(n){return new Qh(n)}function bG(n){return new Qu(n)}function wG(n){return new Hw(n)}function xG(n){return new Zh(n)}function TG(n){return new qw(n)}function kG(n){return new jw(n)}function SG(n){return new Kw(n)}function CG(n){return new Xw(n)}function NG(n){return new r0(n)}function IG(n){return new e0(n)}function EG(n){return new Nm(n)}function DG(n){return new t0(n)}function $G(n){return new n0(n)}function AG(n){return new s0(n)}function _G(n){return new o0(n)}function FG(n){return new a0(n)}function RG(n){return new u0(n)}function PG(n){return new ef(n)}function OG(n){return new rf(n)}function MG(n){return new af(n)}function LG(n){return new sf(n)}function BG(n){return new of(n)}function zG(n){return new nf(n)}function WG(n){return new c0(n)}function VG(n){return new p0(n)}function UG(n){return new d0(n)}function GG(n){return new m0(n)}function E0(n){return new v0(n)}function HG(n){return E0(n)}function qG(n){return E0(n)}function D0(n){return new b0(n)}function jG(n){return D0(n)}function KG(n){return D0(n)}function $0(n){return new x0(n)}function XG(n){return $0(n)}function YG(n){return $0(n)}function JG(n){return new T0(n)}function ZG(n){return new S0(n)}function kI(n){return new k0(n)}function SI(n){return new C0(n)}function CI(n){return new g0(n)}function NI(n){return new y0(n)}function QG(n){return new w0(n)}function tH(n){return new Jw(n)}function eH(n){return new km(n)}function nH(n){return new Zw(n)}function rH(n){return new tf(n)}function sH(n){return new Yw(n)}function oH(n){return new Tm(n)}function aH(n){return new Qw(n)}function iH(n){return new Cm(n)}function uH(n){return new Is(n)}function cH(n){return new Sm(n)}function lH(n){return new I0(n)}function hH(n){return new N0(n)}let fH=kI,pH=SI,dH=CI,mH=NI;function gH(n){return new l0(n)}function vH(n){return new h0(n)}function yH(n){return new f0(n)}function bH(n){return new i0(n)}var wH=Object.freeze({__proto__:null,inputLayer:hG,elu:fG,reLU:pG,leakyReLU:dG,prelu:mG,softmax:gG,thresholdedReLU:vG,conv1d:yG,conv2d:bG,conv2dTranspose:wG,conv3d:xG,separableConv2d:TG,cropping2D:kG,upSampling2d:SG,depthwiseConv2d:CG,activation:NG,dense:IG,dropout:EG,spatialDropout1d:DG,flatten:$G,repeatVector:AG,reshape:_G,permute:FG,embedding:RG,add:PG,average:OG,concatenate:MG,maximum:LG,minimum:BG,multiply:zG,dot:WG,batchNormalization:VG,layerNormalization:UG,zeroPadding2d:GG,averagePooling1d:E0,avgPool1d:HG,avgPooling1d:qG,averagePooling2d:D0,avgPool2d:jG,avgPooling2d:KG,averagePooling3d:$0,avgPool3d:XG,avgPooling3d:YG,globalAveragePooling1d:JG,globalAveragePooling2d:ZG,globalMaxPooling1d:kI,globalMaxPooling2d:SI,maxPooling1d:CI,maxPooling2d:NI,maxPooling3d:QG,gru:tH,gruCell:eH,lstm:nH,lstmCell:rH,simpleRNN:sH,simpleRNNCell:oH,convLstm2d:aH,convLstm2dCell:iH,rnn:uH,stackedRNNCells:cH,bidirectional:lH,timeDistributed:hH,globalMaxPool1d:fH,globalMaxPool2d:pH,maxPool1d:dH,maxPool2d:mH,Layer:Te,RNN:Is,RNNCell:tc,input:jN,gaussianNoise:gH,gaussianDropout:vH,alphaDropout:yH,masking:bH});function xH(n,t){return Sw(n,t)}function TH(n,t){return EN(n,t)}function kH(n,t){return DN(n,t)}function SH(n,t){return Cw(n,t)}function CH(n,t){return Nw(n,t)}function NH(n,t){return IN(n,t)}function IH(n,t){return pU(n,t)}function EH(n,t){return dm(n,t)}function DH(n,t){return Yu(n,t)}function $H(n,t){return ba(n,t)}function AH(n,t){return ba(n,t)}function _H(n,t){return ba(n,t)}function FH(n,t){return No(n,t)}function RH(n,t){return No(n,t)}function PH(n,t){return No(n,t)}var OH=Object.freeze({__proto__:null,binaryAccuracy:xH,binaryCrossentropy:TH,sparseCategoricalAccuracy:kH,categoricalAccuracy:SH,categoricalCrossentropy:CH,precision:NH,recall:IH,cosineProximity:EH,meanAbsoluteError:DH,meanAbsolutePercentageError:$H,MAPE:AH,mape:_H,meanSquaredError:FH,MSE:RH,mse:PH});var MH=Object.freeze({__proto__:null,modelFromJSON:qU});function LH(n){return new Jh(n)}function BH(n){return tG(n)}function zH(n){return eG(n)}var WH=Object.freeze({__proto__:null,l1l2:LH,l1:BH,l2:zH});class II extends Xu{constructor(){super(...arguments);this.model=null}setModel(t){if(!(t instanceof Io))throw new Error("model must be a LayersModel, not some other Container");this.model=t}}function Em(n,t){return n<t}function EI(n,t){return n>t}class DI extends II{constructor(t){super();if(t==null&&(t={}),t.restoreBestWeights)throw new Zt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Em:this.mode==="max"?this.monitorFunc=EI:this.monitor.indexOf("acc")!==-1?this.monitorFunc=EI:this.monitorFunc=Em,this.monitorFunc===Em&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Em?Infinity:-Infinity}async onEpochEnd(t,e){await ya(e);let r=this.getMonitorValue(e);if(r==null)return;this.monitorFunc(r-this.minDelta,this.best)?(this.best=r,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){t==null&&(t={});let e=t[this.monitor];return e==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(t)}`),e}}function VH(n){return new DI(n)}let UH={earlyStopping:VH};var Es;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Es||(Es={}));var $I;(function(n){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})($I||($I={}));let A0={};function GH(n,t){let e={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:t};A0[n]=e}function AI(n){return A0[n]}function HH(n){delete A0[n]}function P(n,t,e,r,s){let u=t.inputParams[n];if(u&&u.inputIndexStart!==void 0){let h=u.inputIndexStart,p=u.inputIndexEnd===0?void 0:u.inputIndexEnd===void 0?h+1:u.inputIndexEnd;if(u.type==="tensor")return yr(t.inputNames[u.inputIndexStart],e,r,s);if(u.type==="tensors"){let b=t.inputNames.slice(h,p);return b.map(x=>yr(x,e,r,s))}let m=yr(t.inputNames.slice(h)[0],e,r,s),y=m.dataSync();return u.type==="number"?y[0]:Mr(m.shape,y)}let l=t.attrParams[n];return l&&l.value}function yr(n,t,e,r){let[s,u]=$r(n);if(r!=null){let h=r.getHashTableHandleByName(s);if(h!=null)return h}let l=e.currentContextIds.find(h=>!!t[Dm(s,h)]);return l!==void 0?t[Dm(s,l)][u]:void 0}function qH(n,t,e){return t[Dm(n,e.currentContextId)]}function Eo(n,t){let[e,r]=$r(n);return[Dm(e,t&&t.currentContextId),r]}function Dm(n,t){return t?`${n}-${t}`:n}function $r(n){let t=n.split(":");if(t.length===1)return[n,0];let e=t[0];return[e,Number(t[t.length-1])]}function pft(n,t){let e=[];for(let r=0;r<n.length;r+=t)e.push(n.slice(r,r+t));return e}function $m(n,t,e){let r=P("pad",n,t,e);if(r==="explicit"){r=P("explicitPaddings",n,t,e);let s=[[0,0],[0,0],[0,0],[0,0]];for(let u=0;u<4;u++)s[u][0]=r[u*2],s[u][1]=r[u*2+1];return s}return r}function Do(n){return n.kept?n:oa(n)}let jH=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var KH=Object.freeze({__proto__:null,json:jH});let XH=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var YH=Object.freeze({__proto__:null,json:XH});let JH=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var ZH=Object.freeze({__proto__:null,json:JH});let QH=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var tq=Object.freeze({__proto__:null,json:QH});let eq=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var nq=Object.freeze({__proto__:null,json:eq});let rq=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var sq=Object.freeze({__proto__:null,json:rq});let oq=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var aq=Object.freeze({__proto__:null,json:oq});let iq=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var uq=Object.freeze({__proto__:null,json:iq});let cq=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}];var lq=Object.freeze({__proto__:null,json:cq});let hq=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var fq=Object.freeze({__proto__:null,json:hq});let pq=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var dq=Object.freeze({__proto__:null,json:pq});let mq=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var gq=Object.freeze({__proto__:null,json:mq});let vq=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var yq=Object.freeze({__proto__:null,json:vq});let bq=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var wq=Object.freeze({__proto__:null,json:bq});let xq=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var Tq=Object.freeze({__proto__:null,json:xq});let kq=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var Sq=Object.freeze({__proto__:null,json:kq});let Cq=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];var Nq=Object.freeze({__proto__:null,json:Cq});class _I{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[KH,YH,ZH,tq,nq,sq,aq,dq,fq,uq,gq,yq,wq,Tq,Sq,Nq,lq],e=[].concat(...t.map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(t,e={}){let r=t.node,s=[],u=[],l=[],h=r.reduce((I,D)=>(I[D.name]=this.mapNode(D),D.op.startsWith("Placeholder")?s.push(I[D.name]):D.op==="Const"?u.push(I[D.name]):(D.input==null||D.input.length===0)&&l.push(I[D.name]),I),{}),p=[],m=[],y={},b={};e!=null&&(y=this.mapSignatureEntries(e.inputs),b=this.mapSignatureEntries(e.outputs));let x=Object.keys(h);x.forEach(I=>{let D=h[I];D.inputNames.forEach(R=>{let[A]=Eo(R);D.inputs.push(h[A]),h[A].children.push(D)})}),Object.keys(b).length===0?x.forEach(I=>{let D=h[I];D.children.length===0&&m.push(D)}):Object.keys(b).forEach(I=>{let[D]=Eo(I),R=h[D];R!=null&&(R.signatureKey=b[I],m.push(R))}),Object.keys(y).length>0?Object.keys(y).forEach(I=>{let[D]=Eo(I),R=h[D];R&&(R.signatureKey=y[I],p.push(R))}):p=s;let S={};t.library!=null&&t.library.function!=null&&(S=t.library.function.reduce((I,D)=>(I[D.signature.name]=this.mapFunction(D),I),{}));let C={nodes:h,inputs:p,outputs:m,weights:u,placeholders:s,signature:e,functions:S};return l.length>0&&(C.initNodes=l),C}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){let e=AI(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return e.inputs!=null&&(r.inputParams=e.inputs.reduce((s,u)=>(s[u.name]={type:u.type,inputIndexStart:u.start,inputIndexEnd:u.end},s),{})),e.attrs!=null&&(r.attrParams=e.attrs.reduce((s,u)=>{let l=u.type,h;switch(u.type){case"string":h=_0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=_0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"string[]":h=z0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=z0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"number":h=R0(t.attr,u.tfName,u.defaultValue||0),h===void 0&&!!u.tfDeprecatedName&&(h=R0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"number[]":h=B0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=B0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"bool":h=F0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=F0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"bool[]":h=V0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=V0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"shape":h=L0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=L0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"shape[]":h=W0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=W0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"dtype":h=O0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=O0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"dtype[]":h=M0(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=M0(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"func":h=RI(t.attr,u.tfName,u.defaultValue),h===void 0&&!!u.tfDeprecatedName&&(h=RI(t.attr,u.tfDeprecatedName,u.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${u.type} for op: ${t.op}`)}return s[u.name]={value:h,type:l},s},{})),r}mapFunction(t){let e=t.nodeDef,r=[],s=[],u={};e!=null&&(u=e.reduce((b,x)=>(b[x.name]=this.mapNode(x),x.op==="Const"&&s.push(b[x.name]),b),{}));let l=[],h=[];t.signature.inputArg.forEach(b=>{let[x]=Eo(b.name),S={name:x,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:P0(b.type),type:"dtype"}},children:[]};S.signatureKey=b.name,l.push(S),u[x]=S});let p=Object.keys(u);p.forEach(b=>{let x=u[b];x.inputNames.forEach(S=>{let[C]=Eo(S);x.inputs.push(u[C]),u[C].children.push(x)})});let m=t.ret;t.signature.outputArg.forEach(b=>{let[x,S]=Eo(m[b.name]),C=u[x];C!=null&&(C.defaultOutput=S,h.push(C))});let y=this.mapArgsToSignature(t);return{nodes:u,inputs:l,outputs:h,weights:s,placeholders:r,signature:y}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return e!=null&&(r=e[r]),{name:r,dtype:t.type}}}function Iq(n){let t=ft().global;if(typeof t.atob!="undefined")return t.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function FI(n,t){let e=Array.isArray(n)?String.fromCharCode.apply(null,n):Iq(n);return t?e:e.toLowerCase()}function _0(n,t,e,r=!1){let s=n[t];return s!=null?FI(s.s,r):e}function F0(n,t,e){let r=n[t];return r?r.b:e}function R0(n,t,e){let r=n[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:e;return typeof s=="number"?s:parseInt(s,10)}function P0(n){typeof n=="string"&&(n=Es[n]);switch(n){case Es.DT_FLOAT:return"float32";case Es.DT_INT32:case Es.DT_INT64:case Es.DT_INT8:case Es.DT_UINT8:return"int32";case Es.DT_BOOL:return"bool";case Es.DT_DOUBLE:return"float32";case Es.DT_STRING:return"string";default:return null}}function RI(n,t,e){let r=n[t];return r&&r.func?r.func.name:e}function O0(n,t,e){let r=n[t];return r&&r.type?P0(r.type):e}function M0(n,t,e){let r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>P0(s)):e}function PI(n){return n.unknownRank?void 0:n.dim!=null?n.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function L0(n,t,e){let r=n[t];return r&&r.shape?PI(r.shape):e}function B0(n,t,e){let r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):e}function z0(n,t,e,r=!1){let s=n[t];return s&&s.list&&s.list.s?s.list.s.map(u=>FI(u,r)):e}function W0(n,t,e){let r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>PI(s)):e}function V0(n,t,e){let r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class Eq{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,u)=>(s[u]=this.getAttr(u),s),{}))}getInput(t){return yr(t,this.tensorMap,this.context)}getAttr(t,e){let r=this.node.rawAttrs[t];if(r.tensor!=null)return yr(t,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return R0(this.node.rawAttrs,t,e);if(r.s!=null)return _0(this.node.rawAttrs,t,e);if(r.b!=null)return F0(this.node.rawAttrs,t,e);if(r.shape!=null)return L0(this.node.rawAttrs,t,e);if(r.type!=null)return O0(this.node.rawAttrs,t,e);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return B0(this.node.rawAttrs,t,e);if(r.list.s!=null)return z0(this.node.rawAttrs,t,e);if(r.list.shape!=null)return W0(this.node.rawAttrs,t,e);if(r.list.b!=null)return V0(this.node.rawAttrs,t,e);if(r.list.type!=null)return M0(this.node.rawAttrs,t,e)}return e}}let Dq=(n,t,e)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[Nt(P("a",n,t,e),P("b",n,t,e))];case"AddN":return[LS(P("tensors",n,t,e))];case"FloorMod":case"Mod":return[Sd(P("a",n,t,e),P("b",n,t,e))];case"Mul":return[st(P("a",n,t,e),P("b",n,t,e))];case"RealDiv":case"Div":return[Ht(P("a",n,t,e),P("b",n,t,e))];case"DivNoNan":return[cb(P("a",n,t,e),P("b",n,t,e))];case"FloorDiv":return[ud(P("a",n,t,e),P("b",n,t,e))];case"Sub":return[Mt(P("a",n,t,e),P("b",n,t,e))];case"Minimum":return[mi(P("a",n,t,e),P("b",n,t,e))];case"Maximum":return[ts(P("a",n,t,e),P("b",n,t,e))];case"Pow":return[ys(P("a",n,t,e),P("b",n,t,e))];case"SquaredDifference":return[Dh(P("a",n,t,e),P("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},dft="arithmetic";let $q=(n,t,e)=>{switch(n.op){case"Abs":case"ComplexAbs":return[kn(P("x",n,t,e))];case"Acos":return[qy(P("x",n,t,e))];case"Acosh":return[jy(P("x",n,t,e))];case"Asin":return[Yy(P("x",n,t,e))];case"Asinh":return[Jy(P("x",n,t,e))];case"Atan":return[Zy(P("x",n,t,e))];case"Atan2":return[Qy(P("x",n,t,e),P("y",n,t,e))];case"Atanh":return[tb(P("x",n,t,e))];case"Ceil":return[sb(P("x",n,t,e))];case"Complex":return[vo(P("real",n,t,e),P("imag",n,t,e))];case"Cos":return[vh(P("x",n,t,e))];case"Cosh":return[gd(P("x",n,t,e))];case"Elu":return[$u(P("x",n,t,e))];case"Erf":return[lb(P("x",n,t,e))];case"Exp":return[Br(P("x",n,t,e))];case"Expm1":return[hb(P("x",n,t,e))];case"Floor":return[_u(P("x",n,t,e))];case"Log":return[Nr(P("x",n,t,e))];case"Log1p":return[wd(P("x",n,t,e))];case"Imag":return[bh(P("x",n,t,e))];case"Neg":return[on(P("x",n,t,e))];case"Reciprocal":return[xb(P("x",n,t,e))];case"Real":return[Ou(P("x",n,t,e))];case"Relu":return[Ys(P("x",n,t,e))];case"Round":return[kb(P("x",n,t,e))];case"Selu":return[Ed(P("x",n,t,e))];case"Sigmoid":return[js(P("x",n,t,e))];case"Sin":return[Dd(P("x",n,t,e))];case"Sign":return[Cb(P("x",n,t,e))];case"Sinh":return[$d(P("x",n,t,e))];case"Softplus":return[Ru(P("x",n,t,e))];case"Sqrt":return[Wn(P("x",n,t,e))];case"Square":return[Oe(P("x",n,t,e))];case"Tanh":return[Du(P("x",n,t,e))];case"Tan":return[Eb(P("x",n,t,e))];case"Relu6":case"ClipByValue":return[fr(P("x",n,t,e),P("clipValueMin",n,t,e),P("clipValueMax",n,t,e))];case"Rsqrt":return[Id(yr(n.inputNames[0],t,e))];case"Prod":return[Nd(P("x",n,t,e),P("axes",n,t,e))];case"LeakyRelu":return[bd(P("x",n,t,e),P("alpha",n,t,e))];case"Prelu":return[Sh(P("x",n,t,e),P("alpha",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},mft="basic_math";function os(n,t,e=""){k(Aq(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Aq(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==-1&&t[e]!==-1&&n[e]!==t[e])return!1;return!0}class _q{constructor(t,e,r,s,u,l,h){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=u,this.dynamicSize=l,this.clearAfterRead=h,this.tensors=[],this.closed_=!1,this.idTensor=Ot(0),An(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),os(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,An(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(t.length===0)return vn([],[0].concat(this.elementShape));let r=this.readMany(t);return os(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),mr(r,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return vn([],[0].concat(this.elementShape));let e=[];for(let s=0;s<this.size();s++)e.push(s);let r=this.readMany(e);return os(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),sn(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,bs(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0,s=t.map(p=>(r+=p,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let u=r===0?0:e.size/r,l=[];ot(()=>{e=rt(e,[1,r,u]);for(let p=0;p<t.length;++p){let m=p===0?0:s[p-1],y=[0,m,0],b=[1,t[p],u];l[p]=rt(ge(e,y,b),this.elementShape)}return l});let h=[];for(let p=0;p<t.length;p++)h[p]=p;this.writeMany(h,l)}}class ec{constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t!=null&&t.forEach(u=>{if(r!==u.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${u.dtype}`);os(e,u.shape,"TensorList shape mismatch: "),An(u)}),this.idTensor=Ot(0),this.maxNumElements=s,An(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ec([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);return os(t,this.elementShape,"TensorList shape mismatch: "),ot(()=>{let s=this.tensors.map(u=>rt(u,t));return mr(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=this.tensors.pop();return os(r.shape,t,"TensorList shape mismatch: "),rt(r,t)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(os(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");An(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);return os(this.tensors[t].shape,e,"TensorList shape mismatch: "),this.tensors[t]}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);os(this.elementShape,e.shape,"TensorList shape mismatch: "),An(e),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);return os(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size()),t.length===0?vn([],[0].concat(this.elementShape)):ot(()=>{let s=t.map(u=>rt(this.tensors[u],r));return mr(s,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);return os(this.elementShape,e,"TensorList shape mismatch: "),this.size()===0?vn([],[0].concat(this.elementShape)):ot(()=>{let r=this.tensors.map(s=>rt(s,e));return sn(r,0)})}}function Fq(n,t,e){let r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);let s=n.shape.slice(1);os(s,t,"TensorList shape mismatch: ");let u=bs(n);return new ec(u,t,r)}function Rq(n,t,e){return new ec([],n,t,e)}function Pq(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let u=new ec([],e,n.dtype,r),l=bs(n,0);return t.forEach((h,p)=>{u.setItem(h,l[p])}),u}function Oq(n,t,e){let r=0,s=t.map(p=>(r+=p,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);let u=r===0?0:n.size/r,l=ot(()=>{let p=[];n=rt(n,[1,r,u]);for(let m=0;m<t.length;++m){let y=m===0?0:s[m-1],b=[0,y,0],x=[1,t[m],u];p[m]=rt(ge(n,b,x),e)}return n.dispose(),p}),h=new ec([],e,n.dtype,t.length);for(let p=0;p<l.length;p++)h.setItem(p,l[p]);return h}let Mq=async(n,t,e)=>{switch(n.op){case"If":case"StatelessIf":{let r=P("thenBranch",n,t,e),s=P("elseBranch",n,t,e),u=P("cond",n,t,e),l=P("args",n,t,e),h=await u.data();return h[0]?e.functionMap[r].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap):e.functionMap[s].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let r=P("body",n,t,e),s=P("cond",n,t,e),u=P("args",n,t,e),l=await e.functionMap[s].executeFunctionAsync(u,e.tensorArrayMap,e.tensorListMap),h=u.map(y=>y.id),p=await l[0].data();l.forEach(y=>{!y.kept&&h.indexOf(y.id)===-1&&y.dispose()});let m=u;for(;p[0];){let y=m;m=await e.functionMap[r].executeFunctionAsync(m,e.tensorArrayMap,e.tensorListMap);let b=m.map(S=>S.id);y.forEach(S=>{!S.kept&&h.indexOf(S.id)===-1&&b.indexOf(S.id)===-1&&S.dispose()});let x=await e.functionMap[s].executeFunctionAsync(m,e.tensorArrayMap,e.tensorListMap);p=await x[0].data(),x.forEach(S=>{!S.kept&&h.indexOf(S.id)===-1&&b.indexOf(S.id)===-1&&S.dispose()})}return m}case"LoopCond":{let r=P("pred",n,t,e);return[Do(r)]}case"Switch":{let r=P("pred",n,t,e),s=P("data",n,t,e);return s.kept||(s=Do(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=n.inputNames.find(s=>yr(s,t,e)!==void 0);if(r){let s=yr(r,t,e);return[Do(s)]}return}case"Enter":{let r=P("frameName",n,t,e),s=P("tensor",n,t,e);return e.enterFrame(r),[Do(s)]}case"Exit":{let r=P("tensor",n,t,e);return e.exitFrame(),[Do(r)]}case"NextIteration":{let r=P("tensor",n,t,e);return e.nextIteration(),[Do(r)]}case"TensorArrayV3":{let r=P("size",n,t,e),s=P("dtype",n,t,e),u=P("elementShape",n,t,e),l=P("dynamicSize",n,t,e),h=P("clearAfterRead",n,t,e),p=P("identicalElementShapes",n,t,e),m=P("name",n,t,e),y=new _q(m,s,r,u,p,l,h);return e.addTensorArray(y),[y.idTensor,Ot(1)]}case"TensorArrayWriteV3":{let r=P("tensorArrayId",n,t,e),s=P("index",n,t,e),u=P("tensor",n,t,e),l=e.getTensorArray(r.id);return l.write(s,u),[l.idTensor]}case"TensorArrayReadV3":{let r=P("tensorArrayId",n,t,e),s=P("index",n,t,e),u=e.getTensorArray(r.id);return[u.read(s)]}case"TensorArrayGatherV3":{let r=P("tensorArrayId",n,t,e),s=P("indices",n,t,e),u=P("dtype",n,t,e),l=e.getTensorArray(r.id);return[l.gather(s,u)]}case"TensorArrayScatterV3":{let r=P("tensorArrayId",n,t,e),s=P("indices",n,t,e),u=P("tensor",n,t,e),l=e.getTensorArray(r.id);return l.scatter(s,u),[l.idTensor]}case"TensorArrayConcatV3":{let r=P("tensorArrayId",n,t,e),s=e.getTensorArray(r.id),u=P("dtype",n,t,e);return[s.concat(u)]}case"TensorArraySplitV3":{let r=P("tensorArrayId",n,t,e),s=P("tensor",n,t,e),u=P("lengths",n,t,e),l=e.getTensorArray(r.id);return l.split(u,s),[l.idTensor]}case"TensorArraySizeV3":{let r=P("tensorArrayId",n,t,e),s=e.getTensorArray(r.id);return[Ot(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=P("tensorArrayId",n,t,e),s=e.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=P("tensorListId",n,t,e),s=P("index",n,t,e),u=P("tensor",n,t,e),l=e.getTensorList(r.id);return l.setItem(s,u),[l.idTensor]}case"TensorListGetItem":{let r=P("tensorListId",n,t,e),s=P("index",n,t,e),u=P("elementShape",n,t,e),l=P("elementDType",n,t,e),h=e.getTensorList(r.id);return[h.getItem(s,u,l)]}case"TensorListScatterV2":case"TensorListScatter":{let r=P("indices",n,t,e),s=P("tensor",n,t,e),u=P("elementShape",n,t,e),l=P("numElements",n,t,e),h=Pq(s,r,u,l);return e.addTensorList(h),[h.idTensor]}case"TensorListReserve":{let r=P("elementShape",n,t,e),s=P("elementDType",n,t,e),u=P("numElements",n,t,e),l=Rq(r,s,u);return e.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=P("tensorListId",n,t,e),s=P("indices",n,t,e),u=P("elementShape",n,t,e),l=P("elementDType",n,t,e),h=e.getTensorList(r.id);return[h.gather(s,l,u)]}case"TensorListStack":{let r=P("tensorListId",n,t,e),s=P("elementShape",n,t,e),u=P("elementDType",n,t,e),l=P("numElements",n,t,e),h=e.getTensorList(r.id);return[h.stack(s,u,l)]}case"TensorListFromTensor":{let r=P("tensor",n,t,e),s=P("elementShape",n,t,e),u=P("elementDType",n,t,e),l=Fq(r,s,u);return e.addTensorList(l),[l.idTensor]}case"TensorListConcat":{let r=P("tensorListId",n,t,e),s=e.getTensorList(r.id),u=P("dtype",n,t,e),l=P("elementShape",n,t,e);return[s.concat(u,l)]}case"TensorListPushBack":{let r=P("tensorListId",n,t,e),s=P("tensor",n,t,e),u=e.getTensorList(r.id);return u.pushBack(s),[u.idTensor]}case"TensorListPopBack":{let r=P("tensorListId",n,t,e),s=P("elementShape",n,t,e),u=P("elementDType",n,t,e),l=e.getTensorList(r.id);return[l.popBack(s,u)]}case"TensorListSplit":{let r=P("tensor",n,t,e),s=P("elementShape",n,t,e),u=P("lengths",n,t,e),l=Oq(r,u,s);return e.addTensorList(l),[l.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},gft="control";function OI(n,t,e){let[r,s]=P("fusedOps",n,t,e),u=r==="biasadd",l=s==="prelu",h=r==="fusedbatchnorm",p=P("numArgs",n,t,e);if(u){if(l&&p!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&p!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(h)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");let m=P("strides",n,t,e),y=$m(n,t,e),b=P("dataFormat",n,t,e).toUpperCase(),x=P("dilations",n,t,e),[S,C]=P("args",n,t,e);return{stride:m,pad:y,dataFormat:b,dilations:x,biasArg:S,preluArg:C,activationFunc:s}}let Lq=(n,t,e)=>{switch(n.op){case"Conv1D":{let r=P("stride",n,t,e),s=P("pad",n,t,e),u=P("dataFormat",n,t,e).toUpperCase(),l=P("dilation",n,t,e);return[dd(P("x",n,t,e),P("filter",n,t,e),r,s,u,l)]}case"Conv2D":{let r=P("strides",n,t,e),s=$m(n,t,e),u=P("dataFormat",n,t,e).toUpperCase(),l=P("dilations",n,t,e);return[wo(P("x",n,t,e),P("filter",n,t,e),[r[1],r[2]],s,u,[l[1],l[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:u,dilations:l,biasArg:h,preluArg:p,activationFunc:m}=OI(n,t,e);return[Pb({x:P("x",n,t,e),filter:P("filter",n,t,e),strides:[r[1],r[2]],pad:s,dataFormat:u,dilations:[l[1],l[2]],bias:h,activation:m,preluActivationWeights:p})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:u,dilations:l,biasArg:h,preluArg:p,activationFunc:m}=OI(n,t,e);return[$C({x:P("x",n,t,e),filter:P("filter",n,t,e),strides:[r[1],r[2]],pad:s,dataFormat:u,dilations:[l[1],l[2]],bias:h,activation:m,preluActivationWeights:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=P("outputShape",n,t,e),s=P("strides",n,t,e),u=$m(n,t,e);return[md(P("x",n,t,e),P("filter",n,t,e),r,[s[1],s[2]],u)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=P("strides",n,t,e),s=$m(n,t,e),u=P("dilations",n,t,e),l=P("dataFormat",n,t,e).toUpperCase();return[pi(P("input",n,t,e),P("filter",n,t,e),[r[1],r[2]],s,l,[u[1],u[2]])]}case"Conv3D":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("dataFormat",n,t,e).toUpperCase(),l=P("dilations",n,t,e);return[ab(P("x",n,t,e),P("filter",n,t,e),[r[1],r[2],r[3]],s,u,[l[1],l[2],l[3]])]}case"AvgPool":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("kernelSize",n,t,e);return[dh(P("x",n,t,e),[u[1],u[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("kernelSize",n,t,e);return[Th(P("x",n,t,e),[u[1],u[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("kernelSize",n,t,e),l=P("includeBatchInIndex",n,t,e),{result:h,indexes:p}=nC(P("x",n,t,e),[u[1],u[2]],[r[1],r[2]],s,l);return[h,p]}case"AvgPool3D":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("kernelSize",n,t,e);return[rb(P("x",n,t,e),[u[1],u[2],u[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("kernelSize",n,t,e);return[gb(P("x",n,t,e),[u[1],u[2],u[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=P("strides",n,t,e),s=P("pad",n,t,e),u=P("dilations",n,t,e),l=r[1],h=r[2],p=u[1],m=u[2];return[ub(P("x",n,t,e),P("filter",n,t,e),[l,h],s,[p,m],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},vft="convolution";let Bq=(n,t,e)=>{switch(n.op){case"Fill":{let r=P("shape",n,t,e),s=P("dtype",n,t,e),u=P("value",n,t,e);return[Au(r,u,s)]}case"LinSpace":{let r=P("start",n,t,e),s=P("stop",n,t,e),u=P("num",n,t,e);return[QS(r,s,u)]}case"Multinomial":{let r=P("logits",n,t,e),s=P("numSamples",n,t,e),u=P("seed",n,t,e);return[rC(r,s,u)]}case"OneHot":{let r=P("indices",n,t,e),s=P("depth",n,t,e),u=P("onValue",n,t,e),l=P("offValue",n,t,e);return[ci(r,s,u,l)]}case"Ones":return[vs(P("shape",n,t,e),P("dtype",n,t,e))];case"OnesLike":return[Xn(P("x",n,t,e))];case"RandomUniform":return[yi(P("shape",n,t,e),P("minval",n,t,e),P("maxval",n,t,e),P("dtype",n,t,e))];case"Range":{let r=P("start",n,t,e),s=P("stop",n,t,e),u=P("step",n,t,e);return[Ch(r,s,u,P("dtype",n,t,e))]}case"TruncatedNormal":{let r=P("shape",n,t,e),s=P("mean",n,t,e),u=P("stdDev",n,t,e),l=P("seed",n,t,e);return[$h(r,s,u,P("dtype",n,t,e),l)]}case"Zeros":return[Se(P("shape",n,t,e),P("dtype",n,t,e))];case"ZerosLike":return[fe(P("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},yft="creation";function U0(n,t,e){let r=P("boxes",n,t,e),s=P("scores",n,t,e),u=P("maxOutputSize",n,t,e),l=P("iouThreshold",n,t,e),h=P("scoreThreshold",n,t,e),p=P("softNmsSigma",n,t,e);return{boxes:r,scores:s,maxOutputSize:u,iouThreshold:l,scoreThreshold:h,softNmsSigma:p}}let zq=async(n,t,e)=>{switch(n.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:s,maxOutputSize:u,iouThreshold:l,scoreThreshold:h,softNmsSigma:p}=U0(n,t,e),m=await da.nonMaxSuppressionWithScoreAsync(r,s,u,l,h,p);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:s,maxOutputSize:u,iouThreshold:l,scoreThreshold:h}=U0(n,t,e),p=P("padToMaxOutputSize",n,t,e),m=await da.nonMaxSuppressionPaddedAsync(r,s,u,l,h,p);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:s,maxOutputSize:u,iouThreshold:l,scoreThreshold:h}=U0(n,t,e);return[await da.nonMaxSuppressionAsync(r,s,u,l,h)]}case"Where":{let r=Rt(P("condition",n,t,e),"bool"),s=[await Ab(r)];return r.dispose(),s}case"ListDiff":return oC(P("x",n,t,e),P("y",n,t,e));default:throw TypeError(`Node type ${n.op} is not implemented`)}},bft="dynamic";let Wq=(n,t,e)=>{switch(n.op){case"TopKV2":{let r=P("x",n,t,e),s=P("k",n,t,e),u=P("sorted",n,t,e),l=Db(r,s,u);return[l.values,l.indices]}case"Unique":{let r=P("x",n,t,e),s=Rd(r);return[s.values,s.indices]}case"UniqueV2":{let r=P("x",n,t,e),s=P("axis",n,t,e),u=Rd(r,s);return[u.values,u.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},wft="evaluation";let Vq=(n,t,e)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":let r=P("default",n,t,e);return[yr(n.name,t,e)||r];case"Placeholder":return[yr(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let m=P("x",n,t,e);return[Do(m)]}case"IdentityN":return P("x",n,t,e).map(m=>Do(m));case"Snapshot":let s=P("x",n,t,e);return[Do(s)];case"Shape":return[Ir(P("x",n,t,e).shape,"int32")];case"ShapeN":return P("x",n,t,e).map(m=>Ir(m.shape));case"Size":return[Ot(P("x",n,t,e).size,"int32")];case"Rank":return[Ot(P("x",n,t,e).rank,"int32")];case"NoOp":return[Ot(1)];case"Print":let u=P("x",n,t,e),l=P("data",n,t,e),h=P("message",n,t,e),p=P("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(h);for(let m=0;m<l.length;m++)console.log(Array.prototype.slice.call(l[m].dataSync()).slice(0,p));return[u];default:throw TypeError(`Node type ${n.op} is not implemented`)}},xft="graph";class Uq{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Ot(0),this.tensorMap=new Map,An(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(t,e){this.checkKeyAndValueTensor(t,e);let r=await t.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),ot(()=>{let s=bs(e),u=r.length,l=s.length;k(u===l,()=>`The number of elements doesn't match, keys has ${u} elements, the values has ${l} elements.`);for(let h=0;h<u;h++){let p=r[h],m=s[h];An(m),this.tensorMap.set(p,m)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let r=await t.data();return ot(()=>{let s=[];for(let u=0;u<r.length;u++){let l=r[u],h=this.findWithDefault(l,e);s.push(h)}return mr(s)})}findWithDefault(t,e){let r=this.tensorMap.get(t);return r!=null?r:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}let Gq=async(n,t,e,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{let s=P("keyDType",n,t,e),u=P("valueDType",n,t,e),l=new Uq(s,u);return r.addHashTable(n.name,l),[l.handle]}case"LookupTableImport":case"LookupTableImportV2":{let s=P("tableHandle",n,t,e,r),u=P("keys",n,t,e),l=P("values",n,t,e),h=r.getHashTableById(s.id);return[await h.import(u,l)]}case"LookupTableFind":case"LookupTableFindV2":{let s=P("tableHandle",n,t,e,r),u=P("keys",n,t,e),l=P("defaultValue",n,t,e),h=r.getHashTableById(s.id);return[await h.find(u,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Tft="hash_table";let Hq=(n,t,e)=>{switch(n.op){case"ResizeBilinear":{let r=P("images",n,t,e),s=P("size",n,t,e),u=P("alignCorners",n,t,e);return[da.resizeBilinear(r,[s[0],s[1]],u)]}case"ResizeNearestNeighbor":{let r=P("images",n,t,e),s=P("size",n,t,e),u=P("alignCorners",n,t,e);return[da.resizeNearestNeighbor(r,[s[0],s[1]],u)]}case"CropAndResize":{let r=P("image",n,t,e),s=P("boxes",n,t,e),u=P("boxInd",n,t,e),l=P("cropSize",n,t,e),h=P("method",n,t,e),p=P("extrapolationValue",n,t,e);return[da.cropAndResize(r,s,u,l,h,p)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},kft="image";let qq=(n,t,e)=>{switch(n.op){case"Equal":return[gs(P("a",n,t,e),P("b",n,t,e))];case"NotEqual":return[ha(P("a",n,t,e),P("b",n,t,e))];case"Greater":return[zr(P("a",n,t,e),P("b",n,t,e))];case"GreaterEqual":return[xo(P("a",n,t,e),P("b",n,t,e))];case"Less":return[wh(P("a",n,t,e),P("b",n,t,e))];case"LessEqual":return[la(P("a",n,t,e),P("b",n,t,e))];case"LogicalAnd":return[es(P("a",n,t,e),P("b",n,t,e))];case"LogicalNot":return[xh(P("a",n,t,e))];case"LogicalOr":return[kd(P("a",n,t,e),P("b",n,t,e))];case"Select":case"SelectV2":return[er(P("condition",n,t,e),P("a",n,t,e),P("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Sft="logical";let jq=(n,t,e)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[xe(P("a",n,t,e),P("b",n,t,e),P("transposeA",n,t,e),P("transposeB",n,t,e))];case"Transpose":return[re(P("x",n,t,e),P("perm",n,t,e))];case"_FusedMatMul":let[r,s]=P("fusedOps",n,t,e),u=r==="biasadd",l=s==="prelu",h=P("numArgs",n,t,e);if(u){if(l&&h!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&h!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,m]=P("args",n,t,e);return[Wd({a:P("a",n,t,e),b:P("b",n,t,e),transposeA:P("transposeA",n,t,e),transposeB:P("transposeB",n,t,e),bias:p,activation:s,preluActivationWeights:m})];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Cft="matrices";let Kq=(n,t,e)=>{switch(n.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[fi(P("x",n,t,e),P("mean",n,t,e),P("variance",n,t,e),P("offset",n,t,e),P("scale",n,t,e),P("epsilon",n,t,e))];case"FusedBatchNormV3":return[fi(P("x",n,t,e),P("mean",n,t,e),P("variance",n,t,e),P("offset",n,t,e),P("scale",n,t,e),P("epsilon",n,t,e))];case"LRN":return[pb(P("x",n,t,e),P("radius",n,t,e),P("bias",n,t,e),P("alpha",n,t,e),P("beta",n,t,e))];case"Softmax":return[bi(P("x",n,t,e))];case"LogSoftmax":return[Td(P("x",n,t,e))];case"SparseToDense":return[_b(P("sparseIndices",n,t,e),P("outputShape",n,t,e),P("sparseValues",n,t,e),P("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Nft="normalization";let Xq=(n,t,e)=>{switch(n.op){case"Max":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[dr(P("x",n,t,e),r,s)]}case"Mean":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[an(P("x",n,t,e),r,s)]}case"Min":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[Pu(P("x",n,t,e),r,s)]}case"Sum":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[Xt(P("x",n,t,e),r,s)]}case"All":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[cd(P("x",n,t,e),r,s)]}case"Any":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[hh(P("x",n,t,e),r,s)]}case"ArgMax":{let r=P("axis",n,t,e);return[fh(P("x",n,t,e),r)]}case"ArgMin":{let r=P("axis",n,t,e);return[Xy(P("x",n,t,e),r)]}case"Prod":{let r=P("axis",n,t,e),s=P("keepDims",n,t,e);return[Nd(P("x",n,t,e),r,s)]}case"Cumsum":{let r=P("axis",n,t,e),s=P("exclusive",n,t,e),u=P("reverse",n,t,e);return[vd(P("x",n,t,e),r,s,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Ift="reduction";let Yq=(n,t,e)=>{switch(n.op){case"ConcatV2":case"Concat":{let r=P("n",n,t,e),s=P("axis",n,t,e),u=P("tensors",n,t,e);return u=u.slice(0,r),[sn(u,s)]}case"GatherV2":case"Gather":{let r=P("axis",n,t,e),s=P("x",n,t,e),u=P("indices",n,t,e);return[Fu(s,Rt(u,"int32"),r)]}case"ReverseV2":case"Reverse":{let r=P("axis",n,t,e),s=P("x",n,t,e);return[Wr(s,r)]}case"Slice":{let r=P("begin",n,t,e),s=P("size",n,t,e);return[ge(P("x",n,t,e),r,s)]}case"StridedSlice":{let r=P("begin",n,t,e),s=P("end",n,t,e),u=P("strides",n,t,e),l=P("beginMask",n,t,e),h=P("endMask",n,t,e),p=P("ellipsisMask",n,t,e),m=P("newAxisMask",n,t,e),y=P("shrinkAxisMask",n,t,e),b=P("x",n,t,e);return[Ib(b,r,s,u,l,h,p,m,y)]}case"Pack":return ot(()=>{let r=P("axis",n,t,e),s=P("tensors",n,t,e),u=s[0].shape,l=fa(s[0]).shape,h=s.map(p=>{let m=K(p.shape,u);if(!m&&!K(fa(p).shape,l))throw new Error("the input tensors shape does not match");return m?p:rt(p,u)});return[mr(h,r)]});case"Unpack":{let r=P("axis",n,t,e),s=P("tensor",n,t,e);return bs(s,r)}case"Tile":{let r=P("reps",n,t,e);return[ca(P("x",n,t,e),r)]}case"Split":case"SplitV":{let r=P("axis",n,t,e),s=P("numOrSizeSplits",n,t,e),u=P("x",n,t,e);return Er(u,s,r)}case"ScatterNd":{let r=P("indices",n,t,e),s=P("values",n,t,e),u=P("shape",n,t,e);return[SC(r,s,u)]}case"GatherNd":{let r=P("x",n,t,e),s=P("indices",n,t,e);return[CC(r,s)]}case"SparseToDense":{let r=P("sparseIndices",n,t,e),s=P("outputShape",n,t,e),u=P("sparseValues",n,t,e),l=P("defaultValue",n,t,e);return[_b(r,u,s,u.dtype===l.dtype?l:Rt(l,u.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}},Eft="slice_join";let Jq=(n,t,e)=>{switch(n.op){case"FFT":return[Ih(P("x",n,t,e))];case"IFFT":return[Bu(P("x",n,t,e))];case"RFFT":return[Eh(P("x",n,t,e))];case"IRFFT":return[Fd(P("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},Dft="spectral";let Zq=(n,t,e)=>{switch(n.op){case"Cast":return[Rt(P("x",n,t,e),P("dtype",n,t,e))];case"ExpandDims":{let r=P("axis",n,t,e);return[pr(P("x",n,t,e),r)]}case"Squeeze":{let r=P("axis",n,t,e);return[fa(P("x",n,t,e),r)]}case"Reshape":return[rt(P("x",n,t,e),P("shape",n,t,e))];case"MirrorPad":return[vb(P("x",n,t,e),P("padding",n,t,e),P("mode",n,t,e))];case"PadV2":case"Pad":return[Xs(P("x",n,t,e),P("padding",n,t,e),P("constantValue",n,t,e))];case"SpaceToBatchND":{let r=P("blockShape",n,t,e),s=P("paddings",n,t,e);return[kh(P("x",n,t,e),r,s)]}case"BatchToSpaceND":{let r=P("blockShape",n,t,e),s=P("crops",n,t,e);return[mh(P("x",n,t,e),r,s)]}case"DepthToSpace":{let r=P("blockSize",n,t,e),s=P("dataFormat",n,t,e).toUpperCase();return[ib(P("x",n,t,e),r,s)]}case"BroadcastTo":return[gh(P("x",n,t,e),P("shape",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}},$ft="transformation";function MI(n,t,e,r){let s=((u,l,h)=>{switch(u.category){case"arithmetic":return ot(()=>Dq(u,l,h));case"basic_math":return ot(()=>$q(u,l,h));case"control":return Mq(u,l,h);case"convolution":return ot(()=>Lq(u,l,h));case"creation":return ot(()=>Bq(u,l,h));case"dynamic":return zq(u,l,h);case"evaluation":return ot(()=>Wq(u,l,h));case"image":return ot(()=>Hq(u,l,h));case"graph":return ot(()=>Vq(u,l,h));case"logical":return ot(()=>qq(u,l,h));case"matrices":return ot(()=>jq(u,l,h));case"normalization":return ot(()=>Kq(u,l,h));case"reduction":return ot(()=>Xq(u,l,h));case"slice_join":return ot(()=>Yq(u,l,h));case"spectral":return ot(()=>Jq(u,l,h));case"transformation":return ot(()=>Zq(u,l,h));case"hash_table":return Gq(u,l,h,r);case"custom":let p=AI(u.op);if(p&&p.customExecutor)return p.customExecutor(new Eq(u,l,h));throw TypeError(`Custom op ${u.op} is not registered.`);default:throw TypeError(`Unknown op '${u.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return ni(s)?s.then(u=>[].concat(u)):[].concat(s)}class LI{constructor(t={},e={},r={},s={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function BI(n,t,e,r){let s=new Set,u=[],l=null,h=null,p=new Set,m=Object.keys(n).map(x=>$r(x)[0]),y=[];r!=null&&(y=r.map(x=>$r(x.name)[0]));let b=[...t];for(;b.length>0;){let x=b.pop();if((zI(x)||rj(x)||sj(x))&&(l==null&&(l=x,h=l.children.map(S=>S.name).filter(S=>s.has(S)))),s.add(x.name),e[x.name]!=null)continue;if(m.indexOf(x.name)!==-1)continue;if(y.indexOf(x.name)!==-1)continue;if(x.inputs.length===0){u.push(x.name);continue}x.inputs.forEach(S=>{if(p.has(S.name))return;p.add(S.name),b.push(S)})}return{inputs:n,outputs:t,usedNodes:s,missingInputs:u,dynamicNode:l,syncInputs:h}}function Qq(n,t,e){let{usedNodes:r,inputs:s}=e,u=[],l=Object.keys(s).map(y=>$r(y)[0]).map(y=>n.nodes[y]),h=n.initNodes;l.forEach(y=>{r.has(y.name)&&u.push(y)}),n.weights.forEach(y=>{r.has(y.name)&&u.push(y)}),h!=null&&h.forEach(y=>{r.has(y.name)&&u.push(y)});let p=new Set,m=[];for(;u.length>0;){let y=u.pop();p.add(y.name),t[y.name]||m.push(y),y.children.forEach(b=>{!p.has(b.name)&&r.has(b.name)&&b.inputs.every(x=>p.has(x.name))&&u.push(b)})}return m}let tj=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],ej=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],nj=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function zI(n){return tj.indexOf(n.op)>=0}function rj(n){return ej.indexOf(n.op)>=0}function sj(n){return nj.indexOf(n.op)>=0}class Am{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new Am(t.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let r=t.map(u=>u.name).sort(),s=e.map(u=>u.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,e){let r=BI(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:u,syncInputs:l}=r;if(u!=null)throw new Error(`This execution contains the node '${u.name}', which has the dynamic op '${u.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${l}]`);if(s.length>0){let h=e.map(m=>m.name),p=Object.keys(t);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${p}]. Missing the following inputs: [${s}]`)}return Qq(this.graph,this.weightMap,r)}execute(t,e){t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let s=r.map(b=>this.graph.nodes[$r(b)[0]]),u=e.map(b=>$r(b)[0]),l=u.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);let h=this.getCompilationKey(s,l),p=this.compiledMap.get(h);p==null&&(p=this.compile(t,l),this.compiledMap.set(h,p));let m={},y={};return ot(()=>{let b=new LI(this.weightMap,m,y,this.functionExecutorMap),x=Object.assign({},this.weightMap);Object.keys(t).forEach(I=>{let[D,R]=$r(I),A=[];A[R]=t[I],x[D]=A});let S=this.getFrozenTensorIds(x),C={};for(let I=0;I<p.length;I++){let D=p[I];if(!x[D.name]){let R=MI(D,x,b,this._resourceManager);if(ni(R))throw new Error(`The execution of the op '${D.op}' returned a promise. Please use model.executeAsync() instead.`);x[D.name]=R,this.checkTensorForDisposal(D.name,D,x,b,S,u,C)}}return this.parent==null&&b.dispose(S),e.map(I=>yr(I,x,b))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,u,l,h){if(e.category==="control"||l.indexOf(t)!==-1)return;r[t].forEach(p=>{p!=null&&(h[p.id]=(h[p.id]||0)+e.children.length)}),e.inputs.forEach(p=>{if(p.category!=="control"){let m=qH(p.name,r,s);m!=null&&m.forEach(y=>{if(y&&!u.has(y.id)){let b=h[y.id];b===1?(y.dispose(),delete h[y.id]):b!=null&&h[y.id]--}})}})}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,r=!1,s={},u={}){r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));let l=new LI(this.weightMap,s,u,this.functionExecutorMap),h=await this.executeWithControlFlow(t,l,e,r),p=e.map(x=>yr(x,h,l)),m=p.map(x=>x.id),y=Object.keys(t).map(x=>t[x].id),b=new Set([...m,...y,...this.weightIds]);return Object.keys(h).forEach(x=>{let S=h[x];S.forEach(C=>{C&&!C.isDisposed&&!b.has(C.id)&&C.dispose()})}),this.parent==null&&l.dispose(b),p}async executeFunctionAsync(t,e,r){let s=t.reduce((u,l,h)=>(u[this.inputs[h].name]=l,u),{});return this._executeAsync(s,this.outputNodes,!0,e,r)}async executeWithControlFlow(t,e,r,s){let u=Object.keys(t),l=u.map(L=>this.graph.nodes[$r(L)[0]]),h=r.map(L=>$r(L)[0]),p=h.map(L=>this.graph.nodes[L]);p.length===0&&(p=this._outputs);let{usedNodes:m,missingInputs:y,dynamicNode:b,syncInputs:x}=BI(t,p,this.weightMap,this._initNodes),S=[...l,...this.graph.weights,...this._initNodes||[]].map(L=>({node:L,contexts:e.currentContext})),C=Object.assign({},this.weightMap);Object.keys(t).forEach(L=>{let[_,B]=$r(L),V=[];V[B]=t[L],C[_]=V});let I={},D=this.getFrozenTensorIds(C),R={};for(;S.length>0;){let L=this.processStack(l,S,e,C,R,D,h,I,m);await Promise.all(L)}b==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let A=p.filter(L=>!zI(L)&&!yr(L.name,C,e)).map(L=>L.name);if(A.length>0){let L="";throw b!=null&&(L=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${x}]`),new Error(`Cannot compute the outputs [${A}] from the provided inputs [${u}]. Consider providing the following inputs: [${y}]. ${L}`)}return C}processStack(t,e,r,s,u,l,h,p,m){let y=[];for(;e.length>0;){let b=e.pop();r.currentContext=b.contexts;let x="";if(b.node.op==="Enter"&&P("isConstant",b.node,s,r)&&([x]=Eo(b.node.name,r)),s[b.node.name]==null){let S=MI(b.node,s,r,this._resourceManager);x||([x]=Eo(b.node.name,r));let C=r.currentContext;ni(S)?y.push(S.then(I=>(s[x]=I,r.currentContext=C,this.checkTensorForDisposal(x,b.node,s,r,l,h,p),this.processChildNodes(b.node,e,r,s,u,m),I))):(s[x]=S,this.checkTensorForDisposal(x,b.node,s,r,l,h,p),this.processChildNodes(b.node,e,r,s,u,m))}else this.processChildNodes(b.node,e,r,s,u,m)}return y}processChildNodes(t,e,r,s,u,l){t.children.forEach(h=>{let[p]=Eo(h.name,r);if(u[p]||!l.has(h.name))return;h.op==="Merge"?h.inputNames.some(m=>!!yr(m,s,r))&&(u[p]=!0,e.push({contexts:r.currentContext,node:h})):h.inputNames.every(m=>!!yr(m,s,r))&&(u[p]=!0,e.push({contexts:r.currentContext,node:h}))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let r=t[e],[s]=$r(e),u=this.graph.nodes[s];if(u.attrParams.shape&&u.attrParams.shape.value){let l=u.attrParams.shape.value,h=l.length===r.shape.length&&r.shape.every((p,m)=>l[m]===-1||l[m]===p);k(h,()=>`The shape of dict['${u.name}'] provided in model.execute(dict) must be [${l}], but was [${r.shape}]`)}u.attrParams.dtype&&u.attrParams.dtype.value&&k(r.dtype===u.attrParams.dtype.value,()=>`The dtype of dict['${u.name}'] provided in model.execute(dict) must be ${u.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){let e={};for(let r in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){let s=this._signature.inputs[r];e[s.name]=t[r]}else e[r]=t[r];return e}checkInputs(t){let e=Object.keys(t).filter(r=>{let[s]=$r(r);return this.graph.nodes[s]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{if(this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null){let r=this._signature.outputs[e];return r.name}return e},{})}checkOutputs(t){t.forEach(e=>{let[r]=$r(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class oj{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}let aj="?tfjs-format=file",ij="model.json";class WI{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",e==null&&(this.loadOptions={}),this.resourceManager=new oj}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=ed(t,this.loadOptions);else{let e=Dy(t,this.loadOptions);if(e.length===0)e.push(ed(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,r={};this.artifacts.userDefinedMetadata!=null&&(r=this.artifacts.userDefinedMetadata.signature),this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let s=Jp(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Am(_I.Instance.transformGraph(e,r)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null){let u=_I.Instance.transformGraph(t.modelInitializer);this.initializer=new Am(u),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let r=Ey(t);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof at)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,r,s)=>(e[r]=t[s],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let r=this.executor.execute(t,e);return r.length>1?r:r[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let r=await this.executor.executeAsync(t,e);return r.length>1?r:r[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function uj(n,t={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&(n.load==null&&(n.endsWith("/")||(n=n+"/"),n=`${n}${ij}${aj}`));let e=new WI(n,t);return await e.load(),e}let VI="2.7.0";function cj(n,t){return _m(n,t)}function _m(n,t,e=new Map,r=new Set){if(n==null)return null;if(r.has(n))throw new Error("Circular references are not supported.");if(e.has(n))return e.get(n);let s=t(n);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(nc(n)){let u=Array.isArray(n)?[]:{};r.add(n);for(let l in n){let h=n[l],p=_m(h,t,e,r);u[l]=p}return r.delete(n),u}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return e.set(n,s.value),s.value}function lj(n,t=GI){return UI(n,t)}function UI(n,t,e=new Set){let r=n[0];if(e.has(r))throw new Error("Circular references are not supported.");let s=t(n);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(nc(r)){let u=Array.isArray(r)?[]:{};e.add(r);for(let l in r){let h=n.map(m=>m[l]),p=UI(h,t,e);u[l]=p}return e.delete(r),u}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function GI(n){return n===null?null:nc(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function HI(n,t){let e=new Map;_m(n,t,e);for(let s of Array.from(e.keys())){let u=e.get(s);if(ni(u)){let l=await u;e.set(s,l)}}let r=_m(n,t,e);return r}function nc(n){return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof at))}function hj(n){return n==null||fj(n)||Array.isArray(n)||typeof n=="object"&&n instanceof at||Re(n)}function fj(n){return n===null||typeof n!="object"&&typeof n!="function"}function pj(n){return cj(n,dj)}function dj(n){return n instanceof at?{value:n.clone(),recurse:!1}:nc(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class qI{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),r=this.get(e);return this.set(e,this.pop()),r}}class Fm extends qI{constructor(){super(Fm.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),r=this.length();for(let s=0;s<r;s++)e[s]=this.get(this.wrap(this.begin+s));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}Fm.INITIAL_CAPACITY=32;function jI(n){return new gj(n)}function Aft(n){let t=n;return lf(()=>({value:t++,done:!1}))}function lf(n){return new vj(n)}function KI(n,t){return new YI(n,t)}function _ft(n,t,e){return KI(lf(n).take(t),e)}function mj(n,t=Sa.FAIL){return new Nj(n,t)}class Rn{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],r=await t.next();for(;!r.done;)e.push(r.value),r=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),r=t(e.value);for(;!e.done&&r;)e=await this.next(),r=t(e.value)}handleErrors(t){return new Sj(this,t)}filter(t){return new Tj(this,t)}map(t){return new kj(this,t)}mapAsync(t){return new XI(this,t)}serialMapAsync(t){return new XI(this,t).serial()}flatmap(t){return new Cj(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new xj(this,t,e)}columnMajorBatch(t,e=!0,r=GI){let s=this.rowMajorBatch(t,e);return s.map(u=>lj(u,r))}concatenate(t,e){return new YI(jI([this,t]),e)}take(t){return t<0||t==null?this:new wj(this,t)}skip(t){return t<0||t==null?this:new bj(this,t)}prefetch(t){return new JI(this,t)}shuffle(t,e){return new Ij(this,t,e)}serial(){return new yj(this)}}class gj extends Rn{constructor(t){super();this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:pj(t),done:!1}}}class vj extends Rn{constructor(t){super();this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class yj extends Rn{constructor(t){super();this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class bj extends Rn{constructor(t,e){super();this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;oe(t.value)}return this.upstream.next()}}class wj extends Rn{constructor(t,e){super();this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class xj extends Rn{constructor(t,e,r=!0){super();this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class Tj extends Rn{constructor(t,e){super();this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;oe(t.value)}}}class kj extends Rn{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=mo(t.value),r=this.transform(t.value),s=mo(r);for(let u of e)Xp(u,s)||u.dispose();return{value:r,done:!1}}}class Sj extends Rn{constructor(t,e){super();this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class XI extends Rn{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=mo(t.value),r=await this.transform(t.value),s=mo(r);for(let u of e)Xp(u,s)||u.dispose();return{value:r,done:!1}}}class G0 extends Rn{constructor(){super();this.outputQueue=new Fm,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Cj extends G0{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=mo(t.value),r=this.transform(t.value),s=mo(r);this.outputQueue.pushAll(r);for(let u of e)Xp(u,s)||u.dispose();return!0}}class YI extends Rn{constructor(t,e){super();this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){let t="TODO: fill in upstream of chained summaries";return`${t} -> Chained`}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}var Sa;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Sa||(Sa={}));class Nj extends Rn{constructor(t,e=Sa.FAIL){super();this.iterators=t,this.mismatchMode=e,this.count=0,this.currentPromise=null}summary(){let t="TODO: fill in upstream of zip summaries";return`{${t}} -> Zip`}async nextState(t){await t;let e=0,r=0;function s(l){if(l instanceof Rn){let h=l.next();return{value:h.then(p=>(e++,p.done&&r++,p.value)),recurse:!1}}else return{value:null,recurse:!0}}let u=await HI(this.iterators,s);if(e===r)return{value:null,done:!0};if(r>0)switch(this.mismatchMode){case Sa.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Sa.SHORTEST:return{value:null,done:!0};case Sa.LONGEST:default:}return this.count++,{value:u,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class JI extends Rn{constructor(t,e){super();this.upstream=t,this.bufferSize=e,this.buffer=new qI(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class Ij extends JI{constructor(t,e,r){super(t,e);this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=Lu(r||cr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}}class rc{constructor(){this.size=null}batch(t,e=!0){let r=this;k(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let s;return this.size===Infinity||this.size==null?s=this.size:e?s=Math.ceil(this.size/t):s=Math.floor(this.size/t),Ar(async()=>(await r.iterator()).columnMajorBatch(t,e,$j),s)}concatenate(t){let e=this,r;return this.size===Infinity||t.size===Infinity?r=Infinity:this.size!=null&&t.size!=null?r=this.size+t.size:r=null,Ar(async()=>(await e.iterator()).concatenate(await t.iterator()),r)}filter(t){let e=this,r;return this.size===Infinity?r=Infinity:r=null,Ar(async()=>(await e.iterator()).filter(s=>ot(()=>t(s))),r)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Ar(async()=>(await e.iterator()).map(r=>ot(()=>t(r))),this.size)}mapAsync(t){let e=this;return Ar(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Ar(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,r;return this.size!=null&&t>0?r=this.size*t:t===0?r=0:this.size!=null&&(t===void 0||t<0)?r=Infinity:r=null,Ar(async()=>{let s=lf(async()=>({value:await e.iterator(),done:!1}));return KI(s.take(t))},r)}skip(t){let e=this,r;return this.size!=null&&t>=0&&this.size>=t?r=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?r=0:r=null,Ar(async()=>(await e.iterator()).skip(t),r)}shuffle(t,e,r=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let s=this,u=Lu(e||cr().toString());return Ar(async()=>{let l=u.int32();return r&&(l+=u.int32()),(await s.iterator()).shuffle(t,l.toString())},this.size)}take(t){let e=this,r;return this.size!=null&&this.size>t?r=t:this.size!=null&&this.size<=t?r=this.size:r=null,Ar(async()=>(await e.iterator()).take(t),r)}async toArray(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}rc.MAX_BUFFER_SIZE=1e4;function Ar(n,t=null){return new class extends rc{constructor(){super(...arguments);this.size=t}async iterator(){return n()}}}function Ej(n){return Ar(async()=>jI(n),n.length)}function Dj(n){if(!nc(n))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(n))for(let e=0;e<n.length;e++)t=t==null?n[e].size:Math.min(t,n[e].size);else if(n instanceof Object)for(let e in n)t=t==null?n[e].size:Math.min(t,n[e].size);return Ar(async()=>{let e=await HI(n,r=>{if(r instanceof rc)return{value:r.iterator(),recurse:!1};if(nc(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return mj(e,Sa.SHORTEST)},t)}function $j(n){if(n===null)return null;let t=n[0];if(hj(t)){let e=Aj(n);return{value:e,recurse:!1}}return{value:null,recurse:!0}}function Aj(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof at?mr(n):vn(n)}class ZI extends rc{constructor(t){super();this.input=t}async iterator(){let t=await this.input.iterator(),e=t.decodeUTF8(),r=e.split(`
`).map(s=>(s.endsWith("\r")&&(s=s.slice(0,-1)),s));return r}}let Rm='"',hf=Symbol("out"),QI=Symbol("field"),Pm=Symbol("quote"),H0=Symbol("quoteafterquote"),tE=Symbol("quoteinquote");class eE extends rc{constructor(t,e){super();this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new ZI(t),e||(e={}),this.hasHeader=!(e.hasHeader===!1),this.fullColumnNames=e.columnNames,this.columnConfigs=e.columnConfigs,this.configuredColumnsOnly=e.configuredColumnsOnly,e.delimWhitespace?(k(e.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=e.delimiter?e.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&k(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let e=this.fullColumnNames.reduce((s,u)=>(s[u]=s[u]+1||1,s),{}),r=Object.keys(e).filter(s=>e[s]>1);if(k(r.length===0,()=>"Duplicate column names found: "+r.toString()),this.columnConfigs)for(let s of Object.keys(this.columnConfigs)){let u=this.fullColumnNames.indexOf(s);if(u===-1)throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await this.base.iterator(),e=await t.next();if(e.done)throw new Error("No data was found for CSV parsing.");let r=e.value,s=this.parseRow(r,!1);return s}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(e=>this.makeDataElement(e))}makeDataElement(t){let e=this.parseRow(t),r={},s={};for(let u=0;u<this.fullColumnNames.length;u++){let l=this.fullColumnNames[u],h=this.columnConfigs?this.columnConfigs[l]:null;if(this.configuredColumnsOnly&&!h)continue;{let p=e[u],m=null;if(p==="")if(h&&h.default!==void 0)m=h.default;else{if(h&&(h.required||h.isLabel))throw new Error(`Required column ${l} is empty in this line: ${t}`);m=void 0}else{let y=Number(p);if(isNaN(y))h&&h.dtype==="bool"?m=this.getBoolean(p):m=p;else if(!h||!h.dtype)m=y;else switch(h.dtype){case"float32":m=y;break;case"int32":m=Math.floor(y);break;case"bool":m=this.getBoolean(p);break;default:m=y}}h&&h.isLabel?s[l]=m:r[l]=m}}return Object.keys(s).length===0?r:{xs:r,ys:s}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,e=!0){let r=[],s=0,u=t.length,l=hf;for(let h=0;h<u;h++)switch(l){case hf:switch(t.charAt(h)){case Rm:s=h+1,l=Pm;break;case this.delimiter:if(s=h+1,this.delimiter===" "&&this.delimWhitespace)break;r.push(""),l=hf;break;default:l=QI,s=h;break}break;case QI:switch(t.charAt(h)){case this.delimiter:r.push(t.substring(s,h)),l=hf,s=h+1;break;default:}break;case Pm:switch(t.charAt(h)){case Rm:l=H0;break;default:}break;case H0:switch(t.charAt(h)){case this.delimiter:r.push(t.substring(s,h-1)),l=hf,s=h+1;break;case Rm:l=Pm;break;default:l=tE;break}break;case tE:switch(t.charAt(h)){case Rm:l=Pm;break;default:}break;default:}if(l===H0?r.push(t.substring(s,u-1)):r.push(t.substring(s)),e&&r.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${r}`);return r}}class q0 extends Rn{constructor(t){super();this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=!(t.includeSpectrogram===!1),this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(ft().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let e=new q0(t);return await e.start(),e}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize);return}async next(){if(this.isClosed)return{value:null,done:!0};let t,e,r=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(r.timeDataQueue);e=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],e=[],r=0;return new Promise(s=>{let u=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-Infinity&&s({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(u),s({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let e=t[0].length,r=new Float32Array(t.length*e);return t.forEach((s,u)=>r.set(s,u*e)),r}getTensorFromAudioDataArray(t,e){let r=new Float32Array(O(e));return r.set(t,r.length-t.length),vn(r,e)}}class j0 extends Rn{constructor(t,e){super();if(this.webcamVideoElement=t,this.webcamConfig=e,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ir([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,u=(1-r)/2,l=(1-s)/2,h=u+r,p=s+l;this.cropBox=pa([l,u,p,h],[1,4])}else this.cropBox=pa([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,e={}){if(ft().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!e.resizeWidth||!e.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=e.resizeWidth,t.height=e.resizeHeight}let r=new j0(t,e);return await r.start(),r}async start(){this.webcamConfig.facingMode&&k(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=kS(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return ot(()=>{let e=t.toFloat().expandDims(0),r;r=da.cropAndResize(e,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=r.shape;return r.reshape(s.slice(1))})}async capture(){return(await this.next()).value}stop(){let t=this.stream.getTracks();t.forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class nE{}class rE extends Rn{split(t){return new _j(this,t)}}class _j extends rE{constructor(t,e){super();this.upstream=t,this.impl=new Fj(t,e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Fj extends G0{constructor(t,e){super();this.upstream=t,this.separator=e,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let e=t.value.split(this.separator);e[0]=this.carryover+e[0];for(let r of e.slice(0,-1))this.outputQueue.push(r);return this.carryover=e[e.length-1],!0}}class Rj extends Rn{decodeUTF8(){return new Pj(this)}}class Pj extends rE{constructor(t){super();this.upstream=t,this.impl=new Oj(t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Oj extends G0{constructor(t){super();if(this.upstream=t,ft().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=require("string_decoder");this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),e;if(t.done)return!1;e=t.value;let r;return ft().get("IS_BROWSER")?r=this.decoder.decode(e,{stream:!0}):r=this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(r),!0}}class sE extends Rj{constructor(t,e={}){super();this.file=t,this.options=e,k(t instanceof Uint8Array||(ft().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=e.offset||0,this.chunkSize=e.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};let t=new Promise((e,r)=>{let s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,s)));else{let u=new FileReader;u.onload=h=>{let p=u.result;if(p instanceof ArrayBuffer&&(p=new Uint8Array(p)),!(p instanceof Uint8Array))return r(new TypeError("FileReader returned unknown type."));e(p)},u.onabort=h=>r(new Error("Aborted")),u.onerror=h=>r(new Error(h.type));let l=this.file.slice(this.offset,s);u.readAsArrayBuffer(l)}this.offset=s});return{value:await t,done:!1}}}async function Mj(n,t={}){let e,r;typeof n=="string"?e=n:(e=n.url,r=Lj(n));let s=await X2(e,r);if(s.ok){let u=new Uint8Array(await s.arrayBuffer());return new sE(u,t)}else throw new Error(s.statusText)}let Lj=n=>{let t={method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity};return t};function oE(n){return typeof n=="string"&&n.substr(0,7)==="file://"}class aE extends nE{constructor(t,e={}){super();this.input=t,this.options=e}async iterator(){if(oE(this.input)&&ft().get("IS_NODE")){let t=require("fs");this.input=t.readFileSync(this.input.substr(7))}return new sE(this.input,this.options)}}class iE extends nE{constructor(t,e={}){super();this.url=t,this.fileOptions=e}async iterator(){return oE(this.url)?new aE(this.url,this.fileOptions).iterator():Mj(this.url,this.fileOptions)}}function Bj(n,t={}){return new eE(new iE(n),t)}function zj(n){let t=lf(n);return Ar(async()=>t)}function Wj(n){return Ar(async()=>{let t=await n();return lf(()=>t.next())})}async function Vj(n,t){return j0.create(n,t)}async function Uj(n){return q0.create(n)}let uE="2.7.0";var Gj=Object.freeze({__proto__:null,array:Ej,Dataset:rc,zip:Dj,CSVDataset:eE,TextLineDataset:ZI,csv:Bj,func:zj,generator:Wj,microphone:Uj,webcam:Vj,FileDataSource:aE,URLDataSource:iE,version_data:uE});function At(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&k(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}let Hj=Vd,qj=Xb,jj=Yb,Kj=Jb,Xj=Pd;class Yj extends f{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new c(this,yo())}write(t,e,r){this.firstUse&&(this.firstUse=!1,ft().get("IS_NODE")&&Gu(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let s={};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,e,r){let s;if(e==="string"&&r!=null&&r.length>0&&dn(r[0])){let u=r.map(l=>qp(l));s=this.write(u,t,e)}else s=this.write(r,t,e);return{dataId:s,shape:t,dtype:e}}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,r,s){this.data.set(t,{values:e,dtype:s,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:r}=this.data.get(t);if(e==="complex64"){let s=this.readSync(r.real.dataId),u=this.readSync(r.imag.dataId);return So(s,u)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId),r=e;if(t.dtype==="string")try{r=e.map(s=>rh(s))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return Ae(t.shape,t.dtype,r)}makeOutput(t,e,r){let s=this.write(t,e,r);return yo().makeTensorFromDataId(s,e,r,this)}disposeData(t){if(this.data.has(t)){let{complexTensorInfos:e}=this.data.get(t);e!=null&&(this.disposeData(e.real.dataId),this.disposeData(e.imag.dataId)),this.data.delete(t)}}disposeIntermediateTensorInfo(t){let e=t.dataId;if(this.data.has(e)){let r=this.data.get(e);r.refCount--,r.refCount<1&&this.disposeData(e)}}async time(t){let e=cr();t();let r=cr()-e;return{kernelMs:r}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}stridedSlice(t,e,r,s){At(t,"stridedSlice");let u=sd(e,r,s);if(u.some(p=>p===0))return vn([],u);let l=Ae(u,t.dtype),h=this.bufferSync(t);for(let p=0;p<l.size;p++){let m=l.indexToLoc(p),y=new Array(m.length);for(let b=0;b<y.length;b++)y[b]=m[b]*s[b]+e[b];l.set(h.get(...y),...m)}return l.toTensor()}diag(t){let e=this.readSync(t.dataId),r=Ae([t.size,t.size],t.dtype),s=r.values;for(let u=0;u<e.length;u++)s[u*t.size+u]=e[u];return r.toTensor()}unstack(t,e){let r=t.shape[e],s=new Array(t.rank-1),u=0;for(let m=0;m<t.rank;m++)m!==e&&(s[u++]=t.shape[m]);let l=new Array(t.rank).fill(0),h=t.shape.slice();h[e]=1;let p=new Array(r);for(let m=0;m<p.length;m++)l[e]=m,p[m]=ge(t,l,h).reshape(s);return p}reverse(t,e){At(t,"reverse");let r=Ae(t.shape,t.dtype),s=this.bufferSync(t);for(let u=0;u<r.size;u++){let l=r.indexToLoc(u),h=l.slice();e.forEach(p=>h[p]=t.shape[p]-1-h[p]),r.set(s.get(...h),...l)}return r.toTensor()}neg(t){return At(t,"neg"),st(Ot(-1),t)}addN(t){At(t,"addN");let e=t.map(u=>this.readSync(u.dataId)),r=Ae(t[0].shape,t[0].dtype),s=r.values;for(let u=0;u<t.length;u++){let l=e[u];for(let h=0;h<s.length;h++)s[h]+=l[h]}return r.toTensor()}softmax(t,e){let r=Et([e],t.shape),s=dr(t,r),u=zn(s.shape,r),l=Mt(t,s.reshape(u)),h=Br(l),p=this.sum(h,r).reshape(u);return Ht(h,p)}pow(t,e){return At([t,e],"pow"),this.broadcastedBinaryOp(t,e,t.dtype,(r,s)=>Math.pow(r,s))}floorDiv(t,e){At([t,e],"floorDiv");let r=(u,l)=>Math.floor(u/l),s="int32";return this.broadcastedBinaryOp(t,e,s,r)}sum(t,e){At(t,"sum"),lr("sum",e,t.rank);let[r,s]=Bn(t.shape,e),u=Qn(t.dtype,"int32"),l=Se(r,u),h=O(s),p=this.readSync(l.dataId),m=this.readSync(t.dataId);for(let y=0;y<p.length;++y){let b=y*h,x=0;for(let S=0;S<h;++S)x+=m[b+S];p[y]=x}return l}prod(t,e){At(t,"sum");let[r,s]=Bn(t.shape,e),u=Qn(t.dtype,"int32"),l=Se(r,u),h=O(s),p=this.readSync(l.dataId),m=this.readSync(t.dataId);for(let y=0;y<p.length;++y){let b=y*h,x=1;for(let S=0;S<h;++S)x*=m[b+S];p[y]=x}return l}unsortedSegmentSum(t,e,r){At(t,"unsortedSegmentSum");let s=[],u=t.rank-e.rank;for(let l=0;l<u;++l)e=e.expandDims(l+1);for(let l=0;l<r;++l){let h=Ot(l,"int32"),p=gs(h,e).asType("float32"),m=p.mul(t).sum(0);s.push(m)}return mr(s)}argMin(t,e){At(t,"argMin");let r=[e];lr("argMin",r,t.rank);let[s,u]=Bn(t.shape,r),l=Se(s,"int32"),h=O(u),p=this.readSync(l.dataId),m=this.readSync(t.dataId);for(let y=0;y<p.length;++y){let b=y*h,x=m[b],S=0;for(let C=0;C<h;++C){let I=m[b+C];I<x&&(x=I,S=C)}p[y]=S}return l}argMax(t,e){At(t,"argMax");let r=[e];lr("argMax",r,t.rank);let[s,u]=Bn(t.shape,r),l=Se(s,"int32"),h=O(u),p=this.readSync(l.dataId),m=this.readSync(t.dataId);for(let y=0;y<p.length;++y){let b=y*h,x=m[b],S=0;for(let C=0;C<h;++C){let I=m[b+C];I>x&&(x=I,S=C)}p[y]=S}return l}cumsum(t,e,r,s){if(At(t,"cumsum"),e!==t.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${t.rank-1} but got axis=${e}`);let u=Qn(t.dtype,"int32"),l=Se(t.shape,u),h=this.readSync(l.dataId),p=this.readSync(t.dataId),m=t.shape[t.rank-1],y=s?(b,x)=>b+m-x-1:(b,x)=>b+x;for(let b=0;b<p.length;b+=m)for(let x=0;x<m;x++){let S=y(b,x);if(x===0)h[S]=r?0:p[S];else{let C=y(b,x-1);h[S]=r?p[C]+h[C]:p[S]+h[C]}}return l}equal(t,e){return At([t,e],"equal"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r===s?1:0)}notEqual(t,e){return At([t,e],"notEqual"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r!==s?1:0)}less(t,e){return At([t,e],"less"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r<s?1:0)}lessEqual(t,e){return At([t,e],"lessEqual"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r<=s?1:0)}greater(t,e){return At([t,e],"greater"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r>s?1:0)}greaterEqual(t,e){return At([t,e],"greaterEqual"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r>=s?1:0)}logicalAnd(t,e){return At([t,e],"logicalAnd"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r&&s)}logicalOr(t,e){return At([t,e],"logicalOr"),this.broadcastedBinaryOp(t,e,"bool",(r,s)=>r||s)}select(t,e,r){At([t,e,r],"select");let s=this.readSync(t.dataId),u=this.readSync(e.dataId),l=this.readSync(r.dataId),h=Se(e.shape,Qn(e.dtype,r.dtype)),p=this.readSync(h.dataId),m=0,y=t.rank===0||t.rank>1||e.rank===1?1:O(e.shape.slice(1));for(let b=0;b<s.length;b++)for(let x=0;x<y;x++)s[b]===1?p[m++]=u[b]:p[m++]=l[b];return h}where(t){At([t],"where");let e=this.readSync(t.dataId);return Xj(t.shape,e)}topk(t,e,r){At(t,"topk");let s=this.readSync(t.dataId);return Kj(s,t.shape,t.dtype,e,r)}min(t,e){At(t,"min"),lr("min",e,t.rank);let[r,s]=Bn(t.shape,e),u=Se(r,t.dtype),l=O(s),h=this.readSync(u.dataId),p=this.readSync(t.dataId);for(let m=0;m<h.length;++m){let y=m*l,b=p[y];for(let x=0;x<l;++x){let S=p[y+x];S<b&&(b=S)}h[m]=b}return u}minimum(t,e){return At([t,e],"minimum"),this.broadcastedBinaryOp(t,e,t.dtype,(r,s)=>Math.min(r,s))}mod(t,e){return At([t,e],"mod"),this.broadcastedBinaryOp(t,e,t.dtype,(r,s)=>{let u=r%s;return r<0&&s<0||r>=0&&s>=0?u:(u+s)%s})}maximum(t,e){return At([t,e],"maximum"),this.broadcastedBinaryOp(t,e,t.dtype,(r,s)=>Math.max(r,s))}all(t,e){At(t,"all"),lr("all",e,t.rank);let[r,s]=Bn(t.shape,e),u=Se(r,t.dtype),l=O(s),h=this.readSync(u.dataId),p=this.readSync(t.dataId);for(let m=0;m<h.length;++m){let y=m*l,b=p[y];for(let x=0;x<l;++x){let S=p[y+x];b=b&&S}h[m]=b}return u}any(t,e){At(t,"any"),lr("any",e,t.rank);let[r,s]=Bn(t.shape,e),u=Se(r,t.dtype),l=O(s),h=this.readSync(u.dataId),p=this.readSync(t.dataId);for(let m=0;m<h.length;++m){let y=m*l,b=p[y];for(let x=0;x<l;++x){let S=p[y+x];b=b||S}h[m]=b}return u}squaredDifference(t,e){return At([t,e],"squaredDifference"),this.broadcastedBinaryOp(t,e,t.dtype,(r,s)=>{let u=r-s;return u*u})}eluDer(t,e){At([t,e],"eluDer");let r=new Float32Array(e.size),s=this.readSync(e.dataId),u=this.readSync(t.dataId);for(let l=0;l<s.length;++l){let h=s[l];h>=1?r[l]=u[l]:r[l]=u[l]*(h+1)}return this.makeOutput(r,e.shape,"float32")}atan2(t,e){return At([t,e],"atan2"),this.broadcastedBinaryOp(t,e,t.dtype,(r,s)=>Math.atan2(r,s))}tile(t,e){return At(t,"tile"),jj(this.bufferSync(t),e)}gather(t,e,r){At([t,e],"gather");let s=t.shape.slice(),u=this.readSync(e.dataId);s[r]=u.length;let l=Ae(s,t.dtype),h=this.bufferSync(t);for(let p=0;p<l.size;++p){let m=l.indexToLoc(p),y=m.slice();y[r]=u[m[r]];let b=h.locToIndex(y);l.values[p]=h.values[b]}return l.toTensor()}batchToSpaceND(t,e,r){At([t],"batchToSpaceND");let s=e.reduce((y,b)=>y*b),u=Mh(t.shape,e,s),l=Lh(u.length,e.length),h=Bh(t.shape,e,s),p=Lb(r,e.length),m=Bb(h,r,e.length);return re(t.reshape(u),l).reshape(h).slice(p,m)}pool3d(t,e,r){At(t,"pool3d");let s=e.strideDepth,u=e.strideHeight,l=e.strideWidth,h=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,x=e.effectiveFilterWidth,S=e.padInfo.front,C=e.padInfo.top,I=e.padInfo.left,D=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,R=this.readSync(t.dataId),A=Ae(e.outShape,t.dtype),L=A.values,_=e.outShape[1]*e.outShape[2]*e.outShape[3]*e.outShape[4],B=e.outShape[2]*e.outShape[3]*e.outShape[4],V=e.outShape[3]*e.outShape[4],q=e.outShape[4];for(let j=0;j<e.batchSize;++j){let et=j*_,tt=j*t.strides[0];for(let ht=0;ht<e.inChannels;++ht)for(let gt=0;gt<e.outDepth;++gt){let vt=gt*s-S,bt=vt;for(;bt<0;)bt+=h;let yt=Math.min(e.inDepth,y+vt),mt=et+gt*B;for(let xt=0;xt<e.outHeight;++xt){let wt=xt*u-C,Tt=wt;for(;Tt<0;)Tt+=p;let Dt=Math.min(e.inHeight,b+wt),$t=mt+xt*V;for(let Lt=0;Lt<e.outWidth;++Lt){let Pt=Lt*l-I,Ft=Pt;for(;Ft<0;)Ft+=m;let Vt=Math.min(e.inWidth,x+Pt),ee=$t+Lt*q,pe=D,we=0,de=0;for(let be=bt;be<yt;be+=h){let Je=tt+be*t.strides[1];for(let ln=Tt;ln<Dt;ln+=p){let hn=Je+ln*t.strides[2];for(let Me=Ft;Me<Vt;Me+=m){let Ze=hn+Me*t.strides[3],Ve=R[Ze+ht];if(r==="max"&&Ve>pe?pe=Ve:r==="avg"&&(we+=Ve,de++),isNaN(pe))break}if(isNaN(pe))break}if(isNaN(pe))break}let Ie=ee+ht;L[Ie]=r==="avg"?we/de:pe}}}}return A.toTensor()}avgPool3d(t,e){return At(t,"avgPool3d"),this.pool3d(t,e,"avg").toFloat()}avgPool3dBackprop(t,e,r){At([t,e],"avgPool3dBackprop");let s=r.strideDepth,u=r.strideHeight,l=r.strideWidth,h=r.filterDepth,p=r.filterHeight,m=r.filterWidth,y=r.dilationDepth,b=r.dilationHeight,x=r.dilationWidth,S=r.effectiveFilterDepth,C=r.effectiveFilterHeight,I=r.effectiveFilterWidth,D=S-1-r.padInfo.front,R=I-1-r.padInfo.left,A=C-1-r.padInfo.top,L=Ae(e.shape,"float32"),_=1/(h*p*m),B=this.bufferSync(t);for(let V=0;V<r.batchSize;++V)for(let q=0;q<r.inChannels;++q)for(let j=0;j<r.inDepth;++j)for(let et=0;et<r.inHeight;++et)for(let tt=0;tt<r.inWidth;++tt){let ht=j-D,gt=et-A,vt=tt-R,bt=0;for(let yt=0;yt<S;yt+=y){let mt=(ht+yt)/s;if(mt<0||mt>=r.outDepth||Math.floor(mt)!==mt)continue;for(let xt=0;xt<C;xt+=b){let wt=(gt+xt)/u;if(wt<0||wt>=r.outHeight||Math.floor(wt)!==wt)continue;for(let Tt=0;Tt<I;Tt+=x){let Dt=(vt+Tt)/l;if(Dt<0||Dt>=r.outWidth||Math.floor(Dt)!==Dt)continue;let $t=B.get(V,mt,wt,Dt,q);bt+=$t}}}L.set(bt*_,V,j,et,tt,q)}return L.toTensor()}maxPool3d(t,e){return At(t,"maxPool3d"),this.pool3d(t,e,"max").toFloat()}maxPool3dPositions(t,e){let r=Ae(e.outShape,"int32"),s=e.strideDepth,u=e.strideHeight,l=e.strideWidth,h=e.dilationDepth,p=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,x=e.effectiveFilterWidth,S=e.padInfo.front,C=e.padInfo.top,I=e.padInfo.left,D=this.bufferSync(t);for(let R=0;R<e.batchSize;++R)for(let A=0;A<e.inChannels;++A)for(let L=0;L<e.outDepth;++L){let _=L*s-S,B=_;for(;B<0;)B+=h;let V=Math.min(e.inDepth,y+_);for(let q=0;q<e.outHeight;++q){let j=q*u-C,et=j;for(;et<0;)et+=p;let tt=Math.min(e.inHeight,b+j);for(let ht=0;ht<e.outWidth;++ht){let gt=ht*l-I,vt=gt;for(;vt<0;)vt+=m;let bt=Math.min(e.inWidth,x+gt),yt=Number.NEGATIVE_INFINITY,mt=-1;for(let xt=B;xt<V;xt+=h){let wt=xt-_;for(let Tt=et;Tt<tt;Tt+=p){let Dt=Tt-j;for(let $t=vt;$t<bt;$t+=m){let Lt=$t-gt,Pt=D.get(R,xt,Tt,$t,A);Pt>=yt&&(yt=Pt,mt=wt*b*x+Dt*b+Lt)}}}r.set(mt,R,L,q,ht,A)}}}return r.toTensor()}maxPool3dBackprop(t,e,r,s){At([e,r],"maxPool3dBackprop");let u=this.maxPool3dPositions(e,s),l=s.strideDepth,h=s.strideHeight,p=s.strideWidth,m=s.dilationDepth,y=s.dilationHeight,b=s.dilationWidth,x=s.effectiveFilterDepth,S=s.effectiveFilterHeight,C=s.effectiveFilterWidth,I=x-1-s.padInfo.front,D=C-1-s.padInfo.left,R=S-1-s.padInfo.top,A=Ae(e.shape,"float32"),L=this.bufferSync(u),_=this.bufferSync(t);for(let B=0;B<s.batchSize;++B)for(let V=0;V<s.inChannels;++V)for(let q=0;q<s.inDepth;++q)for(let j=0;j<s.inHeight;++j)for(let et=0;et<s.inWidth;++et){let tt=q-I,ht=j-R,gt=et-D,vt=0;for(let bt=0;bt<x;bt+=m){let yt=(tt+bt)/l;if(yt<0||yt>=s.outDepth||Math.floor(yt)!==yt)continue;for(let mt=0;mt<S;mt+=y){let xt=(ht+mt)/h;if(xt<0||xt>=s.outHeight||Math.floor(xt)!==xt)continue;for(let wt=0;wt<C;wt+=b){let Tt=(gt+wt)/p;if(Tt<0||Tt>=s.outWidth||Math.floor(Tt)!==Tt)continue;let Dt=x*S*C-1-L.get(B,yt,xt,Tt,V),$t=bt*S*C+mt*C+wt,Lt=Dt===$t?1:0;if(Lt===0)continue;let Pt=_.get(B,yt,xt,Tt,V);vt+=Pt*Lt}}}A.set(vt,B,q,j,et,V)}return A.toTensor()}resizeBilinear(t,e,r,s){At(t,"resizeBilinear");let[u,l,h,p]=t.shape,m=this.readSync(t.dataId),y=new Float32Array(O([u,e,r,p])),b=[s&&e>1?l-1:l,s&&r>1?h-1:h],x=[s&&e>1?e-1:e,s&&r>1?r-1:r],S=0,C=b[0]/x[0],I=b[1]/x[1];for(let D=0;D<u;D++)for(let R=0;R<e;R++){let A=C*R,L=Math.floor(A),_=A-L,B=Math.min(l-1,Math.ceil(A)),V=D*t.strides[0]+L*t.strides[1],q=D*t.strides[0]+B*t.strides[1];for(let j=0;j<r;j++){let et=I*j,tt=Math.floor(et),ht=et-tt,gt=Math.min(h-1,Math.ceil(et)),vt=V+tt*t.strides[2],bt=q+tt*t.strides[2],yt=V+gt*t.strides[2],mt=q+gt*t.strides[2];for(let xt=0;xt<p;xt++){let wt=m[vt+xt],Tt=m[bt+xt],Dt=m[yt+xt],$t=m[mt+xt],Lt=wt+(Dt-wt)*ht,Pt=Tt+($t-Tt)*ht,Ft=Lt+(Pt-Lt)*_;y[S++]=Ft}}}return vn(y,[u,e,r,p])}resizeBilinearBackprop(t,e,r){At([t,e],"resizeBilinearBackprop");let[s,u,l,h]=e.shape,[,p,m]=t.shape,y=new Float32Array(s*u*l*h),b=[r&&p>1?u-1:u,r&&m>1?l-1:l],x=[r&&p>1?p-1:p,r&&m>1?m-1:m],S=b[0]/x[0],C=b[1]/x[1],I=this.readSync(t.dataId),D=0;for(let R=0;R<s;R++){let A=R*e.strides[0];for(let L=0;L<p;L++){let _=L*S,B=Math.floor(_),V=Math.min(Math.ceil(_),u-1),q=A+B*e.strides[1],j=A+V*e.strides[1],et=_-B,tt=1-et;for(let ht=0;ht<m;ht++){let gt=ht*C,vt=Math.floor(gt),bt=Math.min(Math.ceil(gt),l-1),yt=gt-vt,mt=1-yt,xt=q+vt*e.strides[2],wt=q+bt*e.strides[2],Tt=j+vt*e.strides[2],Dt=j+bt*e.strides[2],$t=tt*mt,Lt=tt*yt,Pt=et*mt,Ft=et*yt;for(let Vt=0;Vt<h;Vt++){let ee=I[D++];y[xt+Vt]+=ee*$t,y[wt+Vt]+=ee*Lt,y[Tt+Vt]+=ee*Pt,y[Dt+Vt]+=ee*Ft}}}}return Wu(y,[s,l,u,h],e.dtype)}resizeNearestNeighbor(t,e,r,s){At(t,"resizeNearestNeighbor");let[u,l,h,p]=t.shape,m=this.readSync(t.dataId),y=new Float32Array(u*e*r*p),b=[s&&e>1?l-1:l,s&&r>1?h-1:h],x=[s&&e>1?e-1:e,s&&r>1?r-1:r],S=b[0]/x[0],C=b[1]/x[1],I=0;for(let D=0;D<u;D++){let R=D*t.strides[0];for(let A=0;A<e;A++){let L=S*A,_=Math.min(l-1,s?Math.round(L):Math.floor(L)),B=R+_*t.strides[1];for(let V=0;V<r;V++){let q=C*V,j=Math.min(h-1,s?Math.round(q):Math.floor(q)),et=B+j*t.strides[2];for(let tt=0;tt<p;tt++){let ht=m[et+tt];y[I++]=ht}}}}return vn(y,[u,e,r,p],t.dtype)}resizeNearestNeighborBackprop(t,e,r){At([t,e],"resizeNearestNeighborBackprop");let[s,u,l,h]=e.shape,[,p,m]=t.shape,y=new Float32Array(s*u*l*h),b=this.readSync(t.dataId),x=[r&&p>1?u-1:u,r&&m>1?l-1:l],S=[r&&p>1?p-1:p,r&&m>1?m-1:m],C=x[0]/S[0],I=x[1]/S[1],D=1/C,R=1/I,A=Math.ceil(D)*2+2,L=Math.ceil(R)*2+2;for(let _=0;_<s;_++){let B=_*e.strides[0];for(let V=0;V<u;V++){let q=B+V*e.strides[1],j=Math.floor(V*D),et=Math.floor(j-A/2);for(let tt=0;tt<l;tt++){let ht=q+tt*e.strides[2],gt=Math.floor(tt*R),vt=Math.floor(gt-L/2);for(let bt=0;bt<h;bt++){let yt=0;for(let mt=0;mt<A;mt++){let xt=mt+et;if(xt<0||xt>=p)continue;let wt=B+xt*t.strides[1],Tt=xt*C,Dt=Math.min(u-1,r?Math.round(Tt):Math.floor(Tt));if(V!==Dt)continue;for(let $t=0;$t<L;$t++){let Lt=$t+vt;if(Lt<0||Lt>=m)continue;let Pt=wt+Lt*t.strides[2],Ft=Lt*I,Vt=Math.min(l-1,r?Math.round(Ft):Math.floor(Ft));tt===Vt&&(yt+=b[Pt+bt])}}y[ht+bt]=yt}}}}return Wu(y,e.shape,e.dtype)}localResponseNormalization4D(t,e,r,s,u){At(t,"localResponseNormalization4D");let l=t.shape[3],h=l-1,p=this.readSync(t.dataId),m=t.size,y=new Float32Array(m);function b(x){let S=x%l,C=x-S+Math.max(0,S-e),I=x-S+Math.min(S+e,h),D=0;for(;C<=I;C++){let R=p[C];D+=R*R}return D}for(let x=0;x<m;x++){let S=b(x),C=p[x]*Math.pow(r+s*S,-u);y[x]=C}return Wu(y,t.shape)}LRNGrad(t,e,r,s,u,l,h){At(t,"LRNGrad");let p=t.shape[3],m=this.readSync(t.dataId),y=this.readSync(e.dataId),b=this.readSync(r.dataId),x=new Float32Array(t.size),S=t.size;for(let C=0;C<S;C++){let I=C%p,D=C-I+Math.max(0,I-s),R=C-I+Math.min(p,I+s+1),A=0;for(let L=D;L<R;L++)A+=Math.pow(y[L],2);A=l*A+u;for(let L=D;L<R;L++){let _=-2*l*h*y[L]*b[C]/A;C===L&&(_+=Math.pow(A,-h)),_*=m[C],x[L]+=_}}return Wu(x,t.shape)}multinomial(t,e,r,s){At(t,"multinomial");let u=e?t:bi(t),l=u.shape[0],h=u.shape[1],p=Se([l,r],"int32"),m=this.readSync(p.dataId),y=this.readSync(u.dataId);for(let b=0;b<l;++b){let x=b*h,S=new Float32Array(h-1);S[0]=y[x];for(let D=1;D<S.length;++D)S[D]=S[D-1]+y[x+D];let C=Lu(s.toString()),I=b*r;for(let D=0;D<r;++D){let R=C();m[I+D]=S.length;for(let A=0;A<S.length;A++)if(R<S[A]){m[I+D]=A;break}}}return p}oneHot(t,e,r,s){At(t,"oneHot");let u=new Float32Array(t.size*e);u.fill(s);let l=this.readSync(t.dataId);for(let h=0;h<t.size;++h)l[h]>=0&&l[h]<e&&(u[h*e+l[h]]=r);return pa(u,[t.size,e],"int32")}nonMaxSuppression(t,e,r,s,u){At(t,"nonMaxSuppression");let l=this.readSync(t.dataId),h=this.readSync(e.dataId);return Hj(l,h,r,s,u)}depthToSpace(t,e,r){k(r==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`),k(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`);let s=t.shape[0],u=t.shape[1],l=t.shape[2],h=t.shape[3],p=u*e,m=l*e,y=h/(e*e),b=this.readSync(t.dataId),x=new Float32Array(s*p*m*y),S=0;for(let C=0;C<s;++C)for(let I=0;I<p;++I){let D=Math.floor(I/e),R=I%e;for(let A=0;A<m;++A){let L=Math.floor(A/e),_=A%e,B=(R*e+_)*y;for(let V=0;V<y;++V){let q=V+B,j=q+h*(L+l*(D+u*C));x[S++]=b[j]}}}return Wu(x,[s,p,m,y])}broadcastedBinaryOp(t,e,r,s){let u=ve(t.shape,e.shape),l=Ae(u,r),h=this.readSync(t.dataId),p=this.readSync(e.dataId),m=di(t.shape,u),y=di(e.shape,u),b=l.values;if(m.length+y.length===0)for(let x=0;x<b.length;++x)b[x]=s(h[x%h.length],p[x%p.length]);else{let x=this.bufferSync(t),S=this.bufferSync(e);for(let C=0;C<b.length;++C){let I=l.indexToLoc(C),D=I.slice(-t.rank);m.forEach(_=>D[_]=0);let R=x.locToIndex(D),A=I.slice(-e.rank);y.forEach(_=>A[_]=0);let L=S.locToIndex(A);b[C]=s(h[R],p[L])}}return l.toTensor()}split(t,e,r){return qj(t,e,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(t,e,r,s,u,l){let[h,p,m,y]=t.shape,b=e.shape[0],[x,S]=s,C=Ae([b,x,S,y],"float32"),I=this.readSync(e.dataId),D=this.readSync(r.dataId),R=this.readSync(t.dataId),A=t.strides,L=C.strides;for(let _=0;_<b;_++){let B=_*4,V=I[B],q=I[B+1],j=I[B+2],et=I[B+3],tt=D[_];if(tt>=h)continue;let ht=x>1?(j-V)*(p-1)/(x-1):0,gt=S>1?(et-q)*(m-1)/(S-1):0;for(let vt=0;vt<x;vt++){let bt=x>1?V*(p-1)+vt*ht:.5*(V+j)*(p-1);if(bt<0||bt>p-1){for(let yt=0;yt<S;yt++)for(let mt=0;mt<y;mt++){let xt=mt+yt*L[2]+vt*L[1]+_*L[0];C.values[xt]=l}continue}if(u==="bilinear"){let yt=Math.floor(bt),mt=Math.ceil(bt),xt=bt-yt;for(let wt=0;wt<S;wt++){let Tt=S>1?q*(m-1)+wt*gt:.5*(q+et)*(m-1);if(Tt<0||Tt>m-1){for(let Pt=0;Pt<y;Pt++){let Ft=Pt+wt*L[2]+vt*L[1]+_*L[0];C.values[Ft]=l}continue}let Dt=Math.floor(Tt),$t=Math.ceil(Tt),Lt=Tt-Dt;for(let Pt=0;Pt<y;Pt++){let Ft=Pt+Dt*A[2]+yt*A[1]+tt*A[0],Vt=R[Ft];Ft=Pt+$t*A[2]+yt*A[1]+tt*A[0];let ee=R[Ft];Ft=Pt+Dt*A[2]+mt*A[1]+tt*A[0];let pe=R[Ft];Ft=Pt+$t*A[2]+mt*A[1]+tt*A[0];let we=R[Ft],de=Vt+(ee-Vt)*Lt,Ie=pe+(we-pe)*Lt;Ft=Pt+wt*L[2]+vt*L[1]+_*L[0],C.values[Ft]=de+(Ie-de)*xt}}}else for(let yt=0;yt<S;++yt){let mt=S>1?q*(m-1)+yt*gt:.5*(q+et)*(m-1);if(mt<0||mt>m-1){for(let Tt=0;Tt<y;Tt++){let Dt=Tt+yt*L[2]+vt*L[1]+_*L[0];C.values[Dt]=l}continue}let xt=Math.round(mt),wt=Math.round(bt);for(let Tt=0;Tt<y;Tt++){let Dt=Tt+xt*A[2]+wt*A[1]+tt*A[0],$t=Tt+yt*L[2]+vt*L[1]+_*L[0];C.values[$t]=R[Dt]}}}}return C.toTensor()}sparseToDense(t,e,r,s){let{sliceRank:u,numUpdates:l,sliceSize:h,strides:p,outputSize:m}=Iu(e,t,r),y=!1;return this.scatter(t,e,r,m,h,l,u,p,s,y)}gatherND(t,e){let r=e.shape,s=r[r.length-1],[u,l,h,p]=nd(t,e);if(l===0)return vn([],u,t.dtype);let m=new bn([l,h],t.dtype),y=this.readSync(e.dataId),b=this.readSync(t.dataId);for(let x=0;x<l;x++){let S=[],C=0;for(let I=0;I<s;I++){let D=y[x*s+I];C+=D*p[I],S.push(D)}if(C<0||C>=t.size/h)throw new Error(`Invalid indices: ${S} does not index into ${t.shape}`);for(let I=0;I<h;I++)m.values[x*h+I]=b[C*h+I]}return m.toTensor().reshape(u)}scatterND(t,e,r){let{sliceRank:s,numUpdates:u,sliceSize:l,strides:h,outputSize:p}=Iu(e,t,r),m=Ot(0),y=!0;return this.scatter(t,e,r,p,l,u,s,h,m,y)}onesLike(t){if(t.dtype==="string")throw new Error("onesLike is not supported for string tensors");return Au(t.shape,1,t.dtype)}zerosLike(t){let e=Kt(t.dtype,O(t.shape));return this.makeOutput(e,t.shape,t.dtype)}linspace(t,e,r){return jb(t,e,r)}scatter(t,e,r,s,u,l,h,p,m,y){let b=[s/u,u],x=this.readSync(t.dataId),S=this.readSync(e.dataId);if(s===0)return vn([],r,e.dtype);let C=new bn(b,e.dtype);C.values.fill(this.readSync(m.dataId)[0]);for(let I=0;I<l;I++){let D=[],R=0;for(let A=0;A<h;A++){let L=x[I*h+A];D.push(L),R+=L*p[A]}if(R<0||R>=s/u)throw new Error(`Invalid indices: ${D} does not index into ${r}`);for(let A=0;A<u;A++)y?C.values[R*u+A]+=S[I*u+A]:C.values[R*u+A]=e.rank===0?S[0]:S[I*u+A]}return C.toTensor().reshape(r)}}function cE(n){let t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}let Jj=n=>{let{x:t}=n.inputs,e=n.backend,r=new Float32Array(O(t.shape));if(t.dtype!=="complex64"){let s=e.data.get(t.dataId).values;r=cE(s)}else{let s=e.data.get(t.dataId),u=s.complexTensorInfos.real,l=s.complexTensorInfos.imag,h=e.data.get(u.dataId).values,p=e.data.get(l.dataId).values;for(let m=0;m<h.length;m++){let y=h[m],b=p[m];r[m]=Math.hypot(y,b)}}return e.makeOutput(r,t.shape,"float32")},Zj={kernelName:hp,backendName:"cpu",kernelFunc:Jj};function Ca(n){return(t,e,r,s,u)=>{let l=ve(t,e),h=l.length,p=Jt(l),m=O(l),y=_t(u,m),b=t.length,x=e.length,S=Jt(t),C=Jt(e),I=di(t,l),D=di(e,l);if(I.length+D.length===0)for(let R=0;R<y.length;++R)y[R]=n(r[R%r.length],s[R%s.length]);else for(let R=0;R<y.length;++R){let A=ei(R,h,p),L=A.slice(-b);I.forEach(q=>L[q]=0);let _=Qr(L,b,S),B=A.slice(-x);D.forEach(q=>B[q]=0);let V=Qr(B,x,C);y[R]=n(r[_],s[V])}return[y,l]}}function Ds(n){let{inputs:t,backend:e}=n,{real:r,imag:s}=t,u=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,h=e.makeTensorInfo(r.shape,"complex64"),p=e.data.get(h.dataId);return p.complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",u),imag:e.makeTensorInfo(s.shape,"float32",l)},h}let Qj={kernelName:mp,backendName:"cpu",kernelFunc:Ds};function Di(n){let{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}let t6={kernelName:Al,backendName:"cpu",kernelFunc:Di};function ff(n){let{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,u=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,u)}let e6={kernelName:Rp,backendName:"cpu",kernelFunc:ff};function pf(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:u}=r;if(u==="complex64"){if(s.dtype==="complex64")return Di({inputs:{x:s},backend:e});let l=Se(s.shape),h=pf({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),p=Ds({inputs:{real:h,imag:l},backend:e});return l.dispose(),e.disposeIntermediateTensorInfo(h),p}if(s.dtype==="complex64"){let l=ff({inputs:{input:s},backend:e}),h=pf({inputs:{x:l},backend:e,attrs:{dtype:u}});return e.disposeIntermediateTensorInfo(l),h}if(!me(s.dtype,u)){let l=Di({inputs:{x:s},backend:e});return{dataId:l.dataId,shape:l.shape,dtype:u}}if(u==="int32"){let l=e.data.get(s.dataId).values,h=Int32Array.from(l);return e.makeTensorInfo(s.shape,"int32",h)}if(u==="bool"){let l=e.data.get(s.dataId).values,h=na([0],s.dtype),[p,m]=Ca((y,b)=>y!==b?1:0)(s.shape,[],l,h,"bool");return e.makeTensorInfo(m,"bool",p)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${u}`)}let n6={kernelName:pu,backendName:"cpu",kernelFunc:pf};function sc(n,t,e,r){return e==null?({inputs:s,backend:u})=>{let{a:l,b:h}=s,p=u;At([l,h],n);let m=p.data.get(l.dataId).values,y=p.data.get(h.dataId).values,b=r||l.dtype,[x,S]=t(l.shape,h.shape,m,y,b);return p.makeTensorInfo(S,b,x)}:({inputs:s,backend:u})=>{let{a:l,b:h}=s,p=u;if(l.dtype==="complex64"||h.dtype==="complex64"){let m=pf({inputs:{x:l},backend:p,attrs:{dtype:"complex64"}}),y=p.data.get(m.dataId),b=y.complexTensorInfos.real,x=y.complexTensorInfos.imag,S=p.data.get(b.dataId).values,C=p.data.get(x.dataId).values,I=pf({inputs:{x:h},backend:p,attrs:{dtype:"complex64"}}),D=p.data.get(I.dataId),R=D.complexTensorInfos.real,A=D.complexTensorInfos.imag,L=p.data.get(R.dataId).values,_=p.data.get(A.dataId).values,[B,V,q]=e(l.shape,h.shape,S,C,L,_),j=p.makeTensorInfo(q,"float32",B),et=p.makeTensorInfo(q,"float32",V),tt=Ds({inputs:{real:j,imag:et},backend:p});return p.disposeIntermediateTensorInfo(m),p.disposeIntermediateTensorInfo(I),p.disposeIntermediateTensorInfo(j),p.disposeIntermediateTensorInfo(et),tt}else{let m=p.data.get(l.dataId).values,y=p.data.get(h.dataId).values,b=r||l.dtype,[x,S]=t(l.shape,h.shape,m,y,b);return p.makeTensorInfo(S,b,x)}}}function K0(n){return(t,e,r,s,u,l)=>{let h=ve(t,e),p=O(h),m=h.length,y=Jt(h),b=_t("float32",p),x=_t("float32",p),S=di(t,h),C=di(e,h),I=So(r,s),D=So(u,l),R=t.length,A=Jt(t),L=e.length,_=Jt(e);if(S.length+C.length===0)for(let B=0;B<b.length;B++){let V=B%I.length,q=B%D.length,j=n(I[V*2],I[V*2+1],D[q*2],D[q*2+1]);b[B]=j.real,x[B]=j.imag}else for(let B=0;B<b.length;B++){let V=ei(B,m,y),q=V.slice(-R);S.forEach(gt=>q[gt]=0);let j=Qr(q,R,A),et=V.slice(-L);C.forEach(gt=>et[gt]=0);let tt=Qr(et,L,_),ht=n(I[j*2],I[j*2+1],D[tt*2],D[tt*2+1]);b[B]=ht.real,x[B]=ht.imag}return[b,x,h]}}let lE=Ca((n,t)=>n+t),r6=K0((n,t,e,r)=>({real:n+e,imag:t+r})),df=sc(ri,lE,r6),s6={kernelName:ri,backendName:"cpu",kernelFunc:df};function oc(n){return(t,e,r)=>{let s=_t(e,t.length);for(let u=0;u<t.length;++u)s[u]=n(t[u],r);return s}}function Pe(n,t,e){return({inputs:r,attrs:s,backend:u})=>{let{x:l}=r;if(At(l,n),l.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let h=u,p=h.data.get(l.dataId).values,m=O(l.shape),y=e||l.dtype,b=Kt(y,m);for(let x=0;x<m;++x)b[x]=t(p[x],s);return h.makeTensorInfo(l.shape,y,b)}}function ac(n,t,e){return({inputs:r,attrs:s,backend:u})=>{let{x:l}=r;if(At(l,n),l.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let h=u,p=h.data.get(l.dataId).values,m=e||l.dtype,y=t(p,m,s);return h.makeTensorInfo(l.shape,m,y)}}let hE=oc(n=>Math.ceil(n)),o6=ac(xl,hE),a6={kernelName:xl,backendName:"cpu",kernelFunc:o6};let fE=oc(n=>Math.exp(n)),i6=ac(Il,fE),u6={kernelName:Il,backendName:"cpu",kernelFunc:i6};let pE=oc(n=>Math.expm1(n)),c6=ac(El,pE),l6={kernelName:El,backendName:"cpu",kernelFunc:c6};let dE=oc(n=>Math.floor(n)),h6=ac(Dl,dE),f6={kernelName:Dl,backendName:"cpu",kernelFunc:h6};let mE=oc(n=>Math.log(n)),p6=ac(Pl,mE),d6={kernelName:Pl,backendName:"cpu",kernelFunc:p6};function gE(n,t,e,r){let s=_t(r,O(e));for(let u=0;u<s.length;++u){let l=u*t,h=n[l];for(let p=0;p<t;++p){let m=n[l+p];m>h&&(h=m)}s[u]=h}return s}let vE=Ca((n,t)=>n*t),m6=K0((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),yE=sc(gu,vE,m6),g6={kernelName:gu,backendName:"cpu",kernelFunc:yE};let bE=Ca((n,t)=>n!==t?1:0),v6=sc(zl,bE,null,"bool"),y6={kernelName:zl,backendName:"cpu",kernelFunc:v6};let wE=oc(n=>1/Math.sqrt(n)),b6=ac(ql,wE),w6={kernelName:ql,backendName:"cpu",kernelFunc:b6};function xE(n,t,e,r,s){let u=zy(r,t,e),l=O(e),h=Jt(r);if(u){let m=Wy(t,h);return n.subarray(m,m+l)}let p=_t(s,l);for(let m=0;m<l;++m){let y=e.length,b=Jt(e),x=ei(m,y,b),S=x.map((I,D)=>I+t[D]),C=Qr(S,r.length,h);p[m]=n[C]}return p}function X0(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:u,size:l}=r;At(s,"slice");let[h,p]=od(s,u,l);By(s,h,p);let m=e.data.get(s.dataId).values,y=xE(m,h,p,s.shape,s.dtype);return e.makeTensorInfo(p,s.dtype,y)}let x6={kernelName:Pp,backendName:"cpu",kernelFunc:X0};let TE=Ca((n,t)=>{let e=n-t;return e*e}),T6=sc(yu,TE),k6={kernelName:yu,backendName:"cpu",kernelFunc:T6};let kE=Ca((n,t)=>n-t),S6=K0((n,t,e,r)=>({real:n-e,imag:t-r})),SE=sc(bu,kE,S6),C6={kernelName:bu,backendName:"cpu",kernelFunc:SE};function Y0(n,t,e,r,s){let u=t.length,l=O(t),h=Jt(t),p=Jt(s),m=_t(e,O(s));for(let y=0;y<l;++y){let b=ei(y,u,h),x=new Array(b.length);for(let C=0;C<x.length;C++)x[C]=b[r[C]];let S=Qr(x,u,p);m[S]=n[y]}return m}function CE(n,t,e,r){let s=Et(t,e)[0],u=[1,e[0],1];for(let C=0;C<s;C++)u[0]*=e[C];u[1]=e[s];for(let C=s+1;C<e.length;C++)u[2]*=e[C];let l={},h=new Int32Array(e[s]),p=new bn(u,r,n),m=[],y=u[0]===1&&u[2]===1;for(let C=0;C<e[s];C++){let I;if(y)I=n[C].toString();else{let D=[];for(let R=0;R<u[0];R++)for(let A=0;A<u[2];A++)D.push(p.get(R,C,A));I=D.join(",")}if(l[I]!==void 0)h[C]=l[I];else{let D=Object.keys(l).length;l[I]=D,h[C]=D,m.push(C)}}let b=u.slice();b[1]=Object.keys(l).length;let x=new bn(b,r);m.forEach((C,I)=>{for(let D=0;D<u[0];D++)for(let R=0;R<u[2];R++)x.set(p.get(D,C,R),D,I,R)});let S=e.slice();return S[s]=b[1],{outputValues:x.values,outputShape:S,indices:h}}var N6=Object.freeze({__proto__:null,simpleAbsImpl:cE,addImpl:lE,ceilImpl:hE,expImpl:fE,expm1Impl:pE,floorImpl:dE,logImpl:mE,maxImpl:gE,multiplyImpl:vE,notEqualImpl:bE,rsqrtImpl:wE,sliceImpl:xE,squaredDifferenceImpl:TE,subImpl:kE,transposeImpl:Y0,uniqueImpl:CE});let I6="2.7.0";Hy("cpu",()=>new Yj,1);let NE=Pe(Cl,n=>n>=0?n:Math.exp(n)-1),E6={kernelName:Cl,backendName:"cpu",kernelFunc:NE};let D6=Ca((n,t)=>n<0?t*n:n);function IE(n){let{inputs:t,backend:e}=n,{x:r,alpha:s}=t;At([r,s],"prelu");let u=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,[h,p]=D6(r.shape,s.shape,u,l,r.dtype);return e.makeTensorInfo(p,r.dtype,h)}let $6={kernelName:Fp,backendName:"cpu",kernelFunc:IE};let EE=Pe(Vl,n=>Math.max(0,n)),A6={kernelName:Vl,backendName:"cpu",kernelFunc:EE};let DE=Pe(Gl,n=>Math.min(Math.max(0,n),6)),_6={kernelName:Gl,backendName:"cpu",kernelFunc:DE};function J0(n,t,e,r){if(e==="linear")return Di({inputs:{x:t},backend:n});if(e==="relu")return EE({inputs:{x:t},backend:n});if(e==="elu")return NE({inputs:{x:t},backend:n});if(e==="relu6")return DE({inputs:{x:t},backend:n});if(e==="prelu")return IE({inputs:{x:t,alpha:r},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function to(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:u}=r,l=O(s.shape),h=Gt(u,l),p=O(h);k(l===p,()=>`The new shape (${h}) has ${p} elements and the old shape (${s.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);let m=e.data.get(s.dataId);if(m.complexTensorInfos!=null){let y=m.complexTensorInfos.real,b=m.complexTensorInfos.imag;y.shape=h,b.shape=h}return{dataId:s.dataId,shape:h,dtype:s.dtype}}let F6={kernelName:Ul,backendName:"cpu",kernelFunc:to};function $E(n){let{inputs:t,backend:e,attrs:r}=n,{a:s,b:u}=t,{transposeA:l,transposeB:h}=r;At([s,u],"matMul");let p=s.shape.length,m=u.shape.length,y=l?s.shape[p-2]:s.shape[p-1],b=h?u.shape[m-1]:u.shape[m-2],x=l?s.shape[p-1]:s.shape[p-2],S=h?u.shape[m-2]:u.shape[m-1],C=s.shape.slice(0,-2),I=u.shape.slice(0,-2),D=O(C),R=O(I),A=D===R||D===1||R===1;k(p>=2&&m>=2&&A,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${C}) and (${I}).`);let L=D>R?s.shape.slice(0,-2):u.shape.slice(0,-2),_=L.concat([x,S]);k(y===b,()=>`Error in matMul: inner shapes (${y}) and (${b}) of Tensors with shapes ${s.shape} and ${u.shape} and transposeA=${l} and transposeB=${h} must match.`);let B=l?[D,y,x]:[D,x,y],V=h?[R,S,b]:[R,b,S],q=to({inputs:{x:s},backend:e,attrs:{shape:B}}),j=to({inputs:{x:u},backend:e,attrs:{shape:V}}),et=l?q.shape[1]:q.shape[2],tt=l?q.shape[2]:q.shape[1],ht=h?j.shape[1]:j.shape[2],gt=Math.max(D,R),vt=e.data.get(q.dataId).values,bt=e.data.get(j.dataId).values,yt=Jt(q.shape),mt=Jt(j.shape),[xt,wt,Tt]=l?[yt[0],1,yt[1]]:[yt[0],yt[1],1],[Dt,$t,Lt]=h?[1,mt[1],mt[0]]:[mt[1],1,mt[0]],Pt=tt*ht,Ft=Ae([gt,tt,ht],q.dtype),Vt=Ft.values,ee=e.blockSize;for(let pe=0;pe<gt;pe++)for(let we=0;we<tt;we+=ee)for(let de=0;de<ht;de+=ee)for(let Ie=0;Ie<et;Ie+=ee){let be=Math.min(we+ee,tt),Je=Math.min(de+ee,ht),ln=Math.min(Ie+ee,et);for(let hn=we;hn<be;hn++)for(let Me=de;Me<Je;Me++){let Ze=0;for(let Ve=Ie;Ve<ln;Ve++){let Un=Math.min(pe,D-1)*xt,Po=Math.min(pe,R-1)*Lt,Gn=vt[Un+hn*wt+Ve*Tt],$s=bt[Ve*Dt+Me*$t+Po];Ze+=Gn*$s}Vt[pe*Pt+(hn*ht+Me)]+=Ze}}return e.disposeIntermediateTensorInfo(q),e.disposeIntermediateTensorInfo(j),e.makeTensorInfo(_,Ft.dtype,Ft.values)}let R6={kernelName:dp,backendName:"cpu",kernelFunc:$E};function P6(n){let{inputs:t,backend:e,attrs:r}=n,{a:s,b:u,bias:l,preluActivationWeights:h}=t,{transposeA:p,transposeB:m,activation:y}=r,b,x,S,C=[],I=$E({inputs:{a:s,b:u},attrs:{transposeA:p,transposeB:m},backend:e});b=I,l&&(x=df({inputs:{a:b,b:l},backend:e}),C.push(b),b=x),y&&(S=J0(e,b,y,h),C.push(b),b=S);for(let D of C)e.disposeIntermediateTensorInfo(D);return b}let O6={kernelName:Wp,backendName:"cpu",kernelFunc:P6};let M6=Pe(dl,n=>Math.acos(n)),L6={kernelName:dl,backendName:"cpu",kernelFunc:M6};let B6=Pe(ml,n=>Math.acosh(n)),z6={kernelName:ml,backendName:"cpu",kernelFunc:B6};let W6=Pe(gl,n=>Math.asin(n)),V6={kernelName:gl,backendName:"cpu",kernelFunc:W6};let U6=Pe(vl,n=>Math.asinh(n)),G6={kernelName:vl,backendName:"cpu",kernelFunc:U6};let H6=Pe(yl,n=>Math.atan(n)),q6={kernelName:yl,backendName:"cpu",kernelFunc:H6};let j6=Pe(bl,n=>Math.atanh(n)),K6={kernelName:bl,backendName:"cpu",kernelFunc:j6};function Z0(n,t,e,r,s,u){let l=s.strideHeight,h=s.strideWidth,p=s.dilationHeight,m=s.dilationWidth,y=s.effectiveFilterHeight,b=s.effectiveFilterWidth,x=s.padInfo.top,S=s.padInfo.left,C=u==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,I=Ae(s.outShape,e),D=I.values,R=s.outShape[1]*s.outShape[2]*s.outShape[3],A=s.outShape[2]*s.outShape[3],L=s.outShape[3];for(let _=0;_<s.batchSize;++_){let B=_*R,V=_*r[0];for(let q=0;q<s.inChannels;++q)for(let j=0;j<s.outHeight;++j){let et=j*l-x,tt=Math.max(0,et),ht=Math.min(s.inHeight,y+et),gt=B+j*A;for(let vt=0;vt<s.outWidth;++vt){let bt=vt*h-S,yt=Math.max(0,bt),mt=Math.min(s.inWidth,b+bt),xt=C,wt=0,Tt=0;for(let $t=tt;$t<ht;$t+=p){let Lt=V+$t*r[1];for(let Pt=yt;Pt<mt;Pt+=m){let Ft=Lt+Pt*r[2],Vt=n[Ft+q];u==="max"&&Vt>xt?xt=Vt:u==="avg"&&(wt+=Vt,Tt++)}if(isNaN(xt))break}let Dt=gt+vt*L+q;D[Dt]=u==="avg"?wt/Tt:xt}}}return I}function AE(n,t,e,r,s=!1,u=!1){let l=Ae(r.outShape,"int32"),h=r.strideHeight,p=r.strideWidth,m=r.dilationHeight,y=r.dilationWidth,b=r.effectiveFilterHeight,x=r.effectiveFilterWidth,S=r.padInfo.top,C=r.padInfo.left,I=Ae(t,e,n);for(let D=0;D<r.batchSize;++D)for(let R=0;R<r.inChannels;++R)for(let A=0;A<r.outHeight;++A){let L=A*h-S,_=L;for(;_<0;)_+=m;let B=Math.min(r.inHeight,b+L);for(let V=0;V<r.outWidth;++V){let q=V*p-C,j=q;for(;j<0;)j+=y;let et=Math.min(r.inWidth,x+q),tt=Number.NEGATIVE_INFINITY,ht=-1;for(let gt=_;gt<B;gt+=m){let vt=gt-L;for(let bt=j;bt<et;bt+=y){let yt=bt-q,mt=I.get(D,gt,bt,R);mt>tt&&(tt=mt,s?ht=u?((D*r.inHeight+gt)*r.inWidth+bt)*r.inChannels+R:(gt*r.inWidth+bt)*r.inChannels+R:ht=vt*x+yt)}}l.set(ht,D,A,V,R)}}return l}function X6(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t;At(s,"avgPool");let{filterSize:u,strides:l,pad:h,dimRoundingMode:p}=r,m=1;k(wn(l,m),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let y=tr(s.shape,u,l,m,h,p),b;if(y.filterWidth===1&&y.filterHeight===1&&K(y.inShape,y.outShape))b=Di({inputs:{x:s},backend:e});else{let x=e.data.get(s.dataId).values,S=Jt(s.shape),C=Z0(x,s.shape,s.dtype,S,y,"avg");b=e.makeTensorInfo(y.outShape,s.dtype,C.values)}return b}let Y6={kernelName:wl,backendName:"cpu",kernelFunc:X6};function J6(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,input:u}=t,l=u;At([s,u],"avgPoolBackprop");let{filterSize:h,strides:p,pad:m}=r,y=tr(l.shape,h,p,1,m),b=y.strideHeight,x=y.strideWidth,S=y.filterHeight,C=y.filterWidth,I=y.dilationHeight,D=y.dilationWidth,R=y.effectiveFilterHeight,A=y.effectiveFilterWidth,L=A-1-y.padInfo.left,_=R-1-y.padInfo.top,B=Ae(l.shape,"float32"),V=1/(S*C),q=e.data.get(s.dataId).values,j=Ae(s.shape,"float32",q);for(let et=0;et<y.batchSize;++et)for(let tt=0;tt<y.inChannels;++tt)for(let ht=0;ht<y.inHeight;++ht)for(let gt=0;gt<y.inWidth;++gt){let vt=ht-_,bt=gt-L,yt=0;for(let mt=0;mt<R;mt+=I){let xt=(vt+mt)/b;if(xt<0||xt>=y.outHeight||Math.floor(xt)!==xt)continue;for(let wt=0;wt<A;wt+=D){let Tt=(bt+wt)/x;if(Tt<0||Tt>=y.outWidth||Math.floor(Tt)!==Tt)continue;let Dt=j.get(et,xt,Tt,tt);yt+=Dt}}B.set(yt*V,et,ht,gt,tt)}return e.makeTensorInfo(B.shape,B.dtype,B.values)}let Z6={kernelName:pp,backendName:"cpu",kernelFunc:J6};function Q6(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,scale:u,offset:l,mean:h,variance:p}=t;k(h.shape.length===p.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(l==null||h.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(u==null||h.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),At([s,h,p,u,l],"batchNorm");let{varianceEpsilon:m}=r;m==null&&(m=.001);let y=e.data.get(s.dataId).values,b=e.data.get(h.dataId).values,x=e.data.get(p.dataId).values,S=u?e.data.get(u.dataId).values:new Float32Array([1]),C=l?e.data.get(l.dataId).values:new Float32Array([0]),I=new Float32Array(y.length),D=C.length,R=S.length,A=x.length,L=b.length,_=0,B=0,V=0,q=0;for(let j=0;j<y.length;++j)I[j]=C[_++]+(y[j]-b[B++])*S[V++]/Math.sqrt(x[q++]+m),_>=D&&(_=0),B>=L&&(B=0),V>=R&&(V=0),q>=A&&(q=0);return e.makeTensorInfo(s.shape,s.dtype,I)}let tK={kernelName:$l,backendName:"cpu",kernelFunc:Q6};let eK=Pe(Tl,(n,t)=>{let e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),nK={kernelName:Tl,backendName:"cpu",kernelFunc:eK};function Om(n){let{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,u=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,u)}let rK={kernelName:Np,backendName:"cpu",kernelFunc:Om};function mf(n){let{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,u=Et(s,t[0].shape)[0],l=bo(t.map(S=>S.shape),u);if(O(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);let h=t.filter(S=>O(S.shape)>0);if(h.length===1)return h[0];let p=h.map(S=>S.shape);if(fd(p,u),h[0].dtype==="complex64"){let S=h.map(A=>ff({inputs:{input:A},backend:e})),C=h.map(A=>Om({inputs:{input:A},backend:e})),I=mf({inputs:S,backend:e,attrs:{axis:u}}),D=mf({inputs:C,backend:e,attrs:{axis:u}}),R=Ds({inputs:{real:I,imag:D},backend:e});return S.forEach(A=>e.disposeIntermediateTensorInfo(A)),C.forEach(A=>e.disposeIntermediateTensorInfo(A)),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(D),R}let m=h.map(S=>{let C=O(S.shape.slice(u)),I=[-1,C];return to({inputs:{x:S},backend:e,attrs:{shape:I}})});l=bo(m.map(S=>S.shape),1);let y=_t(h[0].dtype,O(l));if(m[0].shape[0]===1){let S=0;m.forEach(C=>{let I=e.data.get(C.dataId).values,D=O(C.shape);y.set(I,S),S+=D})}else{let S=0;m.forEach(C=>{let I=e.data.get(C.dataId).values,D=0;for(let R=0;R<C.shape[0];++R){let A=R*l[1]+S;for(let L=0;L<C.shape[1];++L)y[A+L]=I[D++]}S+=C.shape[1]})}let b=bo(h.map(S=>S.shape),u),x=e.makeTensorInfo(b,t[0].dtype,y);return m.forEach(S=>e.disposeIntermediateTensorInfo(S)),x}let sK={kernelName:kl,backendName:"cpu",kernelFunc:mf};function _E(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,filter:u}=t,{strides:l,pad:h,dataFormat:p,dilations:m,dimRoundingMode:y}=r;At([s,u],"conv2d");let b=ua(p),x=Kn(s.shape,u.shape,l,m,h,y,!1,b),S=x.filterHeight,C=x.filterWidth,I=x.dilationHeight,D=x.dilationWidth,R=x.padInfo.left,A=x.padInfo.top,L=x.dataFormat==="channelsLast",_=new bn(x.outShape,s.dtype),B=Jt(s.shape),V=Jt(u.shape),q=B[0],j=L?B[1]:B[2],et=L?B[2]:1,tt=L?1:B[1],ht=_.strides[0],gt=L?_.strides[1]:_.strides[2],vt=L?_.strides[2]:1,bt=L?1:_.strides[1],yt=e.data.get(s.dataId).values,mt=e.data.get(u.dataId).values,xt=_.values;for(let wt=0;wt<x.batchSize;++wt){let Tt=wt*q,Dt=wt*ht;for(let $t=0;$t<x.outHeight;++$t){let Lt=Dt+$t*gt,Pt=$t*x.strideHeight-A;for(let Ft=0;Ft<S;++Ft){let Vt=Pt+Ft*I;if(Vt<0||Vt>=x.inHeight)continue;let ee=Ft*V[0],pe=Tt+Vt*j;for(let we=0;we<x.outWidth;++we){let de=Lt+we*vt,Ie=we*x.strideWidth-R;for(let be=0;be<C;++be){let Je=Ie+be*D;if(Je<0||Je>=x.inWidth)continue;let ln=ee+be*V[1],hn=pe+Je*et,Me=ln;for(let Ze=0;Ze<x.inChannels;++Ze){let Ve=yt[hn+Ze*tt];for(let Un=0;Un<x.outChannels;++Un)xt[de+Un*bt]+=Ve*mt[Me+Un];Me+=x.outChannels}}}}}}return e.makeTensorInfo(_.shape,_.dtype,xt)}let oK={kernelName:gp,backendName:"cpu",kernelFunc:_E};function aK(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,dy:u}=t,{strides:l,pad:h,dataFormat:p,dimRoundingMode:m,filterShape:y}=r;At([s,u],"conv2dBackpropFilter");let b=ua(p),x=Kn(s.shape,y,l,1,h,m,!1,b),{strideHeight:S,strideWidth:C,filterHeight:I,filterWidth:D}=x,R=x.dataFormat==="channelsLast",A=new bn(x.filterShape,"float32"),L=x.padInfo.left,_=x.padInfo.top,B=e.data.get(s.dataId).values,V=e.data.get(u.dataId).values,q=new bn(s.shape,s.dtype,B),j=new bn(u.shape,u.dtype,V);for(let et=0;et<I;++et){let tt=Math.max(0,Math.ceil((_-et)/S)),ht=Math.min(x.outHeight,(x.inHeight+_-et)/S);for(let gt=0;gt<D;++gt){let vt=Math.max(0,Math.ceil((L-gt)/C)),bt=Math.min(x.outWidth,(x.inWidth+L-gt)/C);for(let yt=0;yt<x.inChannels;++yt)for(let mt=0;mt<x.outChannels;++mt){let xt=0;for(let wt=0;wt<x.batchSize;++wt)for(let Tt=tt;Tt<ht;++Tt){let Dt=et+Tt*S-_;for(let $t=vt;$t<bt;++$t){let Lt=gt+$t*C-L;R?xt+=q.get(wt,Dt,Lt,yt)*j.get(wt,Tt,$t,mt):xt+=q.get(wt,yt,Dt,Lt)*j.get(wt,mt,Tt,$t)}}A.set(xt,et,gt,yt,mt)}}}return e.makeTensorInfo(A.shape,A.dtype,A.values)}let iK={kernelName:Ov,backendName:"cpu",kernelFunc:aK};function uK(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:u}=t,{inputShape:l,strides:h,pad:p,dataFormat:m,dimRoundingMode:y}=r;At([s,u],"conv2dBackpropInput");let b=Jt(u.shape),x=Jt(s.shape),S=ua(m),C=Kn(l,u.shape,h,1,p,y,!1,S),I=new bn(C.inShape,"float32"),D=I.values,R=e.data.get(s.dataId).values,A=e.data.get(u.dataId).values,[L,_,B]=b,{batchSize:V,filterHeight:q,filterWidth:j,inChannels:et,inHeight:tt,inWidth:ht,outChannels:gt,outHeight:vt,outWidth:bt,strideHeight:yt,strideWidth:mt}=C;S=C.dataFormat;let xt=q-1-C.padInfo.top,wt=j-1-C.padInfo.left,Tt=S==="channelsLast",Dt=I.strides[0],$t=Tt?I.strides[1]:I.strides[2],Lt=Tt?I.strides[2]:1,Pt=Tt?1:I.strides[1],Ft=x[0],Vt=Tt?x[1]:x[2],ee=Tt?x[2]:1,pe=Tt?1:x[1];for(let we=0;we<V;++we)for(let de=0;de<et;++de)for(let Ie=0;Ie<tt;++Ie){let be=Ie-xt,Je=Math.max(0,Math.ceil(be/yt)),ln=Math.min(vt,(q+be)/yt);for(let hn=0;hn<ht;++hn){let Me=hn-wt,Ze=Math.max(0,Math.ceil(Me/mt)),Ve=Math.min(bt,(j+Me)/mt),Un=0;for(let Gn=Je;Gn<ln;++Gn){let $s=Gn*yt-be;for(let qr=Ze;qr<Ve;++qr){let _i=qr*mt-Me,As=Ft*we+Vt*Gn+ee*qr,no=L*(q-1-$s)+_*(j-1-_i)+B*de;for(let Ia=0;Ia<gt;++Ia){let Ea=R[As+pe*Ia],Da=A[no+Ia];Un+=Ea*Da}}}let Po=Dt*we+$t*Ie+Lt*hn+Pt*de;D[Po]=Un}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}let cK={kernelName:vp,backendName:"cpu",kernelFunc:uK};function lK(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,filter:u}=t,{strides:l,pad:h,dilations:p}=r;At([s,u],"conv3d");let m=aa(s.shape,u.shape,l,p,h),{filterDepth:y,filterHeight:b,filterWidth:x,dilationDepth:S,dilationHeight:C,dilationWidth:I,padInfo:D}=m,R=D.front,A=D.left,L=D.top,_=new bn(m.outShape,s.dtype),B=e.data.get(s.dataId).values,V=e.data.get(u.dataId).values,q=_.values,j=Jt(s.shape),et=Jt(u.shape);for(let tt=0;tt<m.batchSize;++tt){let ht=tt*j[0],gt=tt*_.strides[0];for(let vt=0;vt<m.outDepth;++vt){let bt=gt+vt*_.strides[1],yt=vt*m.strideDepth-R;for(let mt=0;mt<y;++mt){let xt=yt+mt*S;if(xt<0||xt>=m.inDepth)continue;let wt=mt*et[0],Tt=ht+xt*j[1];for(let Dt=0;Dt<m.outHeight;++Dt){let $t=bt+Dt*_.strides[2],Lt=Dt*m.strideHeight-L;for(let Pt=0;Pt<b;++Pt){let Ft=Lt+Pt*C;if(Ft<0||Ft>=m.inHeight)continue;let Vt=wt+Pt*et[1],ee=Tt+Ft*j[2];for(let pe=0;pe<m.outWidth;++pe){let we=$t+pe*m.outChannels,de=pe*m.strideWidth-A;for(let Ie=0;Ie<x;++Ie){let be=de+Ie*I;if(be<0||be>=m.inWidth)continue;let Je=Vt+Ie*et[2],ln=ee+be*m.inChannels,hn=Je;for(let Me=0;Me<m.inChannels;++Me){let Ze=B[ln+Me];for(let Ve=0;Ve<m.outChannels;++Ve)q[we+Ve]+=Ze*V[hn+Ve];hn+=m.outChannels}}}}}}}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}let hK={kernelName:yp,backendName:"cpu",kernelFunc:lK};function fK(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,dy:u}=t,{strides:l,pad:h,filterShape:p}=r;At([s,u],"conv3dBackpropFilterV2");let m=Jt(s.shape),y=Jt(u.shape),b=aa(s.shape,p,l,1,h),x=b.strideDepth,S=b.strideHeight,C=b.strideWidth,I=b.filterDepth,D=b.filterHeight,R=b.filterWidth,A=new bn(b.filterShape,"float32"),L=A.values,[_,B,V,q]=A.strides,j=e.data.get(u.dataId).values,[et,tt,ht,gt]=y,vt=e.data.get(s.dataId).values,[bt,yt,mt,xt]=m,wt=b.padInfo.front,Tt=b.padInfo.left,Dt=b.padInfo.top;for(let $t=0;$t<I;++$t){let Lt=Math.max(0,Math.ceil((wt-$t)/x)),Pt=Math.min(b.outDepth,(b.inDepth+wt-$t)/x),Ft=$t*_;for(let Vt=0;Vt<D;++Vt){let ee=Math.max(0,Math.ceil((Dt-Vt)/S)),pe=Math.min(b.outHeight,(b.inHeight+Dt-Vt)/S),we=Vt*B+Ft;for(let de=0;de<R;++de){let Ie=Math.max(0,Math.ceil((Tt-de)/C)),be=Math.min(b.outWidth,(b.inWidth+Tt-de)/C),Je=de*V+we;for(let ln=0;ln<b.inChannels;++ln){let hn=ln*q+Je;for(let Me=0;Me<b.outChannels;++Me){let Ze=0;for(let Ve=0;Ve<b.batchSize;++Ve){let Un=Ve*bt,Po=Ve*et;for(let Gn=Lt;Gn<Pt;++Gn){let $s=$t+Gn*x-wt,qr=$s*yt+Un,_i=Gn*tt+Po;for(let As=ee;As<pe;++As){let no=Vt+As*S-Dt,Ia=no*mt+qr,Ea=As*ht+_i;for(let Da=Ie;Da<be;++Da){let yc=de+Da*C-Tt,mx=yc*xt+Ia,gx=Da*gt+Ea;Ze+=vt[mx+ln]*j[gx+Me]}}}}L[hn+Me]=Ze}}}}}return e.makeTensorInfo(A.shape,A.dtype,A.values)}let pK={kernelName:Mv,backendName:"cpu",kernelFunc:fK};function dK(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:u}=t,{pad:l,strides:h,inputShape:p}=r;At([s],"conv3dBackpropInputV2");let m=Jt(s.shape),y=Jt(u.shape),b=aa(p,u.shape,h,1,l),x=new bn(b.inShape,"float32"),S=x.values,[C,I,D,R]=x.strides,A=e.data.get(s.dataId).values,[L,_,B,V]=m,q=e.data.get(u.dataId).values,[j,et,tt,ht]=y,{batchSize:gt,filterDepth:vt,filterHeight:bt,filterWidth:yt,inChannels:mt,inDepth:xt,inHeight:wt,inWidth:Tt,outChannels:Dt,outDepth:$t,outHeight:Lt,outWidth:Pt,strideDepth:Ft,strideHeight:Vt,strideWidth:ee}=b,pe=vt-1-b.padInfo.front,we=bt-1-b.padInfo.top,de=yt-1-b.padInfo.left;for(let Ie=0;Ie<gt;++Ie)for(let be=0;be<mt;++be)for(let Je=0;Je<xt;++Je){let ln=Je-pe,hn=Math.max(0,Math.ceil(ln/Ft)),Me=Math.min($t,(vt+ln)/Ft);for(let Ze=0;Ze<wt;++Ze){let Ve=Ze-we,Un=Math.max(0,Math.ceil(Ve/Vt)),Po=Math.min(Lt,(bt+Ve)/Vt);for(let Gn=0;Gn<Tt;++Gn){let $s=Gn-de,qr=Math.max(0,Math.ceil($s/ee)),_i=Math.min(Pt,(yt+$s)/ee),As=0;for(let no=hn;no<Me;++no){let Ia=no*Ft-ln;for(let Ea=Un;Ea<Po;++Ea){let Da=Ea*Vt-Ve;for(let yc=qr;yc<_i;++yc){let mx=yc*ee-$s,gx=L*Ie+_*no+B*Ea+V*yc,fZ=j*(vt-1-Ia)+et*(bt-1-Da)+tt*(yt-1-mx)+ht*be;for(let Ym=0;Ym<Dt;++Ym){let pZ=A[gx+Ym],dZ=q[fZ+Ym];As+=pZ*dZ}}}}S[C*Ie+I*Je+D*Ze+R*Gn+be]=As}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}let mK={kernelName:Lv,backendName:"cpu",kernelFunc:dK};let gK=Pe(du,n=>Math.cos(n)),vK={kernelName:du,backendName:"cpu",kernelFunc:gK};let yK=Pe(Sl,n=>Math.cosh(n)),bK={kernelName:Sl,backendName:"cpu",kernelFunc:yK};function FE(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,filter:u}=t,{strides:l,pad:h,dilations:p,dimRoundingMode:m}=r;At([s,u],"depthwiseConv2DNative");let y=Jt(s.shape),b=Jt(u.shape),x=p;x==null&&(x=[1,1]),k(wn(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);let S=Kn(s.shape,u.shape,l,x,h,m,!0),{filterHeight:C,filterWidth:I,dilationHeight:D,dilationWidth:R,padInfo:A}=S,L=A.left,_=A.top,B=S.outChannels/S.inChannels,V=new bn(S.outShape,s.dtype),q=e.data.get(s.dataId).values,j=e.data.get(u.dataId).values,et=V.values;for(let tt=0;tt<S.batchSize;++tt){let ht=tt*y[0],gt=tt*V.strides[0];for(let vt=0;vt<S.outHeight;++vt){let bt=gt+vt*V.strides[1],yt=vt*S.strideHeight-L;for(let mt=0;mt<C;++mt){let xt=yt+mt*D;if(xt<0||xt>=S.inHeight)continue;let wt=mt*b[0],Tt=ht+xt*y[1];for(let Dt=0;Dt<S.outWidth;++Dt){let $t=bt+Dt*V.strides[2],Lt=Dt*S.strideWidth-_;for(let Pt=0;Pt<I;++Pt){let Ft=Lt+Pt*R;if(Ft<0||Ft>=S.inWidth)continue;let Vt=wt+Pt*b[1],ee=Tt+Ft*S.inChannels,pe=$t,we=Vt;for(let de=0;de<S.inChannels;++de){let Ie=q[ee+de];for(let be=0;be<B;++be)et[pe+be]+=Ie*j[we+be];pe+=B,we+=B}}}}}}return e.makeTensorInfo(V.shape,V.dtype,V.values)}let wK={kernelName:bp,backendName:"cpu",kernelFunc:FE};function xK(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,dy:u}=t,{strides:l,dilations:h,pad:p,dimRoundingMode:m,filterShape:y}=r;At([s,u],"depthwiseConv2dNativeBackpropFilter");let b=Kn(s.shape,y,l,h,p,m,!0),{strideHeight:x,strideWidth:S,filterHeight:C,filterWidth:I}=b,D=new bn(b.filterShape,"float32"),R=b.padInfo.left,A=b.padInfo.top,L=b.outChannels/b.inChannels,_=e.data.get(s.dataId).values,B=new bn(s.shape,s.dtype,_),V=e.data.get(u.dataId).values,q=new bn(u.shape,u.dtype,V);for(let j=0;j<C;++j){let et=Math.max(0,Math.ceil((A-j)/x)),tt=Math.min(b.outHeight,(b.inHeight+A-j)/x);for(let ht=0;ht<I;++ht){let gt=Math.max(0,Math.ceil((R-ht)/S)),vt=Math.min(b.outWidth,(b.inWidth+R-ht)/S);for(let bt=0;bt<b.outChannels;++bt){let yt=Math.trunc(bt/L),mt=bt%L,xt=0;for(let wt=0;wt<b.batchSize;++wt)for(let Tt=et;Tt<tt;++Tt){let Dt=j+Tt*x-A;for(let $t=gt;$t<vt;++$t){let Lt=ht+$t*S-R;xt+=B.get(wt,Dt,Lt,yt)*q.get(wt,Tt,$t,bt)}}D.set(xt,j,ht,yt,mt)}}}return e.makeTensorInfo(D.shape,D.dtype,D.values)}let TK={kernelName:zv,backendName:"cpu",kernelFunc:xK};function kK(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:u}=t,{strides:l,dilations:h,pad:p,dimRoundingMode:m,inputShape:y}=r;At([s,u],"depthwiseConv2DNativeBackpropInput");let b=Jt(s.shape),x=Jt(u.shape),S=Kn(y,u.shape,l,h,p,m,!0),C=new bn(S.inShape,"float32"),I=C.values,[D,R,A]=C.strides,L=e.data.get(s.dataId).values,[_,B,V]=b,q=e.data.get(u.dataId).values,[j,et,tt]=x,{batchSize:ht,filterHeight:gt,filterWidth:vt,inChannels:bt,inHeight:yt,inWidth:mt,outChannels:xt,outHeight:wt,outWidth:Tt,strideHeight:Dt,strideWidth:$t}=S,Lt=gt-1-S.padInfo.top,Pt=vt-1-S.padInfo.left,Ft=xt/bt;for(let Vt=0;Vt<ht;++Vt)for(let ee=0;ee<bt;++ee)for(let pe=0;pe<yt;++pe){let we=pe-Lt,de=Math.max(0,Math.ceil(we/Dt)),Ie=Math.min(wt,(gt+we)/Dt);for(let be=0;be<mt;++be){let Je=be-Pt,ln=Math.max(0,Math.ceil(Je/$t)),hn=Math.min(Tt,(vt+Je)/$t),Me=0;for(let Ze=de;Ze<Ie;++Ze){let Ve=Ze*Dt-we;for(let Un=ln;Un<hn;++Un){let Po=Un*$t-Je,Gn=_*Vt+B*Ze+V*Un,$s=j*(gt-1-Ve)+et*(vt-1-Po)+tt*ee;for(let qr=0;qr<Ft;++qr){let _i=ee*Ft+qr,As=L[Gn+_i],no=q[$s+qr];Me+=As*no}}}I[D*Vt+R*pe+A*be+ee]=Me}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}let SK={kernelName:Wv,backendName:"cpu",kernelFunc:kK};let CK={kernelName:wp,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:r,filter:s}=n,{strides:u,pad:l,dilations:h}=e,p=t,m=p.data.get(r.dataId).values,y=r.shape.length,b=p.data.get(s.dataId).values,x=s.shape.length,{batchSize:S,inHeight:C,inWidth:I,inChannels:D,outHeight:R,outWidth:A,padInfo:L,strideHeight:_,strideWidth:B,filterHeight:V,filterWidth:q,dilationHeight:j,dilationWidth:et,outShape:tt}=ld(r.shape,s.shape,u,l,"NHWC",h),ht=O(tt),gt=tt.length,vt=Kt(r.dtype,ht);for(let yt=0;yt<S;++yt)for(let mt=0;mt<R;++mt){let xt=mt*_-L.top;for(let wt=0;wt<A;++wt){let Tt=wt*B-L.left;for(let Dt=0;Dt<D;++Dt){let $t=Number.MIN_SAFE_INTEGER;for(let Pt=0;Pt<V;++Pt){let Ft=xt+Pt*j;if(Ft>=0&&Ft<C)for(let Vt=0;Vt<q;++Vt){let ee=Tt+Vt*et;if(ee>=0&&ee<I){let pe=Qr([yt,Ft,ee,Dt],y,Jt(r.shape)),we=Qr([Pt,Vt,Dt],x,Jt(s.shape)),de=m[pe]+b[we];de>$t&&($t=de)}}}let Lt=Qr([yt,mt,wt,Dt],gt,Jt(tt));vt[Lt]=$t}}}let bt=p.write(na(vt,r.dtype),tt,r.dtype);return{dataId:bt,shape:tt,dtype:r.dtype}}};let NK={kernelName:Tp,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:r,filter:s,dy:u}=n,{strides:l,pad:h,dilations:p}=e,m=t,y=Mr(r.shape,m.data.get(r.dataId).values),b=Mr(s.shape,m.data.get(s.dataId).values),{batchSize:x,inHeight:S,inWidth:C,inChannels:I,outHeight:D,outWidth:R,padInfo:A,strideHeight:L,strideWidth:_,filterHeight:B,filterWidth:V,dilationHeight:q,dilationWidth:j,outShape:et}=ld(r.shape,s.shape,l,h,"NHWC",p);k(u.rank===et.length,()=>`Error in ${Tp}, dy must have the same rank as output ${et.length}, but got ${u.rank}`);let tt=Mr(et,m.data.get(u.dataId).values),ht=Iv(s.shape,s.dtype);for(let vt=0;vt<x;++vt)for(let bt=0;bt<D;++bt){let yt=bt*L-A.top;for(let mt=0;mt<R;++mt){let xt=mt*_-A.left;for(let wt=0;wt<I;++wt){let Tt=Number.MIN_SAFE_INTEGER,Dt=0,$t=0;for(let Lt=0;Lt<B;++Lt){let Pt=yt+Lt*q;if(Pt>=0&&Pt<S)for(let Ft=0;Ft<V;++Ft){let Vt=xt+Ft*j;if(Vt>=0&&Vt<C){let ee=y[vt][Pt][Vt][wt]+b[Lt][Ft][wt];ee>Tt&&(Tt=ee,Dt=Lt,$t=Ft)}}}ht[Dt][$t][wt]+=tt[vt][bt][mt][wt]}}}let gt=m.write(na(ht,r.dtype),s.shape,s.dtype);return{dataId:gt,shape:s.shape,dtype:s.dtype}}};let IK={kernelName:xp,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{x:r,filter:s,dy:u}=n,{strides:l,pad:h,dilations:p}=e,m=t,y=Mr(r.shape,m.data.get(r.dataId).values),b=Mr(s.shape,m.data.get(s.dataId).values),{batchSize:x,inHeight:S,inWidth:C,inChannels:I,outHeight:D,outWidth:R,padInfo:A,strideHeight:L,strideWidth:_,filterHeight:B,filterWidth:V,dilationHeight:q,dilationWidth:j,outShape:et}=ld(r.shape,s.shape,l,h,"NHWC",p);k(u.rank===et.length,()=>`Error in ${xp}, dy must have the same rank as output ${et.length}, but got ${u.rank}`);let tt=Mr(et,m.data.get(u.dataId).values),ht=Iv(r.shape,r.dtype);for(let vt=0;vt<x;++vt)for(let bt=0;bt<D;++bt){let yt=bt*L-A.top;for(let mt=0;mt<R;++mt){let xt=mt*_-A.left;for(let wt=0;wt<I;++wt){let Tt=Number.MIN_SAFE_INTEGER,Dt=yt<0?0:yt,$t=xt<0?0:xt;for(let Lt=0;Lt<B;++Lt){let Pt=yt+Lt*q;if(Pt>=0&&Pt<S)for(let Ft=0;Ft<V;++Ft){let Vt=xt+Ft*j;if(Vt>=0&&Vt<C){let ee=y[vt][Pt][Vt][wt]+b[Lt][Ft][wt];ee>Tt&&(Tt=ee,Dt=Pt,$t=Vt)}}}ht[vt][Dt][$t][wt]+=tt[vt][bt][mt][wt]}}}let gt=m.write(na(ht,r.dtype),r.shape,r.dtype);return{dataId:gt,shape:r.shape,dtype:r.dtype}}};let EK=Ca((n,t)=>n/t),DK=sc(mu,EK),Q0={kernelName:mu,backendName:"cpu",kernelFunc:DK};let $K=zb,AK=Wb,_K=Vb,FK=Ub,RK=Gb,PK=Hb,OK=Pe(Nl,n=>{let t=Math.sign(n),e=Math.abs(n),r=1/(1+$K*e);return t*(1-((((PK*r+RK)*r+FK)*r+_K)*r+AK)*r*Math.exp(-e*e))}),MK={kernelName:Nl,backendName:"cpu",kernelFunc:OK};function RE(n,t,e){let r=n.shape,s=r[0],u=r[1],l=e.data.get(n.dataId),h=l.complexTensorInfos.real,p=l.complexTensorInfos.imag,m=[s,u],y=O(m),b=_t("float32",y),x=_t("float32",y);for(let D=0;D<s;D++){let R=X0({inputs:{x:h},backend:e,attrs:{begin:[D,0],size:[1,u]}}),A=X0({inputs:{x:p},backend:e,attrs:{begin:[D,0],size:[1,u]}}),L=Ds({inputs:{real:R,imag:A},backend:e}),{real:_,imag:B}=LK(L,t,e),V=So(_,B);for(let q=0;q<u;q++){let j=qb(V,q);b[D*u+q]=j.real,x[D*u+q]=j.imag}e.disposeIntermediateTensorInfo(R),e.disposeIntermediateTensorInfo(A),e.disposeIntermediateTensorInfo(L)}let S=e.makeTensorInfo(m,"float32",b),C=e.makeTensorInfo(m,"float32",x),I=Ds({inputs:{real:S,imag:C},backend:e});return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(C),I}function LK(n,t,e){let r=O(n.shape),s=e.data.get(n.dataId),u=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(s.complexTensorInfos.imag.dataId).values;if(BK(r)){let h=tx(u,l,r,t,e),p=[n.shape[0],n.shape[1]];if(t){let m=e.makeTensorInfo(p,"float32",h.real),y=e.makeTensorInfo(p,"float32",h.imag),b=e.makeTensorInfo([],"float32",K2(r,"float32")),x=Di({inputs:{x:b},backend:e}),S=Q0.kernelFunc({inputs:{a:m,b},backend:e}),C=Q0.kernelFunc({inputs:{a:y,b:x},backend:e}),I=e.data.get(S.dataId).values,D=e.data.get(C.dataId).values;return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(C),{real:I,imag:D}}return h}else{let h=So(u,l),p=zK(h,r,t);return LC(p)}}function BK(n){return(n&n-1)===0}function tx(n,t,e,r,s){if(e===1)return{real:n,imag:t};let u=So(n,t),l=e/2,h=BC(u),p=h.real,m=h.imag,y=[p.length],b=s.makeTensorInfo(y,"float32",p),x=s.makeTensorInfo(y,"float32",m),S=Ds({inputs:{real:b,imag:x},backend:s}),C=zC(u),I=C.real,D=C.imag,R=[I.length],A=s.makeTensorInfo(R,"float32",I),L=s.makeTensorInfo(R,"float32",D),_=Ds({inputs:{real:A,imag:L},backend:s}),B=tx(p,m,l,r,s),V=B.real,q=B.imag,j=[V.length],et=s.makeTensorInfo(j,"float32",V),tt=s.makeTensorInfo(j,"float32",q),ht=Ds({inputs:{real:et,imag:tt},backend:s}),gt=tx(I,D,l,r,s),vt=gt.real,bt=gt.imag,yt=[vt.length],mt=s.makeTensorInfo(yt,"float32",vt),xt=s.makeTensorInfo(yt,"float32",bt),wt=Ds({inputs:{real:mt,imag:xt},backend:s}),Tt=VC(e,r),Dt=[Tt.real.length],$t=s.makeTensorInfo(Dt,"float32",Tt.real),Lt=s.makeTensorInfo(Dt,"float32",Tt.imag),Pt=Ds({inputs:{real:$t,imag:Lt},backend:s}),Ft=yE({inputs:{a:Pt,b:wt},backend:s}),Vt=df({inputs:{a:ht,b:Ft},backend:s}),ee=SE({inputs:{a:ht,b:Ft},backend:s}),pe=ff({inputs:{input:Vt},backend:s}),we=ff({inputs:{input:ee},backend:s}),de=Om({inputs:{input:Vt},backend:s}),Ie=Om({inputs:{input:ee},backend:s}),be=mf({inputs:[pe,we],backend:s,attrs:{axis:0}}),Je=mf({inputs:[de,Ie],backend:s,attrs:{axis:0}}),ln=s.data.get(be.dataId).values,hn=s.data.get(Je.dataId).values;return s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(et),s.disposeIntermediateTensorInfo(tt),s.disposeIntermediateTensorInfo(ht),s.disposeIntermediateTensorInfo(mt),s.disposeIntermediateTensorInfo(xt),s.disposeIntermediateTensorInfo(wt),s.disposeIntermediateTensorInfo($t),s.disposeIntermediateTensorInfo(Lt),s.disposeIntermediateTensorInfo(Pt),s.disposeIntermediateTensorInfo(Ft),s.disposeIntermediateTensorInfo(Vt),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(pe),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(we),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo(be),s.disposeIntermediateTensorInfo(Je),{real:ln,imag:hn}}function zK(n,t,e){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let u=0,l=0;for(let h=0;h<t;h++){let p=UC(s*h,t,e),m=qb(n,h);u+=m.real*p.real-m.imag*p.imag,l+=m.real*p.imag+m.imag*p.real}e&&(u/=t,l/=t),WC(r,u,l,s)}return r}function WK(n){let{inputs:t,backend:e}=n,{input:r}=t,s=O(r.shape),u=r.shape[r.shape.length-1],l=s/u,h=to({inputs:{x:r},backend:e,attrs:{shape:[l,u]}}),p=RE(h,!1,e),m=to({inputs:{x:p},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),m}let VK={kernelName:kp,backendName:"cpu",kernelFunc:WK};function UK(n){let{backend:t,attrs:e}=n,{shape:r,value:s,dtype:u}=e,l=u||Us(s),h=Kt(l,O(r));return HK(h,s,l),t.makeTensorInfo(r,l,h)}let GK={kernelName:Vv,backendName:"cpu",kernelFunc:UK};function HK(n,t,e){e==="string",n.fill(t)}let qK={kernelName:Sp,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:r}=n,s=e,u=_t(r.dtype,O(r.shape)),[l,h,p,m]=r.shape,y=s.data.get(r.dataId).values;for(let x=0;x<l;x++){let S=x*p*h*m;for(let C=0;C<h;C++){let I=C*(p*m);for(let D=0;D<p;D++){let R=D*m;for(let A=0;A<m;A++){let L=[l,C,D,A],_=L[2],B=Math.round(p-_),V=S+I+R+A,q=y[V];if(B>=0&&B<p){let j=B*m,et=S+I+j+A;q=y[et]}u[V]=q}}}}let b=s.write(u,r.shape,r.dtype);return{dataId:b,shape:r.shape,dtype:r.dtype}}};function jK(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,filter:u,bias:l,preluActivationWeights:h}=t,{strides:p,pad:m,dataFormat:y,dilations:b,dimRoundingMode:x,activation:S}=r,C=_E({inputs:{x:s,filter:u},backend:e,attrs:{strides:p,pad:m,dataFormat:y,dilations:b,dimRoundingMode:x}});if(l){let I=C;C=df({inputs:{a:C,b:l},backend:e}),e.disposeIntermediateTensorInfo(I)}if(S){let I=C;C=J0(e,C,S,h),e.disposeIntermediateTensorInfo(I)}return C}let KK={kernelName:Vp,backendName:"cpu",kernelFunc:jK};function XK(n){let{inputs:t,backend:e,attrs:r}=n,{x:s,filter:u,bias:l,preluActivationWeights:h}=t,{strides:p,pad:m,dataFormat:y,dilations:b,dimRoundingMode:x,activation:S}=r,C=FE({inputs:{x:s,filter:u},backend:e,attrs:{strides:p,pad:m,dataFormat:y,dilations:b,dimRoundingMode:x}});if(l){let I=C;C=df({inputs:{a:C,b:l},backend:e}),e.disposeIntermediateTensorInfo(I)}if(S){let I=C;C=J0(e,C,S,h),e.disposeIntermediateTensorInfo(I)}return C}let YK={kernelName:Up,backendName:"cpu",kernelFunc:XK};function JK(n){let{inputs:t,backend:e}=n,{input:r}=t,s=O(r.shape),u=r.shape[r.shape.length-1],l=s/u,h=to({inputs:{x:r},backend:e,attrs:{shape:[l,u]}}),p=RE(h,!0,e),m=to({inputs:{x:p},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),m}let ZK={kernelName:Cp,backendName:"cpu",kernelFunc:JK};let QK=Pe(_l,n=>Number.isFinite(n)?1:0,"bool"),t5={kernelName:_l,backendName:"cpu",kernelFunc:QK};let e5=Pe(Fl,n=>Math.abs(n)===Infinity?1:0,"bool"),n5={kernelName:Fl,backendName:"cpu",kernelFunc:e5};let r5=Pe(Rl,n=>Number.isNaN(n)?1:0,"bool"),s5={kernelName:Rl,backendName:"cpu",kernelFunc:r5};let o5=Pe(Ol,n=>Math.log1p(n)),a5={kernelName:Ol,backendName:"cpu",kernelFunc:o5};let i5=Pe(Ip,n=>n?0:1,"bool"),u5={kernelName:Ip,backendName:"cpu",kernelFunc:i5};let c5={kernelName:Ml,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{reductionIndices:s,keepDims:u}=t,l=e,h=r.shape,p=h.length,m=Et(s,h),y=m,b=hr(y,p),x=l.data.get(r.dataId).values;if(b!=null){let L=new Array(p);for(let _=0;_<L.length;_++)L[_]=h[b[_]];x=Y0(x,h,r.dtype,b,L),y=Cr(y.length,p),h=L}At(r,"max"),lr("max",y,p);let[S,C]=Bn(h,y),I=O(C),D=gE(x,I,S,r.dtype),R=l.write(D,S,r.dtype),A=S;if(u){let L=zn(S,m);A=L}return{dataId:R,shape:A,dtype:r.dtype}}};function l5(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t;At(s,"maxPool");let{filterSize:u,strides:l,pad:h,dimRoundingMode:p}=r,m=1;k(wn(l,m),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let y=tr(s.shape,u,l,m,h,p),b;if(y.filterWidth===1&&y.filterHeight===1&&K(y.inShape,y.outShape))b=Di({inputs:{x:s},backend:e});else{let x=e.data.get(s.dataId).values,S=Jt(s.shape),C=Z0(x,s.shape,s.dtype,S,y,"max");b=e.makeTensorInfo(y.outShape,s.dtype,C.values)}return b}let h5={kernelName:Ll,backendName:"cpu",kernelFunc:l5};function f5(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,input:u,output:l}=t,h=u;At([u,l],"maxPoolBackprop");let{filterSize:p,strides:m,pad:y,dimRoundingMode:b}=r,x=tr(h.shape,p,m,1,y,b),S=e.data.get(h.dataId).values,C=Ae(x.outShape,h.dtype,AE(S,h.shape,h.dtype,x).values),I=x.strideHeight,D=x.strideWidth,R=x.dilationHeight,A=x.dilationWidth,L=x.effectiveFilterHeight,_=x.effectiveFilterWidth,B=_-1-x.padInfo.left,V=L-1-x.padInfo.top,q=Ae(h.shape,"float32"),j=e.data.get(s.dataId).values,et=Ae(s.shape,"float32",j);for(let tt=0;tt<x.batchSize;++tt)for(let ht=0;ht<x.inChannels;++ht)for(let gt=0;gt<x.inHeight;++gt)for(let vt=0;vt<x.inWidth;++vt){let bt=gt-V,yt=vt-B,mt=0;for(let xt=0;xt<L;xt+=R){let wt=(bt+xt)/I;if(wt<0||wt>=x.outHeight||Math.floor(wt)!==wt)continue;for(let Tt=0;Tt<_;Tt+=A){let Dt=(yt+Tt)/D;if(Dt<0||Dt>=x.outWidth||Math.floor(Dt)!==Dt)continue;let $t=L*_-1-C.get(tt,wt,Dt,ht),Lt=xt*_+Tt,Pt=$t===Lt?1:0;if(Pt===0)continue;let Ft=et.get(tt,wt,Dt,ht);mt+=Ft*Pt}}q.set(mt,tt,gt,vt,ht)}return e.makeTensorInfo(q.shape,q.dtype,q.values)}let p5={kernelName:Ep,backendName:"cpu",kernelFunc:f5};function d5(n,t,e,r,s){let u=Jt(t),l=Z0(n,t,e,u,s,"max"),h=AE(n,t,e,s,!0,r);return[l.values,h.values]}let m5={kernelName:Dp,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{filterSize:s,strides:u,pad:l,includeBatchInIndex:h}=t,p=e;At(r,"MaxPoolWithArgmax");let m=p.data.get(r.dataId).values,y=tr(r.shape,s,u,[1,1],l),[b,x]=d5(m,r.shape,r.dtype,h,y),S=p.write(b,y.outShape,r.dtype),C=p.write(x,y.outShape,r.dtype);return[{dataId:S,shape:y.outShape,dtype:r.dtype},{dataId:C,shape:y.outShape,dtype:"int32"}]}};function g5(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:u,mode:l}=r;At(s,"mirrorPad");let h=u.map((L,_)=>L[0]+s.shape[_]+L[1]),p=u.map(L=>L[0]),m=u.map((L,_)=>L[0]+s.shape[_]),y=l==="reflect"?0:1,b=e.data.get(s.dataId).values,x=s.shape.length,S=Jt(s.shape),C=O(h),I=h.length,D=Jt(h),R=_t(s.dtype,C);for(let L=0;L<C;L++){let _=ei(L,I,D);for(let V=0;V<I;V++)_[V]<p[V]?_[V]=p[V]*2-_[V]-y:_[V]>=m[V]&&(_[V]=(m[V]-1)*2-_[V]+y);_=_.map((V,q)=>V-p[q]);let B=Qr(_,x,S);R[L]=b[B]}let A=e.write(R,h,s.dtype);return{dataId:A,shape:h,dtype:s.dtype}}let v5={kernelName:Bl,backendName:"cpu",kernelFunc:g5};let y5=Ud,b5={kernelName:$p,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{boxes:r,scores:s}=n,{maxOutputSize:u,iouThreshold:l,scoreThreshold:h,padToMaxOutputSize:p}=e,m=t;At(r,"NonMaxSuppressionPadded");let y=m.data.get(r.dataId).values,b=m.data.get(s.dataId).values,{selectedIndices:x,validOutputs:S}=y5(y,b,u,l,h,p);return[x,S]}};let w5=Gd,x5={kernelName:Ap,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{let{boxes:r,scores:s}=n,{maxOutputSize:u,iouThreshold:l,scoreThreshold:h,softNmsSigma:p}=e,m=t;At(r,"NonMaxSuppressionWithScore");let y=m.data.get(r.dataId).values,b=m.data.get(s.dataId).values,x=u,S=l,C=h,I=p,{selectedIndices:D,selectedScores:R}=w5(y,b,x,S,C,I);return[D,R]}};function T5(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:u,constantValue:l}=r;At(s,"pad");let h=u.map((A,L)=>A[0]+s.shape[L]+A[1]),p=u.map(A=>A[0]),m=e.data.get(s.dataId).values,y=O(s.shape),b=s.shape.length,x=Jt(s.shape),S=O(h),C=h.length,I=Jt(h),D=_t(s.dtype,S);l!==0&&D.fill(l);for(let A=0;A<y;A++){let L=ei(A,b,x),_=L.map((V,q)=>V+p[q]),B=Qr(_,C,I);D[B]=m[A]}let R=e.write(D,h,s.dtype);return{dataId:R,shape:h,dtype:s.dtype}}let PE={kernelName:_p,backendName:"cpu",kernelFunc:T5};let k5=Pe(Wl,n=>1/n),S5={kernelName:Wl,backendName:"cpu",kernelFunc:k5};let C5={kernelName:zp,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:r}=n,{radians:s,fillValue:u,center:l}=t,h=e,p=_t(r.dtype,O(r.shape)),[m,y,b,x]=r.shape,[S,C]=Mb(l,y,b),I=255,D=Math.sin(s),R=Math.cos(s),A=h.data.get(r.dataId).values;for(let _=0;_<m;_++){let B=_*b*y*x;for(let V=0;V<y;V++){let q=V*(b*x);for(let j=0;j<b;j++){let et=j*x;for(let tt=0;tt<x;tt++){let ht=[m,V,j,tt],gt=ht[2],vt=ht[1],bt=(gt-S)*R-(vt-C)*D,yt=(gt-S)*D+(vt-C)*R;bt=Math.round(bt+S),yt=Math.round(yt+C);let mt=u;if(typeof u!="number"&&(tt===3?mt=I:mt=u[tt]),bt>=0&&bt<b&&yt>=0&&yt<y){let wt=yt*(b*x),Tt=bt*x,Dt=B+wt+Tt+tt;mt=A[Dt]}let xt=B+q+et+tt;p[xt]=mt}}}}let L=h.write(p,r.shape,r.dtype);return{dataId:L,shape:r.shape,dtype:r.dtype}}};let N5=Pe(Hl,n=>{let t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),I5={kernelName:Hl,backendName:"cpu",kernelFunc:N5};let E5=qd,D5=jd,$5=Pe(jl,n=>n>=0?D5*n:E5*(Math.exp(n)-1)),A5={kernelName:jl,backendName:"cpu",kernelFunc:$5};let _5=Pe(Yl,n=>1/(1+Math.exp(-n))),F5={kernelName:Yl,backendName:"cpu",kernelFunc:_5};let R5=Pe(Xl,n=>n<0?-1:n>0?1:0),P5={kernelName:Xl,backendName:"cpu",kernelFunc:R5};let O5=Pe(vu,n=>Math.sin(n)),M5={kernelName:vu,backendName:"cpu",kernelFunc:O5};let L5=Pe(Kl,n=>Math.sinh(n)),B5={kernelName:Kl,backendName:"cpu",kernelFunc:L5};let z5=11920928955078125e-23,OE=Math.log(z5)+2,W5=Pe(Jl,n=>{let t=n>-OE,e=n<OE,r=Math.exp(n),s;return e?s=r:t?s=n:s=Math.log(1+r),s}),V5={kernelName:Jl,backendName:"cpu",kernelFunc:W5};function ME(n){let{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:u}=e;At(s,"transpose");let l=s.shape.length,h=new Array(l);for(let b=0;b<h.length;b++)h[b]=s.shape[u[b]];let p=r.data.get(s.dataId).values,m=Y0(p,s.shape,s.dtype,u,h),y=r.write(m,h,s.dtype);return{dataId:y,shape:h,dtype:s.dtype}}let U5={kernelName:th,backendName:"cpu",kernelFunc:ME};function G5(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:u,paddings:l}=r;At([s],"spaceToBatchND");let h=O(u),p=[[0,0]];p.push(...l);for(let V=1+u.length;V<s.shape.length;++V)p.push([0,0]);let m=PE.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:p,constantValue:0}}),y=Mh(m.shape,u,h,!1),b=Lh(y.length,u.length,!1),x=Bh(m.shape,u,h,!1),S={x:m},C={shape:y},I=to({inputs:S,backend:e,attrs:C}),D={x:I},R={perm:b},A=ME({inputs:D,backend:e,attrs:R}),L={x:A},_={shape:x},B=to({inputs:L,backend:e,attrs:_});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(A),B}let H5={kernelName:Op,backendName:"cpu",kernelFunc:G5};let q5=Pe(Zl,n=>Math.sqrt(n)),j5={kernelName:Zl,backendName:"cpu",kernelFunc:q5};let K5={kernelName:Mp,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{let{x:e}=n,r=t;At(e,"square");let s=r.data.get(e.dataId).values,u=new Float32Array(s.length);for(let h=0;h<s.length;++h){let p=s[h];u[h]=p*p}let l=r.write(u,e.shape,e.dtype);return{dataId:l,shape:e.shape,dtype:e.dtype}}};let X5=Pe(eh,(n,t)=>{let e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Y5={kernelName:eh,backendName:"cpu",kernelFunc:X5};let J5=Pe(wu,n=>Math.tan(n)),Z5={kernelName:wu,backendName:"cpu",kernelFunc:J5};let Q5=Pe(Ql,n=>Math.tanh(n)),t8={kernelName:Ql,backendName:"cpu",kernelFunc:Q5};function e8(n){let{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:u}=t;At(u,"unique");let l=r.data.get(u.dataId).values,{outputValues:h,outputShape:p,indices:m}=CE(l,s,u.shape,u.dtype);return[r.makeTensorInfo(p,u.dtype,h),r.makeTensorInfo([m.length],"int32",m)]}let n8={kernelName:Lp,backendName:"cpu",kernelFunc:e8};let r8=[O6,Zj,L6,z6,s6,V6,G6,q6,K6,Y6,Z6,R6,tK,n6,a6,nK,Qj,sK,iK,cK,oK,pK,mK,hK,vK,bK,wK,TK,SK,CK,IK,NK,Q0,E6,MK,u6,l6,VK,GK,qK,f6,KK,YK,t6,ZK,rK,t5,n5,s5,d6,a5,u5,h5,p5,m5,c5,v5,g6,b5,x5,y6,PE,$6,e6,S5,A6,_6,F6,C5,I5,w6,A5,F5,P5,M5,B5,x6,V5,H5,j5,K5,k6,Y5,C6,Z5,t8,U5,n8];for(let n of r8)Hp(n);let Na={},ex={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Fft(n){delete Na[n]}function s8(n,t){Na[n]=t}function eo(n){if(!(n in Na)){let e=a8(n);if(e!==null)Na[n]=e;else return console.log("Could not get context for WebGL version",n),null}let t=Na[n];return t.isContextLost()?(delete Na[n],eo(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Na[n])}function o8(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function a8(n){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=o8(n);return t.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete Na[n]},!1),n===1?t.getContext("webgl",ex)||t.getContext("experimental-webgl",ex):t.getContext("webgl2",ex)}var gf;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(gf||(gf={}));var Hr;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Hr||(Hr={}));var Vn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Vn||(Vn={}));function vf(n,t){return[t,n]}function i8(n,t){return n*t}function Rft(n,t){return[t*4,n]}function yf(n){let t=O(n),e=Math.ceil(t/4);return dt(e)}function Pft(n,t){if(n%t!==0)throw new Error(`unpackedSize (${n}) must be a multiple of ${t}`);return n/t}function Oft(n,t,e){let r=n.length*e/4;if(t.length<r)throw new Error(`matrix length (${t.length}) must be >= ${r}`);let s=0;for(let u=0;u<n.length;u+=4)for(let l=0;l<e;l++)t[s++]=n[u+l]}function ic(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function u8(n,t){let[e,r]=ic(n,t);return e*r*4}function nx(n,t){let e=n,r,s,u,l,h,p,m,y,b,x;return ft().getNumber("WEBGL_VERSION")===2?(r=e.R32F,s=e.R16F,u=e.RGBA16F,l=e.RGBA32F,h=e.RED,m=4,y=1,b=e.HALF_FLOAT,x=e.FLOAT):(r=n.RGBA,s=n.RGBA,u=n.RGBA,l=e.RGBA,h=n.RGBA,m=4,y=4,b=t!=null?t.HALF_FLOAT_OES:null,x=n.FLOAT),p=n.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:u,internalFormatPackedFloat:l,textureFormatFloat:h,downloadTextureFormat:p,downloadUnpackNumChannels:m,defaultNumChannels:y,textureTypeHalfFloat:b,textureTypeFloat:x}}function zt(n,t){let e=t();return ft().getBool("DEBUG")&&c8(n),e}function c8(n){let t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+p8(n,t))}let l8=596e-10,h8=65504;function f8(n){return!!(ft().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||l8<Math.abs(n)&&Math.abs(n)<h8)}function p8(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Mm(n,t){return $o(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function d8(n,t){let e=$o(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(zt(n,()=>n.shaderSource(e,t)),zt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function m8(n,t){let e=$o(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(zt(n,()=>n.shaderSource(e,t)),zt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw v8(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}let g8=/ERROR: [0-9]+:([0-9]+):/g;function v8(n,t){let e=g8.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}let r=+e[1],s=n.split(`
`),u=s.length.toString().length+2,l=s.map((b,x)=>St((x+1).toString(),u)+b),h=0;for(let b=0;b<l.length;b++)h=Math.max(l[b].length,h);let p=l.slice(0,r-1),m=l.slice(r-1,r),y=l.slice(r);console.log(p.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${St(m[0],h)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(y.join(`
`))}function y8(n){return $o(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function b8(n,t){if(zt(n,()=>n.linkProgram(t)),n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function rx(n,t){if(zt(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function w8(n,t){let e=$o(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return zt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),zt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function x8(n,t){let e=$o(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return zt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),zt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Mft(){return ft().getNumber("WEBGL_VERSION")===2?1:4}function T8(n){return $o(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function k8(n,t){let e=ft().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){let r=`[${n}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>e||t>e){let r=`[${n}x${t}]`,s=`[${e}x${e}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function S8(n){return $o(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function LE(n,t,e,r,s,u,l){let h=n.getAttribLocation(t,e);return h===-1?!1:(zt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),zt(n,()=>n.vertexAttribPointer(h,s,n.FLOAT,!1,u,l)),zt(n,()=>n.enableVertexAttribArray(h)),!0)}function C8(n,t,e){zE(n,e),zt(n,()=>n.activeTexture(n.TEXTURE0+e)),zt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function Lft(n,t){zE(n,t),zt(n,()=>n.activeTexture(n.TEXTURE0+t)),zt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function N8(n,t,e){return $o(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function I8(n,t,e){return n.getUniformLocation(t,e)}function E8(n,t,e,r){zt(n,()=>C8(n,t,r)),zt(n,()=>n.uniform1i(e,r))}function Bft(n){zt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),zt(n,()=>n.viewport(0,0,n.canvas.width,n.canvas.height)),zt(n,()=>n.scissor(0,0,n.canvas.width,n.canvas.height))}function sx(n,t,e){zt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),zt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function BE(n,t){zt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),zt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Lm(n){let t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+D8(n,t))}function D8(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function $o(n,t,e){let r=zt(n,()=>t());if(r==null)throw new Error(e);return r}function zE(n,t){let e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e){let s=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${s}.`)}}function uc(n,t=2){return O(n.slice(0,n.length-t))}function cc(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function ox(n){let t=[1,1,1],e=n.length===0||n.length===1&&n[0]===1;return e||(t=[uc(n),...cc(n)]),t}function $8(n,t=!1){let e=ft().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(e=e*2,n=n.map((s,u)=>u>=n.length-2?w(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2){let s=Wt(n);n=s.newShape}let r=O(n);if(n.length<=1&&r<=e)return[1,r];if(n.length===2&&n[0]<=e&&n[1]<=e)return n;if(n.length===3&&n[0]*n[1]<=e&&n[2]<=e)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=e&&n[1]*n[2]<=e)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e)return[n[0],n[1]*n[2]*n[3]];if(t){let s=uc(n),u=2,l=2;return n.length&&([u,l]=cc(n)),r=s*(u/2)*(l/2),dt(r).map(h=>h*2)}return dt(r)}function Bm(n){return n%2===0}function zm(n,t){if(n=n.slice(-2),t=t.slice(-2),K(n,t))return!0;if(!n.length||!t.length)return!0;if(n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){let e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r)return!0;if(Bm(e)&&Bm(r)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&Bm(n[0])&&Bm(t[0])}let Wm,Vm;function A8(n){if(Wm==null){let t=eo(n);Wm=t.getParameter(t.MAX_TEXTURE_SIZE)}return Wm}function zft(){Wm=null}function Wft(){Vm=null}function _8(n){if(Vm==null){let t=eo(n);Vm=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Vm)}function F8(n){if(n===0)return 0;let t,e=eo(n);return as(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:as(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function as(n,t){let e=n.getExtension(t);return e!=null}function WE(n){try{let t=eo(n);if(t!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function R8(n){if(n===0)return!1;let t=eo(n);if(n===1){if(!as(t,"OES_texture_float"))return!1}else if(!as(t,"EXT_color_buffer_float"))return!1;let e=ax(t);return e}function P8(n){if(n===0)return!1;let t=eo(n);if(n===1){if(!as(t,"OES_texture_float"))return!1;if(!as(t,"WEBGL_color_buffer_float"))return!1}else{if(as(t,"EXT_color_buffer_float"))return ax(t);let r="EXT_color_buffer_half_float";if(as(t,r)){let s=t.getExtension(r);return O8(t,s)}return!1}let e=ax(t);return e}function ax(n){let t=nx(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e);let r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let u=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,u),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);let l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(u),l}function O8(n,t){let e=nx(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);let s=1,u=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,s,u,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let l=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,l),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);let h=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(l),h}function M8(n){if(n!==2)return!1;let t=eo(n),e=t.fenceSync!=null;return e}function bf(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&k(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}let te=ft();te.registerFlag("HAS_WEBGL",()=>te.getNumber("WEBGL_VERSION")>0),te.registerFlag("WEBGL_VERSION",()=>WE(2)?2:WE(1)?1:0),te.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),te.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>te.get("WEBGL_VERSION")===2),te.registerFlag("WEBGL_CPU_FORWARD",()=>!0),te.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),te.registerFlag("WEBGL_PACK",()=>te.getBool("HAS_WEBGL")),te.registerFlag("WEBGL_PACK_NORMALIZATION",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_CLIP",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1),te.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_REDUCE",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_LAZILY_UNPACK",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_CONV_IM2COL",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>A8(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>_8(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let n=te.getNumber("WEBGL_VERSION");return n===0?0:F8(n)}),te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>te.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!rS()),te.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>R8(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>te.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:te.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),te.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>P8(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_FENCE_API_ENABLED",()=>M8(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>{let n=te.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return n?4:0}),te.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});let{simpleAbsImpl:L8,addImpl:B8,ceilImpl:z8,expImpl:W8,expm1Impl:V8,floorImpl:U8,logImpl:G8,maxImpl:H8,multiplyImpl:q8,rsqrtImpl:j8,sliceImpl:K8,subImpl:X8,transposeImpl:ix,uniqueImpl:Y8}=N6;class J8{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((u,l)=>`T${l}`);let r=[];this.variableNames.forEach(u=>{r.push(`float v${u} = get${u}AtOutCoords();`)});let s=this.variableNames.map(u=>`v${u}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}class Z8{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((u,l)=>`T${l}`);let r=[];this.variableNames.forEach(u=>{r.push(`vec4 v${u} = get${u}AtOutCoords();`)});let s=this.variableNames.map(u=>`v${u}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}class Q8{constructor(t,e,r){this.variableNames=["A"];let{windowSize:s,batchSize:u,outSize:l}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[u,l];let h=e==="max"?">":"<",p=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${p};
          float candidate = getA(batch, inIdx);
          if (candidate ${h} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}function VE(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function nr(n,t){return t===1?[n]:VE(n,t)}function tX(n,t){if(n===1)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}function rr(){let n,t,e,r,s,u,l,h,p,m;return ft().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",r="in",s="texture",u="outputColor",l="out vec4 outputColor;",h=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,p="",m=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",r="varying",s="texture2D",u="gl_FragColor",l="",h=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,p=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,m=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:u,defineOutput:l,defineSpecialNaN:h,defineSpecialInf:p,defineRound:m}}function $i(n,t,e="index"){let r=Jt(t);return r.map((s,u)=>{let l=`int ${n[u]} = ${e} / ${s}`,h=u===r.length-1?`int ${n[u+1]} = ${e} - ${n[u]} * ${s}`:`index -= ${n[u]} * ${s}`;return`${l}; ${h};`}).join("")}function Um(n){return n.length===1?`${n[0]}`:`vec${n.length}(${n.join(",")})`}function Vft(n,t){if(n.length!==t.length)throw new Error(`Vectors to be dotted must be of the same length -got ${n.length} and ${t.length}`);let e=[],r=Math.floor(n.length/4),s=n.length%4;for(let u=0;u<r;u++){let l=n.slice(u*4,u*4+4),h=t.slice(u*4,u*4+4);e.push(`${Um(l)}, ${Um(h)}`)}if(s!==0){let u=n.slice(r*4),l=t.slice(r*4);u.length===1&&(u=u.map(h=>`float(${h})`),l=l.map(h=>`float(${h})`)),e.push(`${Um(u)}, ${Um(l)}`)}return e.map((u,l)=>`dot(${u})`).join("+")}function ux(n){let t=Jt(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}let UE=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;let{getBroadcastDims:GE}=Kb;function eX(n,t,e,r){let s=[];n.forEach(C=>{let I=O(C.shapeInfo.logicalShape);C.shapeInfo.isUniform?s.push(`uniform float ${C.name}${I>1?`[${I}]`:""};`):(s.push(`uniform sampler2D ${C.name};`),s.push(`uniform int offset${C.name};`))});let u=s.join(`
`),l=n.map(C=>nX(C,t,r)).join(`
`),h=t.texShape,p=rr(),m=oX(p),y,b,x=uX(p);t.isPacked?(y=rX(t.logicalShape,h),b=iX(p)):(y=sX(t.logicalShape,h),b=aX(p)),r&&(x+=fX);let S=[x,m,b,u,y,l,e].join(`
`);return S}function lc(n){let t=n.shapeInfo.logicalShape;switch(t.length){case 0:return SX(n);case 1:return NX(n);case 2:return EX(n);case 3:return $X(n);case 4:return _X(n);case 5:return FX(n);case 6:return RX(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function HE(n){let t=n.shapeInfo.logicalShape;switch(t.length){case 0:return kX(n);case 1:return CX(n);case 2:return IX(n);case 3:return DX(n);default:return AX(n)}}function nX(n,t,e=!1){let r="";e?r+=HE(n):r+=lc(n);let s=n.shapeInfo.logicalShape,u=t.logicalShape;return s.length<=u.length&&(e?r+=PX(n,t):r+=OX(n,t)),r}function rX(n,t){switch(n.length){case 0:return qE();case 1:return pX(n,t);case 2:return xX(n,t);case 3:return mX(n,t);default:return vX(n,t)}}function sX(n,t){switch(n.length){case 0:return qE();case 1:return dX(n,t);case 2:return TX(n,t);case 3:return gX(n,t);case 4:return yX(n,t);case 5:return bX(n,t);case 6:return wX(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function oX(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function aX(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function iX(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function uX(n){let t=`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${cX}
    ${lX}
    ${hX}
  `;return t}let cX=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,lX=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hX=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,fX=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function qE(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function pX(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return e[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${e[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return 2 * (resTexRC.x * ${e[1]} + resTexRC.y);
    }
  `}function dX(n,t){return t[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function mX(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),s=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function gX(n,t){let e=$i(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${e}
      return ivec3(r, c, d);
    }
  `}function vX(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),s=r*Math.ceil(n[n.length-2]/2),u=s,l="",h="b, r, c";for(let p=2;p<n.length-1;p++)u*=n[n.length-p-1],l=`
      int b${p} = index / ${u};
      index -= b${p} * ${u};
    `+l,h=`b${p}, `+h;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${l}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${h});
    }
  `}function yX(n,t){let e=$i(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${e}
      return ivec4(r, c, d, d2);
    }
  `}function bX(n,t){let e=$i(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function wX(n,t){let e=$i(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function xX(n,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(K(n,t))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `;let r=Math.ceil(n[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function TX(n,t){return K(n,t)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Ai(n){return`offset${n}`}function kX(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),r=rr();return`
    vec4 ${e}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function SX(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${e}() {return ${t};}`;let[r,s]=n.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${e}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let[u,l]=n.shapeInfo.texShape,h=Ai(t);return`
    float ${e}() {
      vec2 uv = uvFromFlat(${u}, ${l}, ${h});
      return sampleTexture(${t}, uv);
    }
  `}function CX(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=rr();return`
    vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
        ${s[0]}, ${s[1]}, index);
      return ${u.texture2D}(${t}, uv);
    }
  `}function NX(n){let t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${e}(int index) {
        ${hc(n)}
      }
    `;let r=n.shapeInfo.texShape,s=r[0],u=r[1];if(u===1&&s===1)return`
      float ${e}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let l=Ai(t);return u===1?`
      float ${e}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${l}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?`
      float ${e}(int index) {
        vec2 uv = vec2((float(index + ${l}) + 0.5) / ${u}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
    float ${e}(int index) {
      vec2 uv = uvFromFlat(${s}, ${u}, index + ${l});
      return sampleTexture(${t}, uv);
    }
  `}function IX(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,u=s[0],l=s[1],h=rr();if(s!=null&&K(t,s))return`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);

        return ${h.texture2D}(${e}, uv);
      }
    `;let p=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],m=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${m}, ${p[0]}, ${p[1]}, row, col);
      return ${h.texture2D}(${e}, uv);
    }
  `}function EX(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape;if(s!=null&&K(t,s)){let b=s[0],x=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${x}.0, ${b}.0);
      return sampleTexture(${e}, uv);
    }
  `}let{newShape:u,keptDims:l}=Wt(t),h=u;if(h.length<t.length){let b=fc(n,h),x=["row","col"];return`
      ${lc(b)}
      float ${r}(int row, int col) {
        return ${r}(${pc(x,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${hc(n)}
      }
    `;let p=s[0],m=s[1],y=Ai(e);return m===1?`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${y}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);
      return sampleTexture(${e}, uv);
    }
  `:p===1?`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${y}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${m}.0, 0.5);
      return sampleTexture(${e}, uv);
    }
  `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${y};
    vec2 uv = uvFromFlat(${p}, ${m}, index);
    return sampleTexture(${e}, uv);
  }
`}function DX(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let b=t.slice(1),x=[1,2],S=fc(n,b),C=["b","row","col"];return`
        ${HE(S)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${pc(C,x)});
        }
      `}let l=u[0],h=u[1],p=Math.ceil(t[2]/2),m=p*Math.ceil(t[1]/2),y=rr();return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${h}, ${m}, ${p}, b, row, col);
      return ${y.texture2D}(${e}, uv);
    }
  `}function $X(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[1]*t[2],u=t[2],{newShape:l,keptDims:h}=Wt(t),p=l;if(p.length<t.length){let C=fc(n,p),I=["row","col","depth"];return`
        ${lc(C)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${pc(I,h)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${u}, 1)));
        ${hc(n)}
      }
    `;let m=n.shapeInfo.texShape,y=m[0],b=m[1],x=n.shapeInfo.flatOffset;if(b===s&&x==null)return`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${u}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${b}.0, ${y}.0);
          return sampleTexture(${e}, uv);
        }
      `;if(b===u&&x==null)return`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${b}.0, ${y}.0);
      return sampleTexture(${e}, uv);
    }
  `;let S=Ai(e);return`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${u} + depth + ${S};
        vec2 uv = uvFromFlat(${y}, ${b}, index);
        return sampleTexture(${e}, uv);
      }
  `}function AX(n){let t=n.shapeInfo.logicalShape,e=t.length,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),u=n.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],h=l[0],p=l[1],m=Math.ceil(t[e-1]/2),y=m*Math.ceil(t[e-2]/2),b="int b, int row, int col",x=`b * ${y} + (row / 2) * ${m} + (col / 2)`;for(let C=2;C<e-1;C++)b=`int b${C}, `+b,y*=t[e-C-1],x=`b${C} * ${y} + `+x;let S=rr();return`
    vec4 ${s}(${b}) {
      int index = ${x};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${h});
      return ${S.texture2D}(${r}, uv);
    }
  `}function _X(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[3],u=t[2]*s,l=t[1]*u,{newShape:h,keptDims:p}=Wt(t);if(h.length<t.length){let C=fc(n,h),I=["row","col","depth","depth2"];return`
      ${lc(C)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${pc(I,p)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${l}, ${u}, ${s}, 1)));
        ${hc(n)}
      }
    `;let m=n.shapeInfo.flatOffset,y=n.shapeInfo.texShape,b=y[0],x=y[1];if(x===l&&m==null)return`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${u}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${x}.0, ${b}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(x===s&&m==null)return`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${x}.0, ${b}.0);
        return sampleTexture(${e}, uv);
      }
    `;let S=Ai(e);return`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${u} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${b}, ${x}, index + ${S});
      return sampleTexture(${e}, uv);
    }
  `}function FX(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],u=t[3]*s,l=t[2]*u,h=t[1]*l,{newShape:p,keptDims:m}=Wt(t);if(p.length<t.length){let I=fc(n,p),D=["row","col","depth","depth2","depth3"];return`
      ${lc(I)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${pc(D,m)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${l}, ${u}, ${s})) +
          depth3;
        ${hc(n)}
      }
    `;let y=n.shapeInfo.flatOffset,b=n.shapeInfo.texShape,x=b[0],S=b[1];if(S===h&&y==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${l}, ${u}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${S}.0, ${x}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(S===s&&y==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${S}.0, ${x}.0);
        return sampleTexture(${e}, uv);
      }
    `;let C=Ai(e);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${l} + depth * ${u} +
          depth2 * ${s} + depth3 + ${C};
      vec2 uv = uvFromFlat(${x}, ${S}, index);
      return sampleTexture(${e}, uv);
    }
  `}function RX(n){let t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:u}=Wt(t);if(s.length<t.length){let D=fc(n,s),R=["row","col","depth","depth2","depth3","depth4"];return`
      ${lc(D)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${pc(R,u)});
      }
    `}let l=t[5],h=t[4]*l,p=t[3]*h,m=t[2]*p,y=t[1]*m;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${y}, ${m}, ${p}, ${h})) +
          dot(
            vec2(depth3, depth4),
            vec2(${l}, 1)));
        ${hc(n)}
      }
    `;let b=n.shapeInfo.flatOffset,x=n.shapeInfo.texShape,S=x[0],C=x[1];if(C===y&&b==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${m}, ${p}, ${h}, ${l})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${C}.0, ${S}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(C===l&&b==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${C}.0, ${S}.0);
        return sampleTexture(${e}, uv);
      }
    `;let I=Ai(e);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${y} + col * ${m} + depth * ${p} +
          depth2 * ${h} + depth3 * ${l} + depth4 + ${I};
      vec2 uv = uvFromFlat(${S}, ${C}, index);
      return sampleTexture(${e}, uv);
    }
  `}function hc(n){let t=n.name,e=O(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function PX(n,t){let e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",u=n.shapeInfo.logicalShape.length,l=t.logicalShape.length,h=GE(n.shapeInfo.logicalShape,t.logicalShape),p=We(l),m=l-u,y,b=["x","y","z","w","u","v"];u===0?y="":l<2&&h.length>=1?y="coords = 0;":y=h.map(A=>`coords.${b[A+m]} = 0;`).join(`
`);let x="";l<2&&u>0?x="coords":x=n.shapeInfo.logicalShape.map((A,L)=>`coords.${b[L+m]}`).join(", ");let S="return outputValue;",C=O(n.shapeInfo.logicalShape),I=C===1,D=O(t.logicalShape),R=D===1;if(u===1&&!I&&!R)S=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(I&&!R)l===1?S=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:S=`
        return vec4(outputValue.x);
      `;else if(h.length){let A=u-2,L=u-1;h.indexOf(A)>-1&&h.indexOf(L)>-1?S="return vec4(outputValue.x);":h.indexOf(A)>-1?S="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":h.indexOf(L)>-1&&(S="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${p} coords = getOutputCoords();
      ${y}
      vec4 outputValue = get${r}(${x});
      ${S}
    }
  `}function OX(n,t){let e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",u=t.texShape,l=n.shapeInfo.texShape,h=n.shapeInfo.logicalShape.length,p=t.logicalShape.length;if(!n.shapeInfo.isUniform&&h===p&&n.shapeInfo.flatOffset==null&&K(l,u))return`
      float ${s}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let m=We(p),y=GE(n.shapeInfo.logicalShape,t.logicalShape),b=p-h,x,S=["x","y","z","w","u","v"];h===0?x="":p<2&&y.length>=1?x="coords = 0;":x=y.map(I=>`coords.${S[I+b]} = 0;`).join(`
`);let C="";return p<2&&h>0?C="coords":C=n.shapeInfo.logicalShape.map((I,D)=>`coords.${S[D+b]}`).join(", "),`
    float ${s}() {
      ${m} coords = getOutputCoords();
      ${x}
      return get${r}(${C});
    }
  `}function We(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function fc(n,t){let e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function pc(n,t){return t.map(e=>n[e]).join(", ")}class MX{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,k(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let u=t[t.length-1],l=Math.ceil(u/e);this.outputShape=t.slice(0,-1),l>1&&this.outputShape.push(l),s||this.variableNames.push("bestIndicesA");let h=this.outputShape,p=h.length,m=We(p),y=nr("coords",p),b,x;if(l===1){x=p+1;let j=We(x);b=`
        ${j} sourceLocR = ${j}(${y.join()}, 0);
        ++${y[p-1]};
        ${j} sourceLocG = ${j}(${y.join()}, 0);
        ++${y[p-2]};
        ${j} sourceLocA = ${j}(${y.join()}, 0);
        --${y[p-1]};
        ${j} sourceLocB = ${j}(${y.join()}, 0);
        --${y[p-2]};`}else x=p,b=`
        ${m} sourceLocR = coords;
        ++${y[p-1]};
        ${m} sourceLocG = coords;
        ++${y[p-2]};
        ${m} sourceLocA = coords;
        --${y[p-1]};
        ${m} sourceLocB = coords;
        --${y[p-2]};`;let S=["x","y","z","w","u","v"].slice(0,x),C="."+S[x-1],I=S.map(j=>"int "+j),D=nr("sourceLocR",x-1).concat("inIdx.r"),R=nr("sourceLocG",x-1).concat("inIdx.g"),A=nr("sourceLocB",x-1).concat("inIdx.b"),L=nr("sourceLocA",x-1).concat("inIdx.a"),_=r==="max"?"greaterThan":"lessThan",B=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${D.join()}),
                             getBestIndicesAChannel(${R.join()}),
                             getBestIndicesAChannel(${A.join()}),
                             getBestIndicesAChannel(${L.join()})));`,V=`vec4(
            getAChannel(${D.join()}),
            hasNextCol ? getAChannel(${R.join()}) : 0.,
            hasNextRow ? getAChannel(${A.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${L.join()}) : 0.)`,q=s?"":`
      float getBestIndicesAChannel(${I.join()}) {
        return getChannel(getBestIndicesA(${S.join()}),
                                          vec2(${S.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${I.join()}) {
        return getChannel(getA(${S.join()}),
                               vec2(${S.slice(-2).join()}));
      }
      ${q}
      void main() {
        ${m} coords = getOutputCoords();
        bool hasNextCol = ${y[p-1]} < ${h[p-1]-1};
        bool hasNextRow = ${y[p-2]} < ${h[p-2]-1};
        ${b}
        ivec4 srcIdx = ivec4(sourceLocR${C}, sourceLocG${C},
          sourceLocB${C}, sourceLocA${C}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${V};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${B}
          vec4 candidate = ${V};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}class LX{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,r=t.filterWidth,s=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,y=p-1-t.padInfo.top,b=m-1-t.padInfo.left,x=1/(e*r);this.userCode=`
      const ivec2 pads = ivec2(${y}, ${b});
      const float avgMultiplier = float(${x});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p};
            wR += ${l}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${m};
            wC+= ${h}) {
            float dyC = float(dyCCorner + wC) / ${u}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class BX{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,r=t.filterHeight,s=t.filterWidth,u=t.strideDepth,l=t.strideHeight,h=t.strideWidth,p=t.dilationDepth,m=t.dilationHeight,y=t.dilationWidth,b=t.effectiveFilterDepth,x=t.effectiveFilterHeight,S=t.effectiveFilterWidth,C=b-1-t.padInfo.front,I=x-1-t.padInfo.top,D=S-1-t.padInfo.left,R=1/(e*r*s);this.userCode=`
      const ivec3 pads = ivec3(${C}, ${I}, ${D});
      const float avgMultiplier = float(${R});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${b};
            wD += ${p}) {
          float dyD = float(dyDCorner + wD) / ${u}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${x};
              wR += ${m}) {
            float dyR = float(dyRCorner + wR) / ${l}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${S};
                wC += ${y}) {
              float dyC = float(dyCCorner + wC) / ${h}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}let jE=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,zX=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,WX=`
if(a < 0.0 && floor(b) < b){
  return NAN;
}
if (b == 0.0) {
  return 1.0;
}
return (round(mod(b, 2.0)) != 1) ?
    pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Uft="return (a - b) * (a - b);",VX="return float(a == b);",UX="return float(a < b);",GX="return float(a <= b);",HX="return float(a > b);",qX="return float(a >= b);",jX="return float(a >= 1.0 && b >= 1.0);",KX="return float(a >= 1.0 || b >= 1.0);",XX=jE+`
  return max(a, b);
`,YX=jE+`
  return min(a, b);
`,JX=`if (b == 0.0) return NAN;
  return mod(a, b);`,ZX="return (b >= 1.0) ? a : a * (b + 1.0);",KE="return (a < 0.) ? b * a : a;";class Yn{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=ve(e,r),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}let Gm=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`,QX=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,tY=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Gm+`
  return result;
`,XE=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,eY=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,nY=`
  return vec4(equal(a, b));
`,Gft=`
  return vec4(notEqual(a, b));
`,rY=`
  return vec4(lessThan(a, b));
`,sY=`
  return vec4(lessThanEqual(a, b));
`,oY=`
  return vec4(greaterThan(a, b));
`,aY=`
  return vec4(greaterThanEqual(a, b));
`,iY=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,uY=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,cY=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Gm+`
  return result;
`,lY=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Gm+`
  return result;
`,hY=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Gm+`
  return result;
`;class Ao{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ve(e,r);let u=this.outputShape.length,l="";if(s)if(u===0||O(this.outputShape)===1)l=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{let h=We(u);if(l=`
          ${h} coords = getOutputCoords();
        `,u===1)l+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let p=nr("coords",u);l+=`
            bool nextRowOutOfBounds =
              (${p[u-2]} + 1) >= ${this.outputShape[u-2]};
            bool nextColOutOfBounds =
              (${p[u-1]} + 1) >= ${this.outputShape[u-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${l}

        setOutput(result);
      }
    `}}class fY{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}getCustomSetupFunc(t,e){return(r,s)=>{this.minLoc==null&&(this.minLoc=r.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=r.getUniformLocationNoThrow(s,"maxVal")),r.gl.uniform1f(this.minLoc,t),r.gl.uniform1f(this.maxLoc,e)}}}class pY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}getCustomSetupFunc(t,e){return(r,s)=>{this.minLoc==null&&(this.minLoc=r.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=r.getUniformLocationNoThrow(s,"maxVal")),r.gl.uniform1f(this.minLoc,t),r.gl.uniform1f(this.maxLoc,e)}}}class dY{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}class mY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,u=t.padInfo.left,l=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${l}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class gY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,r=t.filterWidth,s=t.strideHeight,u=t.strideWidth,l=t.dataFormat==="channelsLast",h=e-1-t.padInfo.top,p=r-1-t.padInfo.left,m=l?1:2,y=l?2:3,b=l?3:1;this.userCode=`
      const ivec2 pads = ivec2(${h}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${b}];

        ivec2 dyCorner = ivec2(coords[${m}], coords[${y}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${u}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${l}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,r=t.strideHeight,s=t.strideWidth,u=t.padInfo.front,l=t.padInfo.top,h=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${u};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${l};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${h};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class yY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,r=t.filterHeight,s=t.filterWidth,u=t.strideDepth,l=t.strideHeight,h=t.strideWidth,p=e-1-t.padInfo.front,m=r-1-t.padInfo.top,y=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${u}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${l}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${h}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class bY{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,u=t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${l} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${u};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class wY{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,r=t.filterWidth,s=t.strideHeight,u=t.strideWidth,l=e-1-t.padInfo.top,h=r-1-t.padInfo.left,p=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${u}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${p}; dm++) {
              int d2 = d1 * ${p} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class YE{constructor(t,e=!1,r=null,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let u=t.padInfo.top,l=t.padInfo.left,h=t.strideHeight,p=t.strideWidth,m=t.dilationHeight,y=t.dilationWidth,b=t.filterHeight,x=t.filterWidth,S=Math.floor(t.inChannels/4)*4,C=t.inChannels%4,I=t.dataFormat==="channelsLast",D=I?1:2,R=I?2:3,A=I?3:1,L="",_="";r&&(s?L=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:L=`
          float activation(float x) {
            ${r}
          }
        `,_="result = activation(result);");let B=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      ${L}

      const ivec2 strides = ivec2(${h}, ${p});
      const ivec2 pads = ivec2(${u}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${A}];

        ivec2 xRCCorner =
            ivec2(coords[${D}], coords[${R}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${b}; wR++) {
          int xR = xRCorner + wR * ${m};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC++) {
            int xC = xCCorner + wC * ${y};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${S}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${I}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${C===1}) {

              if (${I}) {
                dotProd +=
                    getX(batch, xR, xC, ${S}) *
                    getW(wR, wC, ${S}, d2);
              } else {
                dotProd +=
                    getX(batch, ${S}, xR, xC) *
                    getW(wR, wC, ${S}, d2);
              }

            } else if (${C===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${S}, d2),
                getW(wR, wC, ${S} + 1, d2)
              );

              if (${I}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${S}),
                  getX(batch, xR, xC, ${S} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${S}, xR, xC),
                  getX(batch, ${S} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${C===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${S}, d2),
                getW(wR, wC, ${S} + 1, d2),
                getW(wR, wC, ${S} + 2, d2)
              );

              if (${I}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${S}),
                  getX(batch, xR, xC, ${S} + 1),
                  getX(batch, xR, xC, ${S} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${S}, xR, xC),
                  getX(batch, ${S} + 1, xR, xC),
                  getX(batch, ${S} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${B}
        ${_}
        setOutput(result);
      }
    `}}class xY{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,u=t.strideDepth,l=t.strideHeight,h=t.strideWidth,p=t.dilationDepth,m=t.dilationHeight,y=t.dilationWidth,b=t.filterDepth,x=t.filterHeight,S=t.filterWidth,C=Math.floor(t.inChannels/4)*4,I=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${u}, ${l}, ${h});
      const ivec3 pads = ivec3(${e}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${b}; wF++) {
          int xF = xFCorner + wF * ${p};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${x}; wR++) {
            int xR = xRCorner + wR * ${m};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC++) {
              int xC = xCCorner + wC * ${y};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${C}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${I===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${C}) *
                  getW(wF, wR, wC, ${C}, d2);
              } else if (${I===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${C}),
                  getX(batch, xF, xR, xC, ${C} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${C}, d2),
                  getW(wF, wR, wC, ${C} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${I===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${C}),
                  getX(batch, xF, xR, xC, ${C} + 1),
                  getX(batch, xF, xR, xC, ${C} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${C}, d2),
                  getW(wF, wR, wC, ${C} + 1, d2),
                  getW(wF, wR, wC, ${C} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class JE{constructor(t,e=!1,r=null,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let u=t.inHeight,l=t.inWidth,h=t.padInfo.top,p=t.padInfo.left,m=t.strideHeight,y=t.strideWidth,b=t.dilationHeight,x=t.dilationWidth,S=t.filterHeight,C=t.filterWidth,I=t.outChannels/t.inChannels,D="",R="";r&&(s?D=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:D=`
          float activation(float x) {
            ${r}
          }
        `,R="result = activation(result);");let A=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      ${D}

      const ivec2 strides = ivec2(${m}, ${y});
      const ivec2 pads = ivec2(${h}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${I};
        int q = d2 - d1 * ${I};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${S}; wR++) {
          int xR = xRCorner + wR * ${b};

          if (xR < 0 || xR >= ${u}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC++) {
            int xC = xCCorner + wC * ${x};

            if (xC < 0 || xC >= ${l}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${A}
        ${R}
        setOutput(result);
      }
    `}}class ZE{constructor(t,e=!1,r=null,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;let u=t.inHeight,l=t.inWidth,h=t.padInfo.top,p=t.padInfo.left,m=t.strideHeight,y=t.strideWidth,b=t.dilationHeight,x=t.dilationWidth,S=t.filterHeight,C=t.filterWidth,I=C,D="int xR; int xC; int xCOffset;";for(let _=0;_<S;_++)for(let B=0;B<C;B++)D+=`
          vec4 xTexelR${_}C${B*2} = vec4(0.);
          vec4 wR${_}C${B} = vec4(0.);
          vec4 xR${_}C${B} = vec4(0.);`;for(let _=0;_<S;_++)for(let B=0;B<I;B++){let V=B*2;if(D+=`
          xR = xRCorner + ${_*b};
          xC = xCCorner + ${V*x};
        `,y===1){if(V<C&&(p%2===1?D+=`
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${u} && xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelR${_}C${V} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${l}) {
                    xTexelR${_}C${V}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${_}C${V} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${u} && xCOffset >= 0 && xCOffset < ${l}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${l}) {
                    previous.zw = vec2(0.);
                  }

                  xR${_}C${V} = vec4(previous.zw, xTexelR${_}C${V}.xy);
                } else {
                  xR${_}C${V} = vec4(0, 0, xTexelR${_}C${V}.xy);
                }
              `:D+=`
                if(xR >= 0 && xR < ${u} && xC >= 0 && xC < ${l}) {
                  xTexelR${_}C${V} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${_}C${V} = vec4(0.);
                }

                xR${_}C${V} = xTexelR${_}C${V};
              `,V+1<C)){let q=p%2===0?w(x):x;x%2===0&&p%2===1||x%2!==0&&p%2!==1?(D+=`
                  xCOffset = xC + ${p%2} + ${q};

                  if(xR >= 0 && xR < ${u} &&
                    xCOffset >= 0 && xCOffset < ${l}) {
                    xTexelR${_}C${V+2} = getX(batch, xR, xCOffset, d1);
                  }
                `,x>1&&(D+=`
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${u} &&
                      xCOffset >= 0 && xCOffset < ${l}) {
                      xTexelR${_}C${V} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${_}C${V} = vec4(0.);
                    }
                  `),D+=`
                  xR${_}C${V+1} = vec4(
                    xTexelR${_}C${V}.zw, xTexelR${_}C${V+2}.xy);
                `):D+=`
                  xCOffset = xC + ${q};

                  if(xR >= 0 && xR < ${u} &&
                    xCOffset >= 0 && xCOffset < ${l}) {
                    xTexelR${_}C${V+2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${_}C${V+1} = xTexelR${_}C${V+2};
                `}}else V<C&&(D+=`
              if(xR >= 0 && xR < ${u}) {
            `,p%2===1?(D+=`
                xCOffset = xC + 1 - ${y};
                if(xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelR${_}C${V} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${_}C${V} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${l}) {
                  xTexelR${_}C${V+2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${_}C${V+2} = vec4(0.);
                }

                xR${_}C${V} = vec4(
                  xTexelR${_}C${V}.zw, xTexelR${_}C${V+2}.zw);
              `,V+1<C&&(D+=`
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${y};
                  if(xCOffset >= 0 && xCOffset < ${l}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${_}C${V+1} = vec4(xTexelR${_}C${V+2}.xy, final.xy);
                `)):(D+=`
                if(xC >= 0 && xC < ${l}) {
                  xTexelR${_}C${V} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${_}C${V} = vec4(0.);
                }

                xCOffset = xC + ${y};
                if(xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelR${_}C${V+2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${_}C${V+2} = vec4(0.);
                }

                xR${_}C${V} = vec4(
                  xTexelR${_}C${V}.xy, xTexelR${_}C${V+2}.xy);
              `,V+1<C&&(D+=`
                  xR${_}C${V+1} = vec4(
                    xTexelR${_}C${V}.zw, xTexelR${_}C${V+2}.zw);
                `)),D+="}");V<C&&(D+=`
            vec4 wTexelR${_}C${V} = getW(${_}, ${V}, d1, q);
            wR${_}C${V} = vec4(wTexelR${_}C${V}.xz, wTexelR${_}C${V}.xz);
          `,V+1<C&&(D+=`
              vec4 wTexelR${_}C${V+1} = getW(${_}, ${V+1}, d1, q);
              wR${_}C${V+1} =
                vec4(wTexelR${_}C${V+1}.xz, wTexelR${_}C${V+1}.xz);`))}for(let _=0;_<S;_++)for(let B=0;B<C;B++)D+=`dotProd += xR${_}C${B} * wR${_}C${B};`;let R="",A="";r&&(s?R=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:R=`vec4 activation(vec4 x) {
          ${r}
        }`,A="result = activation(result);");let L=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      ${R}

      const ivec2 strides = ivec2(${m}, ${y});
      const ivec2 pads = ivec2(${h}, ${p});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${D}

        vec4 result = dotProd;
        ${L}
        ${A}
        setOutput(result);
      }
    `}}class TY{constructor(t,e,r,s,u){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[l,h,p,m]=t,[y]=e,[b,x]=r;this.outputShape=[y,b,x,m];let S=s==="bilinear"?1:0,[C,I]=[`${h-1}.0`,`${p-1}.0`],[D,R,A]=b>1?[`${(h-1)/(b-1)}`,"(y2-y1) * height_ratio",`y1*${C} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${C}`],[L,_,B]=x>1?[`${(p-1)/(x-1)}`,"(x2-x1) * width_ratio",`x1*${I} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${I}`];this.userCode=`
      const float height_ratio = float(${D});
      const float width_ratio = float(${L});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${l}) {
          return;
        }

        float height_scale = ${R};
        float width_scale = ${_};

        float in_y = ${A};
        if( in_y < 0.0 || in_y > ${C} ) {
          setOutput(float(${u}));
          return;
        }
        float in_x = ${B};
        if( in_x < 0.0 || in_x > ${I} ) {
          setOutput(float(${u}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${S} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}class QE{constructor(t,e,r){this.variableNames=["x"],this.outputShape=t;let s=t.length,u=e?"0.0":`getX(${tD(s,"coords")})`,l=t[t.length-1],h="",p="";e?(h=r?`end != ${l-1}`:"end != 0",p=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${l}`:"end >= pow2",p=r?"end + pow2":"end - pow2"),this.userCode=`
      uniform float index;
      void main() {
        ${We(s)} coords = getOutputCoords();
        int end = ${eD(s,"coords")};
        float val = ${u};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${p};
          ${eD(s,"coords")} = idx;
          val += getX(${tD(s,"coords")});
        }
        setOutput(val);
      }
    `}getCustomSetupFunc(t){return(e,r)=>{this.index==null&&(this.index=e.getUniformLocation(r,"index")),e.gl.uniform1f(this.index,t)}}}function tD(n,t){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function eD(n,t){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}class kY{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=gf.DENSE;let e=yf(t),r=rr();this.outputShape=t,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${$i(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${e[0]}, ${e[1]}));
        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${r.output} = result;
      }
    `}}class SY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=gf.DENSE;let e=yf(t),r=rr();this.outputShape=t,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${$i(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${e[0]}, ${e[1]}));
        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${r.output} = result;
      }
    `}}class CY{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}class NY{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}class IY{constructor(t){this.variableNames=["A"],this.outTexUsage=Hr.DOWNLOAD;let e=rr();this.outputShape=t,this.userCode=`
      ${UE}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class EY{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Hr.DOWNLOAD;let e=rr();this.outputShape=t,this.userCode=`
      ${UE}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}class DY{constructor(t,e,r=!1){this.variableNames=["A"];let s=rr(),[u,l]=e;this.outputShape=t;let h="result";r&&(h="floor(result * 255. + 0.5)"),this.userCode=`
      ${ux(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${l};
        int c = imod(flatIndex, ${l});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${l}.0, ${u}.0);
        vec4 values = ${s.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${s.output} = vec4(${h}, 0., 0., 0.);
      }
    `}}class $Y{constructor(t,e,r=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let s=rr(),[u,l]=e;this.outputShape=t;let h="",p="result";r&&(p="floor(result * 255. + 0.5)");for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){let b=m*2+y;h+=`
          localCoords = coords;
          if(localCoords[2] + ${y} < ${t[2]}) {
            localCoords[2] += ${y};
            if(localCoords[1] + ${m} < ${t[1]}) {
              localCoords[1] += ${m};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${l};
              c = imod(flatIndex, ${l});
              uv = (vec2(c, r) + halfCR) / vec2(${l}.0, ${u}.0);
              values = ${s.texture2D}(A, uv);

              if(offset == 0) {
                result[${b}] = values[0];
              } else if(offset == 1) {
                result[${b}] = values[1];
              } else if(offset == 2) {
                result[${b}] = values[2];
              } else {
                result[${b}] = values[3];
              }
            }
          }
        `}this.userCode=`
      ${ux(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${h}

        ${s.output} = ${p};
      }
    `}}class AY{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}getCustomSetupFunc(t){return(e,r)=>{this.valueLoc==null&&(this.valueLoc=e.getUniformLocationNoThrow(r,"value")),e.gl.uniform1f(this.valueLoc,t)}}}class _Y{constructor(t,e,r){this.variableNames=["A","indices"];let s=t.slice();s[r]=e,this.outputShape=s,this.rank=s.length;let u=We(this.rank),l=FY(t,r);this.userCode=`
      void main() {
        ${u} resRC = getOutputCoords();
        setOutput(getA(${l}));
      }
    `}}function FY(n,t){let e=n.length;if(e>4)throw Error(`Gather for rank ${e} is not yet supported`);if(e===1)return"int(getIndices(resRC))";let r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let u=0;u<n.length;u++)u===t?s.push(`int(getIndices(${r[u]}))`):s.push(`${r[u]}`);return s.join()}class RY{constructor(t,e,r){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=r;let s=We(e.length),u=We(r.length),l=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${u} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${l};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}function PY(n){let t=rr(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return d8(n,e)}function OY(n){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return w8(n,t)}function MY(n){let t=new Uint16Array([0,1,2,2,1,3]);return x8(n,t)}function wf(n,t,e,r,s,u){k8(t,e);let l=T8(n),h=n.TEXTURE_2D;return zt(n,()=>n.bindTexture(h,l)),zt(n,()=>n.texParameteri(h,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),zt(n,()=>n.texParameteri(h,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),zt(n,()=>n.texParameteri(h,n.TEXTURE_MIN_FILTER,n.NEAREST)),zt(n,()=>n.texParameteri(h,n.TEXTURE_MAG_FILTER,n.NEAREST)),zt(n,()=>n.texImage2D(h,0,r,t,e,0,s,u,null)),zt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),l}function nD(n){return n.internalFormatFloat}function LY(n,t,e,r){let[s,u]=vf(t,e);return wf(n,s,u,nD(r),r.textureFormatFloat,n.FLOAT)}function rD(n){return n.internalFormatHalfFloat}function BY(n,t,e,r){let[s,u]=vf(t,e);return wf(n,s,u,rD(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function sD(n){return n.downloadTextureFormat}function zY(n,t,e,r){let[s,u]=vf(t,e);return wf(n,s,u,sD(r),n.RGBA,n.UNSIGNED_BYTE)}function oD(n){return n.internalFormatPackedFloat}function WY(n,t,e,r){let[s,u]=ic(t,e);return wf(n,s,u,oD(r),n.RGBA,n.FLOAT)}function aD(n){return n.internalFormatPackedHalfFloat}function VY(n,t,e,r){let[s,u]=ic(t,e);return wf(n,s,u,aD(r),n.RGBA,r.textureTypeHalfFloat)}function UY(n,t,e){let r=0,s=3*4,u=3*4+2*4;zt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e));let l=LE(n,t,"clipSpacePos",e,3,u,r);return l&&LE(n,t,"uv",e,2,u,s)}function GY(n,t,e,r,s,u){zt(n,()=>n.bindTexture(n.TEXTURE_2D,t));let l,h,p;s instanceof Uint8Array?(l=new Uint8Array(e*r*4),h=n.UNSIGNED_BYTE,p=n.RGBA):(l=new Float32Array(e*r*4),h=n.FLOAT,p=u.internalFormatPackedFloat),l.set(s),zt(n,()=>n.texImage2D(n.TEXTURE_2D,0,p,e,r,0,n.RGBA,h,l)),zt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function HY(n,t,e){zt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?zt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):zt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),zt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function qY(n,t,e,r){let s=n.createBuffer();zt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));let u=4,l=4,h=u*l*t*e;return zt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,h,n.STREAM_READ)),zt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),zt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function jY(n,t,e){let r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function KY(n,t,e,r){let[s,u]=vf(t,e),l=4,h=new Uint8Array(i8(t*e,l));return zt(n,()=>n.readPixels(0,0,s,u,r.downloadTextureFormat,n.UNSIGNED_BYTE,h)),new Float32Array(h.buffer)}function XY(n,t,e,r,s,u,l,h){let p=n,m=new Float32Array(u8(u,l));return p.bindBuffer(p.PIXEL_PACK_BUFFER,t),p.getBufferSubData(p.PIXEL_PACK_BUFFER,0,m),p.bindBuffer(p.PIXEL_PACK_BUFFER,null),m}function YY(n,t,e){let r=new Float32Array(t*e*4);return zt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}class JY{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=ft().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,s8(e,t)):this.gl=eo(e);let r="WEBGL_color_buffer_float",s="EXT_color_buffer_half_float";if(ft().getNumber("WEBGL_VERSION")===1){let u="OES_texture_float",l="OES_texture_half_float";if(this.textureFloatExtension=Mm(this.gl,u),as(this.gl,l))this.textureHalfFloatExtension=Mm(this.gl,l);else if(ft().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),as(this.gl,s))this.colorBufferHalfFloatExtension=Mm(this.gl,s);else if(ft().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",as(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(as(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=OY(this.gl),this.indexBuffer=MY(this.gl),this.framebuffer=S8(this.gl),this.textureConfig=nx(this.gl,this.textureHalfFloatExtension)}get debug(){return ft().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;zt(t,()=>t.finish()),zt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),zt(t,()=>t.deleteFramebuffer(this.framebuffer)),zt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),zt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),zt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),LY(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),BY(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),zY(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),HY(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),GY(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),VY(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),WY(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(BE(this.gl,this.framebuffer),this.outputTexture=null),zt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>KY(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,u,l){return XY(this.gl,t,e,r,s,u,l,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return jY(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);let s=qY(this.gl,e,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(ft().getBool("WEBGL_FENCE_API_ENABLED")){let s=t,u=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{let l=s.clientWaitSync(u,0,0);return l===s.ALREADY_SIGNALED||l===s.CONDITION_SATISFIED},e=u}else ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>YY(this.gl,e,r))}createProgram(t){this.throwIfDisposed();let e=this.gl,r=m8(e,t),s=PY(e),u=y8(e);return zt(e,()=>e.attachShader(u,s)),zt(e,()=>e.attachShader(u,r)),b8(e,u),this.debug&&rx(e,u),this.vertexAttrsAreBound||(this.setProgram(u),this.vertexAttrsAreBound=UY(e,this.program,this.vertexBuffer)),u}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&zt(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&rx(this.gl,this.program),zt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?N8(this.gl,t,e):I8(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),zt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),E8(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();let[s,u]=ic(e,r);this.setOutputMatrixTextureDriver(t,s,u)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&rx(this.gl,this.program),Lm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),zt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),zt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Mm(this.gl,ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,s=this.getQueryTimerExtensionWebGL2(),u=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,u),u}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,r=this.getQueryTimerExtensionWebGL2();e.endQuery(r.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await It(()=>this.disposed||this.isQueryAvailable(t,ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let r=this.gl,s=r.getQueryParameter(t,r.QUERY_RESULT);return s/1e6}else{let r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT);return s/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let r=this.gl,s=this.getQueryTimerExtensionWebGL2(),u=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),u&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=ZY(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;It(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),sx(this.gl,t,this.framebuffer),this.debug&&Lm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(sx(this.gl,this.outputTexture,this.framebuffer),this.debug&&Lm(this.gl)):BE(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();let s=this.gl;sx(s,t,this.framebuffer),this.debug&&Lm(s),this.outputTexture=t,zt(s,()=>s.viewport(0,0,e,r)),zt(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),zt(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function ZY(n){let t=0;for(;t<n.length;++t){let e=n[t]();if(!e)break}return t-1}function QY(n,t,e,r){let s=t.userCode,u=e.map((S,C)=>{let I={logicalShape:S.shape,texShape:S.isUniform?null:S.texData.texShape,isUniform:S.isUniform,isPacked:S.isUniform?!1:S.texData.isPacked,flatOffset:null};return S.texData!=null&&S.texData.slice!=null&&S.texData.slice.flatOffset>0&&(I.flatOffset=S.texData.slice.flatOffset),{name:t.variableNames[C],shapeInfo:I}}),l=u.map(S=>S.shapeInfo),h={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},p=eX(u,h,s,t.packedInputs),m=n.createProgram(p),y=null,b=n.getUniformLocation(m,"NAN",!1);ft().getNumber("WEBGL_VERSION")===1&&(y=n.getUniformLocation(m,"INFINITY",!1));let x={};for(let S=0;S<t.variableNames.length;S++){let C=t.variableNames[S],I=!1;x[C]=n.getUniformLocation(m,C,I),x[`offset${C}`]=n.getUniformLocation(m,`offset${C}`,I)}return{program:t,source:p,webGLProgram:m,uniformLocations:x,inShapeInfos:l,outShapeInfo:h,infLoc:y,nanLoc:b}}function iD(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{let s=e.logicalShape,u=t[r],l=u.shape;if(!K(s,l))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${l} must match`);if(e.isUniform&&u.isUniform)return;let h=e.texShape,p=u.isUniform?null:u.texData.texShape;if(!K(h,p))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${h} and ${p} must match`)})}function t7(n,t,e,r,s){iD(t.inShapeInfos,e),iD([t.outShapeInfo],[r]);let u=r.texData.texture,l=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(u,l[0],l[1]):n.setOutputMatrixTexture(u,l[0],l[1]),n.setProgram(t.webGLProgram),ft().getNumber("WEBGL_VERSION")===1&&(t.infLoc!==null&&n.gl.uniform1f(t.infLoc,Infinity)),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((h,p)=>{let m=t.program.variableNames[p],y=t.uniformLocations[m],b=t.uniformLocations[`offset${m}`];if(y==null)return;if(h.isUniform){if(O(h.shape)<2)n.gl.uniform1f(y,h.uniformValues[0]);else{let x=h.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),n.gl.uniform1fv(y,x)}return}h.texData.slice!=null&&b!=null&&n.gl.uniform1i(b,h.texData.slice.flatOffset),n.setInputMatrixTexture(h.texData.texture,y,p)}),s!=null&&s(n,t.webGLProgram),n.executeProgram()}function e7(n,t,e){let r="";t.concat(e).forEach(l=>{let h=l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0,p=l.isUniform?"uniform":l.texData.texShape;r+=`${l.shape}_${p}_${h}`});let s=n.userCode,u=n.constructor.name;return u+="_"+r+"_"+s,u}class n7{constructor(t,e,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let{filterWidth:s,inChannels:u,strideWidth:l,strideHeight:h,padInfo:p,outWidth:m,dilationWidth:y,dilationHeight:b,dataFormat:x}=r,{left:S,top:C}=p,I=u*s,D=rr(),R=x==="channelsLast",A=R?0:1,L=R?1:2,_="";for(let B=0;B<=1;B++)for(let V=0;V<=1;V++)_+=`
          blockIndex = rc.y + ${V};
          pos = rc.x + ${B};

          if(blockIndex < ${t[1]} && pos < ${t[0]}) {
            offsetY = int(blockIndex / (${m})) * ${h} - ${C};
            d0 = offsetY + ${b} * (pos / ${I});

            if(d0 < ${e[A]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${m}.) * ${l}. - ${S}.);
              d1 = offsetX + ${y} * (int(mod(float(pos), ${I}.) / ${u}.));

              if(d1 < ${e[L]} && d1 >= 0) {

                ch = int(mod(float(pos), ${u}.));

                if (${R}) {
                  innerDims = vec2(d1, ch);
                  result[${B*2+V}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${B*2+V}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${_}

        ${D.output} = result;
      }
    `}}class r7{constructor(t,e,r,s,u){this.variableNames=["x"],this.outputShape=[];let l=e,h=t[3]-1;this.outputShape=t;let p,m=`float(${r}) + float(${s}) * sum`;u===.5?p=`inversesqrt(${m})`:u===1?p=`1.0/(${m})`:p=`exp(log(${m}) * float(-${u}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${l}; j <= ${l}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${h}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${p};
        setOutput(val);
      }
    `}}class s7{constructor(t,e,r,s,u){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=u,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${u})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${u});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}class o7{constructor(t,e,r,s,u){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let l=e,h=t[3]-1;this.outputShape=t;let p,m=`float(${r}) + float(${s}) * sum`;u===.5?p=`inversesqrt(${m})`:u===1?p=`1.0/(${m})`:p=`exp(log(${m}) * float(-${u}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${l};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${l}; j <= ${l}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${h}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${p};
        setOutput(result);
      }
    `}}class a7{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,h=u-1-t.padInfo.top,p=l-1-t.padInfo.left,m=u*l-1;this.userCode=`
      const ivec2 pads = ivec2(${h}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${m} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${l} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class i7{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,r=t.strideHeight,s=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=p-1-t.padInfo.front,x=m-1-t.padInfo.top,S=y-1-t.padInfo.left,C=p*m*y-1;this.userCode=`
      const ivec3 pads = ivec3(${b}, ${x}, ${S});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
           wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${C} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${m} * ${y} +
                  wR * ${y} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class cx{constructor(t,e,r,s=!1,u=!1,l=!1,h=null,p=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;let m=s?t[1]:t[2],y=Math.ceil(m/2),b=s?"i * 2, rc.y":"rc.y, i * 2",x=u?"rc.z, i * 2":"i * 2, rc.z",S=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],C=u?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],I="",D="";h&&(p?I=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${h}
        }`:I=`vec4 activation(vec4 x) {
          ${h}
        }`,D="result = activation(result);");let R=l?"result += getBiasAtOutCoords();":"";l&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights");let A="rc.x",L="rc.x";t[0]<e[0]?A=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(L=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${I}

      const float sharedDimension = ${y}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${y}; i++) {
          int batchA = ${A};
          int batchB = ${L};
          vec4 a = getMatrixA(batchA, ${b});
          vec4 b = getMatrixB(batchB, ${x});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${S[0]} * ${C[0]});
          result += (${S[1]} * ${C[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${R}

        ${D}

        setOutput(result);
      }
    `}}class u7{constructor(t,e,r){this.variableNames=["probs"],this.outputShape=[t,r],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}getCustomSetupFunc(t){return(e,r)=>{this.seedLoc==null&&(this.seedLoc=e.getUniformLocation(r,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}class c7{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}class l7{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;let e=t.length;if(e===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let r=nr("rc",e),s=We(e),u=f7(e,t,r),l=p7(e,t[t.length-1],t[t.length-2],r),h=d7(t,r);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${u}) {
            setOutput(vec4(0));
          } else {
            ${l}

            setOutput(vec4(${h}));
          }
        }
      `}}}function h7(n,t){let e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let u=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let l=2;l<n;l++)u=`${t[t.length-1-l]},`+u;e.push(u)}return e}function f7(n,t,e){if(n===1)return`rc > ${t[0]}`;let r="";for(let s=n-2;s<n;s++)r+=`${e[s]} >= ${t[s]}`,s<n-1&&(r+="||");return r}function p7(n,t,e,r){if(n===1)return"";let s=r.slice(-2);return`
    int r = ${s[0]};
    int c = ${s[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${t};
    bool rEdge = rp1 >= ${e};
  `}function d7(n,t){let e=n.length,r=h7(e,t);return e===1?`getA(rc),
            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${r[0]}),
          cEdge ? 0. : getA(${r[1]}),
          rEdge ? 0. : getA(${r[2]}),
          rEdge || cEdge ? 0. : getA(${r[3]})`}class m7{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((m,y)=>m[0]+t[y]+m[1]);let s=t.length,u=We(s),l=e.map(m=>m[0]).join(","),h=e.map((m,y)=>m[0]+t[y]).join(","),p=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${l};
        int end = ${h};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${r}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${u} start = ${u}(${l});
      ${u} end = ${u}(${h});

      void main() {
        ${u} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${r}));
        } else {
          ${u} coords = outC - start;
          setOutput(getX(${p}));
        }
      }
    `}}class g7{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((I,D)=>I[0]+t[D]+I[1]);let s=t.length,u=We(s),l=e.map(I=>I[0]).join(","),h=e.map((I,D)=>I[0]+t[D]).join(","),p=nr("rc",s),m=nr("source",s),y=`${p[s-1]} < ${this.outputShape[s-1]}`,b=s===1?"source":`vec2(${m.slice(-2).join()})`,x=[`${u} rc = outputLoc;`,`${p[s-1]} += 1;
       if(${y}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${p[s-2]} += 1;
       if(${p[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${p[s-1]} += 1;
         if(${y}) {`],S=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",C="";for(let I=0,D=s===1?2:4;I<D;I++)C+=`
        ${x[I]}
        if (${S}) {
          result[${I}] = float(${r});
        } else {
          ${u} source = rc - start;
          result[${I}] = getChannel(getX(${m.join()}), ${b});
        }
      `;C+=s===1?"} ":"}}",this.userCode=`
      const ${u} start = ${u}(${l});
      const ${u} end = ${u}(${h});

      void main() {
        ${u} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${C}
        setOutput(result);
      }
    `}}class xf{constructor(t,e,r,s=!1,u=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let l=t.filterWidth,h=t.strideHeight,p=t.strideWidth,m=t.dilationHeight,y=t.dilationWidth,b=t.effectiveFilterHeight,x=t.effectiveFilterWidth,S=t.padInfo.top,C=t.padInfo.left;this.outputShape=t.outShape;let I=e==="avg",D=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,R=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,A="0.0";if(I||(A="-1.0 / 1e-20"),r){let j=">=";this.userCode=`
        const ivec2 strides = ivec2(${h}, ${p});
        const ivec2 pads = ivec2(${S}, ${C});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${b};
              wR += ${m}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${x};
                wC += ${y}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${j} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?u?D:R:`wR * ${x} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let L="max",_=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(_="avgValue / count");let B=Math.floor(l/4)*4,V=l%4,q=`
      if (${I}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${L}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${h}, ${p});
      const ivec2 pads = ivec2(${S}, ${C});
      const float initializationValue = ${A};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${A});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${b};
            wR += ${m}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${B}; wC += 4) {
            int xC = xCCorner + wC * ${y};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${y}, d),
              getValue(batch, xR, xC + 2 * ${y}, d),
              getValue(batch, xR, xC + 3 * ${y}, d)
            );

            ${q}
          }

          int xC = xCCorner + ${B};
          if (${V===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${q}
          } else if (${V===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${y}, d),
              initializationValue,
              initializationValue
            );

            ${q}
          } else if (${V===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${y}, d),
              getValue(batch, xR, xC + 2 * ${y}, d),
              initializationValue
            );

            ${q}
          }
        }
        setOutput(${_});
      }
    `}}class lx{constructor(t,e,r,s=!1,u=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let l=t.filterWidth,h=t.strideDepth,p=t.strideHeight,m=t.strideWidth,y=t.dilationDepth,b=t.dilationHeight,x=t.dilationWidth,S=t.effectiveFilterDepth,C=t.effectiveFilterHeight,I=t.effectiveFilterWidth,D=t.padInfo.front,R=t.padInfo.top,A=t.padInfo.left;this.outputShape=t.outShape;let L=e==="avg",_="0.0";if(L||(_="-1.0 / 1e-20"),r){let tt=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${h}, ${p}, ${m});
        const ivec3 pads = ivec3(${D}, ${R}, ${A});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${S};
              wD += ${y}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${C};
                wR += ${b}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${I};
                  wC += ${x}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${tt} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?u?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${C} * ${I} +
                      wR * ${I} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let B="max",V=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(V="avgValue / count");let q=Math.floor(l/4)*4,j=l%4,et=`
      if (${L}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${B}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${h}, ${p}, ${m});
      const ivec3 pads = ivec3(${D}, ${R}, ${A});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${S};
            wD += ${y}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${C};
            wR += ${b}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${q}; wC += 4) {
              int xC = xCCorner + wC * ${x};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${x}, ch),
                getValue(batch, xD, xR, xC + 2 * ${x}, ch),
                getValue(batch, xD, xR, xC + 3 * ${x}, ch)
              );

              ${et}
            }

            int xC = xCCorner + ${q};
            if (${j===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${et}
            } else if (${j===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${x}, ch),
                initializationValue,
                initializationValue
              );

              ${et}
            } else if (${j===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${x}, ch),
                getValue(batch, xD, xR, xC + 2 * ${x}, ch),
                initializationValue
              );

              ${et}
            }
          }
          setOutput(${V});
        }
      }
    `}}class uD{constructor(t,e){this.variableNames=["x"];let{windowSize:r,batchSize:s,inSize:u,outSize:l}=t;this.outputShape=[s,l];let h="0.0",p="";e==="prod"?h="1.0":e==="min"?(h="1.0 / 1e-20",p="min"):e==="max"&&(h="-1.0 / 1e-20",p="max");let m=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?m="sumValue":e==="prod"?m="prodValue":e==="all"?m="allValue":e==="any"&&(m="anyValue");let y=Math.floor(r/4)*4,b=r%4,x=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${p}(values, minMaxValue);
      }
    `,S="vec4";e==="all"?(h="1.0",x=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,S="bvec4"):e==="any"&&(h="0.0",x=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,S="bvec4");let C="";u%r>0&&(C=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${h};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${C}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${h});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${y}; i += 4) {
          int inIdx = inOffset + i;
          ${S} values = ${S}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${x}
        }

        int inIdx = inOffset + ${y};
        if (${b===1}) {
          ${S} values = ${S}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${x}
        } else if (${b===2}) {
          ${S} values = ${S}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${x}
        } else if (${b===3}) {
          ${S} values = ${S}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${x}
        }
        setOutput(${m});
      }
    `}}class cD{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let r="";for(let s=0;s<4;s++){let u="thisRC = rc;";s%2===1&&(u+="thisRC.z += 1;"),s>1&&(u+="thisRC.y += 1;"),r+=`
        ${u}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${v7(e)}
      ${ux(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${t[1]};
        int cols = ${t[2]};

        ${r}

        setOutput(result);
      }
    `}}function v7(n){let t=$i(["r","c","d"],n);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t}
      return ivec3(r, c, d);
    }
  `}class y7{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;let[,s,u]=e.shape,[,l,h]=t.shape,p=[r&&l>1?s-1:s,r&&h>1?u-1:u],m=[r&&l>1?l-1:l,r&&h>1?h-1:h],y=p[0]/m[0],b=p[1]/m[1],x=1/y,S=1/b,C=Math.ceil(x)*2+2,I=Math.ceil(S)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${y});
        const float widthScale = float(${b});

        const float invHeightScale = float(${x});
        const float invWidthScale = float(${S});

        const int winHeight = int(${C});
        const int winWidth = int(${I});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${l}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${h}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${u-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}class b7{constructor(t,e,r,s){this.variableNames=["A"],this.outputShape=[];let[u,l,h,p]=t;this.outputShape=[u,e,r,p];let m=[s&&e>1?l-1:l,s&&r>1?h-1:h],y=[s&&e>1?e-1:e,s&&r>1?r-1:r];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${m[0]/y[0]},
          ${m[1]/y[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${h}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class w7{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[u,l,h,p]=t;this.outputShape=[u,e,r,p];let m=[s&&e>1?l-1:l,s&&r>1?h-1:h],y=[s&&e>1?e-1:e,s&&r>1?r-1:r];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${m[0]/y[0]},
          ${m[1]/y[1]},
          ${m[1]/y[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${h}.0,
                                     ${h}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${p-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}class x7{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e.shape;let[,s,u]=e.shape,[,l,h]=t.shape,p=[r&&l>1?s-1:s,r&&h>1?u-1:u],m=[r&&l>1?l-1:l,r&&h>1?h-1:h],y=p[0]/m[0],b=p[1]/m[1],x=1/y,S=1/b,C=Math.ceil(x)*2+2,I=Math.ceil(S)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${y});
        const float widthScale = float(${b});

        const float invHeightScale = float(${x});
        const float invWidthScale = float(${S});

        const int winHeight = int(${C});
        const int winWidth = int(${I});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${l}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${h}) {
              continue;
            }

            float sourceFracRow =
              float(${p[0]}) *
                (float(dyR) / float(${m[0]}));

            float sourceFracCol =
                float(${p[1]}) *
                  (float(dyC) / float(${m[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${u}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}class T7{constructor(t,e,r,s){this.variableNames=["A"],this.outputShape=[];let[u,l,h,p]=t;this.outputShape=[u,e,r,p];let m=[s&&e>1?l-1:l,s&&r>1?h-1:h],y=[s&&e>1?e-1:e,s&&r>1?r-1:r],b=s?"0.5":"0.0";this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${m[0]/y[0]},
          ${m[1]/y[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${h}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${b})));

        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class k7{constructor(t,e){this.variableNames=["x"];let r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let s=h=>e.indexOf(h)!==-1&&t[h]!==1?`${t[h]} - coords[${h}] - 1`:`coords[${h}]`,u=t.map((h,p)=>s(p)).join(","),l=We(r);this.userCode=`
      void main() {
        ${l} coords = getOutputCoords();
        setOutput(getX(${u}));
      }
    `}}class S7{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;let s=nr("rc",r),u=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,l=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,h=We(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${u}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${h} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${p(s.slice())};
          if(${u}){
            result.g = ${m(s.slice())};
          }
          if(${l}) {
            result.b = ${y(s.slice())};
            if(${u}) {
              result.a = ${b(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function p(C){return x(C)}function m(C){return C[r-1]="("+C[r-1]+" + 1)",x(C)}function y(C){return C[r-2]="("+C[r-2]+" + 1)",x(C)}function b(C){return C[r-1]="("+C[r-1]+" + 1)",C[r-2]="("+C[r-2]+" + 1)",x(C)}function x(C){let I=t.map((A,L)=>S(L,C)),D=I.join(","),R=I.slice(-2).join(",");return`getChannel(getX(${D}), vec2(${R}))`}function S(C,I){return e.indexOf(C)!==-1&&t[C]!==1?`${t[C]} - ${I[C]} - 1`:`${I[C]}`}}}class lD{constructor(t,e,r,s,u,l,h=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=l;let p=We(u.length),m=We(l.length),y="";r===1?y="i":r===2&&(y="i, j");let b=`getIndices(${y})`,x="";s===1?x="i":s===2&&(x="i, coords[1]");let S=`getUpdates(${x})`,C=e>1?"strides[j]":"strides";this.userCode=`
        ${p} strides = ${p}(${u});

        void main() {
          ${m} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${b});
              flattenedIndex += index * ${C};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${S};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}class C7{constructor(t,e){this.variableNames=["x","segmentIds"];let r=t.windowSize,s=t.batchSize,u=t.inSize,l=t.numSegments,h=l*Math.ceil(u/r);this.outputShape=[s,h];let p="0.0",m="sumValue",y=Math.floor(r/4)*4,b=r%4,x=`
        sumValue += dot(values, segFilter);
    `,S="";u%r>0&&(S=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return initializationValue;
        }
      `);let C="";u%r>0&&(C=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${p};

      float getValue(int batch, int inIdx) {
        ${S}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${C}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${l})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${l})));

        float sumValue = 0.0;

        for (int i = 0; i < ${y}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${x}
        }

        int inIdx = inOffset + ${y};
        if (${b===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${x}
        } else if (${b===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${x}
        } else if (${b===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${x}
        }
        setOutput(${m});
      }
    `}}class N7{constructor(t,e,r){this.variableNames=["c","a","b"],this.outputShape=e;let s,u;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)u="resRC",s="resRC";else{let h=["resRC.x","resRC.y","resRC.z","resRC.w"],p=[],m=[];for(let y=0;y<e.length;y++)m.push(`${h[y]}`),y<t&&p.push(`${h[y]}`);s=p.join(),u=m.join()}let l=We(r);this.userCode=`
      void main() {
        ${l} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${u}));
        } else {
          setOutput(getB(${u}));
        }
      }
    `}}class I7{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=We(this.rank),r=`uniform int start[${this.rank}];`,s=E7(this.rank),u,l=t.map((h,p)=>`sourceLoc.${hx[p]} = start[${p}] + coords.${hx[p]};`);u=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${l.join(`
`)}
      `,this.userCode=`
      ${r}
      void main() {
        ${u}
        setOutput(getSource(${s}));
      }
    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,r)=>{if(this.startLoc==null&&(this.startLoc=e.getUniformLocationNoThrow(r,"start"),this.startLoc==null))return;e.gl.uniform1iv(this.startLoc,t)}}}let hx=["x","y","z","w","u","v"];function E7(n){if(n===1)return"sourceLoc";if(n<=6)return hx.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class D7{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;let e=We(this.rank),r=nr("coords",this.rank),s=nr("sourceLoc",this.rank),u=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,l=`getChannel(getSource(${s.join()}), ${u})`,h=`
      result.x = ${l};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${l};
        --${s[this.rank-1]};
      }
    `,p=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${l};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${l};
        }
      }
    `,m=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((y,b)=>`start[${b}]`).join()});`:t.map((y,b)=>`${s[b]} = ${r[b]} + start[${b}];`).join(`
`);this.userCode=`
      uniform int start[${this.rank}];
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${m}
        vec4 result = vec4(0.);
        ${h}
        ${p}
        setOutput(result);
      }
    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,r)=>{if(this.startLoc==null&&(this.startLoc=e.getUniformLocationNoThrow(r,"start"),this.startLoc==null))return;e.gl.uniform1iv(this.startLoc,t)}}}class $7{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;let s=r.length,u=We(r.length),l=We(r.length),h="";if(s===1)h="coords * strides + begin";else{let p=0;h=r.map((m,y)=>(p++,r.length===1?`coords * strides[${y}] + begin[${y}]`:`coords[${p-1}] * strides[${y}] + begin[${y}]`)).join(",")}this.userCode=`
      ${u} begin = ${u}(${t});
      ${u} strides = ${u}(${e});

      void main() {
        ${l} coords = getOutputCoords();
        setOutput(getX(${h}));
      }
    `}}class A7{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,r){let s=fD(e,r),u=pD(t,s,r);u in this.freeTextures||(this.freeTextures[u]=[]),u in this.usedTextures||(this.usedTextures[u]=[]);let l=hD(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[u].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=l,this.log();let p=this.freeTextures[u].shift();return this.usedTextures[u].push(p),p}let h;return s===Vn.PACKED_2X2_FLOAT32?h=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Vn.PACKED_2X2_FLOAT16?h=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Vn.UNPACKED_FLOAT32?h=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Vn.UNPACKED_FLOAT16?h=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Vn.PACKED_4X1_UNSIGNED_BYTE&&(h=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[u].push(h),this.numUsedTextures++,this._numBytesAllocated+=l,this.log(),h}releaseTexture(t,e,r,s){if(this.freeTextures==null)return;let u=fD(r,s),l=pD(e,u,s);l in this.freeTextures||(this.freeTextures[l]=[]);let h=hD(e,u,this.gpgpu.gl,this.gpgpu.textureConfig,s),p=ft().get("WEBGL_DELETE_TEXTURE_THRESHOLD");p!==-1&&this._numBytesAllocated>p?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=h):(this.freeTextures[l].push(t),this.numFreeTextures++,this._numBytesFree+=h),this.numUsedTextures--;let m=this.usedTextures[l],y=m.indexOf(t);if(y<0)throw new Error("Cannot release a texture that was never provided by this texture manager");m.splice(y,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures==null)return;for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}function _7(n,t){let e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}function hD(n,t,e,r,s){let u=F7(t,r),l;if(s){let[p,m]=ic(n[0],n[1]);l=p*m}else{let[p,m]=vf(n[0],n[1]);l=p*m}let h=_7(e,u);return l*h}function F7(n,t){switch(n){case Vn.PACKED_2X2_FLOAT32:return oD(t);case Vn.PACKED_2X2_FLOAT16:return aD(t);case Vn.UNPACKED_FLOAT32:return nD(t);case Vn.UNPACKED_FLOAT16:return rD(t);case Vn.PACKED_4X1_UNSIGNED_BYTE:return sD(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function R7(n){return ft().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Vn.PACKED_2X2_FLOAT32:Vn.UNPACKED_FLOAT32:n?Vn.PACKED_2X2_FLOAT16:Vn.UNPACKED_FLOAT16}function fD(n,t){if(n===Hr.UPLOAD)return Vn.PACKED_2X2_FLOAT32;if(n===Hr.RENDER||n==null)return R7(t);if(n===Hr.DOWNLOAD||n===Hr.PIXELS)return Vn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function pD(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class P7{constructor(t,e){this.variableNames=["A"];let r=new Array(t.length);for(let l=0;l<r.length;l++)r[l]=t[l]*e[l];this.outputShape=r,this.rank=r.length;let s=We(this.rank),u=O7(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${u}));
      }
    `}}function O7(n){let t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}class ye{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}let _o="if (isnan(x)) return x;",M7="return x;",dD="return abs(x);",mD=_o+`
  return (x < 0.0) ? 0.0 : x;
`,gD=_o+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,vD="return (x >= 0.0) ? x : (exp(x) - 1.0);",L7=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${qd};
  float scale = ${jd};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;function B7(n=0){return _o+`
    return x > 0.0 ? 1.0 : float(${n});
  `}let yD="return -x;",bD="return ceil(x);",wD="return floor(x);",z7=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,W7="return float(isnan(x));",V7="return float(isinf(x));",U7="return float(!isnan(x) && !isinf(x));",G7=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,xD="return exp(x);",TD="return exp(x) - 1.0;",H7=`if (x < 0.0) return NAN;
  return log(x);`,q7="return log(1.0 + x);",j7="return sqrt(x);",K7="return inversesqrt(x);",X7="return 1.0 / (1.0 + exp(-1.0 * x));",Y7=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,J7=_o+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Z7=_o+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Q7=_o+`
  return atan(x);
`,tJ=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,eJ=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,nJ=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,rJ=_o+"return log(x + sqrt(x * x + 1.0));",sJ=_o+`
  if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`,oJ=_o+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,aJ=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${zb};
  float a1 = ${Wb};
  float a2 = ${Vb};
  float a3 = ${Ub};
  float a4 = ${Gb};
  float a5 = ${Hb};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,iJ="return 1.0 / x;",uJ="return float(!(x >= 1.0));",Hm="return x;";let cJ="return x;",lJ=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,kD=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,SD=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,CD=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`;class Tf{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class hJ{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;let e=t.length,r=nr("rc",e),s=We(e),u=tX(e,r),l=r.slice(-2),h=e<=1?"rc":`vec2(${l.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${u});

        setOutput(getChannel(packedInput, ${h}));
      }
    `}}let{segment_util:ND}=Kb,fJ=Xb,pJ=Yb,dJ=Jb,mJ=Pd,gJ=1e-7,vJ=1e-4,qm={};function yJ(n){return n in qm||(qm[n]={}),qm[n]}function jm(n,t=!1){if(n==="linear")return t?cJ:M7;if(n==="relu")return t?kD:mD;if(n==="elu")return t?CD:vD;if(n==="relu6")return t?SD:gD;if(n==="prelu")return t?XE:KE;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}let bJ=128,wJ=600;function xJ(){return ft().global.screen==null?1024:ft().global.screen.height*ft().global.screen.width*window.devicePixelRatio*wJ/1024/1024}let ID=1e3;class TJ extends f{constructor(t){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!ft().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(t==null){let e=eo(ft().getNumber("WEBGL_VERSION"));this.binaryCache=yJ(ft().getNumber("WEBGL_VERSION")),this.gpgpu=new JY(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;this.textureManager=new A7(this.gpgpu),this.numMBBeforeWarning=xJ(),this.texData=new c(this,yo())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,r){if((ft().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ft().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={};return this.texData.set(s,{shape:e,dtype:r,values:t,usage:Hr.UPLOAD,refCount:1,complexParentRefCount:0}),s}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}move(t,e,r,s){if(ft().getBool("DEBUG")&&this.checkNumericalProblems(e),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:e,usage:Hr.UPLOAD,refCount:1,complexParentRefCount:0})}disposeIntermediateTensorInfo(t){let e=t.dataId;if(this.texData.has(e)){let r=this.texData.get(e);r.refCount--,r.refCount<1&&this.disposeData(e)}}readSync(t){let e=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:u,slice:l,shape:h,isPacked:p}=e;if(l!=null){let x;p?x=new Tf(h,Hm):x=new ye(h,Hm);let S=this.runWebGLProgram(x,[{dataId:t,shape:h,dtype:s}],s),C=this.readSync(S.dataId);return this.disposeIntermediateTensorInfo(S),C}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;let m=this.activeTimers!=null,y;m&&(y=cr());let b;if(s==="complex64"){let x=this.readSync(u.real.dataId),S=this.readSync(u.imag.dataId);b=So(x,S)}else b=this.getValuesFromTexture(t);return m&&(this.downloadWaitMs+=cr()-y),this.convertAndCacheOnCPU(t,b)}async read(t){if(this.pendingRead.has(t)){let C=this.pendingRead.get(t);return new Promise(I=>C.push(I))}let e=this.texData.get(t),{values:r,shape:s,slice:u,dtype:l,complexTensorInfos:h,isPacked:p}=e;if(u!=null){let C;p?C=new Tf(s,Hm):C=new ye(s,Hm);let I=this.runWebGLProgram(C,[{dataId:t,shape:s,dtype:l}],l),D=this.read(I.dataId);return this.disposeIntermediateTensorInfo(I),D}if(r!=null)return this.convertAndCacheOnCPU(t);if(!ft().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ft().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let m=null,y;if(l!=="complex64"&&ft().get("WEBGL_BUFFER_SUPPORTED")){y=this.decode(t);let C=this.texData.get(y.dataId);m=this.gpgpu.createBufferFromTexture(C.texture,...yf(s))}this.pendingRead.set(t,[]),l!=="complex64"&&await this.gpgpu.createAndWaitForFence();let b;if(l==="complex64"){let C=await Promise.all([this.read(h.real.dataId),this.read(h.imag.dataId)]),I=C[0],D=C[1];b=So(I,D)}else if(m==null)b=this.getValuesFromTexture(t);else{let C=O(s);b=this.gpgpu.downloadFloat32MatrixFromBuffer(m,C)}y!=null&&this.disposeIntermediateTensorInfo(y);let x=this.convertAndCacheOnCPU(t,b),S=this.pendingRead.get(t);return this.pendingRead.delete(t),S.forEach(C=>C(x)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),x}checkNumericalProblems(t){if(t==null)return;for(let e=0;e<t.length;e++){let r=t[e];if(!f8(r))throw ft().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:r,isPacked:s}=this.texData.get(t),u=O(e);if(ft().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let x=this.decode(t),S=this.texData.get(x.dataId),C=this.gpgpu.downloadMatrixFromPackedTexture(S.texture,...yf(e)).subarray(0,u);return this.disposeIntermediateTensorInfo(x),C}let l=ft().getBool("WEBGL_PACK")&&s===!0,h=l?ox(e):e,p=l?new EY(h):new IY(h),m=this.runWebGLProgram(p,[{shape:h,dtype:r,dataId:t}],"float32"),y=this.texData.get(m.dataId),b=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(y.texture,y.texShape[0],y.texShape[1]).subarray(0,u);return this.disposeIntermediateTensorInfo(m),b}async time(t){let e=this.activeTimers,r=[],s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();let u=G(this.activeTimers.map(p=>p.query)).filter(p=>p!=null),l=G(this.activeTimers.map(p=>p.name)).filter(p=>p!=null);this.activeTimers=e,s&&(this.programTimersStack=null);let h={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let p=await Promise.all(u);h.kernelMs=T(p),h.getExtraProfileInfo=()=>p.map((m,y)=>({name:l[y],ms:m})).map(m=>`${m.name}: ${m.ms}`).join(", ")}else h.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,h}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:cr(),endMs:null}}endTimer(t){return ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=cr(),t)}async getQueryTime(t){if(ft().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t)){this.pendingDisposal.add(t),this.pendingDeletes++;return}if(!this.texData.has(t))return;if(this.texData.get(t).complexParentRefCount>0){this.texData.get(t).refCount--;return}this.releaseGPUData(t);let{complexTensorInfos:e}=this.texData.get(t);e!=null&&(this.texData.get(e.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(e.real),this.texData.get(e.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(e.imag)),this.texData.delete(t)}releaseGPUData(t){let{texture:e,dtype:r,texShape:s,usage:u,isPacked:l,slice:h}=this.texData.get(t),p=h&&h.origDataId||t,m=this.dataRefCount.get(p);m>1?this.dataRefCount.set(p,m-1):(this.dataRefCount.delete(p),e!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(e,s,u,l)));let y=this.texData.get(t);y.texture=null,y.texShape=null,y.isPacked=!1,y.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return ft().getBool("WEBGL_CPU_FORWARD")?(this.cpuBackend==null&&(this.cpuBackend=yo().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=bJ){let r=this.getCPUBackend();return!this.warnedAboutCPUBackend&&r==null&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),r!=null&&t.every(s=>this.texData.get(s.dataId).texture==null&&O(s.shape)<e)}getGPGPUContext(){return this.gpgpu}slice(t,e,r){if(this.shouldExecuteOnCPU([t])){let l=K8(this.texData.get(t.dataId).values,e,r,t.shape,t.dtype);return this.makeOutput(r,t.dtype,l)}if(O(r)===0)return vn([],r,t.dtype);let{isPacked:s}=this.texData.get(t.dataId),u=zy(t.shape,e,r);if(s||!u){let l=ft().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new D7(r):new I7(r),h=l.getCustomSetupFunc(e);return this.compileAndRun(l,[t],null,h)}return this.uploadToGPU(t.dataId),this.shallowSlice(t,e,r)}shallowSlice(t,e,r){let s=this.texData.get(t.dataId),u=this.makeOutput(r,t.dtype),l=this.texData.get(u.dataId);Object.assign(l,s),l.shape=r,l.dtype=t.dtype;let h=Wy(e,t.strides);s.slice&&(h+=s.slice.flatOffset),l.slice={flatOffset:h,origDataId:s.slice&&s.slice.origDataId||t.dataId};let p=this.dataRefCount.get(l.slice.origDataId)||1;return this.dataRefCount.set(l.slice.origDataId,p+1),u}stridedSlice(t,e,r,s){let u=this.tryRunOnCpuOrThrow([t],()=>this.cpuBackend.stridedSlice(t,e,r,s));if(u)return u;let l=sd(e,r,s);if(l.some(p=>p===0))return vn([],l);let h=new $7(e,s,l);return this.compileAndRun(h,[t])}reverse(t,e){let r=ft().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new S7(t.shape,e):new k7(t.shape,e);return this.compileAndRun(r,[t])}neg(t){let e=this.tryRunOnCpuOrThrow([t],()=>this.cpuBackend.neg(t));if(e)return e;if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,yD,t.dtype);let r=new ye(t.shape,yD);return this.compileAndRun(r,[t])}batchMatMul(t,e,r,s){let u=r?t.shape[2]:t.shape[1],l=s?e.shape[1]:e.shape[2],h=r?t.shape[1]:t.shape[2],p=Math.max(t.shape[0],e.shape[0]);if((u===1||l===1)&&h>ID){r&&(t=re(t,[0,2,1])),s&&(e=re(e,[0,2,1]));let b=l===1?t:t.as3D(p,h,1),x=l===1?2:1,S=l===1?e.as3D(p,1,h):e,C=st(b,S);return C.sum(x,!0)}let m=Qn(t.dtype,e.dtype),y=new cx(t.shape,e.shape,[p,u,l],r,s);return this.compileAndRun(y,[t,e],m)}fusedBatchMatMul({a:t,b:e,transposeA:r,transposeB:s,bias:u,activation:l,preluActivationWeights:h}){let p=r?t.shape[2]:t.shape[1],m=s?e.shape[1]:e.shape[2],y=Math.max(t.shape[0],e.shape[0]),b=Qn(t.dtype,e.dtype),x=u!=null,S=h!=null,C=l?jm(l,!0):null,I=new cx(t.shape,e.shape,[y,p,m],r,s,x,C,S),D=[t,e];return u&&D.push(u),h&&D.push(h),this.compileAndRun(I,D,b)}localResponseNormalization4D(t,e,r,s,u){let l=ft().getBool("WEBGL_PACK_NORMALIZATION")?new o7(t.shape,e,r,s,u):new r7(t.shape,e,r,s,u);return this.compileAndRun(l,[t])}LRNGrad(t,e,r,s,u,l,h){let p=new s7(e.shape,s,u,l,h);return this.compileAndRun(p,[e,r,t])}tile(t,e){if(t.dtype==="string"){let s=this.readSync(t.dataId),u=s.map(h=>rh(h)),l=Ae(t.shape,t.dtype,u);return pJ(l,e)}let r=new P7(t.shape,e);return this.compileAndRun(r,[t])}pad(t,e,r){let s=ft().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new g7(t.shape,e,r):new m7(t.shape,e,r);return this.compileAndRun(s,[t])}gather(t,e,r){let s=this.tryRunOnCpuOrThrow([t,e],()=>this.cpuBackend.gather(t,e,r));if(s)return s;let u=new _Y(t.shape,e.size,r);return this.compileAndRun(u,[t,e])}batchToSpaceND(t,e,r){k(t.rank<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let s=e.reduce((y,b)=>y*b),u=Mh(t.shape,e,s),l=Lh(u.length,e.length),h=Bh(t.shape,e,s),p=Lb(r,e.length),m=Bb(h,r,e.length);return re(t.reshape(u),l).reshape(h).slice(p,m)}spaceToBatchND(t,e,r){k(t.rank<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let s=e.reduce((b,x)=>b*x),u=[[0,0]];u.push(...r);for(let b=1+e.length;b<t.shape.length;++b)u.push([0,0]);let l=t.pad(u),h=Mh(l.shape,e,s,!1),p=Lh(h.length,e.length,!1),m=Bh(l.shape,e,s,!1),y=re(l.reshape(h),p);return rt(y,m)}reduce(t,e,r){let s=t.shape[0],u=t.shape[1],l=yh(u),h=Math.ceil(u/l),p={windowSize:l,inSize:u,batchSize:s,outSize:h},m=new uD(p,e),y=this.compileAndRun(m,[t],r);return y.shape[1]===1?y:this.reduce(y,e,r)}argReduce(t,e,r=null){let s=t.shape[0],u=t.shape[1];r!=null&&(s=r.shape[0],u=r.shape[1]);let l=yh(u),h={windowSize:l,inSize:u,batchSize:s,outSize:Math.ceil(u/l)},p=new Q8(h,e,r==null),m=[t];r!=null&&m.push(r);let y=this.compileAndRun(p,m,"int32");return y.shape[1]===1?y:this.argReduce(t,e,y)}argReducePacked(t,e,r=null){let s=r!=null?r.shape:t.shape,u=s[s.length-1],l=yh(u),h=new MX(s,l,e,r==null),p=r==null?[t]:[t,r],m=this.compileAndRun(h,p,"int32");return m.rank===t.rank?this.argReducePacked(t,e,m):m}sum(t,e){lr("sum",e,t.rank);let[r,s]=Bn(t.shape,e),u=O(s),l=t.as2D(-1,u),h=Kp(t.dtype);return this.reduce(l,"sum",h).reshape(r)}prod(t,e){let r=this.tryRunOnCpuOrThrow([t],()=>this.cpuBackend.prod(t,e));if(r)return r;let[s,u]=Bn(t.shape,e),l=O(u),h=t.as2D(-1,l),p=Kp(t.dtype);return this.reduce(h,"prod",p).reshape(s)}unsortedSegmentSum(t,e,r){let s=0,u=hr([s],t.rank),l=t;u!=null&&(l=re(t,u),s=Cr(1,t.rank)[0]);let h=ND.computeOutShape(l.shape,s,r),p=O([l.shape[s]]),m=l.as2D(-1,p),y=Kp(t.dtype),b=this.segOpCompute(m,"unsortedSegmentSum",e,y,r).reshape(h);return u!=null&&(b=re(b,lh(u))),b}segOpCompute(t,e,r,s,u){let l=t.shape[0],h=t.shape[1],p=ND.segOpComputeOptimalWindowSize(h,u),m={windowSize:p,inSize:h,batchSize:l,numSegments:u},y=new C7(m,e),b=this.compileAndRun(y,[t,r],s);return b.shape[1]===u?b:(r=Ch(0,u).tile([h/p]),this.segOpCompute(b,e,r,s,u))}argMinMaxReduce(t,e,r){let s=[e];if(lr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.rank),!ft().getBool("WEBGL_PACK_REDUCE")||t.rank<=2){let[u,l]=Bn(t.shape,s),h=O(l),p=t.as2D(-1,h);return this.argReduce(p,r).reshape(u)}return this.argReducePacked(t,r)}argMin(t,e){return this.argMinMaxReduce(t,e,"min")}argMax(t,e){return this.argMinMaxReduce(t,e,"max")}cumsum(t,e,r,s){if(e!==t.rank-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${t.rank-1} but got axis=${e}`);let u=t.shape[e],l=t;for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){let p=new QE(t.shape,!1,s),m=p.getCustomSetupFunc(h),y=l;l=this.compileAndRun(p,[l],l.dtype,m),y.dispose()}if(r){let h=new QE(t.shape,r,s),p=l;l=this.compileAndRun(h,[l]),p.dispose()}return l}equal(t,e){if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,nY,"bool");let r=new Yn(VX,t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}less(t,e){let r=this.tryRunOnCpuOrThrow([t,e],()=>this.cpuBackend.less(t,e));if(r)return r;if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,rY,"bool");let s=new Yn(UX,t.shape,e.shape);return this.compileAndRun(s,[t,e],"bool")}lessEqual(t,e){if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,sY,"bool");let r=new Yn(GX,t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}greater(t,e){let r=this.tryRunOnCpuOrThrow([t,e],()=>this.cpuBackend.greater(t,e));if(r)return r;if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,oY,"bool");let s=new Yn(HX,t.shape,e.shape);return this.compileAndRun(s,[t,e],"bool")}greaterEqual(t,e){if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,aY,"bool");let r=new Yn(qX,t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}logicalNot(t){let e=new ye(t.shape,uJ);return this.compileAndRun(e,[t])}logicalAnd(t,e){if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,iY,"bool");let r=new Yn(jX,t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}logicalOr(t,e){if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,uY,"bool");let r=new Yn(KX,t.shape,e.shape);return this.compileAndRun(r,[t,e],"bool")}select(t,e,r){let s=new N7(t.rank,e.shape,e.rank);return this.compileAndRun(s,[t,e,r],Qn(e.dtype,r.dtype))}where(t){Gu("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return mJ(t.shape,e)}topk(t,e,r){let s=t.dataSync();return dJ(s,t.shape,t.dtype,e,r)}min(t,e){lr("min",e,t.rank);let[r,s]=Bn(t.shape,e),u=O(s),l=t.as2D(-1,u);return this.reduce(l,"min",l.dtype).reshape(r)}minimum(t,e){let r=this.tryRunOnCpuOrThrow([t,e],()=>this.cpuBackend.minimum(t,e));if(r)return r;let s=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ao(lY,t.shape,e.shape):new Yn(YX,t.shape,e.shape);return this.compileAndRun(s,[t,e])}mod(t,e){let r=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ao(hY,t.shape,e.shape):new Yn(JX,t.shape,e.shape);return this.compileAndRun(r,[t,e])}maximum(t,e){let r=this.tryRunOnCpuOrThrow([t,e],()=>this.cpuBackend.maximum(t,e));if(r)return r;let s=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ao(cY,t.shape,e.shape):new Yn(XX,t.shape,e.shape);return this.compileAndRun(s,[t,e])}all(t,e){lr("all",e,t.rank);let[r,s]=Bn(t.shape,e),u=O(s),l=t.as2D(-1,u);return this.reduce(l,"all",l.dtype).reshape(r)}any(t,e){lr("any",e,t.rank);let[r,s]=Bn(t.shape,e),u=O(s),l=t.as2D(-1,u);return this.reduce(l,"any",l.dtype).reshape(r)}floorDiv(t,e){let r=zX,s="int32";if(ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(t,e,QX,s);let u=new Yn(r,t.shape,e.shape);return this.compileAndRun(u,[t,e],s)}packedUnaryOp(t,e,r){let s=new Tf(t.shape,e);return this.compileAndRun(s,[t],r)}packedBinaryOp(t,e,r,s,u=!1){let l=new Ao(r,t.shape,e.shape,u);return this.compileAndRun(l,[t,e],s)}makeComplexComponentTensorInfo(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}addN(t){if(t.length===1)return t[0];if(t.length>ft().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(t.length/2),h=this.addN(t.slice(0,l)),p=this.addN(t.slice(l));return this.addN([h,p])}let e=t.map(l=>l.dtype).reduce((l,h)=>Qn(l,h)),r=t.map(l=>l.shape),s=ft().getBool("WEBGL_PACK"),u=s?new Z8(t[0].shape,r):new J8(t[0].shape,r);return this.compileAndRun(u,t,e)}pow(t,e){let r=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS"),s=r?new Ao(tY,t.shape,e.shape):new Yn(WX,t.shape,e.shape),u=Qn(t.dtype,e.dtype);return this.compileAndRun(s,[t,e],u)}ceil(t){if(this.shouldExecuteOnCPU([t])){let r=z8(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,r)}if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,bD,t.dtype);let e=new ye(t.shape,bD);return this.compileAndRun(e,[t])}floor(t){if(this.shouldExecuteOnCPU([t])){let r=U8(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,r)}if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,wD,t.dtype);let e=new ye(t.shape,wD);return this.compileAndRun(e,[t])}sign(t){let e=new ye(t.shape,z7);return this.compileAndRun(e,[t])}isNaN(t){let e=new ye(t.shape,W7);return this.compileAndRun(e,[t],"bool")}isInf(t){let e=new ye(t.shape,V7);return this.compileAndRun(e,[t],"bool")}isFinite(t){let e=new ye(t.shape,U7);return this.compileAndRun(e,[t],"bool")}round(t){let e=new ye(t.shape,G7);return this.compileAndRun(e,[t])}exp(t){if(this.shouldExecuteOnCPU([t])){let r=W8(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,r)}if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,xD,t.dtype);let e=new ye(t.shape,xD);return this.compileAndRun(e,[t])}expm1(t){if(this.shouldExecuteOnCPU([t])){let r=V8(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,r)}if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,TD,t.dtype);let e=new ye(t.shape,TD);return this.compileAndRun(e,[t])}softmax(t,e){let r=Et([e],t.shape),s=dr(t,r),u=zn(s.shape,r),l=Mt(t,s.reshape(u)),h=this.exp(l),p=this.sum(h,r).reshape(u);return Ht(h,p)}log(t){if(this.shouldExecuteOnCPU([t])){let r=G8(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,r)}if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,lJ,t.dtype);let e=new ye(t.shape,H7);return this.compileAndRun(e,[t])}log1p(t){let e=new ye(t.shape,q7);return this.compileAndRun(e,[t])}sqrt(t){let e=new ye(t.shape,j7);return this.compileAndRun(e,[t])}rsqrt(t){if(this.shouldExecuteOnCPU([t])){let r=j8(this.texData.get(t.dataId).values,t.dtype);return this.makeOutput(t.shape,t.dtype,r)}let e=new ye(t.shape,K7);return this.compileAndRun(e,[t])}reciprocal(t){let e=new ye(t.shape,iJ);return this.compileAndRun(e,[t])}relu(t){let e;return ft().getBool("WEBGL_PACK")?e=new Tf(t.shape,kD):e=new ye(t.shape,mD),this.compileAndRun(e,[t])}relu6(t){let e;return ft().getBool("WEBGL_PACK")?e=new Tf(t.shape,SD):e=new ye(t.shape,gD),this.compileAndRun(e,[t])}prelu(t,e){let r=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ao(XE,t.shape,e.shape):new Yn(KE,t.shape,e.shape);return this.compileAndRun(r,[t,e])}elu(t){if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,CD,t.dtype);let e=new ye(t.shape,vD);return this.compileAndRun(e,[t])}eluDer(t,e){let r=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ao(eY,t.shape,e.shape):new Yn(ZX,t.shape,e.shape);return this.compileAndRun(r,[t,e])}selu(t){let e=new ye(t.shape,L7);return this.compileAndRun(e,[t])}clip(t,e,r){let s;ft().getBool("WEBGL_PACK_CLIP")?s=new pY(t.shape):s=new fY(t.shape);let u=s.getCustomSetupFunc(e,r);return this.compileAndRun(s,[t],null,u)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=L8(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(ft().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,dD,t.dtype);let e=new ye(t.shape,dD);return this.compileAndRun(e,[t])}complexAbs(t){let e=this.texData.get(t.dataId),r=new dY(t.shape),s=[this.makeComplexComponentTensorInfo(t,e.complexTensorInfos.real),this.makeComplexComponentTensorInfo(t,e.complexTensorInfos.imag)];return this.compileAndRun(r,s)}sigmoid(t){let e=new ye(t.shape,X7);return this.compileAndRun(e,[t])}softplus(t){let e=new ye(t.shape,Y7);return this.compileAndRun(e,[t])}asin(t){let e=new ye(t.shape,J7);return this.compileAndRun(e,[t])}acos(t){let e=new ye(t.shape,Z7);return this.compileAndRun(e,[t])}atan(t){let e=new ye(t.shape,Q7);return this.compileAndRun(e,[t])}sinh(t){let e=new ye(t.shape,tJ);return this.compileAndRun(e,[t])}cosh(t){let e=new ye(t.shape,eJ);return this.compileAndRun(e,[t])}tanh(t){let e=new ye(t.shape,nJ);return this.compileAndRun(e,[t])}asinh(t){let e=new ye(t.shape,rJ);return this.compileAndRun(e,[t])}acosh(t){let e=new ye(t.shape,sJ);return this.compileAndRun(e,[t])}atanh(t){let e=new ye(t.shape,oJ);return this.compileAndRun(e,[t])}erf(t){let e=new ye(t.shape,aJ);return this.compileAndRun(e,[t])}step(t,e){let r=new ye(t.shape,B7(e));return this.compileAndRun(r,[t])}conv2dByMatMul(t,e,r,s,u,l){let h=t.shape,p=this.texData.get(t.dataId),m=r.inChannels,y=h[0]*h[1]*h[2],b=r.outChannels,x=r.dataFormat==="channelsLast",S=!1,C=!1,I=(y===1||b===1)&&m>ID,D=h[2]%2!==0&&!!p.isPacked;if(I||!ft().getBool("WEBGL_LAZILY_UNPACK")||!ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!D){let q=x?h[0]*h[1]*h[2]:h[0]*h[2]*h[3],j=rt(t,[1,q,r.inChannels]),et=rt(e,[1,r.inChannels,r.outChannels]),tt=this.fusedBatchMatMul({a:j,b:et,transposeA:S,transposeB:C,bias:s,activation:u,preluActivationWeights:l});return rt(tt,r.outShape)}let R=x?h[0]*h[1]*(h[2]+1):h[0]*h[2]*(h[3]+1),A={dataId:t.dataId,shape:[1,R,r.inChannels],dtype:t.dtype},L=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,k(zm(p.shape,A.shape),()=>`packed reshape ${p.shape} to ${A.shape} isn't free`);let _=rt(e,[1,r.inChannels,r.outChannels]),B=this.fusedBatchMatMul({a:A,b:_,transposeA:S,transposeB:C,bias:s,activation:u,preluActivationWeights:l}),V=this.texData.get(B.dataId);return k(V.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=L,V.shape=r.outShape,yo().makeTensorFromDataId(B.dataId,r.outShape,B.dtype)}conv2dWithIm2Row(t,e,r,s,u,l){let{filterWidth:h,filterHeight:p,inChannels:m,outWidth:y,outHeight:b,dataFormat:x}=r,S=x==="channelsLast",C=h*p*m,I=b*y,D=[C,I],R=!0,A=!1,L=t.squeeze([0]),_=e.reshape([1,C,-1]),B=new n7(D,L.shape,r),V=this.compileAndRun(B,[L]).reshape([1,D[0],D[1]]),q=s!=null,j=l!=null,et=u?jm(u,!0):null,tt=new cx(V.shape,_.shape,[1,I,r.outChannels],R,A,q,et,j),ht=[V,_];s&&ht.push(s),j&&ht.push(l);let gt=this.compileAndRun(tt,ht);return S?gt.reshape([1,b,y,r.outChannels]):gt.reshape([1,r.outChannels,b,y])}fusedConv2d({input:t,filter:e,convInfo:r,bias:s,activation:u,preluActivationWeights:l}){if(r.filterHeight===1&&r.filterWidth===1&&r.dilationHeight===1&&r.dilationWidth===1&&r.strideHeight===1&&r.strideWidth===1&&(r.padInfo.type==="SAME"||r.padInfo.type==="VALID"))return this.conv2dByMatMul(t,e,r,s,u,l);if(ft().getBool("WEBGL_CONV_IM2COL")&&t.shape[0]===1)return this.conv2dWithIm2Row(t,e,r,s,u,l);let h=s!=null,p=l!=null,m=u?jm(u,!1):null,y=new YE(r,h,m,p),b=[t,e];return s&&b.push(s),l&&b.push(l),this.compileAndRun(y,b)}conv2d(t,e,r){if(r.filterHeight===1&&r.filterWidth===1&&r.dilationHeight===1&&r.dilationWidth===1&&r.strideHeight===1&&r.strideWidth===1&&(r.padInfo.type==="SAME"||r.padInfo.type==="VALID"))return this.conv2dByMatMul(t,e,r);if(ft().getBool("WEBGL_CONV_IM2COL")&&t.shape[0]===1)return this.conv2dWithIm2Row(t,e,r);let s=new YE(r);return this.compileAndRun(s,[t,e])}conv2dDerInput(t,e,r){let s=new gY(r);return this.compileAndRun(s,[t,e])}conv2dDerFilter(t,e,r){let s=new mY(r);return this.compileAndRun(s,[t,e])}fusedDepthwiseConv2D({input:t,filter:e,convInfo:r,bias:s,activation:u,preluActivationWeights:l}){let h=ft().getBool("WEBGL_PACK_DEPTHWISECONV")&&r.strideWidth<=2&&r.outChannels/r.inChannels===1,p=u?jm(u,h):null,m=[t,e],y=s!=null,b=l!=null;y&&m.push(s),b&&m.push(l);let x;return h?(x=new ZE(r,y,p,b),this.compileAndRun(x,m)):(x=new JE(r,y,p,b),this.compileAndRun(x,m))}depthwiseConv2D(t,e,r){let s;return ft().getBool("WEBGL_PACK_DEPTHWISECONV")&&r.strideWidth<=2&&r.outChannels/r.inChannels===1?(s=new ZE(r),this.compileAndRun(s,[t,e])):(s=new JE(r),this.compileAndRun(s,[t,e]))}depthwiseConv2DDerInput(t,e,r){let s=new wY(r);return this.compileAndRun(s,[t,e])}depthwiseConv2DDerFilter(t,e,r){let s=new bY(r);return this.compileAndRun(s,[t,e])}conv3d(t,e,r){let s=new xY(r);return this.compileAndRun(s,[t,e])}conv3dDerInput(t,e,r){let s=new yY(r);return this.compileAndRun(s,[t,e])}conv3dDerFilter(t,e,r){let s=new vY(r);return this.compileAndRun(s,[t,e])}unstack(t,e){let r=t.shape[e],s=new Array(t.rank-1),u=0;for(let m=0;m<t.rank;m++)m!==e&&(s[u++]=t.shape[m]);let l=new Array(t.rank).fill(0),h=t.shape.slice();h[e]=1;let p=new Array(r);for(let m=0;m<p.length;m++)l[e]=m,p[m]=this.slice(t,l,h).reshape(s);return p}avgPool3d(t,e){let r=new lx(e,"avg",!1);return this.compileAndRun(r,[t],"float32")}avgPool3dBackprop(t,e,r){let s=new BX(r);return this.compileAndRun(s,[t],e.dtype)}maxPool3d(t,e){let r=new lx(e,"max",!1);return this.compileAndRun(r,[t],"float32")}maxPool3dBackprop(t,e,r,s){let u=!0,l=new lx(s,"max",u),h=this.compileAndRun(l,[e]),p=new i7(s),m=this.compileAndRun(p,[t,h],e.dtype);return h.dispose(),m}resizeBilinear(t,e,r,s){let u=ft().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new w7(t.shape,e,r,s):new b7(t.shape,e,r,s);return this.compileAndRun(u,[t],"float32")}resizeBilinearBackprop(t,e,r){let s=new y7(t,e,r);return this.compileAndRun(s,[t])}resizeNearestNeighbor(t,e,r,s){let u=new T7(t.shape,e,r,s);return this.compileAndRun(u,[t])}resizeNearestNeighborBackprop(t,e,r){let s=new x7(t,e,r);return this.compileAndRun(s,[t])}multinomial(t,e,r,s){let u=e?t:bi(t),l=u.shape[0],h=u.shape[1],p=new u7(l,h,r),m=p.getCustomSetupFunc(s);return this.compileAndRun(p,[u],"int32",m)}oneHot(t,e,r,s){let u=new c7(t.size,e,r,s);return this.compileAndRun(u,[t])}diag(t){let e=new NY(t.size);return this.compileAndRun(e,[t])}cropAndResize(t,e,r,s,u,l){let h=new TY(t.shape,e.shape,s,u,l);return this.compileAndRun(h,[t,e,r],"float32")}depthToSpace(t,e,r){k(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`);let s=t.shape[0],u=r==="NHWC"?t.shape[1]:t.shape[2],l=r==="NHWC"?t.shape[2]:t.shape[3],h=r==="NHWC"?t.shape[3]:t.shape[1],p=u*e,m=l*e,y=h/(e*e),b=r==="NHWC"?[s,p,m,y]:[s,y,p,m],x=new CY(b,e,r);return this.compileAndRun(x,[t])}split(t,e,r){return fJ(t,e,r)}scatterND(t,e,r){let{sliceRank:s,numUpdates:u,sliceSize:l,strides:h,outputSize:p}=Iu(e,t,r),m=[p/l,l],y=t.reshape([u,s]),b=e.reshape([u,l]);if(p===0)return GC(vn([]),r);let x=Ot(0),S=new lD(u,s,y.rank,b.rank,h,m),C=this.compileAndRun(S,[b,y,x]);return C.reshape(r)}sparseToDense(t,e,r,s){let{sliceRank:u,numUpdates:l,strides:h,outputSize:p}=Iu(e,t,r),m=!1,y=new lD(l,u,t.rank,e.rank,h,[p,1],m),b=this.compileAndRun(y,[e,t,s]);return b.reshape(r)}gatherND(t,e){let r=e.shape,s=r[r.length-1],[u,l,h,p]=nd(t,e),m=e.reshape([l,s]),y=t.reshape([t.size/h,h]),b=new RY(s,p,[l,h]),x=this.compileAndRun(b,[y,m]);return x.reshape(u)}fill(t,e,r){if(r=r||Us(e),r==="string"){let s=Kt(r,O(t));return s.fill(e),yo().makeTensor(s,t,r,this)}else{let s=new AY(t,e),u=s.getCustomSetupFunc(e);return this.compileAndRun(s,[],r,u)}}onesLike(t){if(t.dtype==="string")throw new Error("onesLike is not supported under string dtype");return this.fill(t.shape,1,t.dtype)}zerosLike(t){return this.fill(t.shape,t.dtype==="string"?"":0,t.dtype)}linspace(t,e,r){return jb(t,e,r)}makeTensorInfo(t,e,r){let s=this.write(r,t,e);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:e}}makeOutput(t,e,r){let{dataId:s}=this.makeTensorInfo(t,e,r);return yo().makeTensorFromDataId(s,t,e,this)}unpackTensor(t){let e=new hJ(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new l7(t.shape),r=!0;return this.runWebGLProgram(e,[t],t.dtype,null,r)}packedReshape(t,e){let r=[uc(t.shape),...cc(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},u=[uc(e),...cc(e)],l=new cD(u,r),h=!0,p=this.runWebGLProgram(l,[s],t.dtype,null,h);return{dataId:p.dataId,shape:e,dtype:p.dtype}}decode(t){let e=this.texData.get(t),{isPacked:r,shape:s,dtype:u}=e,l=ox(s),h;r?h=new SY(l):h=new kY(l);let p=!0,m=this.runWebGLProgram(h,[{shape:l,dtype:u,dataId:t}],u,null,p);return{dtype:u,shape:s,dataId:m.dataId}}runWebGLProgram(t,e,r,s,u=!1){let l=this.makeTensorInfo(t.outputShape,r),h=this.texData.get(l.dataId);if(t.packedOutput&&(h.isPacked=!0),t.outPackingScheme===gf.DENSE){let I=yf(t.outputShape);h.texShape=I.map(D=>D*2)}if(t.outTexUsage!=null&&(h.usage=t.outTexUsage),O(l.shape)===0)return h.values=_t(l.dtype,0),l;let p=[],m=e.map(I=>{if(I.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let D=this.texData.get(I.dataId);if(D.texture==null){if(!t.packedInputs&&O(I.shape)<=ft().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:I.shape,texData:null,isUniform:!0,uniformValues:D.values};t.packedInputs&&(D.isPacked=!0,D.shape=I.shape)}else if(!!D.isPacked!==!!t.packedInputs)I=D.isPacked?this.unpackTensor(I):this.packTensor(I),p.push(I),D=this.texData.get(I.dataId);else if(D.isPacked&&!zm(D.shape,I.shape)){let R=I,A=I.shape;I.shape=D.shape,I=this.packedReshape(I,A),p.push(I),D=this.texData.get(I.dataId),R.shape=A}return this.uploadToGPU(I.dataId),{shape:I.shape,texData:D,isUniform:!1}});this.uploadToGPU(l.dataId);let y={shape:l.shape,texData:h,isUniform:!1},b=e7(t,m,y),x=this.getAndSaveBinary(b,()=>QY(this.gpgpu,t,m,y)),S=this.activeTimers!=null,C;if(S&&(C=this.startTimer()),t7(this.gpgpu,x,m,y,s),p.forEach(I=>this.disposeIntermediateTensorInfo(I)),S&&(C=this.endTimer(C),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(C)})),!ft().getBool("WEBGL_LAZILY_UNPACK")&&h.isPacked&&u===!1){let I=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),I}return l}compileAndRun(t,e,r,s,u=!1){r=r||e[0].dtype;let l=this.runWebGLProgram(t,e,r,s,u);return yo().makeTensorFromDataId(l.dataId,l.shape,l.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(this.disposed)return;if(!ft().getBool("IS_TEST")){let t=Object.keys(this.binaryCache);t.forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ot(()=>{if(!ft().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=ft().getBool("DEBUG");ft().set("DEBUG",!1);let e=this.abs(Ot(1e-8)).dataSync()[0];if(ft().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?gJ:vJ}uploadToGPU(t){let e=this.texData.get(t),{shape:r,dtype:s,values:u,texture:l,usage:h,isPacked:p}=e;if(l!=null)return;let m=this.activeTimers!=null,y;m&&(y=cr());let b=e.texShape;if(b==null&&(b=$8(r,p),e.texShape=b),u!=null){let x=ox(r),S,C=b[1],I=b[0],D=u instanceof Uint8Array;p?([C,I]=ic(b[0],b[1]),S=new $Y(x,[I,C],D)):S=new DY(x,[I,C],D);let R=this.makeTensorInfo([I,C],s);D?this.texData.get(R.dataId).usage=Hr.PIXELS:this.texData.get(R.dataId).usage=Hr.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(R.dataId),C,I,u);let A=!0,L=this.runWebGLProgram(S,[R],s,null,A),_=this.texData.get(L.dataId);e.texture=_.texture,e.texShape=_.texShape,e.isPacked=_.isPacked,e.usage=_.usage,this.disposeIntermediateTensorInfo(R),this.texData.delete(L.dataId),e.values=null,m&&(this.uploadWaitMs+=cr()-y)}else{let x=this.acquireTexture(b,h,s,p);e.texture=x}}convertAndCacheOnCPU(t,e){let r=this.texData.get(t),{dtype:s}=r;return this.releaseGPUData(t),e!=null&&(r.values=kJ(e,s)),r.values}acquireTexture(t,e,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let u=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${u} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,s)}computeBytes(t,e){return t[0]*t[1]*gn(e)}tryRunOnCpuOrThrow(t,e){if(this.shouldExecuteOnCPU(t))try{return e()}catch(r){if(ft().getBool("IS_TEST"))throw new Error("CPU forwarding failed")}return null}}function kJ(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}else throw new Error(`Unknown dtype ${t}`)}let SJ="2.7.0";function CJ(){ft().set("WEBGL_FORCE_F16_TEXTURES",!0)}Sy()&&Hy("webgl",()=>new TJ,2);let Hft={forceHalfFloat:CJ};function Fo(n){let{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}let NJ={kernelName:Al,backendName:"webgl",kernelFunc:Fo};function dc(n){let{inputs:t,backend:e}=n,{real:r,imag:s}=t,u=e.makeTensorInfo(r.shape,"complex64"),l=e.texData.get(u.dataId),h=Fo({inputs:{x:r},backend:e}),p=e.texData.get(h.dataId);p.complexParentRefCount++;let m=Fo({inputs:{x:s},backend:e}),y=e.texData.get(m.dataId);return y.complexParentRefCount++,l.complexTensorInfos={real:h,imag:m},u}let IJ={kernelName:mp,backendName:"webgl",kernelFunc:dc};let ED="if (isnan(x)) return x;",EJ=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,DJ=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Km(n){return({inputs:t,backend:e})=>{let{x:r}=t,s=e,u=new ye(r.shape,n);return s.runWebGLProgram(u,[r],r.dtype)}}function mc({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:u}){return({inputs:l,backend:h})=>{let{a:p,b:m}=l,y=h;if(r&&p.dtype==="complex64"){let C=y.texData.get(p.dataId),I=y.texData.get(m.dataId),[D,R]=[[C.complexTensorInfos.real,I.complexTensorInfos.real],[C.complexTensorInfos.imag,I.complexTensorInfos.imag]].map(L=>{let[_,B]=L,V={dataId:_.dataId,dtype:_.dtype,shape:p.shape},q={dataId:B.dataId,dtype:B.dtype,shape:m.shape},j=new Yn(n,p.shape,m.shape);return y.runWebGLProgram(j,[V,q],Qn(_.dtype,B.dtype))}),A=dc({inputs:{real:D,imag:R},backend:y});return y.disposeIntermediateTensorInfo(D),y.disposeIntermediateTensorInfo(R),A}let b=u||Qn(p.dtype,m.dtype);if(y.shouldExecuteOnCPU([p,m])&&s!=null){let C=y.texData.get(p.dataId),I=y.texData.get(m.dataId),[D,R]=s(p.shape,m.shape,C.values,I.values,b),A=y.makeTensorInfo(R,b),L=y.texData.get(A.dataId);return L.values=D,A}let x=ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,S;return x?S=new Ao(t,p.shape,m.shape,e):S=new Yn(n,p.shape,m.shape),y.runWebGLProgram(S,[p,m],b)}}let DD="return a + b;",$J=mc({opSnippet:DD,packedOpSnippet:DD,supportsComplex:!0,cpuKernelImpl:B8}),AJ={kernelName:ri,backendName:"webgl",kernelFunc:$J};let _J=EJ+`
  return atan(a, b);
`,FJ=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+DJ+`
  return result;
`,RJ=mc({opSnippet:_J,packedOpSnippet:FJ}),PJ={kernelName:fp,backendName:"webgl",kernelFunc:RJ};function OJ(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t;bf(s,"avgPool");let{filterSize:u,strides:l,pad:h,dimRoundingMode:p}=r,m=1;k(wn(l,m),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let y=tr(s.shape,u,l,m,h,p);if(y.filterWidth===1&&y.filterHeight===1&&K(y.inShape,y.outShape))return Fo({inputs:{x:s},backend:e});let b=new xf(y,"avg",!1);return e.runWebGLProgram(b,[s],"float32")}let MJ={kernelName:wl,backendName:"webgl",kernelFunc:OJ};function LJ(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,input:u}=t,l=u;bf([s,u],"avgPoolBackprop");let{filterSize:h,strides:p,pad:m}=r,y=tr(l.shape,h,p,1,m),b=new LX(y);return e.runWebGLProgram(b,[s],l.dtype)}let BJ={kernelName:pp,backendName:"webgl",kernelFunc:LJ};class zJ{constructor(t,e,r,s,u,l){this.outputShape=[],this.variableNames=["x","mean","variance"],ve(t,e),ve(t,r);let h="0.0";s!=null&&(ve(t,s),this.variableNames.push("offset"),h="getOffsetAtOutCoords()");let p="1.0";u!=null&&(ve(t,u),this.variableNames.push("scale"),p="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${h};
        float scale = ${p};
        float inv = scale * inversesqrt(variance + float(${l}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class WJ{constructor(t,e,r,s,u,l){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ve(t,e),ve(t,r);let h="vec4(0.0)";s!=null&&(ve(t,s),this.variableNames.push("offset"),h="getOffsetAtOutCoords()");let p="vec4(1.0)";u!=null&&(ve(t,u),this.variableNames.push("scale"),p="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${h};
        vec4 scale = ${p};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${l}));

        setOutput((x - mean) * inv + offset);
      }
    `}}let VJ=({inputs:n,backend:t,attrs:e})=>{let{x:r,mean:s,variance:u,offset:l,scale:h}=n;k(s.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),k(l==null||s.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),k(h==null||s.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:p}=e;p==null&&(p=.001);let m=[r,s,u],y=null;l!=null&&(y=l.shape,m.push(l));let b=null;h!=null&&(b=h.shape,m.push(h));let x=ft().getBool("WEBGL_PACK_NORMALIZATION")?new WJ(r.shape,s.shape,u.shape,y,b,p):new zJ(r.shape,s.shape,u.shape,y,b,p),S=t.runWebGLProgram(x,m,m[0].dtype);return S},UJ={kernelName:$l,backendName:"webgl",kernelFunc:VJ};let GJ="return float(a != b);",$D=mc({opSnippet:GJ,dtype:"bool"}),HJ={kernelName:zl,backendName:"webgl",kernelFunc:$D};function fx(n){let{inputs:t,backend:e}=n,{input:r}=t,s=e.texData.get(r.dataId);return Fo({inputs:{x:s.complexTensorInfos.real},backend:e})}let qJ={kernelName:Rp,backendName:"webgl",kernelFunc:fx};let jJ="return float(int(x));";function KJ(n,t){let e=new ye(n.shape,jJ),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function px(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:u}=r;if(u==="complex64"){if(s.dtype==="complex64")return Fo({inputs:{x:s},backend:e});let l=Se(s.shape),h=px({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),p=dc({inputs:{real:h,imag:l},backend:e});return l.dispose(),e.disposeIntermediateTensorInfo(h),p}if(s.dtype==="complex64"){let l=fx({inputs:{input:s},backend:e}),h=px({inputs:{x:l},backend:e,attrs:{dtype:u}});return e.disposeIntermediateTensorInfo(l),h}if(!me(s.dtype,u)){let l=Fo({inputs:{x:s},backend:e});return{dataId:l.dataId,shape:l.shape,dtype:u}}if(u==="int32")return KJ(s,e);if(u==="bool"){let l=e.makeTensorInfo([],"bool",_t("bool",1)),h={a:s,b:l},p=$D({inputs:h,backend:e});return e.disposeIntermediateTensorInfo(l),p}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${u}`)}let XJ={kernelName:pu,backendName:"webgl",kernelFunc:px};class YJ{constructor(t){this.outputShape=[],this.outputShape=bo(t,1),this.variableNames=t.map((l,h)=>`T${h}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let l=1;l<e.length;l++)e[l]=e[l-1]+t[l][1];let r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let l=1;l<e.length;l++){let h=e[l-1];r.push(`else if (yC < ${e[l]}) setOutput(getT${l}(yR, yC-${h}));`)}let s=e.length,u=e[e.length-1];r.push(`else setOutput(getT${s}(yR, yC-${u}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}class JJ{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=bo(t,e);let r=this.outputShape,s=r.length,u=We(s),l=nr("coords",s),h=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((I,D)=>`T${D}`);let p=new Array(t.length-1);p[0]=t[0][e];for(let I=1;I<p.length;I++)p[I]=p[I-1]+t[I][e];let m=h[e],y=h.slice(-2),b=h.join(),x=`if (${m} < ${p[0]}) {
        return getChannel(
            getT0(${b}), vec2(${y.join()}));
        }`;for(let I=1;I<p.length;I++){let D=p[I-1];x+=`
        if (${m} < ${p[I]}  && ${m} >= ${p[I-1]}) {
          return getChannel(
            getT${I}(${Xm(h,m,D)}),
            vec2(${Xm(y,m,D)}));
        }`}let S=p.length,C=p[p.length-1];x+=`
        return getChannel(
          getT${S}(${Xm(h,m,C)}),
          vec2(${Xm(y,m,C)}));`,this.userCode=`
      float getValue(${h.map(I=>"int "+I)}) {
        ${x}
      }

      void main() {
        ${u} coords = getOutputCoords();
        vec4 result = vec4(getValue(${l}), 0., 0., 0.);

        ${l[s-1]} = ${l[s-1]} + 1;
        if (${l[s-1]} < ${r[s-1]}) {
          result.g = getValue(${l});
        }

        ${l[s-2]} = ${l[s-2]} + 1;
        if (${l[s-2]} < ${r[s-2]}) {
          result.a = getValue(${l});
        }

        ${l[s-1]} = ${l[s-1]} - 1;
        if (${l[s-2]} < ${r[s-2]} &&
            ${l[s-1]} < ${r[s-1]}) {
          result.b = getValue(${l});
        }
        setOutput(result);
      }
    `}}function Xm(n,t,e){let r=n.indexOf(t),s=n.map((u,l)=>l===r?`${u} - ${e}`:u);return s.join()}function AD(n){let{inputs:t,backend:e}=n,{input:r}=t,s=e.texData.get(r.dataId);return Fo({inputs:{x:s.complexTensorInfos.imag},backend:e})}let ZJ={kernelName:Np,backendName:"webgl",kernelFunc:AD};function QJ(n,t,e){let r=[uc(n.shape),...cc(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},u=[uc(t),...cc(t)],l=new cD(u,r),h=!0,p=e.runWebGLProgram(l,[s],n.dtype,null,h);return{dataId:p.dataId,shape:t,dtype:p.dtype}}function Ro(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:u}=r,l=e,h=O(s.shape),p=Gt(u,h),m=O(p);k(h===m,()=>`The new shape (${p}) has ${m} elements and the old shape (${s.shape}) has ${h} elements. The new shape and old shape must have the same number of elements.`);let y=l.texData.get(s.dataId);return y.isPacked&&!zm(s.shape,p)&&!(y.texture!==null&&zm(y.shape,p))?QJ(s,p,l):(l.incRef(s.dataId),{dataId:s.dataId,shape:p,dtype:s.dtype})}let t9={kernelName:Ul,backendName:"webgl",kernelFunc:Ro};function gc(n,t,e){let r=n[0].dtype;if(r==="complex64"){let m=n.map(C=>fx({inputs:{input:C},backend:e})),y=n.map(C=>AD({inputs:{input:C},backend:e})),b=gc(m,t,e),x=gc(y,t,e),S=dc({inputs:{real:b,imag:x},backend:e});return m.forEach(C=>e.disposeIntermediateTensorInfo(C)),y.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(x),S}if(n.length>ft().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let m=Math.floor(n.length/2),y=gc(n.slice(0,m),t,e),b=gc(n.slice(m),t,e),x=gc([y,b],t,e);return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),x}if(ft().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){let m=new JJ(n.map(y=>y.shape),t);return e.runWebGLProgram(m,n,r)}let s=bo(n.map(m=>m.shape),t),u=n.map(m=>Ro({inputs:{x:m},attrs:{shape:[-1,O(m.shape.slice(t))]},backend:e})),l=new YJ(u.map(m=>m.shape)),h=e.runWebGLProgram(l,u,r);u.forEach(m=>e.disposeIntermediateTensorInfo(m));let p=Ro({inputs:{x:h},attrs:{shape:s},backend:e});return e.disposeIntermediateTensorInfo(h),p}function e9(n){let{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,u=Et(s,t[0].shape)[0],l=bo(t.map(m=>m.shape),u);if(O(l)===0)return e.makeTensorInfo(l,t[0].dtype,[]);let h=t.filter(m=>O(m.shape)>0);if(h.length===1)return h[0];let p=h.map(m=>m.shape);return fd(p,u),gc(h,u,e)}let n9={kernelName:kl,backendName:"webgl",kernelFunc:e9};let r9=ED+`
  return cos(x);
`,s9=Km(r9),o9={kernelName:du,backendName:"webgl",kernelFunc:s9};let a9=`
if (a == b) {
  return 1.0;
};
return a / b;`,i9=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,u9=mc({opSnippet:a9,packedOpSnippet:i9,checkOutOfBounds:!0}),c9={kernelName:mu,backendName:"webgl",kernelFunc:u9};class _D{constructor(t,e,r){this.variableNames=["real","imag"];let s=e[1];this.outputShape=e;let u=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,l=r?`${s}.0`:"1.0",h;if(t==="real")h="return real * expR - imag * expI;";else if(t==="imag")h="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${u};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${h}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${l};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function FD(n,t,e){let r=e.texData.get(n.dataId),s=O(n.shape),u=n.shape[n.shape.length-1],l=s/u,h=Ro({inputs:{x:n},backend:e,attrs:{shape:[l,u]}}),p=h.shape,m=new _D("real",p,t),y=new _D("imag",p,t),b=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:p},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:p}],x=e.runWebGLProgram(m,b,"float32"),S=e.runWebGLProgram(y,b,"float32"),C=dc({inputs:{real:x,imag:S},backend:e});e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(S);let I=Ro({inputs:{x:C},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(I),I}function l9(n){let{inputs:t,backend:e}=n,{input:r}=t;return FD(r,!1,e)}let h9={kernelName:kp,backendName:"webgl",kernelFunc:l9};class f9{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let p9={kernelName:Sp,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{let{image:e}=n,r=t,s=new f9(e.shape),u=r.runWebGLProgram(s,[e],e.dtype);return u}};class d9{constructor(t){this.variableNames=["A"];let e=rr(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class m9{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=rr(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}let g9={kernelName:Bp,backendName:"webgl",kernelFunc:v9},vc;function v9(n){let{inputs:t,backend:e,attrs:r}=n,{pixels:s}=t,{numChannels:u}=r,l=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,h=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[p,m]=l?[s.videoWidth,s.videoHeight]:[s.width,s.height],y=[m,p],b=[m,p,u];(h||l)&&(vc==null&&(vc=document.createElement("canvas").getContext("2d")),vc.canvas.width=p,vc.canvas.height=m,vc.drawImage(s,0,0,p,m),s=vc.canvas);let x=e.makeTensorInfo(y,"int32");e.texData.get(x.dataId).usage=Hr.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(x.dataId),s);let S=ft().getBool("WEBGL_PACK")?new m9(b):new d9(b),C=e.runWebGLProgram(S,[x],"int32");return e.disposeData(x.dataId),C}function y9(n){let{inputs:t,backend:e}=n,{input:r}=t;return FD(r,!0,e)}let b9={kernelName:Cp,backendName:"webgl",kernelFunc:y9};class RD{constructor(t,e){this.variableNames=["x"];let{windowSize:r,batchSize:s,inSize:u,outSize:l}=t;this.outputShape=[s,l];let h=Math.floor(r/4)*4,p=r%4,m="sumValue += dot(values, ones);";if(e!=null){let b=1/e;m=`sumValue += dot(values * ${nt(b)?b.toPrecision(2):b}, ones);`}let y="";u%r>0&&(y=`
        if (inIdx < 0 || inIdx >= ${u}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${h};
        if (${p===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${m}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${m}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${m}
        }
        setOutput(sumValue);
      }
    `}}function w9(n){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:n[1],r=yh(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}function PD(n,t,e,r){let s=w9(n.shape),u=n;for(let l=0;l<s.length;l++){let{inSize:h,windowSize:p,outSize:m}=s[l],y,b;e==="mean"?y=l===0?new RD({windowSize:p,inSize:h,batchSize:n.shape[0],outSize:m},h):new RD({windowSize:p,inSize:h,batchSize:n.shape[0],outSize:m}):y=new uD({windowSize:p,inSize:h,batchSize:n.shape[0],outSize:m},e),b=u,u=r.runWebGLProgram(y,[u],t),b.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(b)}return u}function x9(n,t,e,r){let s=O(t),u=O(n.shape),l=u/s,h=Ro({inputs:{x:n},attrs:{shape:[l,s]},backend:r}),p=PD(h,n.dtype,"max",r),m=Ro({inputs:{x:p},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),m}class T9{constructor(t,e){this.variableNames=["A"];let r=new Array(t.length);for(let l=0;l<r.length;l++)r[l]=t[e[l]];this.outputShape=r,this.rank=r.length;let s=We(this.rank),u=k9(e);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${u}));
    }
    `}}function k9(n){let t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}class S9{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(t.length);for(let y=0;y<r.length;y++)r[y]=t[e[y]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let s=We(this.rank),u=VE("rc",this.rank),l=new Array(this.rank);for(let y=0;y<e.length;y++)l[e[y]]=u[y];let h=`vec2(${l.slice(-2).join()})`,p=`++${u[this.rank-1]} < ${r[this.rank-1]}`,m=`getChannel(getA(${l.join()}), ${h})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${m};
      if(${p}) {
        result[1] = ${m};
      }
      --${u[this.rank-1]};
      if(++${u[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${m};
        if(${p}) {
          result[3] = ${m};
        }
      }
      setOutput(result);
    }
    `}}function dx(n,t,e){let r=ft().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new S9(n.shape,t):new T9(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}let C9={kernelName:Ml,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{reductionIndices:s,keepDims:u}=t,l=e,h=r.shape.length,p=Et(s,r.shape),m=p,y=hr(m,h),b=y!=null,x=l.shouldExecuteOnCPU([r]),S=r;if(b){if(x){let A=l.texData.get(S.dataId),L=A.values,_=new Array(h);for(let q=0;q<_.length;q++)_[q]=r.shape[y[q]];let B=ix(L,r.shape,r.dtype,y,_);S=l.makeTensorInfo(_,r.dtype);let V=l.texData.get(S.dataId);V.values=B}else S=dx(r,y,l);m=Cr(m.length,h)}lr("max",m,h);let[C,I]=Bn(S.shape,m),D=C;u&&(D=zn(C,p));let R;if(x){let A=l.texData.get(S.dataId),L=A.values,_=H8(L,O(I),D,r.dtype);R=l.makeTensorInfo(D,r.dtype);let B=l.texData.get(R.dataId);B.values=_}else R=x9(S,I,D,l);return b&&l.disposeIntermediateTensorInfo(S),R}};function N9(n){let{inputs:t,backend:e,attrs:r}=n,{x:s}=t;bf(s,"maxPool");let{filterSize:u,strides:l,pad:h,dimRoundingMode:p}=r,m=1;k(wn(l,m),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let y=tr(s.shape,u,l,m,h,p);if(y.filterWidth===1&&y.filterHeight===1&&K(y.inShape,y.outShape))return Fo({inputs:{x:s},backend:e});let b=new xf(y,"max",!1);return e.runWebGLProgram(b,[s],s.dtype)}let I9={kernelName:Ll,backendName:"webgl",kernelFunc:N9};function E9(n){let{inputs:t,backend:e,attrs:r}=n,{dy:s,input:u,output:l}=t,h=u;bf([u,l],"maxPoolBackprop");let{filterSize:p,strides:m,pad:y,dimRoundingMode:b}=r,x=tr(h.shape,p,m,1,y,b),S=!0,C=new xf(x,"max",S),I=e.runWebGLProgram(C,[h],h.dtype),D=new a7(x),R=e.runWebGLProgram(D,[s,I],h.dtype);return e.disposeIntermediateTensorInfo(I),R}let D9={kernelName:Ep,backendName:"webgl",kernelFunc:E9};function $9(n,t,e,r){let s=new xf(e,"max",!1),u=r.runWebGLProgram(s,[n],"float32");s=new xf(e,"max",!0,!0,t);let l=r.runWebGLProgram(s,[n],"float32");return[u,l]}let A9={kernelName:Dp,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{filterSize:s,strides:u,pad:l,includeBatchInIndex:h}=t,p=e;k(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let m=[1,1];k(wn(u,m),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);let y=tr(r.shape,s,u,m,l),[b,x]=$9(r,h,y,p);return[b,x]}};function _9(n,t,e,r){let s=O(t),u=O(n.shape),l=u/s,h=Ro({inputs:{x:n},attrs:{shape:[l,s]},backend:r}),p=PD(h,"float32","mean",r),m=Ro({inputs:{x:p},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),m}let F9={kernelName:Yv,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{keepDims:s,axis:u}=t,l=e,h=r.shape.length,p=Et(u,r.shape),m=p,y=hr(m,h),b=y!=null,x=l.shouldExecuteOnCPU([r]),S=[],C=r;if(b){if(x){let L=l.texData.get(C.dataId),_=L.values,B=new Array(h);for(let j=0;j<B.length;j++)B[j]=r.shape[y[j]];let V=ix(_,r.shape,r.dtype,y,B);C=l.makeTensorInfo(B,r.dtype);let q=l.texData.get(C.dataId);q.values=V}else C=dx(r,y,l);S.push(C),m=Cr(m.length,h)}lr("sum",m,h);let[I,D]=Bn(C.shape,m),R=I;s&&(R=zn(I,p));let A=_9(C,D,R,l);for(let L of S)l.disposeIntermediateTensorInfo(L);return A}};class R9{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((y,b)=>y[0]+t[b]+y[1]);let s=t.length,u=We(s),l=e.map(y=>y[0]).join(","),h=e.map((y,b)=>y[0]+t[b]).join(","),p=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),m=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${l};
        int end = ${h};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${m};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${m};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${u} start = ${u}(${l});
      ${u} end = ${u}(${h});

      void main() {
        ${u} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${m};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${m};
          }
        }
        ${u} coords = outC - start;
        setOutput(getX(${p}));
      }
    `}}class P9{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((C,I)=>C[0]+t[I]+C[1]);let s=t.length,u=We(s),l=e.map(C=>C[0]).join(","),h=e.map((C,I)=>C[0]+t[I]).join(","),p=nr("rc",s),m=nr("source",s),y=`${p[s-1]} < ${this.outputShape[s-1]}`,b=s===1?"source":`vec2(${m.slice(-2).join()})`,x=r==="reflect"?0:1,S="";if(s===1){let C=`
        ${u} source = rc;
        if (source < start) {
          source = start * 2 - source - ${x};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${x};
        }
        source -= start;
      `;S=`
        ${u} rc = outputLoc;
        ${C}
        result[0] = getChannel(getX(${m.join()}), ${b});
        ${p[s-1]} += 1;
        if(${y}) {
          ${C}
          result[1] = getChannel(getX(${m.join()}), ${b});
        }
      `}else{let C=`
        ${u} source = rc;
        ${u} lt = ${u}(lessThan(source, start));
        ${u} gte = ${u}(greaterThanEqual(source, end));
        ${u} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${x}) +
                gte * ((end - 1) * 2 - source + ${x});
        source -= start;
      `;S=`
        ${u} rc = outputLoc;
        ${C}
        result[0] = getChannel(getX(${m.join()}), ${b});
        ${p[s-1]} += 1;
        if(${y}) {
          ${C}
          result[1] = getChannel(getX(${m.join()}), ${b});
        }
        rc = outputLoc;
        ${p[s-2]} += 1;
        if(${p[s-2]} < ${this.outputShape[s-2]}) {
          ${C}
          result[2] = getChannel(getX(${m.join()}), ${b});
          ${p[s-1]} += 1;
          if(${y}) {
            ${C}
            result[3] = getChannel(getX(${m.join()}), ${b});
          }
        }
      `}this.userCode=`
      const ${u} start = ${u}(${l});
      const ${u} end = ${u}(${h});

      void main() {
        ${u} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${S}
        setOutput(result);
      }
    `}}let O9=({inputs:n,backend:t,attrs:e})=>{let{x:r}=n,{paddings:s,mode:u}=e,l=ft().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new P9(r.shape,s,u):new R9(r.shape,s,u),h=t.runWebGLProgram(l,[r],r.dtype);return h},M9={kernelName:Bl,backendName:"webgl",kernelFunc:O9};let OD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class MD{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ve(e,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}let LD="return a * b;";function L9(n){let{inputs:t,backend:e}=n,{a:r,b:s}=t,u=Qn(r.dtype,s.dtype);if(r.dtype==="complex64"){let h=e.texData.get(r.dataId),p=e.texData.get(s.dataId),m=new MD(OD.REAL,r.shape,s.shape),y=new MD(OD.IMAG,r.shape,s.shape),b=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:r.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:s.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:s.shape}],x=e.runWebGLProgram(m,b,"float32"),S=e.runWebGLProgram(y,b,"float32"),C=dc({inputs:{real:x,imag:S},backend:e});return e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(S),C}if(e.shouldExecuteOnCPU([r,s])){let h=e.texData.get(r.dataId),p=e.texData.get(s.dataId),[m,y]=q8(r.shape,s.shape,h.values,p.values,u),b=e.makeTensorInfo(y,u),x=e.texData.get(b.dataId);return x.values=m,b}let l;return ft().getBool("WEBGL_PACK_BINARY_OPERATIONS")?l=new Ao(LD,r.shape,s.shape):l=new Yn(LD,r.shape,s.shape),e.runWebGLProgram(l,[r,s],u)}let B9={kernelName:gu,backendName:"webgl",kernelFunc:L9};let z9={kernelName:ey,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{Gu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{boxes:r,scores:s}=n,{maxOutputSize:u,iouThreshold:l,scoreThreshold:h}=e,p=t,m=p.readSync(r.dataId),y=p.readSync(s.dataId),b=u,x=l,S=h;return Vd(m,y,b,x,S)}};let W9=Ud,V9={kernelName:$p,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{Gu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{boxes:r,scores:s}=n,{maxOutputSize:u,iouThreshold:l,scoreThreshold:h,padToMaxOutputSize:p}=e,m=t,y=m.readSync(r.dataId),b=m.readSync(s.dataId),{selectedIndices:x,validOutputs:S}=W9(y,b,u,l,h,p);return[x,S]}};let U9=Gd,G9={kernelName:Ap,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{Gu("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{boxes:r,scores:s}=n,{maxOutputSize:u,iouThreshold:l,scoreThreshold:h,softNmsSigma:p}=e,m=t,y=m.readSync(r.dataId),b=m.readSync(s.dataId),x=u,S=l,C=h,I=p,{selectedIndices:D,selectedScores:R}=U9(y,b,x,S,C,I);return[D,R]}};class H9{constructor(t,e,r,s){this.variableNames=["Image"],this.outputShape=[];let u=t[1],l=t[2],h=Math.sin(e).toFixed(3),p=Math.cos(e).toFixed(3);this.outputShape=t;let[m,y]=Mb(s,u,l),b=m.toFixed(3),x=y.toFixed(3),S="";typeof r=="number"?S=`float outputValue = ${r.toFixed(2)};`:S=`
        vec3 fill = vec3(${r.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${b}) * ${p} - (float(y) - ${x}) * ${h};
          float coordYFloat = (float(x) - ${b}) * ${h} + (float(y) - ${x}) * ${p};
          int coordX = int(round(coordXFloat + ${b}));
          int coordY = int(round(coordYFloat + ${x}));
          ${S}
          if(coordX >= 0 && coordX < ${l} && coordY >= 0 && coordY < ${u}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}let q9={kernelName:zp,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{image:r}=n,{radians:s,fillValue:u,center:l}=t,h=e,p=new H9(r.shape,s,u,l),m=h.runWebGLProgram(p,[r],r.dtype);return m}};let j9=ED+`
  return sin(x);
`,K9=Km(j9),X9={kernelName:vu,backendName:"webgl",kernelFunc:K9};let Y9="return x * x;",J9=Km(Y9),Z9={kernelName:Mp,backendName:"webgl",kernelFunc:J9};let BD="return (a - b) * (a - b);",Q9=mc({opSnippet:BD,packedOpSnippet:BD}),tZ={kernelName:yu,backendName:"webgl",kernelFunc:Q9};let zD="return a - b;",eZ=mc({opSnippet:zD,packedOpSnippet:zD,supportsComplex:!0,cpuKernelImpl:X8}),nZ={kernelName:bu,backendName:"webgl",kernelFunc:eZ};let rZ="return tan(x);",sZ=Km(rZ),oZ={kernelName:wu,backendName:"webgl",kernelFunc:sZ};let aZ={kernelName:th,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{let{x:r}=n,{perm:s}=t,u=e,l=r.shape.length,h=new Array(l);for(let m=0;m<h.length;m++)h[m]=r.shape[s[m]];let p;if(u.shouldExecuteOnCPU([r])){let m=u.texData.get(r.dataId),y=m.values,b=ix(y,r.shape,r.dtype,s,h);p=u.makeTensorInfo(h,r.dtype);let x=u.texData.get(p.dataId);x.values=b}else p=dx(r,s,u);return p}};function iZ(n){let{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:u}=t;bf(u,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let l=r.readSync(u.dataId),{outputValues:h,outputShape:p,indices:m}=Y8(l,s,u.shape,u.dtype);return[r.makeTensorInfo(p,u.dtype,h),r.makeTensorInfo([m.length],"int32",m)]}let uZ={kernelName:Lp,backendName:"webgl",kernelFunc:iZ};let cZ=[AJ,PJ,MJ,BJ,UJ,XJ,IJ,n9,o9,c9,h9,p9,g9,NJ,b9,ZJ,C9,I9,D9,A9,F9,M9,B9,z9,V9,G9,HJ,qJ,t9,q9,X9,Z9,nZ,tZ,oZ,aZ,uZ];for(let n of cZ)Hp(n);let lZ="2.7.0";let hZ={"tfjs-core":PS,"tfjs-backend-cpu":I6,"tfjs-backend-webgl":SJ,"tfjs-data":uE,"tfjs-layers":bm,"tfjs-converter":VI,tfjs:lZ};o.Abs=hp,o.Acos=dl,o.Acosh=ml,o.AdadeltaOptimizer=Ah,o.AdagradOptimizer=_h,o.AdamOptimizer=Fh,o.AdamaxOptimizer=Rh,o.Add=ri,o.AddN=$v,o.All=T2,o.Any=k2,o.ArgMax=Av,o.ArgMin=_v,o.Asin=gl,o.Asinh=vl,o.Atan=yl,o.Atan2=fp,o.Atanh=bl,o.AvgPool=wl,o.AvgPool3D=Fv,o.AvgPool3DBackprop=S2,o.AvgPoolBackprop=pp,o.BatchMatMul=dp,o.BatchToSpaceND=Rv,o.BroadcastTo=Pv,o.Callback=II,o.CallbackList=xN,o.Cast=pu,o.Ceil=xl,o.ClipByValue=Tl,o.Complex=mp,o.Concat=kl,o.Conv2D=gp,o.Conv2DBackpropFilter=Ov,o.Conv2DBackpropInput=vp,o.Conv3D=yp,o.Conv3DBackpropFilterV2=Mv,o.Conv3DBackpropInputV2=Lv,o.Cos=du,o.Cosh=Sl,o.CropAndResize=C2,o.Cumsum=Bv,o.CustomCallback=kN,o.DataStorage=c,o.DepthToSpace=N2,o.DepthwiseConv2dNative=bp,o.DepthwiseConv2dNativeBackpropFilter=zv,o.DepthwiseConv2dNativeBackpropInput=Wv,o.Diag=I2,o.Dilation2D=wp,o.Dilation2DBackpropFilter=Tp,o.Dilation2DBackpropInput=xp,o.Div=mu,o.EarlyStopping=DI,o.Elu=Cl,o.EluGrad=E2,o.Environment=b2,o.Equal=D2,o.Erf=Nl,o.Exp=Il,o.Expm1=El,o.FFT=kp,o.Fill=Vv,o.FlipLeftRight=Sp,o.Floor=Dl,o.FloorDiv=Uv,o.FromPixels=Bp,o.FusedBatchNorm=$l,o.FusedConv2D=Vp,o.FusedDepthwiseConv2D=Up,o.GatherNd=$2,o.GatherV2=Gv,o.GraphModel=WI,o.Greater=A2,o.GreaterEqual=Hv,o.History=TN,o.IFFT=Cp,o.Identity=Al,o.Imag=Np,o.InputSpec=Fn,o.IsFinite=_l,o.IsInf=Fl,o.IsNan=Rl,o.KernelBackend=f,o.LRN=jv,o.LRNBackprop=M2,o.LayerVariable=Ts,o.LayersModel=Io,o.Less=_2,o.LessEqual=F2,o.LinSpace=R2,o.Log=Pl,o.Log1p=Ol,o.LogSoftmax=qv,o.LogicalAnd=P2,o.LogicalNot=Ip,o.LogicalOr=O2,o.Max=Ml,o.MaxPool=Ll,o.MaxPool3D=Xv,o.MaxPool3DBackprop=L2,o.MaxPoolBackprop=Ep,o.MaxPoolWithArgmax=Dp,o.Maximum=Kv,o.Mean=Yv,o.Min=Jv,o.Minimum=Zv,o.MirrorPad=Bl,o.Mod=Qv,o.MomentumOptimizer=Ph,o.Multiply=gu,o.Negate=ty,o.NonMaxSuppressionV3=ey,o.NonMaxSuppressionV4=$p,o.NonMaxSuppressionV5=Ap,o.NotEqual=zl,o.OP_SCOPE_SUFFIX=aS,o.OneHot=ry,o.OnesLike=ny,o.Optimizer=ko,o.PadV2=_p,o.Pool=UR,o.Pow=sy,o.Prelu=Fp,o.Prod=B2,o.RMSPropOptimizer=Oh,o.RNN=Is,o.Range=z2,o.Real=Rp,o.Reciprocal=Wl,o.Relu=Vl,o.Relu6=Gl,o.Reshape=Ul,o.ResizeBilinear=ay,o.ResizeBilinearGrad=V2,o.ResizeNearestNeighbor=oy,o.ResizeNearestNeighborGrad=W2,o.Reverse=iy,o.RotateWithOffset=zp,o.Round=Hl,o.Rsqrt=ql,o.SGDOptimizer=Uu,o.ScatterNd=U2,o.SelectV2=uy,o.Selu=jl,o.Sequential=Ii,o.Sigmoid=Yl,o.Sign=Xl,o.Sin=vu,o.Sinh=Kl,o.Slice=Pp,o.Softmax=hy,o.Softplus=Jl,o.SpaceToBatchND=Op,o.SparseToDense=G2,o.SplitV=ly,o.Sqrt=Zl,o.Square=Mp,o.SquaredDifference=yu,o.Step=eh,o.StridedSlice=H2,o.Sub=bu,o.Sum=cy,o.SymbolicTensor=ks,o.Tan=wu,o.Tanh=Ql,o.Tensor=at,o.TensorBuffer=bn,o.Tile=fy,o.TopK=q2,o.Transpose=th,o.Unique=Lp,o.Unpack=py,o.UnsortedSegmentSum=dy,o.Variable=ih,o.ZerosLike=my,o._FusedMatMul=Wp,o.abs=kn,o.acos=qy,o.acosh=jy,o.add=Nt,o.addN=LS,o.addStrict=dC,o.all=cd,o.any=hh,o.argMax=fh,o.argMin=Xy,o.asin=Yy,o.asinh=Jy,o.atan=Zy,o.atan2=Qy,o.atanh=tb,o.avgPool=dh,o.avgPool3d=rb,o.backend=MS,o.backend_util=Kb,o.basicLSTMCell=uM,o.batchNorm=fi,o.batchNorm2d=zS,o.batchNorm3d=WS,o.batchNorm4d=VS,o.batchToSpaceND=mh,o.booleanMaskAsync=wB,o.broadcastTo=gh,o.browser=hO,o.buffer=Ae,o.callbacks=UH,o.cast=Rt,o.ceil=sb,o.clipByValue=fr,o.clone=oa,o.complex=vo,o.concat=sn,o.concat1d=US,o.concat2d=GS,o.concat3d=HS,o.concat4d=qS,o.constraints=dV,o.conv1d=dd,o.conv2d=wo,o.conv2dTranspose=md,o.conv3d=ab,o.conv3dTranspose=DM,o.copyRegisteredKernels=qR,o.cos=vh,o.cosh=gd,o.cosineWindow=Fb,o.cumsum=vd,o.customGrad=Ks,o.data=Gj,o.deprecationWarn=Tn,o.depthToSpace=ib,o.depthwiseConv2d=pi,o.deregisterOp=HH,o.device_util=hP,o.diag=OM,o.dilation2d=ub,o.disableDeprecationWarnings=SO,o.dispose=oe,o.disposeVariables=CO,o.div=Ht,o.divNoNan=cb,o.divStrict=mC,o.dot=KS,o.dropout=NC,o.elu=$u,o.enableDebugMode=kO,o.enableProdMode=TO,o.enclosingPowerOfTwo=IC,o.engine=yo,o.env=ft,o.equal=gs,o.equalStrict=uC,o.erf=lb,o.exp=Br,o.expandDims=pr,o.expm1=hb,o.eye=yd,o.fft=Ih,o.fill=Au,o.findBackend=AO,o.findBackendFactory=_O,o.floor=_u,o.floorDiv=ud,o.fused=QB,o.gather=Fu,o.gatherND=CC,o.gather_util=fO,o.getBackend=DO,o.getGradient=vy,o.getKernel=gy,o.getKernelsForBackend=Gp,o.grad=dL,o.grads=mL,o.greater=zr,o.greaterEqual=xo,o.greaterEqualStrict=cC,o.greaterStrict=lC,o.ifft=Bu,o.imag=bh,o.image=da,o.inTopKAsync=qB,o.initializers=YV,o.input=jN,o.io=eO,o.irfft=Fd,o.isFinite=YS,o.isInf=JS,o.isNaN=ZS,o.keep=An,o.kernel_impls=c4,o.layers=wH,o.leakyRelu=bd,o.less=wh,o.lessEqual=la,o.lessEqualStrict=hC,o.lessStrict=fC,o.linalg=MC,o.linspace=QS,o.loadGraphModel=uj,o.loadLayersModel=ZU,o.localResponseNormalization=pb,o.log=Nr,o.log1p=wd,o.logSigmoid=tC,o.logSoftmax=Td,o.logSumExp=mb,o.logicalAnd=es,o.logicalNot=xh,o.logicalOr=kd,o.logicalXor=eC,o.losses=o4,o.matMul=xe,o.math=uO,o.max=dr,o.maxPool=Th,o.maxPool3d=gb,o.maxPoolWithArgmax=nC,o.maximum=ts,o.maximumStrict=gC,o.mean=an,o.memory=id,o.metrics=OH,o.min=Pu,o.minimum=mi,o.minimumStrict=vC,o.mirrorPad=vb,o.mod=Sd,o.modStrict=yC,o.model=YU,o.models=MH,o.moments=Cd,o.movingAverage=LB,o.mul=st,o.mulStrict=bC,o.multiRNNCell=WL,o.multinomial=rC,o.neg=on,o.nextFrame=Hd,o.norm=Od,o.notEqual=ha,o.notEqualStrict=pC,o.oneHot=ci,o.ones=vs,o.onesLike=Xn,o.op=X,o.outerProduct=jL,o.pad=Xs,o.pad1d=YL,o.pad2d=ZL,o.pad3d=t3,o.pad4d=n3,o.pool=sC,o.pow=ys,o.powStrict=wC,o.prelu=Sh,o.print=mS,o.prod=Nd,o.profile=NO,o.rand=h3,o.randomGamma=C3,o.randomNormal=wb,o.randomUniform=yi,o.range=Ch,o.ready=EO,o.real=Ou,o.reciprocal=xb,o.registerBackend=Hy,o.registerCallbackConstructor=QU,o.registerGradient=j2,o.registerKernel=Hp,o.registerOp=GH,o.regularizers=WH,o.relu=Ys,o.relu6=Tb,o.removeBackend=$O,o.reshape=rt,o.reverse=Wr,o.reverse1d=F3,o.reverse2d=P3,o.reverse3d=M3,o.reverse4d=B3,o.rfft=Eh,o.round=kb,o.rsqrt=Id,o.scalar=Ot,o.scatterND=SC,o.scatter_util=pO,o.selu=Ed,o.separableConv2d=Sb,o.sequential=JU,o.serialization=dO,o.setBackend=OS,o.setPlatform=FO,o.setdiff1dAsync=oC,o.sigmoid=js,o.sign=Cb,o.signal=s4,o.sin=Dd,o.sinh=$d,o.slice=ge,o.slice1d=Ad,o.slice2d=Nb,o.slice3d=_d,o.slice4d=Nh,o.slice_util=FS,o.softmax=bi,o.softplus=Ru,o.spaceToBatchND=kh,o.sparseToDense=_b,o.spectral=r4,o.split=Er,o.sqrt=Wn,o.square=Oe,o.squaredDifference=Dh,o.squaredDifferenceStrict=xC,o.squeeze=fa,o.stack=mr,o.step=zu,o.stridedSlice=Ib,o.sub=Mt,o.subStrict=TC,o.sum=Xt,o.sumOutType=Kp,o.tan=Eb,o.tanh=Du,o.tensor=vn,o.tensor1d=Ir,o.tensor2d=pa,o.tensor3d=TS,o.tensor4d=Wu,o.tensor5d=hB,o.tensor6d=fB,o.tensor_util=iP,o.test_util=xO,o.tidy=ot,o.tile=ca,o.time=IO,o.topk=Db,o.train=xi,o.transpose=re,o.truncatedNormal=$h,o.unique=Rd,o.unregisterGradient=HR,o.unregisterKernel=GR,o.unsortedSegmentSum=$b,o.unstack=bs,o.upcastType=Qn,o.util=KR,o.valueAndGrad=gL,o.valueAndGrads=vL,o.variable=iC,o.variableGrads=db,o.version=hZ,o.version_converter=VI,o.version_core=PS,o.version_layers=bm,o.where=er,o.whereAsync=Ab,o.zeros=Se,o.zerosLike=fe,Object.defineProperty(o,"__esModule",{value:!0})})}),n$=Zm((zZ,e$)=>{kf(zZ,{isNodejs:()=>WZ});function WZ(){return typeof global=="object"&&!0&&typeof e$!="undefined"&&typeof process!="undefined"&&!!process.version}}),KF=Zm(F=>{"use strict";Object.defineProperty(F,"__esModule",{value:!0});var Hx=function(o,a){return Hx=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(i,c){i.__proto__=c}||function(i,c){for(var f in c)c.hasOwnProperty(f)&&(i[f]=c[f])},Hx(o,a)};function Uo(o,a){Hx(o,a);function i(){this.constructor=o}o.prototype=a===null?Object.create(a):(i.prototype=a.prototype,new i)}function qt(o,a,i,c){return new(i||(i=Promise))(function(f,d){function g(T){try{w(c.next(T))}catch(N){d(N)}}function v(T){try{w(c.throw(T))}catch(N){d(N)}}function w(T){T.done?f(T.value):new i(function(N){N(T.value)}).then(g,v)}w((c=c.apply(o,a||[])).next())})}function jt(o,a){var i={label:0,sent:function(){if(d[0]&1)throw d[1];return d[1]},trys:[],ops:[]},c,f,d,g;return g={next:v(0),throw:v(1),return:v(2)},typeof Symbol=="function"&&(g[Symbol.iterator]=function(){return this}),g;function v(T){return function(N){return w([T,N])}}function w(T){if(c)throw new TypeError("Generator is already executing.");for(;i;)try{if(c=1,f&&(d=T[0]&2?f.return:T[0]?f.throw||((d=f.return)&&d.call(f),0):f.next)&&!(d=d.call(f,T[1])).done)return d;(f=0,d)&&(T=[T[0]&2,d.value]);switch(T[0]){case 0:case 1:d=T;break;case 4:return i.label++,{value:T[1],done:!1};case 5:i.label++,f=T[1],T=[0];continue;case 7:T=i.ops.pop(),i.trys.pop();continue;default:if(!(d=i.trys,d=d.length>0&&d[d.length-1])&&(T[0]===6||T[0]===2)){i=0;continue}if(T[0]===3&&(!d||T[1]>d[0]&&T[1]<d[3])){i.label=T[1];break}if(T[0]===6&&i.label<d[1]){i.label=d[1],d=T;break}if(d&&i.label<d[2]){i.label=d[2],i.ops.push(T);break}d[2]&&i.ops.pop(),i.trys.pop();continue}T=a.call(o,i)}catch(N){T=[6,N],f=0}finally{c=d=0}if(T[0]&5)throw T[1];return{value:T[0]?T[1]:void 0,done:!0}}}var HZ=1e-7,qZ=1e-4,jZ=function(){function o(a,i){this.backend=a,this.dataMover=i,this.data=new WeakMap,this.dataIdsCount=0}return o.prototype.get=function(a){return this.data.has(a)||this.dataMover.moveData(this.backend,a),this.data.get(a)},o.prototype.set=function(a,i){this.dataIdsCount++,this.data.set(a,i)},o.prototype.has=function(a){return this.data.has(a)},o.prototype.delete=function(a){return this.dataIdsCount--,this.data.delete(a)},o.prototype.numDataIds=function(){return this.dataIdsCount},o}(),r$=function(){function o(){}return o.prototype.time=function(a){return lt("time")},o.prototype.read=function(a){return lt("read")},o.prototype.readSync=function(a){return lt("readSync")},o.prototype.numDataIds=function(){return lt("numDataIds")},o.prototype.disposeData=function(a){return lt("disposeData")},o.prototype.write=function(a,i,c){return lt("write")},o.prototype.move=function(a,i,c,f){return lt("move")},o.prototype.memory=function(){return lt("memory")},o.prototype.floatPrecision=function(){return lt("floatPrecision")},o.prototype.epsilon=function(){return this.floatPrecision()===32?HZ:qZ},o.prototype.batchMatMul=function(a,i,c,f){return lt("batchMatMul")},o.prototype.fusedBatchMatMul=function(a){var i=a.a,c=a.b,f=a.transposeA,d=a.transposeB,g=a.bias,v=a.activation,w=a.preluActivationWeights;return lt("fusedBatchMatMul")},o.prototype.slice=function(a,i,c){return lt("slice")},o.prototype.stridedSlice=function(a,i,c,f){return lt("stridedSlice")},o.prototype.unstack=function(a,i){return lt("unstack")},o.prototype.reverse=function(a,i){return lt("reverse")},o.prototype.concat=function(a,i){return lt("concat")},o.prototype.neg=function(a){return lt("neg")},o.prototype.add=function(a,i){return lt("add")},o.prototype.addN=function(a){return lt("addN")},o.prototype.subtract=function(a,i){return lt("subtract")},o.prototype.multiply=function(a,i){return lt("multiply")},o.prototype.realDivide=function(a,i){return lt("realDivide")},o.prototype.floorDiv=function(a,i){return lt("floorDiv")},o.prototype.sum=function(a,i){return lt("sum")},o.prototype.prod=function(a,i){return lt("prod")},o.prototype.unsortedSegmentSum=function(a,i,c){return lt("unsortedSegmentSum")},o.prototype.argMin=function(a,i){return lt("argMin")},o.prototype.argMax=function(a,i){return lt("argMax")},o.prototype.equal=function(a,i){return lt("equal")},o.prototype.notEqual=function(a,i){return lt("notEqual")},o.prototype.less=function(a,i){return lt("less")},o.prototype.lessEqual=function(a,i){return lt("lessEqual")},o.prototype.greater=function(a,i){return lt("greater")},o.prototype.greaterEqual=function(a,i){return lt("greaterEqual")},o.prototype.logicalNot=function(a){return lt("logicalNot")},o.prototype.logicalAnd=function(a,i){return lt("logicalAnd")},o.prototype.logicalOr=function(a,i){return lt("logicalOr")},o.prototype.where=function(a){return lt("where")},o.prototype.select=function(a,i,c){return lt("select")},o.prototype.topk=function(a,i,c){return lt("topk")},o.prototype.min=function(a,i){return lt("min")},o.prototype.minimum=function(a,i){return lt("minimum")},o.prototype.mod=function(a,i){return lt("mod")},o.prototype.max=function(a,i){return lt("max")},o.prototype.maximum=function(a,i){return lt("maximum")},o.prototype.all=function(a,i){return lt("all")},o.prototype.any=function(a,i){return lt("any")},o.prototype.squaredDifference=function(a,i){return lt("squaredDifference")},o.prototype.ceil=function(a){return lt("ceil")},o.prototype.floor=function(a){return lt("floor")},o.prototype.round=function(a){return lt("round")},o.prototype.sign=function(a){return lt("sign")},o.prototype.isNaN=function(a){return lt("isNaN")},o.prototype.isInf=function(a){return lt("isInf")},o.prototype.isFinite=function(a){return lt("isFinite")},o.prototype.pow=function(a,i){return lt("pow")},o.prototype.exp=function(a){return lt("exp")},o.prototype.expm1=function(a){return lt("expm1")},o.prototype.softmax=function(a,i){return lt("softmax")},o.prototype.log=function(a){return lt("log")},o.prototype.log1p=function(a){return lt("log1p")},o.prototype.sqrt=function(a){return lt("sqrt")},o.prototype.rsqrt=function(a){return lt("rsqrt")},o.prototype.square=function(a){return lt("square")},o.prototype.reciprocal=function(a){return lt("reciprocal")},o.prototype.relu=function(a){return lt("relu")},o.prototype.relu6=function(a){return lt("relu6")},o.prototype.prelu=function(a,i){return lt("prelu")},o.prototype.elu=function(a){return lt("elu")},o.prototype.eluDer=function(a,i){return lt("eluDer")},o.prototype.selu=function(a){return lt("selu")},o.prototype.int=function(a){return lt("int")},o.prototype.clip=function(a,i,c){return lt("clip")},o.prototype.abs=function(a){return lt("abs")},o.prototype.complexAbs=function(a){return lt("complexAbs")},o.prototype.sigmoid=function(a){return lt("sigmoid")},o.prototype.softplus=function(a){return lt("softplus")},o.prototype.sin=function(a){return lt("sin")},o.prototype.cos=function(a){return lt("cos")},o.prototype.tan=function(a){return lt("tan")},o.prototype.asin=function(a){return lt("asin")},o.prototype.acos=function(a){return lt("acos")},o.prototype.atan=function(a){return lt("atan")},o.prototype.atan2=function(a,i){return lt("atan2")},o.prototype.sinh=function(a){return lt("sinh")},o.prototype.cosh=function(a){return lt("cosh")},o.prototype.tanh=function(a){return lt("tanh")},o.prototype.asinh=function(a){return lt("asinh")},o.prototype.acosh=function(a){return lt("acosh")},o.prototype.atanh=function(a){return lt("atanh")},o.prototype.erf=function(a){return lt("erf")},o.prototype.step=function(a,i){return lt("step")},o.prototype.fusedConv2d=function(a){var i=a.input,c=a.filter,f=a.convInfo,d=a.bias,g=a.activation,v=a.preluActivationWeights;return lt("fusedConv2d")},o.prototype.conv2d=function(a,i,c){return lt("conv2d")},o.prototype.conv2dDerInput=function(a,i,c){return lt("conv2dDerInput")},o.prototype.conv2dDerFilter=function(a,i,c){return lt("conv2dDerFilter")},o.prototype.fusedDepthwiseConv2D=function(a){var i=a.input,c=a.filter,f=a.convInfo,d=a.bias,g=a.activation,v=a.preluActivationWeights;return lt("fusedDepthwiseConv2D")},o.prototype.depthwiseConv2D=function(a,i,c){return lt("depthwiseConv2D")},o.prototype.depthwiseConv2DDerInput=function(a,i,c){return lt("depthwiseConv2DDerInput")},o.prototype.depthwiseConv2DDerFilter=function(a,i,c){return lt("depthwiseConv2DDerFilter")},o.prototype.conv3d=function(a,i,c){return lt("conv3d")},o.prototype.conv3dDerInput=function(a,i,c){return lt("conv3dDerInput")},o.prototype.conv3dDerFilter=function(a,i,c){return lt("conv3dDerFilter")},o.prototype.maxPool=function(a,i){return lt("maxPool")},o.prototype.maxPoolBackprop=function(a,i,c,f){return lt("maxPoolBackprop")},o.prototype.avgPool=function(a,i){return lt("avgPool")},o.prototype.avgPoolBackprop=function(a,i,c){return lt("avgPoolBackprop")},o.prototype.avgPool3d=function(a,i){return lt("avgPool3d")},o.prototype.avgPool3dBackprop=function(a,i,c){return lt("avgPool3dBackprop")},o.prototype.maxPool3d=function(a,i){return lt("maxPool3d")},o.prototype.maxPool3dBackprop=function(a,i,c,f){return lt("maxPool3dBackprop")},o.prototype.reshape=function(a,i){return lt("reshape")},o.prototype.cast=function(a,i){return lt("cast")},o.prototype.tile=function(a,i){return lt("tile")},o.prototype.pad=function(a,i,c){return lt("pad")},o.prototype.transpose=function(a,i){return lt("transpose")},o.prototype.gather=function(a,i,c){return lt("gather")},o.prototype.gatherND=function(a,i){return lt("gatherND")},o.prototype.scatterND=function(a,i,c){return lt("scatterND")},o.prototype.batchToSpaceND=function(a,i,c){return lt("batchToSpaceND")},o.prototype.spaceToBatchND=function(a,i,c){return lt("spaceToBatchND")},o.prototype.resizeBilinear=function(a,i,c,f){return lt("resizeBilinear")},o.prototype.resizeBilinearBackprop=function(a,i,c){return lt("resizeBilinearBackprop")},o.prototype.resizeNearestNeighbor=function(a,i,c,f){return lt("resizeNearestNeighbor")},o.prototype.resizeNearestNeighborBackprop=function(a,i,c){return lt("resizeNearestNeighborBackprop")},o.prototype.batchNorm=function(a,i,c,f,d,g){return lt("batchNorm")},o.prototype.localResponseNormalization4D=function(a,i,c,f,d){return lt("localResponseNormalization4D")},o.prototype.LRNGrad=function(a,i,c,f,d,g,v){return lt("LRNGrad")},o.prototype.multinomial=function(a,i,c,f){return lt("multinomial")},o.prototype.oneHot=function(a,i,c,f){return lt("oneHot")},o.prototype.cumsum=function(a,i,c,f){return lt("cumsum")},o.prototype.nonMaxSuppression=function(a,i,c,f,d){return lt("nonMaxSuppression")},o.prototype.fft=function(a){return lt("fft")},o.prototype.ifft=function(a){return lt("ifft")},o.prototype.complex=function(a,i){return lt("complex")},o.prototype.real=function(a){return lt("real")},o.prototype.imag=function(a){return lt("imag")},o.prototype.cropAndResize=function(a,i,c,f,d,g){return lt("cropAndResize")},o.prototype.depthToSpace=function(a,i,c){return lt("depthToSpace")},o.prototype.split=function(a,i,c){return lt("split")},o.prototype.sparseToDense=function(a,i,c,f){return lt("sparseToDense")},o.prototype.diag=function(a){return lt("diag")},o.prototype.fill=function(a,i,c){return lt("fill")},o.prototype.onesLike=function(a){return lt("onesLike")},o.prototype.zerosLike=function(a){return lt("zerosLike")},o.prototype.linspace=function(a,i,c){return lt("linspace")},o.prototype.dispose=function(){return lt("dispose")},o}();function lt(o){throw new Error("'"+o+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function s$(o){for(var a=o.length,i=0,c=0;a>0;)c=Math.random()*a|0,a--,i=o[a],o[a]=o[c],o[c]=i}function Ff(o,a,i){return Math.max(o,Math.min(a,i))}function KZ(o){return o%2===0?o:o+1}function XZ(o){for(var a=0,i=0;i<o.length;i++)a+=o[i];return a}function YZ(o,a){var i=Math.random();return a*i+(1-i)*o}function JZ(o,a){for(var i=0,c=0;c<o.length;c++){var f=Number(o[c])-Number(a[c]);i+=f*f}return i}function U(o,a){if(!o)throw new Error(typeof a=="string"?a:a())}function Ee(o,a,i){i===void 0&&(i=""),U(Rs(o,a),function(){return i+(" Shapes "+o+" and "+a+" must match")})}function zi(o){U(o!=null,function(){return"The input to the tensor constructor must be a non-null value."})}function Wi(o,a,i){if(a===void 0&&(a=[]),i===void 0&&(i=!1),a==null&&(a=[]),Array.isArray(o)||Jn(o)&&!i)for(var c=0;c<o.length;++c)Wi(o[c],a,i);else a.push(o);return a}function mn(o){if(o.length===0)return 1;for(var a=o[0],i=1;i<o.length;i++)a*=o[i];return a}function ZZ(o){return o.length===0}function Rs(o,a){if(o===a)return!0;if(o==null||a==null)return!1;if(o.length!==a.length)return!1;for(var i=0;i<o.length;i++)if(o[i]!==a[i])return!1;return!0}function fn(o){return o%1===0}function QZ(o){if(Math.tanh!=null)return Math.tanh(o);if(o===Infinity)return 1;if(o===-Infinity)return-1;var a=Math.exp(2*o);return(a-1)/(a+1)}function tQ(o){var a=Math.ceil(Math.sqrt(o));return[a,Math.ceil(o/a)]}function eQ(o){for(var a=new Uint32Array(o),i=0;i<o;++i)a[i]=i;return s$(a),a}function Rf(o,a){return a<=o.length?o:o+" ".repeat(a-o.length)}function nQ(o,a,i){return a===void 0&&(a=function(c){return 0}),new Promise(function(c,f){var d=0,g=function(){if(o()){c();return}d++;var v=a(d);if(i!=null&&d>=i){f();return}setTimeout(g,v)};g()})}function o$(o,a){for(var i=1,c=-1,f=0;f<o.length;++f)if(o[f]>=0)i*=o[f];else if(o[f]===-1){if(c!==-1)throw Error("Shapes can only have 1 implicit size. "+("Found -1 at dim "+c+" and dim "+f));c=f}else if(o[f]<0)throw Error("Shapes can not be < 0. Found "+o[f]+" at dim "+f);if(c===-1){if(a>0&&a!==i)throw Error("Size("+a+") must match the product of shape "+o);return o}if(i===0)throw Error("Cannot infer the missing size in ["+o+"] when there are 0 elements");if(a%i!==0)throw Error("The implicit shape can't be a fractional number. "+("Got "+a+" / "+i));var d=o.slice();return d[c]=a/i,d}function Qe(o,a){var i=a.length;return o=o==null?a.map(function(c,f){return f}):[].concat(o),U(o.every(function(c){return c>=-i&&c<i}),function(){return"All values in axis param must be in range [-"+i+", "+i+") but "+("got axis "+o)}),U(o.every(function(c){return fn(c)}),function(){return"All values in axis param must be integers but "+("got axis "+o)}),o.map(function(c){return c<0?i+c:c})}function a$(o,a){for(var i=[],c=[],f=a!=null&&Array.isArray(a)&&a.length===0,d=a==null||f?null:Qe(a,o).sort(),g=0,v=0;v<o.length;++v){if(d!=null){if(d[g]===v&&o[v]!==1)throw new Error("Can't squeeze axis "+v+" since its dim '"+o[v]+"' is not 1");(d[g]==null||d[g]>v)&&o[v]===1&&(i.push(o[v]),c.push(v)),d[g]<=v&&g++}o[v]!==1&&(i.push(o[v]),c.push(v))}return{newShape:i,keptDims:c}}function ug(o,a){var i=null;if(o==null||o==="float32")i=new Float32Array(a);else if(o==="int32")i=new Int32Array(a);else if(o==="bool")i=new Uint8Array(a);else throw new Error("Unknown data type "+o);return i}function i$(o,a){var i=null;if(o==null||o==="float32")i=new Float32Array(a);else if(o==="int32")i=new Int32Array(a);else if(o==="bool")i=new Uint8Array(a);else if(o==="string")i=new Array(a);else throw new Error("Unknown data type "+o);return i}function u$(o,a){for(var i=0;i<o.length;i++){var c=o[i];if(isNaN(c)||!isFinite(c))throw Error("A tensor of type "+a+" being uploaded contains "+c+".")}}function c$(o){return o==="bool"||o==="complex64"||o==="float32"||o==="int32"||o==="string"}function l$(o,a){return a==="complex64"||(a==="float32"&&o!=="complex64"||a==="int32"&&o!=="float32"&&o!=="complex64")?!1:!(a==="bool"&&o==="bool")}function Jn(o){return o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array}function h$(o){if(o==="float32"||o==="int32")return 4;if(o==="complex64")return 8;if(o==="bool")return 1;throw new Error("Unknown dtype "+o)}function f$(o){if(o==null)return 0;var a=0;return o.forEach(function(i){return a+=i.length}),a}function Oa(o){return typeof o=="string"||o instanceof String}function p$(o){return typeof o=="boolean"}function d$(o){return typeof o=="number"}function cg(o){return Array.isArray(o)?cg(o[0]):o instanceof Float32Array?"float32":o instanceof Int32Array||o instanceof Uint8Array?"int32":d$(o)?"float32":Oa(o)?"string":p$(o)?"bool":"float32"}function Ma(o){return!!(o&&o.constructor&&o.call&&o.apply)}function lg(o,a){for(var i=a;i<o;++i)if(o%i===0)return i;return o}function Nc(o){var a=o.length;if(a<2)return[];var i=new Array(a-1);i[a-2]=o[a-1];for(var c=a-3;c>=0;--c)i[c]=i[c+1]*o[c+1];return i}function m$(o,a,i){var c=new Array;if(a.length===1)for(var f=a[0],d=0;d<f;d++)c[d]=i[o+d];else for(var f=a[0],g=a.slice(1),v=g.reduce(function(T,N){return T*N}),d=0;d<f;d++)c[d]=m$(o+d*v,g,i);return c}function Ic(o,a){if(o.length===0)return a[0];var i=o.reduce(function(c,f){return c*f});if(i===0)return[];if(i!==a.length)throw new Error("["+o+"] does not match the input size "+a.length+".");return m$(0,o,a)}function qx(o,a){for(var i=Ec(o,a),c=0;c<i.length;c++)i[c]=1;return i}function Ec(o,a){if(a==null||a==="float32"||a==="complex64")return new Float32Array(o);if(a==="int32")return new Int32Array(o);if(a==="bool")return new Uint8Array(o);throw new Error("Unknown data type "+a)}function rQ(o,a){var i=o.reduce(function(c,f){return c*f},1);if(a==null||a==="float32")return Ic(o,new Float32Array(i));if(a==="int32")return Ic(o,new Int32Array(i));if(a==="bool")return Ic(o,new Uint8Array(i));throw new Error("Unknown data type "+a)}function jx(o){o.forEach(function(a){U(Number.isInteger(a)&&a>=0,function(){return"Tensor must have a shape comprised of positive integers but got "+("shape ["+o+"].")})})}function sQ(o,a,i){if(a===0)return 0;if(a===1)return o[0];for(var c=o[o.length-1],f=0;f<o.length-1;++f)c+=i[f]*o[f];return c}function oQ(o,a,i){if(a===0)return[];if(a===1)return[o];for(var c=new Array(a),f=0;f<c.length-1;++f)c[f]=Math.floor(o/i[f]),o-=c[f]*i[f];return c[c.length-1]=o,c}function Kx(o){return o&&o.then&&typeof o.then=="function"}var g$="tfjsflags",v$=function(){function o(a){this.global=a,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return o.prototype.setPlatform=function(a,i){this.platform!=null&&console.warn("Platform "+this.platformName+" has already been set. "+("Overwriting the platform with "+i+".")),this.platformName=a,this.platform=i},o.prototype.registerFlag=function(a,i,c){if(this.flagRegistry[a]={evaluationFn:i,setHook:c},this.urlFlags[a]!=null){var f=this.urlFlags[a];console.warn("Setting feature override from URL "+a+": "+f+"."),this.set(a,f)}},o.prototype.getAsync=function(a){return qt(this,void 0,void 0,function(){var i,c;return jt(this,function(f){switch(f.label){case 0:return a in this.flags?[2,this.flags[a]]:(i=this.flags,c=a,[4,this.evaluateFlag(a)]);case 1:return i[c]=f.sent(),[2,this.flags[a]]}})})},o.prototype.get=function(a){if(a in this.flags)return this.flags[a];var i=this.evaluateFlag(a);if(Kx(i))throw new Error("Flag "+a+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[a]=i,this.flags[a]},o.prototype.getNumber=function(a){return this.get(a)},o.prototype.getBool=function(a){return this.get(a)},o.prototype.getFlags=function(){return this.flags},Object.defineProperty(o.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),o.prototype.set=function(a,i){if(this.flagRegistry[a]==null)throw new Error("Cannot set flag "+a+" as it has not been registered.");this.flags[a]=i,this.flagRegistry[a].setHook!=null&&this.flagRegistry[a].setHook(i)},o.prototype.evaluateFlag=function(a){if(this.flagRegistry[a]==null)throw new Error("Cannot evaluate flag '"+a+"': no evaluation function found.");return this.flagRegistry[a].evaluationFn()},o.prototype.setFlags=function(a){this.flags=Object.assign({},a)},o.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},o.prototype.populateURLFlags=function(){var a=this;if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;var i=aQ(this.global.location.search);if(g$ in i){var c=i[g$].split(",");c.forEach(function(f){var d=f.split(":"),g=d[0],v=d[1];a.urlFlags[g]=iQ(g,v)})}},o}();function aQ(o){var a={};return o.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,function(i){for(var c=[],f=1;f<arguments.length;f++)c[f-1]=arguments[f];return uQ(a,c[0],c[1]),c.join("=")}),a}function uQ(o,a,i){o[decodeURIComponent(a)]=decodeURIComponent(i||"")}function iQ(o,a){if(a=a.toLowerCase(),a==="true"||a==="false")return a==="true";if(""+ +a===a)return+a;throw new Error("Could not parse value flag value "+a+" for flag "+o+".")}function Fe(){return F.ENV}F.ENV=null;function cQ(o){F.ENV=o}var Xx;function y$(){if(Xx==null){var o=void 0;if(typeof window!="undefined")o=window;else if(typeof global!="undefined")o=global;else if(typeof process!="undefined")o=process;else if(typeof self!="undefined")o=self;else throw new Error("Could not find a global object");Xx=o}return Xx}function lQ(){var o=y$();return o._tfGlobals==null&&(o._tfGlobals=new Map),o._tfGlobals}function b$(o,a){var i=lQ();if(i.has(o))return i.get(o);var c=a();return i.set(o,c),i.get(o)}var Yx="Abs",Jx="Acos",Zx="Acosh",hg="Add",Qx="AddN",w$="All",x$="Any",t1="ArgMax",e1="ArgMin",n1="Asin",r1="Asinh",s1="Atan",o1="Atanh",a1="Atan2",i1="AvgPool",T$="AvgPoolBackprop",u1="AvgPool3D",k$="AvgPool3DBackprop",c1="BatchMatMul",l1="BatchToSpaceND",h1="BroadcastTo",fg="Cast",f1="Ceil",p1="ClipByValue",S$="Complex",d1="Concat",m1="Conv2D",C$="Conv2DBackpropFilter",g1="Conv2DBackpropInput",v1="Conv3D",N$="Conv3DBackpropFilterV2",I$="Conv3DBackpropInputV2",y1="Cos",b1="Cosh",w1="Cumsum",E$="CropAndResize",D$="DepthToSpace",x1="DepthwiseConv2dNative",$$="DepthwiseConv2dNativeBackpropFilter",A$="DepthwiseConv2dNativeBackpropInput",_$="Diag",T1="Dilation2D",F$="Dilation2DBackpropInput",R$="Dilation2DBackpropFilter",k1="Div",S1="Elu",P$="EluGrad",C1="Erf",O$="Equal",N1="Exp",I1="Expm1",M$="FFT",L$="Fill",B$="FlipLeftRight",E1="Floor",D1="FloorDiv",$1="FusedBatchNorm",A1="GatherV2",z$="GatherNd",W$="Greater",_1="GreaterEqual",F1="Identity",V$="IFFT",U$="Imag",R1="IsFinite",P1="IsInf",O1="IsNan",G$="Less",H$="LessEqual",q$="LinSpace",M1="Log",L1="Log1p",j$="LogicalAnd",K$="LogicalNot",X$="LogicalOr",B1="LogSoftmax",z1="LRN",Y$="LRNBackprop",W1="Max",V1="Maximum",U1="MaxPool",J$="MaxPoolBackprop",G1="MaxPool3D",Z$="MaxPool3DBackprop",Q$="MaxPoolWithArgmax",tA="Mean",H1="Min",q1="Minimum",j1="MirrorPad",K1="Mod",X1="Multiply",Y1="Negate",eA="NotEqual",nA="NonMaxSuppressionV3",rA="NonMaxSuppressionV4",sA="NonMaxSuppressionV5",J1="OnesLike",Z1="OneHot",Q1="PadV2",hQ="Pool",tT="Pow",eT="Prelu",oA="Prod",aA="Range",iA="Real",nT="Reciprocal",rT="Relu",sT="Reshape",oT="ResizeNearestNeighbor",uA="ResizeNearestNeighborGrad",aT="ResizeBilinear",cA="ResizeBilinearGrad",iT="Relu6",uT="Reverse",cT="Round",lT="Rsqrt",lA="ScatterNd",hT="SelectV2",fT="Selu",pT="Slice",dT="Sin",mT="Sinh",gT="Sign",vT="Sigmoid",yT="Softplus",bT="Sqrt",wT="Sum",xT="SpaceToBatchND",TT="SplitV",kT="Softmax",ST="SquaredDifference",hA="Square",CT="Sub",fA="SparseToDense",pA="StridedSlice",NT="Tan",IT="Tanh",ET="Tile",dA="TopK",DT="Transpose",mA="Unique",$T="Unpack",AT="UnsortedSegmentSum",_T="ZerosLike",FT="Step",RT="FromPixels",gA="RotateWithOffset",PT="_FusedMatMul",OT="FusedConv2D",MT="FusedDepthwiseConv2D";var Dc=b$("kernelRegistry",function(){return new Map}),Pf=b$("gradRegistry",function(){return new Map});function BT(o,a){var i=LT(o,a);return Dc.get(i)}function zT(o){return Pf.get(o)}function pg(o){for(var a=Dc.entries(),i=[];;){var c=a.next(),f=c.done,d=c.value;if(f)break;var g=d[0],v=d[1],w=g.split("_")[0];w===o&&i.push(v)}return i}function vA(o){var a=o.kernelName,i=o.backendName,c=LT(a,i);Dc.has(c)&&console.warn("The kernel '"+a+"' for backend "+("'"+i+"' is already registered")),Dc.set(c,o)}function yA(o){var a=o.kernelName;Pf.has(a)&&(Fe().getBool("DEBUG")&&console.warn("Overriding the gradient for '"+a+"'")),Pf.set(a,o)}function fQ(o,a){var i=LT(o,a);if(!Dc.has(i))throw new Error("The kernel '"+o+"' for backend "+("'"+a+"' is not registered"));Dc.delete(i)}function pQ(o){if(!Pf.has(o))throw new Error("The gradient '"+o+"' for backend is not registered");Pf.delete(o)}function dQ(o,a){var i=pg(o);i.forEach(function(c){var f=Object.assign({},c,{backendName:a});vA(f)})}function LT(o,a){return a+"_"+o}function mQ(o,a){return a==="string"?WT(o):dg([o],a)}function gQ(o,a){return o instanceof Float32Array&&a==="float32"||o instanceof Int32Array&&a==="int32"||o instanceof Uint8Array&&a==="bool"}function dg(o,a){if(a==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(o)&&(o=Wi(o)),Fe().getBool("DEBUG")&&u$(o,a),gQ(o,a))return o;if(a==null||a==="float32"||a==="complex64")return new Float32Array(o);if(a==="int32")return new Int32Array(o);if(a==="bool"){for(var i=new Uint8Array(o.length),c=0;c<i.length;++c)Math.round(o[c])!==0&&(i[c]=1);return i}else throw new Error("Unknown data type "+a)}function VT(){return Fe().platform.now()}function vQ(o,a){return Fe().platform.fetch(o,a)}function WT(o,a){return a===void 0&&(a="utf-8"),a=a||"utf-8",Fe().platform.encode(o,a)}function UT(o,a){return a===void 0&&(a="utf-8"),a=a||"utf-8",Fe().platform.decode(o,a)}var yQ={__proto__:null,createScalarValue:mQ,toTypedArray:dg,now:VT,fetch:vQ,encodeString:WT,decodeString:UT,shuffle:s$,clamp:Ff,nearestLargerEven:KZ,sum:XZ,randUniform:YZ,distSquared:JZ,assert:U,assertShapesMatch:Ee,assertNonNull:zi,flatten:Wi,sizeFromShape:mn,isScalarShape:ZZ,arraysEqual:Rs,isInt:fn,tanh:QZ,sizeToSquarishShape:tQ,createShuffledIndices:eQ,rightPad:Rf,repeatedTry:nQ,inferFromImplicitShape:o$,parseAxisParam:Qe,squeezeShape:a$,getTypedArrayFromDType:ug,getArrayFromDType:i$,checkConversionForErrors:u$,isValidDtype:c$,hasEncodingLoss:l$,isTypedArray:Jn,bytesPerElement:h$,bytesFromStringArray:f$,isString:Oa,isBoolean:p$,isNumber:d$,inferDtype:cg,isFunction:Ma,nearestDivisor:lg,computeStrides:Nc,toNestedArray:Ic,makeOnesTypedArray:qx,makeZerosTypedArray:Ec,makeZerosNestedTypedArray:rQ,assertNonNegativeIntegerDimensions:jx,locToIndex:sQ,indexToLoc:oQ,isPromise:Kx};var xQ=function(){function o(a,i){this.backendTimer=a,this.logger=i,i==null&&(this.logger=new wQ)}return o.prototype.profileKernel=function(a,i,c){for(var f,d=function(){f=c()},g=this.backendTimer.time(d),v=function(N){var E=f[N];E.data().then(function(k){bQ(k,E.dtype,a)})},w=0;w<f.length;w++)v(w);var T={kernelName:a,outputs:f,inputs:i,timeMs:g.then(function(N){return N.kernelMs}),extraInfo:g.then(function(N){return N.getExtraProfileInfo!=null?N.getExtraProfileInfo():""})};return T},o.prototype.logKernelProfile=function(a){var i=this,c=a.kernelName,f=a.outputs,d=a.timeMs,g=a.inputs,v=a.extraInfo;f.forEach(function(w){Promise.all([w.data(),d,v]).then(function(T){i.logger.logKernelProfile(c,w,T[0],T[1],g,T[2])})})},o}();function bQ(o,a,i){if(a!=="float32")return!1;for(var c=0;c<o.length;c++){var f=o[c];if(isNaN(f)||!isFinite(f))return console.warn("Found "+f+" in the result of '"+i+"'"),!0}return!1}var wQ=function(){function o(){}return o.prototype.logKernelProfile=function(a,i,c,f,d,g){var v=typeof f=="number"?Rf(f+"ms",9):f.error,w=Rf(a,25),T=i.rank,N=i.size,E=Rf(i.shape.toString(),14),k="";for(var $ in d){var M=d[$];if(M!=null){var G=M.shape||i.shape,O=G.length;k+=$+": "+O+"D "+(O>0?G:"")+" "}}console.log("%c"+w+"	%c"+v+"	%c"+T+"D "+E+"	%c"+N+"	%c"+k+"	%c"+g,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},o}();function TQ(o,a,i){for(var c={},f={},d=0;d<a.length;d++)c[a[d].id]=!0;for(var d=0;d<o.length;d++){var g=o[d],v=g.inputs;for(var w in v){for(var T=v[w],N=!1,E=0;E<a.length;E++)if(c[T.id]){g.outputs.forEach(function(nt){return c[nt.id]=!0}),N=!0,f[g.id]=!0;break}if(N)break}}var k={};k[i.id]=!0;for(var $={},d=o.length-1;d>=0;d--)for(var g=o[d],v=g.inputs,E=0;E<g.outputs.length;E++)if(k[g.outputs[E].id]){for(var w in v)k[v[w].id]=!0,$[g.id]=!0;break}for(var M=[],d=0;d<o.length;d++){var g=o[d];if(f[g.id]&&$[g.id]){var G={};for(var w in g.inputs){var O=g.inputs[w];c[O.id]&&(G[w]=O)}var H=Object.assign({},g);H.inputs=G,H.outputs=g.outputs,M.push(H)}}return M}function kQ(o,a,i,c){for(var f=function(g){var v=a[g],w=[];if(v.outputs.forEach(function(k){var $=o[k.id];$!=null?w.push($):w.push(null)}),v.gradient==null)throw new Error("Cannot compute gradient: gradient function not found "+("for "+v.kernelName+"."));var T=v.gradient(w),N=function(k){if(!(k in T))throw new Error("Cannot backprop through input "+k+". "+("Available gradients found: "+Object.keys(T)+"."));var $=i(function(){return T[k]()});if($.dtype!=="float32")throw new Error("Error in gradient for op "+v.kernelName+". The gradient of input "+(k+" must have 'float32' dtype, but has '"+$.dtype+"'"));var M=v.inputs[k];if(!Rs($.shape,M.shape))throw new Error("Error in gradient for op "+v.kernelName+". The gradient of input "+("'"+k+"' has shape '"+$.shape+"', which does not match ")+("the shape of the input '"+M.shape+"'"));if(o[M.id]==null)o[M.id]=$;else{var G=o[M.id];o[M.id]=c(G,$),G.dispose()}};for(var E in v.inputs)N(E)},d=a.length-1;d>=0;d--)f(d)}var bA=20,Of=3,GT=7;function CQ(o,a,i,c){var f=Nc(a),d=SQ(o,a,i,f),g=a.length,v=mg(o,a,i,f,d),w=["Tensor"];return c&&(w.push("  dtype: "+i),w.push("  rank: "+g),w.push("  shape: ["+a+"]"),w.push("  values:")),w.push(v.map(function(T){return"    "+T}).join(`
`)),w.join(`
`)}function SQ(o,a,i,c){var f=mn(a),d=c[c.length-1],g=new Array(d).fill(0),v=a.length,w=i==="complex64"?Lf(o):o;if(v>1)for(var T=0;T<f/d;T++)for(var N=T*d,E=0;E<d;E++)g[E]=Math.max(g[E],Mf(w[N+E],0,i).length);return g}function Mf(o,a,i){var c;return Array.isArray(o)?c=parseFloat(o[0].toFixed(GT))+" + "+(parseFloat(o[1].toFixed(GT))+"j"):Oa(o)?c="'"+o+"'":i==="bool"?c=wA(o):c=parseFloat(o.toFixed(GT)).toString(),Rf(c,a)}function wA(o){return o===0?"false":"true"}function mg(o,a,i,c,f,d){d===void 0&&(d=!0);var g=i==="complex64"?2:1,v=a[0],w=a.length;if(w===0){if(i==="complex64"){var T=Lf(o);return[Mf(T[0],0,i)]}return i==="bool"?[wA(o[0])]:[o[0].toString()]}if(w===1){if(v>bA){var N=Of*g,E=Array.from(o.slice(0,N)),k=Array.from(o.slice((v-Of)*g,v*g));return i==="complex64"&&(E=Lf(E),k=Lf(k)),["["+E.map(function(St,It){return Mf(St,f[It],i)}).join(", ")+", ..., "+k.map(function(St,It){return Mf(St,f[v-Of+It],i)}).join(", ")+"]"]}var $=i==="complex64"?Lf(o):Array.from(o);return["["+$.map(function(St,It){return Mf(St,f[It],i)}).join(", ")+"]"]}var M=a.slice(1),G=c.slice(1),O=c[0]*g,H=[];if(v>bA){for(var K=0;K<Of;K++){var nt=K*O,ct=nt+O;H.push.apply(H,mg(o.slice(nt,ct),M,i,G,f,!1))}H.push("...");for(var K=v-Of;K<v;K++){var nt=K*O,ct=nt+O;H.push.apply(H,mg(o.slice(nt,ct),M,i,G,f,K===v-1))}}else for(var K=0;K<v;K++){var nt=K*O,ct=nt+O;H.push.apply(H,mg(o.slice(nt,ct),M,i,G,f,K===v-1))}var dt=w===2?",":"";H[0]="["+H[0]+dt;for(var K=1;K<H.length-1;K++)H[K]=" "+H[K]+dt;for(var Ct=`,
`,K=2;K<w;K++)Ct+=`
`;return H[H.length-1]=" "+H[H.length-1]+"]"+(d?"":Ct),H}function Lf(o){for(var a=[],i=0;i<o.length;i+=2)a.push([o[i],o[i+1]]);return a}var gg=function(){function o(a,i,c){var f=this;if(this.dtype=i,this.shape=a.slice(),this.size=mn(a),c!=null){var d=c.length;U(d===this.size,function(){return"Length of values '"+d+"' does not match the size "+("inferred by the shape '"+f.size+"'.")})}if(i==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=c||i$(i,this.size),this.strides=Nc(a)}return o.prototype.set=function(a){for(var i=this,c=[],f=1;f<arguments.length;f++)c[f-1]=arguments[f];c.length===0&&(c=[0]),U(c.length===this.rank,function(){return"The number of provided coordinates ("+c.length+") must "+("match the rank ("+i.rank+")")});var d=this.locToIndex(c);this.values[d]=a},o.prototype.get=function(){for(var a=[],i=0;i<arguments.length;i++)a[i]=arguments[i];a.length===0&&(a=[0]);for(var c=0,f=0,d=a;f<d.length;f++){var g=d[f];if(g<0||g>=this.shape[c]){var v="Requested out of range element at "+a+". "+("  Buffer shape="+this.shape);throw new Error(v)}c++}for(var w=a[a.length-1],T=0;T<a.length-1;++T)w+=this.strides[T]*a[T];return this.values[w]},o.prototype.locToIndex=function(a){if(this.rank===0)return 0;if(this.rank===1)return a[0];for(var i=a[a.length-1],c=0;c<a.length-1;++c)i+=this.strides[c]*a[c];return i},o.prototype.indexToLoc=function(a){if(this.rank===0)return[];if(this.rank===1)return[a];for(var i=new Array(this.shape.length),c=0;c<i.length-1;++c)i[c]=Math.floor(a/this.strides[c]),a-=i[c]*this.strides[c];return i[i.length-1]=a,i},Object.defineProperty(o.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),o.prototype.toTensor=function(){return io().makeTensor(this.values,this.shape,this.dtype)},o}(),io=null,$c=null;function NQ(o){io=o}function IQ(o){$c=o}var ut=function(){function o(a,i,c,f){this.kept=!1,this.isDisposedInternal=!1,this.shape=a.slice(),this.dtype=i||"float32",this.size=mn(a),this.strides=Nc(a),this.dataId=c,this.id=f,this.rankType=this.rank<5?this.rank.toString():"higher"}return Object.defineProperty(o.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),o.prototype.buffer=function(){return qt(this,void 0,void 0,function(){var a;return jt(this,function(i){switch(i.label){case 0:return[4,this.data()];case 1:return a=i.sent(),[2,$c.buffer(this.shape,this.dtype,a)]}})})},o.prototype.bufferSync=function(){return $c.buffer(this.shape,this.dtype,this.dataSync())},o.prototype.array=function(){return qt(this,void 0,void 0,function(){var a;return jt(this,function(i){switch(i.label){case 0:return[4,this.data()];case 1:return a=i.sent(),[2,Ic(this.shape,a)]}})})},o.prototype.arraySync=function(){return Ic(this.shape,this.dataSync())},o.prototype.data=function(){return qt(this,void 0,void 0,function(){var a,i;return jt(this,function(c){switch(c.label){case 0:return this.throwIfDisposed(),a=io().read(this.dataId),this.dtype==="string"?[4,a]:[3,2];case 1:i=c.sent();try{return[2,i.map(function(f){return UT(f)})]}catch(f){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}c.label=2;case 2:return[2,a]}})})},o.prototype.dataSync=function(){this.throwIfDisposed();var a=io().readSync(this.dataId);if(this.dtype==="string")try{return a.map(function(i){return UT(i)})}catch(i){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return a},o.prototype.bytes=function(){return qt(this,void 0,void 0,function(){var a;return jt(this,function(i){switch(i.label){case 0:return this.throwIfDisposed(),[4,io().read(this.dataId)];case 1:return a=i.sent(),this.dtype==="string"?[2,a]:[2,new Uint8Array(a.buffer)]}})})},o.prototype.dispose=function(){if(this.isDisposed)return;io().disposeTensor(this),this.isDisposedInternal=!0},Object.defineProperty(o.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),o.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},o.prototype.print=function(a){return a===void 0&&(a=!1),$c.print(this,a)},o.prototype.clone=function(){return this.throwIfDisposed(),$c.clone(this)},o.prototype.toString=function(a){a===void 0&&(a=!1);var i=this.dataSync();return CQ(i,this.shape,this.dtype,a)},o.prototype.cast=function(a){return this.throwIfDisposed(),$c.cast(this,a)},o.prototype.variable=function(a,i,c){return a===void 0&&(a=!0),this.throwIfDisposed(),io().makeVariable(this,a,i,c)},o}();Object.defineProperty(ut,Symbol.hasInstance,{value:function(o){return!!o&&o.data!=null&&o.dataSync!=null&&o.throwIfDisposed!=null}});var Bf=function(o){Uo(a,o);function a(i,c,f,d){var g=o.call(this,i.shape,i.dtype,i.dataId,d)||this;return g.trainable=c,g.name=f,g}return a.prototype.assign=function(i){if(i.dtype!==this.dtype)throw new Error("dtype of the new value ("+i.dtype+") and "+("previous value ("+this.dtype+") must match"));if(!Rs(i.shape,this.shape))throw new Error("shape of the new value ("+i.shape+") and "+("previous value ("+this.shape+") must match"));io().disposeTensor(this),this.dataId=i.dataId,io().incRef(this,null)},a.prototype.dispose=function(){io().disposeVariable(this),this.isDisposedInternal=!0},a}(ut);Object.defineProperty(Bf,Symbol.hasInstance,{value:function(o){return o instanceof ut&&o.assign!=null&&o.assign instanceof Function}});(function(o){o.R0="R0",o.R1="R1",o.R2="R2",o.R3="R3",o.R4="R4",o.R5="R5",o.R6="R6"})(F.Rank||(F.Rank={}));var HT;(function(o){o.float32="float32",o.int32="int32",o.bool="int32",o.complex64="complex64"})(HT||(HT={}));var qT;(function(o){o.float32="float32",o.int32="int32",o.bool="bool",o.complex64="complex64"})(qT||(qT={}));var jT;(function(o){o.float32="float32",o.int32="float32",o.bool="float32",o.complex64="complex64"})(jT||(jT={}));var KT;(function(o){o.float32="complex64",o.int32="complex64",o.bool="complex64",o.complex64="complex64"})(KT||(KT={}));var EQ={float32:jT,int32:HT,bool:qT,complex64:KT};function vg(o,a){if(o==="string"||a==="string"){if(o==="string"&&a==="string")return"string";throw new Error("Can not upcast "+o+" with "+a)}return EQ[o][a]}function DQ(o){return vg(o,"int32")}function pn(o,a){if(o.dtype===a.dtype)return[o,a];var i=vg(o.dtype,a.dtype);return[o.cast(i),a.cast(i)]}function xA(o,a){U(o.dtype===a.dtype,function(){return"The dtypes of the first("+o.dtype+") and"+(" second("+a.dtype+") input must match")})}function $Q(o,a){return a.some(function(i){return i.id===o.id})}function XT(o){var a=[],i=new Set;return TA(o,a,i),a}function TA(o,a,i){if(o==null)return;if(o instanceof ut){a.push(o);return}if(!AQ(o))return;var c=o;for(var f in c){var d=c[f];i.has(d)||(i.add(d),TA(d,a,i))}}function AQ(o){return Array.isArray(o)||typeof o=="object"}var _Q={__proto__:null,makeTypesMatch:pn,assertTypesMatch:xA,isTensorInList:$Q,getTensorsInContainer:XT};var kA=function(){function o(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return o.prototype.dispose=function(){for(var a in this.registeredVariables)this.registeredVariables[a].dispose()},o}(),PQ=function(){function o(a){this.ENV=a,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new kA}return o.prototype.ready=function(){return qt(this,void 0,void 0,function(){var a,i,c,f;return jt(this,function(d){switch(d.label){case 0:if(this.pendingBackendInit!=null)return[2,this.pendingBackendInit.then(function(){})];if(this.backendInstance!=null)return[2];a=this.getSortedBackends(),i=0,d.label=1;case 1:return i<a.length?(c=a[i],[4,this.initializeBackend(c).success]):[3,5];case 2:return f=d.sent(),f?[4,this.setBackend(c)]:[3,4];case 3:return d.sent(),[2];case 4:return i++,[3,1];case 5:throw new Error("Could not initialize any backends, all backend initializations failed.")}})})},Object.defineProperty(o.prototype,"backend",{get:function(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){var a=this.initializeBackendsAndReturnBest(),i=a.name,c=a.asyncInit;if(c)throw new Error("The highest priority backend '"+i+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(i)}return this.backendInstance},enumerable:!0,configurable:!0}),o.prototype.backendNames=function(){return Object.keys(this.registryFactory)},o.prototype.findBackend=function(a){if(!(a in this.registry))if(a in this.registryFactory){var i=this.initializeBackend(a).asyncInit;if(i)return null}else return null;return this.registry[a]},o.prototype.findBackendFactory=function(a){return a in this.registryFactory?this.registryFactory[a].factory:null},o.prototype.registerBackend=function(a,i,c){return c===void 0&&(c=1),a in this.registryFactory?(console.warn(a+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[a]={factory:i,priority:c},!0)},o.prototype.setBackend=function(a){return qt(this,void 0,void 0,function(){var i,c,f,d,g;return jt(this,function(v){switch(v.label){case 0:if(this.registryFactory[a]==null)throw new Error("Backend name '"+a+"' not found in registry");return this.backendName=a,this.registry[a]==null?(this.backendInstance=null,i=this.initializeBackend(a),c=i.success,f=i.asyncInit,f?[4,c]:[3,2]):[3,4];case 1:return g=v.sent(),[3,3];case 2:g=c,v.label=3;case 3:if(d=g,!d)return[2,!1];v.label=4;case 4:return this.backendInstance=this.registry[a],this.setupRegisteredKernels(),this.profiler=new xQ(this.backendInstance),[2,!0]}})})},o.prototype.setupRegisteredKernels=function(){var a=this,i=pg(this.backendName);i.forEach(function(c){c.setupFunc!=null&&c.setupFunc(a.backendInstance)})},o.prototype.disposeRegisteredKernels=function(a){var i=this,c=pg(a);c.forEach(function(f){f.disposeFunc!=null&&f.disposeFunc(i.registry[a])})},o.prototype.initializeBackend=function(a){var i=this,c=this.registryFactory[a];if(c==null)throw new Error("Cannot initialize backend "+a+", no registration found.");try{var f=c.factory();if(f&&!(f instanceof r$)&&typeof f.then=="function"){var d=++this.pendingBackendInitId,g=f.then(function(v){return d<i.pendingBackendInitId?!1:(i.registry[a]=v,i.pendingBackendInit=null,!0)}).catch(function(v){return d<i.pendingBackendInitId||(i.pendingBackendInit=null,console.warn("Initialization of backend "+a+" failed"),console.warn(v.stack||v.message)),!1});return this.pendingBackendInit=g,{success:g,asyncInit:!0}}else return this.registry[a]=f,{success:!0,asyncInit:!1}}catch(v){return console.warn("Initialization of backend "+a+" failed"),console.warn(v.stack||v.message),{success:!1,asyncInit:!1}}},o.prototype.removeBackend=function(a){if(!(a in this.registryFactory))throw new Error(a+" backend not found in registry");this.backendName===a&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,a in this.registry&&(this.disposeRegisteredKernels(a),this.registry[a].dispose(),delete this.registry[a]),delete this.registryFactory[a],this.backendName===a&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},o.prototype.getSortedBackends=function(){var a=this;if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(function(i,c){return a.registryFactory[c].priority-a.registryFactory[i].priority})},o.prototype.initializeBackendsAndReturnBest=function(){for(var a=this.getSortedBackends(),i=0;i<a.length;i++){var c=a[i],f=this.initializeBackend(c),d=f.success,g=f.asyncInit;if(g||d)return{name:c,asyncInit:g}}throw new Error("Could not initialize any backends, all backend initializations failed.")},o.prototype.moveData=function(a,i){var c=this.state.tensorInfo.get(i),f=c.backend,d=this.readSync(i);f.disposeData(i),c.backend=a,a.move(i,d,c.shape,c.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},o.prototype.tidy=function(a,i){var c=this,f=null;if(i==null){if(typeof a!="function")throw new Error("Please provide a function to tidy()");i=a}else{if(typeof a!="string"&&!(a instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof i!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");f=a}var d;return this.scopedRun(function(){return c.startScope(f)},function(){return c.endScope(d)},function(){return d=i(),d instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),d})},o.prototype.scopedRun=function(a,i,c){a();try{var f=c();return i(),f}catch(d){throw i(),d}},o.prototype.nextTensorId=function(){return o.nextTensorId++},o.prototype.nextVariableId=function(){return o.nextVariableId++},o.prototype.clone=function(a){var i=this.makeTensorFromDataId(a.dataId,a.shape,a.dtype),c={x:a},f=function(g){return{x:function(){var v="float32",w={x:g},T={dtype:v};return Z.runKernelFunc(function(N){return N.cast(g,v)},w,null,fg,T)}}},d=[];return this.addTapeNode(this.state.activeScope.name,c,[i],f,d,{}),i},o.prototype.runKernel=function(a,i,c,f,d){var g=null,v=null;return this.runKernelFunc(g,i,v,a,c,f,d)},o.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},o.prototype.checkKernelForMemLeak=function(a,i,c){var f=this.backend.numDataIds(),d=0;c.forEach(function(w){d+=w.dtype==="complex64"?3:1});var g=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],v=f-i-d-g;if(v>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak "+("("+v+" data ids) after running '"+a+"'"))},o.prototype.runKernelFunc=function(a,i,c,f,d,g,v){var w=this,T,N=[],E=this.isTapeOn();f==null&&(f=this.state.activeScope!=null?this.state.activeScope.name:"");var k=this.state.numBytes,$=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var M,G=BT(f,this.backendName),O;if(G!=null)M=function(){var nt=w.backend.numDataIds();O=G.kernelFunc({inputs:i,attrs:d,backend:w.backend});var ct=Array.isArray(O)?O:[O];w.shouldCheckForMemLeaks()&&w.checkKernelForMemLeak(f,nt,ct);var dt=ct.map(function(It){var Gt=It.dataId,Et=It.shape,Wt=It.dtype;return w.makeTensorFromDataId(Gt,Et,Wt)});if(E){var Ct=w.getTensorsForGradient(f,i,dt);if(Ct==null){v==null&&(v=[]);var St=dt.filter(function(It,Gt){return v[Gt]});Ct=(g||[]).slice().concat(St)}N=w.saveTensorsForBackwardMode(Ct)}return dt};else{var H=function(nt){if(!E)return;N=nt.map(function(ct){return w.keep(w.clone(ct))})};M=function(){var nt=w.backend.numDataIds();O=w.tidy(function(){return a(w.backend,H)});var ct=Array.isArray(O)?O:[O];return w.shouldCheckForMemLeaks()&&w.checkKernelForMemLeak(f,nt,ct),ct}}var K;return this.scopedRun(function(){return w.state.kernelDepth++},function(){return w.state.kernelDepth--},function(){!w.ENV.getBool("DEBUG")&&!w.state.profiling?T=M():(K=w.profiler.profileKernel(f,i,function(){return M()}),w.ENV.getBool("DEBUG")&&w.profiler.logKernelProfile(K),T=K.outputs)}),E&&this.addTapeNode(f,i,T,c,N,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:f,bytesAdded:this.state.numBytes-k,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-$,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(i).map(function(nt){return i[nt]!=null?i[nt].shape:null}),outputShapes:T.map(function(nt){return nt.shape}),kernelTimeMs:K.timeMs,extraInfo:K.extraInfo}),Array.isArray(O)?T:T[0]},o.prototype.saveTensorsForBackwardMode=function(a){var i=this,c=a.map(function(f){return i.keep(i.clone(f))});return c},o.prototype.getTensorsForGradient=function(a,i,c){var f=zT(a);if(f!=null){var d=f.inputsToSave||[],g=f.outputsToSave||[],v=void 0;f.saveAllInputs?(U(Array.isArray(i),function(){return"saveAllInputs is true, expected inputs to be an array."}),v=Object.keys(i).map(function(T){return i[T]})):v=d.map(function(T){return i[T]});var w=c.filter(function(T,N){return g[N]});return v.concat(w)}return null},o.prototype.makeTensor=function(a,i,c,f){if(a==null)throw new Error("Values passed to engine.makeTensor() are null");c=c||"float32",f=f||this.backend;var d=a;c==="string"&&Oa(a[0])&&(d=a.map(function(N){return WT(N)}));var g=f.write(d,i,c),v=new ut(i,c,g,this.nextTensorId());if(this.incRef(v,f),c==="string"){var w=this.state.tensorInfo.get(g),T=f$(d);this.state.numBytes+=T-w.bytes,w.bytes=T}return v},o.prototype.makeTensorFromDataId=function(a,i,c,f){c=c||"float32";var d=new ut(i,c,a,this.nextTensorId());return this.incRef(d,f),d},o.prototype.makeVariable=function(a,i,c,f){i===void 0&&(i=!0),c=c||this.nextVariableId().toString(),f!=null&&f!==a.dtype&&(a=a.cast(f));var d=new Bf(a,i,c,this.nextTensorId());if(this.state.registeredVariables[d.name]!=null)throw new Error("Variable with name "+d.name+" was already registered");return this.state.registeredVariables[d.name]=d,this.incRef(d,this.backend),d},o.prototype.incRef=function(a,i){var c=this.state.tensorInfo.has(a.dataId)?this.state.tensorInfo.get(a.dataId).refCount:0;if(this.state.numTensors++,a.dtype==="string"&&this.state.numStringTensors++,c===0){this.state.numDataBuffers++;var f=0;a.dtype!=="complex64"&&a.dtype!=="string"&&(f=a.size*h$(a.dtype)),this.state.tensorInfo.set(a.dataId,{backend:i||this.backend,dtype:a.dtype,shape:a.shape,bytes:f,refCount:0}),this.state.numBytes+=f}this.state.tensorInfo.get(a.dataId).refCount++,a instanceof Bf||this.track(a)},o.prototype.disposeTensor=function(a){if(!this.state.tensorInfo.has(a.dataId))return;this.state.numTensors--,a.dtype==="string"&&this.state.numStringTensors--;var i=this.state.tensorInfo.get(a.dataId),c=i.refCount;c<=1?(a.dtype!=="complex64"&&(this.state.numBytes-=i.bytes),this.state.numDataBuffers--,i.backend.disposeData(a.dataId),this.state.tensorInfo.delete(a.dataId)):this.state.tensorInfo.get(a.dataId).refCount--},o.prototype.disposeVariables=function(){for(var a in this.state.registeredVariables){var i=this.state.registeredVariables[a];this.disposeVariable(i)}},o.prototype.disposeVariable=function(a){this.disposeTensor(a),this.state.registeredVariables[a.name]!=null&&delete this.state.registeredVariables[a.name]},o.prototype.memory=function(){var a=this.backend.memory();return a.numTensors=this.state.numTensors,a.numDataBuffers=this.state.numDataBuffers,a.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(a.unreliable=!0,a.reasons==null&&(a.reasons=[]),a.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),a},o.prototype.profile=function(a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v,w,T;return jt(this,function(N){switch(N.label){case 0:return this.state.profiling=!0,i=this.state.numBytes,c=this.state.numTensors,this.state.activeProfile.kernels=[],f=this.state.activeProfile,[4,a()];case 1:f.result=N.sent(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map(function(E){return E.totalBytesSnapshot})),this.state.activeProfile.newBytes=this.state.numBytes-i,this.state.activeProfile.newTensors=this.state.numTensors-c,d=0,g=this.state.activeProfile.kernels,N.label=2;case 2:return d<g.length?(v=g[d],w=v,[4,v.kernelTimeMs]):[3,6];case 3:return w.kernelTimeMs=N.sent(),T=v,[4,v.extraInfo];case 4:T.extraInfo=N.sent(),N.label=5;case 5:return d++,[3,2];case 6:return[2,this.state.activeProfile]}})})},o.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&this.state.kernelDepth===0},o.prototype.addTapeNode=function(a,i,c,f,d,g){var v=this,w={id:this.state.nextTapeNodeId++,kernelName:a,inputs:i,outputs:c,saved:d},T=zT(a);T!=null&&(f=T.gradFunc),f!=null&&(w.gradient=function(N){return N=N.map(function(E,k){if(E==null){var $=c[k],M=Ec($.size,$.dtype);return v.makeTensor(M,$.shape,$.dtype)}return E}),f(N.length>1?N:N[0],d,g)}),this.state.activeTape.push(w)},o.prototype.keep=function(a){return a.kept=!0,a},o.prototype.startTape=function(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++},o.prototype.endTape=function(){this.state.gradientDepth--},o.prototype.startScope=function(a){var i={track:[],name:"unnamed scope",id:this.state.nextScopeId++};a&&(i.name=a),this.state.scopeStack.push(i),this.state.activeScope=i},o.prototype.endScope=function(a){for(var i=this,c=XT(a),f=new Set(c.map(function(w){return w.id})),d=0;d<this.state.activeScope.track.length;d++){var g=this.state.activeScope.track[d];!g.kept&&!f.has(g.id)&&g.dispose()}var v=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],c.forEach(function(w){!w.kept&&w.scopeId===v.id&&i.track(w)})},o.prototype.gradients=function(a,i,c,f){var d=this;if(f===void 0&&(f=!1),U(i.length>0,function(){return"gradients() received an empty list of xs."}),c!=null&&c.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+c.dtype+"'");var g=this.scopedRun(function(){return d.startTape()},function(){return d.endTape()},function(){return d.tidy("forward",a)});U(g instanceof ut,function(){return"The result y returned by f() must be a tensor."});var v=TQ(this.state.activeTape,i,g);if(!f&&v.length===0&&i.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",function(){var w={};w[g.id]=c==null?FQ(g.shape):c,kQ(w,v,function(N){return d.tidy(N)},RQ);var T=i.map(function(N){return w[N.id]});return d.state.gradientDepth===0&&(d.state.activeTape.forEach(function(N){for(var E=0,k=N.saved;E<k.length;E++){var $=k[E];$.dispose()}}),d.state.activeTape=null),{value:g,grads:T}})},o.prototype.customGrad=function(a){var i=this;return U(Ma(a),function(){return"The f passed in customGrad(f) must be a function."}),function(){for(var c=[],f=0;f<arguments.length;f++)c[f]=arguments[f];U(c.every(function(v){return v instanceof ut}),function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"});var d,g={};return c.forEach(function(v,w){g[w]=v}),i.runKernelFunc(function(v,w){return d=a.apply(void 0,c.concat([w])),U(d.value instanceof ut,function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"}),U(Ma(d.gradFunc),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."}),d.value},g,function(v,w){var T=d.gradFunc(v,w),N=Array.isArray(T)?T:[T];U(N.length===c.length,function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."}),U(N.every(function(k){return k instanceof ut}),function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."});var E={};return N.forEach(function(k,$){E[$]=function(){return k}}),E})}},o.prototype.readSync=function(a){var i=this.state.tensorInfo.get(a);return i.backend.readSync(a)},o.prototype.read=function(a){var i=this.state.tensorInfo.get(a);return i.backend.read(a)},o.prototype.time=function(a){return qt(this,void 0,void 0,function(){var i,c;return jt(this,function(f){switch(f.label){case 0:return i=VT(),[4,this.backend.time(a)];case 1:return c=f.sent(),c.wallMs=VT()-i,[2,c]}})})},o.prototype.track=function(a){return this.state.activeScope!=null&&(a.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(a)),a},Object.defineProperty(o.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),o.prototype.reset=function(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new kA;for(var a in this.registry)this.disposeRegisteredKernels(a),this.registry[a].dispose(),delete this.registry[a];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},o.nextTensorId=0,o.nextVariableId=0,o}();function FQ(o){var a=qx(mn(o),"float32");return Z.makeTensor(a,o,"float32")}function SA(){var o=y$();if(o._tfengine==null){var a=new v$(o);o._tfengine=new PQ(a)}return cQ(o._tfengine.ENV),NQ(function(){return o._tfengine}),o._tfengine}var Z=SA();function RQ(o,a){var i={a:o,b:a};return Z.runKernelFunc(function(c,f){var d=c.add(o,a);return f([o,a]),d},i,null,hg)}function OQ(){return typeof navigator!="undefined"&&navigator!=null}function MQ(){if(OQ()){var o=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(o)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(o.substr(0,4))}return!1}function CA(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var LQ={__proto__:null,isMobile:MQ,isBrowser:CA};var Go=Fe();Go.registerFlag("DEBUG",function(){return!1},function(o){o&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Go.registerFlag("IS_BROWSER",function(){return CA()});Go.registerFlag("IS_NODE",function(){return typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined"});Go.registerFlag("IS_CHROME",function(){return typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)});Go.registerFlag("PROD",function(){return!1});Go.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",function(){return Go.getBool("DEBUG")});Go.registerFlag("DEPRECATION_WARNINGS_ENABLED",function(){return!0});Go.registerFlag("IS_TEST",function(){return!1});function uo(o,a){var i=o;if(Jn(o))return a==="string"?[]:[o.length];if(!Array.isArray(o))return[];for(var c=[];Array.isArray(i)||Jn(i)&&a!=="string";)c.push(i.length),i=i[0];return Array.isArray(o)&&Fe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&NA(o,c,[]),c}function NA(o,a,i){if(i=i||[],!Array.isArray(o)&&!Jn(o)){U(a.length===0,function(){return"Element arr["+i.join("][")+"] is a primitive, "+("but should be an array/TypedArray of "+a[0]+" elements")});return}U(a.length>0,function(){return"Element arr["+i.join("][")+"] should be a primitive, "+("but is an array of "+o.length+" elements")}),U(o.length===a[0],function(){return"Element arr["+i.join("][")+"] should have "+a[0]+" "+("elements, but has "+o.length+" elements")});for(var c=a.slice(1),f=0;f<o.length;++f)NA(o[f],c,i.concat(f))}function IA(o,a,i,c){if(o==null)return;if(o!=="numeric"&&o!==a||o==="numeric"&&a==="string")throw new Error("Argument '"+i+"' passed to '"+c+"' must "+("be "+o+" tensor, but got "+a+" tensor"))}function W(o,a,i,c){if(c===void 0&&(c="numeric"),o instanceof ut)return IA(c,o.dtype,a,i),o;var f=cg(o);if(f!=="string"&&["bool","int32","float32"].indexOf(c)>=0&&(f=c),IA(c,f,a,i),o==null||!Jn(o)&&!Array.isArray(o)&&typeof o!="number"&&typeof o!="boolean"&&typeof o!="string"){var d=o==null?"null":o.constructor.name;throw new Error("Argument '"+a+"' passed to '"+i+"' must be a "+("Tensor or TensorLike, but got '"+d+"'"))}var g=uo(o,f);!Jn(o)&&!Array.isArray(o)&&(o=[o]);var v=!0,w=f!=="string"?dg(o,f):Wi(o,[],v);return Z.makeTensor(w,g,f)}function zf(o,a,i,c){if(c===void 0&&(c="numeric"),!Array.isArray(o))throw new Error("Argument "+a+" passed to "+i+" must be a `Tensor[]` or `TensorLike[]`");var f=o;return f.map(function(d,g){return W(d,a+"["+g+"]",i)},c)}var EA="__op";function Y(o){var a=Object.keys(o);if(a.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+(a.length+" keys."));var i=a[0],c=o[i];i.endsWith("_")&&(i=i.substring(0,i.length-1)),i=i+EA;var f=function(){for(var d=[],g=0;g<arguments.length;g++)d[g]=arguments[g];Z.startScope(i);try{var v=c.apply(void 0,d);return Kx(v)&&console.error("Cannot return a Promise inside of tidy."),Z.endScope(v),v}catch(w){throw Z.endScope(null),w}};return Object.defineProperty(f,"name",{value:i,configurable:!0}),f}function BQ(o,a){var i=W(o,"real","complex"),c=W(a,"imag","complex");Ee(i.shape,c.shape,"real and imag shapes, "+i.shape+" and "+c.shape+", must match in call to tf.complex().");var f=function(g){return g.complex(i,c)},d={real:i,imag:c};return Z.runKernelFunc(f,d,null,S$)}var La=Y({complex_:BQ});function Ba(o,a,i,c){if(c==null&&(c=cg(o)),c==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Jn(o)&&!Array.isArray(o)&&typeof o!="number"&&typeof o!="boolean"&&typeof o!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(a!=null){jx(a);var f=mn(a),d=mn(i);U(f===d,function(){return"Based on the provided shape, ["+a+"], the tensor should have "+(f+" values but has "+d)});for(var g=0;g<i.length;++g){var v=i[g],w=g===i.length-1?v!==mn(a.slice(g)):!0;U(i[g]===a[g]||!w,function(){return"Error creating a new Tensor. Inferred shape "+("("+i+") does not match the provided ")+("shape ("+a+"). ")})}}return!Jn(o)&&!Array.isArray(o)&&(o=[o]),a=a||i,o=c!=="string"?dg(o,c):Wi(o,[],!0),Z.makeTensor(o,a,c)}function za(o,a,i){var c=uo(o,i);return Ba(o,a,c,i)}var YT={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var yg=4;function WQ(o,a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v,w=this;return jt(this,function(T){switch(T.label){case 0:for(i=[],c=[],f=Array.isArray(o)?o.map(function(N){return N.name}):Object.keys(o),d=function(N){var E=f[N],k=Array.isArray(o)?o[N].tensor:o[E];if(k.dtype!=="float32"&&k.dtype!=="int32"&&k.dtype!=="bool"&&k.dtype!=="string"&&k.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+E+"': "+k.dtype);var $={name:E,shape:k.shape,dtype:k.dtype};if(k.dtype==="string"){var M=new Promise(function(G){return qt(w,void 0,void 0,function(){var O,H,K,nt,ct,dt,Ct;return jt(this,function(St){switch(St.label){case 0:return[4,k.bytes()];case 1:for(O=St.sent(),H=O.reduce(function(It,Gt){return It+Gt.length},0)+yg*O.length,K=new Uint8Array(H),nt=0,ct=0;ct<O.length;ct++)dt=O[ct],Ct=new Uint8Array(new Uint32Array([dt.length]).buffer),K.set(Ct,nt),nt+=yg,K.set(dt,nt),nt+=dt.length;return G(K),[2]}})})});c.push(M)}else c.push(k.data());a!=null&&($.group=a),i.push($)},g=0;g<f.length;++g)d(g);return[4,Promise.all(c)];case 1:return v=T.sent(),[2,{data:zQ(v),specs:i}]}})})}function DA(o,a){for(var i={},c,f=0,d=0,g=a;d<g.length;d++){var v=g[d],w=v.name,T=v.dtype,N=v.shape,E=mn(N),k=void 0;if("quantization"in v){var $=v.quantization;if($.dtype==="uint8"||$.dtype==="uint16"){if(!("min"in $&&"scale"in $))throw new Error("Weight "+v.name+" with quantization "+$.dtype+" doesn't have corresponding metadata min and scale.")}else if($.dtype==="float16"){if(T!=="float32")throw new Error("Weight "+v.name+" is quantized with "+$.dtype+" "+("which only supports weights of type float32 not "+T+"."))}else throw new Error("Weight "+v.name+" has unknown "+("quantization dtype "+$.dtype+". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");var M=YT[$.dtype],G=o.slice(f,f+E*M),O=$.dtype==="uint8"?new Uint8Array(G):new Uint16Array(G);if(T==="float32")if($.dtype==="uint8"||$.dtype==="uint16"){k=new Float32Array(O.length);for(var H=0;H<O.length;H++){var K=O[H];k[H]=K*$.scale+$.min}}else if($.dtype==="float16")c===void 0&&(c=VQ()),k=c(O);else throw new Error("Unsupported quantization type "+$.dtype+" for weight type float32.");else if(T==="int32"){if($.dtype!=="uint8"&&$.dtype!=="uint16")throw new Error("Unsupported quantization type "+$.dtype+" for weight type int32.");k=new Int32Array(O.length);for(var H=0;H<O.length;H++){var K=O[H];k[H]=Math.round(K*$.scale+$.min)}}else throw new Error("Unsupported dtype in weight '"+w+"': "+T);f+=E*M}else if(T==="string"){var nt=mn(v.shape);k=[];for(var H=0;H<nt;H++){var ct=new Uint32Array(o.slice(f,f+yg))[0];f+=yg;var dt=new Uint8Array(o.slice(f,f+ct));k.push(dt),f+=ct}}else{var Ct=YT[T],G=o.slice(f,f+E*Ct);if(T==="float32")k=new Float32Array(G);else if(T==="int32")k=new Int32Array(G);else if(T==="bool")k=new Uint8Array(G);else if(T==="complex64"){k=new Float32Array(G);for(var St=new Float32Array(k.length/2),It=new Float32Array(k.length/2),H=0;H<St.length;H++)St[H]=k[H*2],It[H]=k[H*2+1];var Gt=za(St,N,"float32"),Et=za(It,N,"float32");i[w]=La(Gt,Et),Gt.dispose(),Et.dispose()}else throw new Error("Unsupported dtype in weight '"+w+"': "+T);f+=E*Ct}T!=="complex64"&&(i[w]=za(k,N,T))}return i}function zQ(o){if(o===null)throw new Error("Invalid input value: "+JSON.stringify(o));var a=0,i=[];o.forEach(function(d){if(a+=d.byteLength,i.push(d.byteLength===d.buffer.byteLength?d:new d.constructor(d)),!(d instanceof Float32Array||d instanceof Int32Array||d instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+d.constructor.name)});var c=new Uint8Array(a),f=0;return i.forEach(function(d){c.set(new Uint8Array(d.buffer),f),f+=d.byteLength}),c.buffer}var JT=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function $A(o){return JT?Buffer.byteLength(o):new Blob([o]).size}function UQ(o){if(JT)return Buffer.from(o).toString("base64");for(var a=new Uint8Array(o),i="",c=0,f=a.length;c<f;c++)i+=String.fromCharCode(a[c]);return btoa(i)}function GQ(o){if(JT){var a=Buffer.from(o,"base64");return a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength)}for(var i=atob(o),c=new Uint8Array(i.length),f=0;f<i.length;++f)c.set([i.charCodeAt(f)],f);return c.buffer}function ZT(o){if(o.length===1)return o[0];var a=0;o.forEach(function(f){a+=f.byteLength});var i=new Uint8Array(a),c=0;return o.forEach(function(f){i.set(new Uint8Array(f),c),c+=f.byteLength}),i.buffer}function AA(o){var a="/";for(o=o.trim();o.endsWith(a);)o=o.slice(0,o.length-1);var i=o.split(a);return i[i.length-1]}function Wf(o){if(o.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:o.modelTopology==null?0:$A(JSON.stringify(o.modelTopology)),weightSpecsBytes:o.weightSpecs==null?0:$A(JSON.stringify(o.weightSpecs)),weightDataBytes:o.weightData==null?0:o.weightData.byteLength}}function HQ(){var o=function(c){for(var f=c<<13,d=0;(f&8388608)===0;)d-=8388608,f<<=1;return f&=~8388608,d+=947912704,f|d},a=new Uint32Array(2048);a[0]=0;for(var i=1;i<1024;i++)a[i]=o(i);for(var i=1024;i<2048;i++)a[i]=939524096+(i-1024<<13);return a}function qQ(){var o=new Uint32Array(64);o[0]=0,o[31]=1199570944,o[32]=2147483648,o[63]=3347054592;for(var a=1;a<31;a++)o[a]=a<<23;for(var a=33;a<63;a++)o[a]=2147483648+(a-32<<23);return o}function jQ(){for(var o=new Uint32Array(64),a=0;a<64;a++)o[a]=1024;return o[0]=o[32]=0,o}function VQ(){var o=HQ(),a=qQ(),i=jQ();return function(c){for(var f=new ArrayBuffer(4*c.length),d=new Uint32Array(f),g=0;g<c.length;g++){var v=c[g],w=o[i[v>>10]+(v&1023)]+a[v>>10];d[g]=w}return new Float32Array(f)}}var Yr=function(){function o(){this.saveRouters=[],this.loadRouters=[]}return o.getInstance=function(){return o.instance==null&&(o.instance=new o),o.instance},o.registerSaveRouter=function(a){o.getInstance().saveRouters.push(a)},o.registerLoadRouter=function(a){o.getInstance().loadRouters.push(a)},o.getSaveHandlers=function(a){return o.getHandlers(a,"save")},o.getLoadHandlers=function(a,i){return o.getHandlers(a,"load",i)},o.getHandlers=function(a,i,c){var f=[],d=i==="load"?o.getInstance().loadRouters:o.getInstance().saveRouters;return d.forEach(function(g){var v=g(a,c);v!==null&&f.push(v)}),f},o}(),KQ=function(o){return Yr.registerSaveRouter(o)},XQ=function(o){return Yr.registerLoadRouter(o)},YQ=function(o){return Yr.getSaveHandlers(o)},JQ=function(o,a){return Yr.getLoadHandlers(o,a)};var QT="tensorflowjs",tk=1,Vi="models_store",Wa="model_info_store";function _A(){if(!Fe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var o=typeof window=="undefined"?self:window,a=o.indexedDB||o.mozIndexedDB||o.webkitIndexedDB||o.msIndexedDB||o.shimIndexedDB;if(a==null)throw new Error("The current browser does not appear to support IndexedDB.");return a}function ek(o){var a=o.result;a.createObjectStore(Vi,{keyPath:"modelPath"}),a.createObjectStore(Wa,{keyPath:"modelPath"})}var Ac=function(){function o(a){if(this.indexedDB=_A(),a==null||!a)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=a}return o.prototype.save=function(a){return qt(this,void 0,void 0,function(){return jt(this,function(i){if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,a)]})})},o.prototype.load=function(){return qt(this,void 0,void 0,function(){return jt(this,function(a){return[2,this.databaseAction(this.modelPath)]})})},o.prototype.databaseAction=function(a,i){var c=this;return new Promise(function(f,d){var g=c.indexedDB.open(QT,tk);g.onupgradeneeded=function(){return ek(g)},g.onsuccess=function(){var v=g.result;if(i==null){var w=v.transaction(Vi,"readonly"),T=w.objectStore(Vi),N=T.get(c.modelPath);N.onsuccess=function(){if(N.result==null)return v.close(),d(new Error("Cannot find model with path '"+c.modelPath+"' in IndexedDB."));f(N.result.modelArtifacts)},N.onerror=function(O){return v.close(),d(N.error)},w.oncomplete=function(){return v.close()}}else{var E=Wf(i),k=v.transaction(Wa,"readwrite"),$=k.objectStore(Wa),M=$.put({modelPath:c.modelPath,modelArtifactsInfo:E}),G;M.onsuccess=function(){G=v.transaction(Vi,"readwrite");var O=G.objectStore(Vi),H=O.put({modelPath:c.modelPath,modelArtifacts:i,modelArtifactsInfo:E});H.onsuccess=function(){return f({modelArtifactsInfo:E})},H.onerror=function(K){$=k.objectStore(Wa);var nt=$.delete(c.modelPath);nt.onsuccess=function(){return v.close(),d(H.error)},nt.onerror=function(ct){return v.close(),d(H.error)}}},M.onerror=function(O){return v.close(),d(M.error)},k.oncomplete=function(){G==null?v.close():G.oncomplete=function(){return v.close()}}}},g.onerror=function(v){return d(g.error)}})},o.URL_SCHEME="indexeddb://",o}(),FA=function(o){return Fe().getBool("IS_BROWSER")&&(!Array.isArray(o)&&o.startsWith(Ac.URL_SCHEME))?ZQ(o.slice(Ac.URL_SCHEME.length)):null};Yr.registerSaveRouter(FA);Yr.registerLoadRouter(FA);function ZQ(o){return new Ac(o)}function QQ(o){return o.startsWith(Ac.URL_SCHEME)?o.slice(Ac.URL_SCHEME.length):o}var ttt=function(){function o(){this.indexedDB=_A()}return o.prototype.listModels=function(){return qt(this,void 0,void 0,function(){var a=this;return jt(this,function(i){return[2,new Promise(function(c,f){var d=a.indexedDB.open(QT,tk);d.onupgradeneeded=function(){return ek(d)},d.onsuccess=function(){var g=d.result,v=g.transaction(Wa,"readonly"),w=v.objectStore(Wa),T=w.getAll();T.onsuccess=function(){for(var N={},E=0,k=T.result;E<k.length;E++){var $=k[E];N[$.modelPath]=$.modelArtifactsInfo}c(N)},T.onerror=function(N){return g.close(),f(T.error)},v.oncomplete=function(){return g.close()}},d.onerror=function(g){return f(d.error)}})]})})},o.prototype.removeModel=function(a){return qt(this,void 0,void 0,function(){var i=this;return jt(this,function(c){return a=QQ(a),[2,new Promise(function(f,d){var g=i.indexedDB.open(QT,tk);g.onupgradeneeded=function(){return ek(g)},g.onsuccess=function(){var v=g.result,w=v.transaction(Wa,"readwrite"),T=w.objectStore(Wa),N=T.get(a),E;N.onsuccess=function(){if(N.result==null)return v.close(),d(new Error("Cannot find model with path '"+a+"' in IndexedDB."));var k=T.delete(a),$=function(){E=v.transaction(Vi,"readwrite");var M=E.objectStore(Vi),G=M.delete(a);G.onsuccess=function(){return f(N.result.modelArtifactsInfo)},G.onerror=function(O){return d(N.error)}};k.onsuccess=$,k.onerror=function(M){return $(),v.close(),d(N.error)}},N.onerror=function(k){return v.close(),d(N.error)},w.oncomplete=function(){E==null?v.close():E.oncomplete=function(){return v.close()}}},g.onerror=function(v){return d(g.error)}})]})})},o}();var Ho="/",_c="tensorflowjs_models",RA="info",ett="model_topology",ntt="weight_specs",rtt="weight_data",stt="model_metadata";function PA(o){return{info:[_c,o,RA].join(Ho),topology:[_c,o,ett].join(Ho),weightSpecs:[_c,o,ntt].join(Ho),weightData:[_c,o,rtt].join(Ho),modelMetadata:[_c,o,stt].join(Ho)}}function ott(o){var a=o.split(Ho);if(a.length<3)throw new Error("Invalid key format: "+o);return a.slice(1,a.length-1).join(Ho)}function att(o){return o.startsWith(Fc.URL_SCHEME)?o.slice(Fc.URL_SCHEME.length):o}var Fc=function(){function o(a){if(!Fe().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,a==null||!a)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=a,this.keys=PA(this.modelPath)}return o.prototype.save=function(a){return qt(this,void 0,void 0,function(){var i,c,f;return jt(this,function(d){if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");i=JSON.stringify(a.modelTopology),c=JSON.stringify(a.weightSpecs),f=Wf(a);try{return this.LS.setItem(this.keys.info,JSON.stringify(f)),this.LS.setItem(this.keys.topology,i),this.LS.setItem(this.keys.weightSpecs,c),this.LS.setItem(this.keys.weightData,UQ(a.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy,userDefinedMetadata:a.userDefinedMetadata})),[2,{modelArtifactsInfo:f}]}catch(g){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: "+("modelTopologyBytes="+f.modelTopologyBytes+", ")+("weightSpecsBytes="+f.weightSpecsBytes+", ")+("weightDataBytes="+f.weightDataBytes+"."))}return[2]})})},o.prototype.load=function(){return qt(this,void 0,void 0,function(){var a,i,c,f,d,g,v;return jt(this,function(w){if(a=JSON.parse(this.LS.getItem(this.keys.info)),a==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(a.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(i={},c=JSON.parse(this.LS.getItem(this.keys.topology)),c==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(i.modelTopology=c,f=JSON.parse(this.LS.getItem(this.keys.weightSpecs)),f==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(i.weightSpecs=f,d=this.LS.getItem(this.keys.modelMetadata),d!=null&&(g=JSON.parse(d),i.format=g.format,i.generatedBy=g.generatedBy,i.convertedBy=g.convertedBy,i.userDefinedMetadata=g.userDefinedMetadata),v=this.LS.getItem(this.keys.weightData),v==null)throw new Error("In local storage, the binary weight values of model "+("'"+this.modelPath+"' are missing."));return i.weightData=GQ(v),[2,i]})})},o.URL_SCHEME="localstorage://",o}(),OA=function(o){return Fe().getBool("IS_BROWSER")&&(!Array.isArray(o)&&o.startsWith(Fc.URL_SCHEME))?itt(o.slice(Fc.URL_SCHEME.length)):null};Yr.registerSaveRouter(OA);Yr.registerLoadRouter(OA);function itt(o){return new Fc(o)}var utt=function(){function o(){U(Fe().getBool("IS_BROWSER"),function(){return"Current environment is not a web browser"}),U(typeof window=="undefined"||typeof window.localStorage!="undefined",function(){return"Current browser does not appear to support localStorage"}),this.LS=window.localStorage}return o.prototype.listModels=function(){return qt(this,void 0,void 0,function(){var a,i,c,f,d,g;return jt(this,function(v){for(a={},i=_c+Ho,c=Ho+RA,f=0;f<this.LS.length;++f)d=this.LS.key(f),d.startsWith(i)&&d.endsWith(c)&&(g=ott(d),a[g]=JSON.parse(this.LS.getItem(d)));return[2,a]})})},o.prototype.removeModel=function(a){return qt(this,void 0,void 0,function(){var i,c;return jt(this,function(f){if(a=att(a),i=PA(a),this.LS.getItem(i.info)==null)throw new Error("Cannot find model at path '"+a+"'");return c=JSON.parse(this.LS.getItem(i.info)),this.LS.removeItem(i.info),this.LS.removeItem(i.topology),this.LS.removeItem(i.weightSpecs),this.LS.removeItem(i.weightData),[2,c]})})},o}();var Rc="://",Va=function(){function o(){this.managers={}}return o.getInstance=function(){return o.instance==null&&(o.instance=new o),o.instance},o.registerManager=function(a,i){U(a!=null,function(){return"scheme must not be undefined or null."}),a.endsWith(Rc)&&(a=a.slice(0,a.indexOf(Rc))),U(a.length>0,function(){return"scheme must not be an empty string."});var c=o.getInstance();U(c.managers[a]==null,function(){return"A model store manager is already registered for scheme '"+a+"'."}),c.managers[a]=i},o.getManager=function(a){var i=this.getInstance().managers[a];if(i==null)throw new Error("Cannot find model manager for scheme '"+a+"'");return i},o.getSchemes=function(){return Object.keys(this.getInstance().managers)},o}();function bg(o){if(o.indexOf(Rc)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+(""+Va.getSchemes().join(",")));return{scheme:o.split(Rc)[0],path:o.split(Rc)[1]}}function MA(o,a,i){return i===void 0&&(i=!1),qt(this,void 0,void 0,function(){var c,f,d,g,v,w,T,N,E;return jt(this,function(k){switch(k.label){case 0:return U(o!==a,function(){return"Old path and new path are the same: '"+o+"'"}),c=Yr.getLoadHandlers(o),U(c.length>0,function(){return"Copying failed because no load handler is found for source URL "+o+"."}),U(c.length<2,function(){return"Copying failed because more than one ("+c.length+") "+("load handlers for source URL "+o+".")}),f=c[0],d=Yr.getSaveHandlers(a),U(d.length>0,function(){return"Copying failed because no save handler is found for destination "+("URL "+a+".")}),U(d.length<2,function(){return"Copying failed because more than one ("+c.length+") "+("save handlers for destination URL "+a+".")}),g=d[0],v=bg(o).scheme,w=bg(o).path,T=v===bg(o).scheme,[4,f.load()];case 1:return N=k.sent(),i&&T?[4,Va.getManager(v).removeModel(w)]:[3,3];case 2:k.sent(),k.label=3;case 3:return[4,g.save(N)];case 4:return E=k.sent(),i&&!T?[4,Va.getManager(v).removeModel(w)]:[3,6];case 5:k.sent(),k.label=6;case 6:return[2,E.modelArtifactsInfo]}})})}function ctt(){return qt(this,void 0,void 0,function(){var o,a,i,c,f,d,g,v;return jt(this,function(w){switch(w.label){case 0:o=Va.getSchemes(),a={},i=0,c=o,w.label=1;case 1:return i<c.length?(f=c[i],[4,Va.getManager(f).listModels()]):[3,4];case 2:d=w.sent();for(g in d)v=f+Rc+g,a[v]=d[g];w.label=3;case 3:return i++,[3,1];case 4:return[2,a]}})})}function ltt(o){return qt(this,void 0,void 0,function(){var a,i;return jt(this,function(c){return a=bg(o),i=Va.getManager(a.scheme),[2,i.removeModel(a.path)]})})}function htt(o,a){return qt(this,void 0,void 0,function(){var i;return jt(this,function(c){return i=!1,[2,MA(o,a,i)]})})}function ftt(o,a){return qt(this,void 0,void 0,function(){var i;return jt(this,function(c){return i=!0,[2,MA(o,a,i)]})})}var ptt=function(){function o(){}return o.prototype.fetch=function(a,i){return fetch(a,i)},o.prototype.now=function(){return performance.now()},o.prototype.encode=function(a,i){if(i!=="utf-8"&&i!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+i);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(a)},o.prototype.decode=function(a,i){return new TextDecoder(i).decode(a)},o}();if(Fe().get("IS_BROWSER")){Fe().setPlatform("browser",new ptt);try{Va.registerManager(Fc.URL_SCHEME,new utt)}catch(o){}try{Va.registerManager(Ac.URL_SCHEME,new ttt)}catch(o){}}var dtt={importFetch:function(){return Nx()}},nk,mtt=function(){function o(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}return o.prototype.fetch=function(a,i){return Fe().global.fetch!=null?Fe().global.fetch(a,i):(nk==null&&(nk=dtt.importFetch()),nk(a,i))},o.prototype.now=function(){var a=process.hrtime();return a[0]*1e3+a[1]/1e6},o.prototype.encode=function(a,i){if(i!=="utf-8"&&i!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+i);return this.textEncoder.encode(a)},o.prototype.decode=function(a,i){return a.length===0?"":new this.util.TextDecoder(i).decode(a)},o}();Fe().get("IS_NODE")&&Fe().setPlatform("node",new mtt);function co(o,a,i){return a===void 0&&(a="float32"),a=a||"float32",jx(o),new gg(o,a,i)}function gtt(o,a){var i=W(o,"x","cast");if(!c$(a))throw new Error("Failed to cast to unknown dtype "+a);if(a==="string"&&i.dtype!=="string"||a!=="string"&&i.dtype==="string")throw new Error("Only strings can be casted to strings");var c={x:i},f={dtype:a};return Z.runKernelFunc(function(d){return d.cast(i,a)},c,null,fg,f)}var Bt=Y({cast_:gtt});function vtt(o){var a=W(o,"x","clone",null),i=function(){return Z.makeTensorFromDataId(a.dataId,a.shape,a.dtype)},c={x:a};return Z.runKernelFunc(i,c,null,F1)}var Ui=Y({clone_:vtt});function LA(o,a){a===void 0&&(a=!1),console.log(o.toString(a))}SA();var ytt={buffer:co,cast:Bt,clone:Ui,print:LA};IQ(ytt);var btt="model",wtt=".json",xtt=".weights.bin";function BA(o){return new Promise(function(a){return setTimeout(a)}).then(o)}var rk=function(){function o(a){if(!Fe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");a.startsWith(o.URL_SCHEME)&&(a=a.slice(o.URL_SCHEME.length)),(a==null||a.length===0)&&(a=btt),this.modelTopologyFileName=a+wtt,this.weightDataFileName=a+xtt}return o.prototype.save=function(a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v;return jt(this,function(w){switch(w.label){case 0:if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");if(i=window.URL.createObjectURL(new Blob([a.weightData],{type:"application/octet-stream"})),!(a.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return c=[{paths:["./"+this.weightDataFileName],weights:a.weightSpecs}],f={modelTopology:a.modelTopology,format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy,weightsManifest:c},d=window.URL.createObjectURL(new Blob([JSON.stringify(f)],{type:"application/json"})),g=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor,g.download=this.modelTopologyFileName,g.href=d,[4,BA(function(){return g.dispatchEvent(new MouseEvent("click"))})];case 2:return w.sent(),a.weightData!=null?(v=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor,v.download=this.weightDataFileName,v.href=i,[4,BA(function(){return v.dispatchEvent(new MouseEvent("click"))})]):[3,4];case 3:w.sent(),w.label=4;case 4:return[2,{modelArtifactsInfo:Wf(a)}]}})})},o.URL_SCHEME="downloads://",o}(),Ttt=function(){function o(a){if(a==null||a.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+("but received "+a));this.files=a}return o.prototype.load=function(){return qt(this,void 0,void 0,function(){var a,i,c=this;return jt(this,function(f){return a=this.files[0],i=this.files.slice(1),[2,new Promise(function(d,g){var v=new FileReader;v.onload=function(w){var T=JSON.parse(w.target.result),N=T.modelTopology;if(N==null){g(new Error("modelTopology field is missing from file "+a.name));return}i.length===0&&d({modelTopology:N});var E=T.weightsManifest;if(E==null){g(new Error("weightManifest field is missing from file "+a.name));return}var k;try{k=c.checkManifestAndWeightFiles(E,i)}catch(O){g(O);return}var $=[],M=[],G=[];E.forEach(function(O){O.paths.forEach(function(H){M.push(H),G.push(null)}),$.push.apply($,O.weights)}),E.forEach(function(O){O.paths.forEach(function(H){var K=new FileReader;K.onload=function(nt){var ct=nt.target.result,dt=M.indexOf(H);G[dt]=ct,G.indexOf(null)===-1&&d({modelTopology:N,weightSpecs:$,weightData:ZT(G),format:T.format,generatedBy:T.generatedBy,convertedBy:T.convertedBy,userDefinedMetadata:T.userDefinedMetadata})},K.onerror=function(nt){return g("Failed to weights data from file of path '"+H+"'.")},K.readAsArrayBuffer(k[H])})})},v.onerror=function(w){return g("Failed to read model topology and weights manifest JSON "+("from file '"+a.name+"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only.")},v.readAsText(a)})]})})},o.prototype.checkManifestAndWeightFiles=function(a,i){for(var c=[],f=i.map(function(T){return AA(T.name)}),d={},g=0,v=a;g<v.length;g++){var w=v[g];w.paths.forEach(function(T){var N=AA(T);if(c.indexOf(N)!==-1)throw new Error("Duplicate file basename found in weights manifest: "+("'"+N+"'"));if(c.push(N),f.indexOf(N)===-1)throw new Error("Weight file with basename '"+N+"' is not provided.");d[T]=i[f.indexOf(N)]})}if(c.length!==i.length)throw new Error("Mismatch in the number of files in weights manifest "+("("+c.length+") and the number of weight files provided ")+("("+i.length+")."));return d},o}(),Stt=function(o){return Fe().getBool("IS_BROWSER")&&(!Array.isArray(o)&&o.startsWith(rk.URL_SCHEME))?ktt(o.slice(rk.URL_SCHEME.length)):null};Yr.registerSaveRouter(Stt);function ktt(o){return o===void 0&&(o="model"),new rk(o)}function Ctt(o){return new Ttt(o)}function zA(o,a,i,c){g(o),i=i==null?0:i,c=c==null?1:c,v(i,c);var f=0,d=function(w){return w.then(function(T){var N=i+ ++f/o.length*(c-i);return a(N),T}),w};function g(w){U(w!=null&&Array.isArray(w)&&w.length>0,function(){return"promises must be a none empty array"})}function v(w,T){U(w>=0&&w<=1,function(){return"Progress fraction must be in range [0, 1], but "+("got startFraction "+w)}),U(T>=0&&T<=1,function(){return"Progress fraction must be in range [0, 1], but "+("got endFraction "+T)}),U(T>=w,function(){return"startFraction must be no more than endFraction, but "+("got startFraction "+w+" and endFraction ")+(""+T)})}return Promise.all(o.map(d))}function WA(o,a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v,w,T,N,E,k;return jt(this,function($){switch($.label){case 0:return a==null&&(a={}),i=a.fetchFunc==null?Fe().platform.fetch:a.fetchFunc,c=o.map(function(M){return i(M,a.requestInit,{isBinary:!0})}),f=0,d=.5,a.onProgress==null?[4,Promise.all(c)]:[3,2];case 1:return v=$.sent(),[3,4];case 2:return[4,zA(c,a.onProgress,f,d)];case 3:v=$.sent(),$.label=4;case 4:return g=v,w=g.map(function(M){return M.arrayBuffer()}),T=.5,N=1,a.onProgress==null?[4,Promise.all(w)]:[3,6];case 5:return k=$.sent(),[3,8];case 6:return[4,zA(w,a.onProgress,T,N)];case 7:k=$.sent(),$.label=8;case 8:return E=k,[2,E]}})})}function Ntt(o,a,i,c){return a===void 0&&(a=""),qt(this,void 0,void 0,function(){var f,d;return jt(this,function(g){return f=function(v){return WA(v,{requestInit:c})},d=VA(f),[2,d(o,a,i)]})})}function VA(o){var a=this;return function(i,c,f){return c===void 0&&(c=""),qt(a,void 0,void 0,function(){var d,g,v,w,T,N,E,k,$,M;return jt(this,function(G){switch(G.label){case 0:if(d=i.map(function(){return!1}),g={},v=f!=null?f.map(function(){return!1}):[],w=[],i.forEach(function(O,H){var K=0;O.weights.forEach(function(nt){var ct="quantization"in nt?nt.quantization.dtype:nt.dtype,dt=YT[ct]*mn(nt.shape),Ct=function(){d[H]=!0,g[H]==null&&(g[H]=[]),g[H].push({manifestEntry:nt,groupOffset:K,sizeBytes:dt})};f!=null?f.forEach(function(St,It){St===nt.name&&(Ct(),v[It]=!0)}):Ct(),w.push(nt.name),K+=dt})}),!v.every(function(O){return O}))throw T=f.filter(function(O,H){return!v[H]}),new Error("Could not find weights in manifest with names: "+(T.join(", ")+`. 
`)+"Manifest JSON has weights with names: "+(w.join(", ")+"."));return N=d.reduce(function(O,H,K){return H&&O.push(K),O},[]),E=[],N.forEach(function(O){i[O].paths.forEach(function(H){var K=c+(c.endsWith("/")?"":"/")+H;E.push(K)})}),[4,o(E)];case 1:return k=G.sent(),$={},M=0,N.forEach(function(O){for(var H=i[O].paths.length,K=0,nt=0;nt<H;nt++)K+=k[M+nt].byteLength;for(var ct=new ArrayBuffer(K),dt=new Uint8Array(ct),Ct=0,St=0;St<H;St++){var It=new Uint8Array(k[M+St]);dt.set(It,Ct),Ct+=It.byteLength}var Gt=g[O];Gt.forEach(function(Et){var Wt=ct.slice(Et.groupOffset,Et.groupOffset+Et.sizeBytes),_t=DA(Wt,[Et.manifestEntry]);for(var Kt in _t)$[Kt]=_t[Kt]}),M+=H}),[2,$]}})})}}var Itt="application/octet-stream",Ett="application/json",UA=function(){function o(a,i){if(this.DEFAULT_METHOD="POST",i==null&&(i={}),this.weightPathPrefix=i.weightPathPrefix,this.onProgress=i.onProgress,this.weightUrlConverter=i.weightUrlConverter,i.fetchFunc!=null?(U(typeof i.fetchFunc=="function",function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"}),this.fetch=i.fetchFunc):this.fetch=Fe().platform.fetch,U(a!=null&&a.length>0,function(){return"URL path for http must not be null, undefined or empty."}),Array.isArray(a)&&U(a.length===2,function(){return"URL paths for http must have a length of 2, "+("(actual length is "+a.length+").")}),this.path=a,i.requestInit!=null&&i.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=i.requestInit||{}}return o.prototype.save=function(a){return qt(this,void 0,void 0,function(){var i,c,f,d;return jt(this,function(g){switch(g.label){case 0:if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return i=Object.assign({method:this.DEFAULT_METHOD},this.requestInit),i.body=new FormData,c=[{paths:["./model.weights.bin"],weights:a.weightSpecs}],f={modelTopology:a.modelTopology,format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy,userDefinedMetadata:a.userDefinedMetadata,weightsManifest:c},i.body.append("model.json",new Blob([JSON.stringify(f)],{type:Ett}),"model.json"),a.weightData!=null&&i.body.append("model.weights.bin",new Blob([a.weightData],{type:Itt}),"model.weights.bin"),[4,this.fetch(this.path,i)];case 1:if(d=g.sent(),d.ok)return[2,{modelArtifactsInfo:Wf(a),responses:[d]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+(d.status+"."))}})})},o.prototype.load=function(){return qt(this,void 0,void 0,function(){var a,i,c,f,d,g,v,w,T,N,E,k,$,M,G;return jt(this,function(O){switch(O.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(a=O.sent(),!a.ok)throw new Error("Request to "+this.path+" failed with status code "+(a.status+". Please verify this URL points to ")+"the model JSON of the model to load.");O.label=2;case 2:return O.trys.push([2,4,,5]),[4,a.json()];case 3:return i=O.sent(),[3,5];case 4:throw c=O.sent(),f="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?f+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":f+=" Please make sure the server is serving valid JSON for this request.",new Error(f);case 5:if(d=i.modelTopology,g=i.weightsManifest,v=i.generatedBy,w=i.convertedBy,T=i.format,N=i.userDefinedMetadata,d==null&&g==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return g!=null?[4,this.loadWeights(g)]:[3,7];case 6:$=O.sent(),E=$[0],k=$[1],O.label=7;case 7:return M={modelTopology:d,weightSpecs:E,weightData:k,userDefinedMetadata:N,generatedBy:v,convertedBy:w,format:T},G=i.modelInitializer,G&&(M.modelInitializer=G),[2,M]}})})},o.prototype.loadWeights=function(a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v,w,T,N,E,k,$,M,G,O,H,K,nt,ct,dt,Ct;return jt(this,function(St){switch(St.label){case 0:for(i=Array.isArray(this.path)?this.path[1]:this.path,c=Dtt(i),f=c[0],d=c[1],g=this.weightPathPrefix||f,v=[],w=0,T=a;w<T.length;w++)N=T[w],v.push.apply(v,N.weights);for(E=[],k=[],$=0,M=a;$<M.length;$++)for(G=M[$],O=0,H=G.paths;O<H.length;O++)K=H[O],this.weightUrlConverter!=null?k.push(this.weightUrlConverter(K)):E.push(g+K+d);return this.weightUrlConverter?(ct=(nt=E.push).apply,dt=[E],[4,Promise.all(k)]):[3,2];case 1:ct.apply(nt,dt.concat([St.sent()])),St.label=2;case 2:return[4,WA(E,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 3:return Ct=St.sent(),[2,[v,ZT(Ct)]]}})})},o.URL_SCHEME_REGEX=/^https?:\/\//,o}();function Dtt(o){var a=o.lastIndexOf("/"),i=o.lastIndexOf("?"),c=o.substring(0,a),f=i>a?o.substring(i):"";return[c+"/",f]}function sk(o){return o.match(UA.URL_SCHEME_REGEX)!=null}var GA=function(o,a){if(typeof fetch=="undefined"&&(a==null||a.fetchFunc==null))return null;var i=!0;return Array.isArray(o)?i=o.every(function(c){return sk(c)}):i=sk(o),i?ok(o,a):null};Yr.registerSaveRouter(GA);Yr.registerLoadRouter(GA);function ok(o,a){return new UA(o,a)}function $tt(o,a){return ok(o,a)}var ak=function(){function o(a){this.modelArtifacts=a}return o.prototype.load=function(){return qt(this,void 0,void 0,function(){return jt(this,function(a){return[2,this.modelArtifacts]})})},o}(),Att=function(){function o(a){this.saveHandler=a}return o.prototype.save=function(a){return qt(this,void 0,void 0,function(){return jt(this,function(i){return[2,this.saveHandler(a)]})})},o}();function _tt(o,a,i,c){if(arguments.length===1){var f=o.modelTopology!=null||o.weightSpecs!=null;return f?new ak(o):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ak({modelTopology:o}))}else return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ak({modelTopology:o,weightSpecs:a,weightData:i,trainingConfig:c})}function Ftt(o){return new Att(o)}var Rtt={__proto__:null,browserFiles:Ctt,browserHTTPRequest:$tt,concatenateArrayBuffers:ZT,decodeWeights:DA,encodeWeights:WQ,fromMemory:_tt,getLoadHandlers:JQ,getModelArtifactsInfoForJSON:Wf,getSaveHandlers:YQ,http:ok,isHTTPScheme:sk,loadWeights:Ntt,registerLoadRouter:XQ,registerSaveRouter:KQ,weightsLoaderFactory:VA,withSaveHandler:Ftt,copyModel:htt,listModels:ctt,moveModel:ftt,removeModel:ltt};function Ptt(o,a){var i=W(o,"x","reshape",null),c={x:i},f={shape:a},d=function(g,v){return a=o$(a,i.size),U(i.size===mn(a),function(){return"new shape and old shape must have the same number of elements."}),v([i]),g.reshape(i,a)};return Z.runKernelFunc(d,c,null,sT,f)}var it=Y({reshape_:Ptt});function Ott(o,a,i,c){var f;i===void 0&&(i=!1),c===void 0&&(c=!1);var d=W(o,"a","matMul"),g=W(a,"b","matMul");f=pn(d,g),d=f[0],g=f[1];var v=function(N,E){E([d,g]);var k=i?d.shape[d.rank-2]:d.shape[d.rank-1],$=c?g.shape[g.rank-1]:g.shape[g.rank-2],M=i?d.shape[d.rank-1]:d.shape[d.rank-2],G=c?g.shape[g.rank-2]:g.shape[g.rank-1],O=d.shape.slice(0,-2),H=g.shape.slice(0,-2),K=mn(O),nt=mn(H),ct=K===nt||K===1||nt===1;U(d.rank>=2&&g.rank>=2&&ct,function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input "+("batch dimensions of ("+O+") and ("+H+").")}),U(k===$,function(){return"Error in matMul: inner shapes ("+k+") and ("+($+") of Tensors with shapes "+d.shape+" and ")+(g.shape+" and transposeA="+i)+(" and transposeB="+c+" must match.")});var dt=K>nt?O:H,Ct=dt.concat([M,G]),St=i?it(d,[K,k,M]):it(d,[K,M,k]),It=c?it(g,[nt,G,$]):it(g,[nt,$,G]),Gt=N.batchMatMul(St,It,i,c);return it(Gt,Ct)},w={a:d,b:g},T={transposeA:i,transposeB:c};return Z.runKernelFunc(v,w,null,c1,T)}var Ce=Y({matMul_:Ott});function Mtt(o,a,i,c){if(i===void 0&&(i=1),c===void 0&&(c=0),a<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+a);var f=W(o,"indices","oneHot","int32"),d=f.shape.concat([a]),g=function(T,N){return N([f]),it(T.oneHot(it(f,[f.size]),a,i,c),d)},v={indices:f},w={depth:a,onValue:i,offValue:c};return Z.runKernelFunc(g,v,null,Z1,w)}var wg=Y({oneHot_:Mtt});function Ltt(o,a){var i=W(o,"x","transpose");if(a==null&&(a=i.shape.map(function(d,g){return g}).reverse()),U(i.rank===a.length,function(){return"Error in transpose: rank of input "+i.rank+" "+("must match length of perm "+a+".")}),a.forEach(function(d){U(d>=0&&d<i.rank,function(){return"All entries in 'perm' must be between 0 and "+(i.rank-1)+(" but got "+a)})}),i.rank<=1)return i.clone();var c={x:i},f={perm:a};return Z.runKernelFunc(function(d){return d.transpose(i,a)},c,null,DT,f)}var On=Y({transpose_:Ltt});function Btt(o,a,i){var c=W(o,"labels","confusionMatrix"),f=W(a,"predictions","confusionMatrix");U(i==null||i>0&&Number.isInteger(i),function(){return"If provided, numClasses must be a positive integer, "+("but got "+i)}),U(c.rank===1,function(){return"Expected the rank of labels to be 1, but got "+c.rank}),U(f.rank===1,function(){return"Expected the rank of predictions to be 1, "+("but got "+f.rank)}),U(c.shape[0]===f.shape[0],function(){return"Mismatch in the number of examples: "+(c.shape[0]+" vs. "+f.shape[0]+". ")+"Labels and predictions should have the same number of elements."}),U(i>0&&Number.isInteger(i),function(){return"numClasses is required to be a positive integer, but got "+(""+i)});var d=wg(Bt(c,"int32"),i),g=wg(Bt(f,"int32"),i),v=On(d),w=Ce(v,g);return Bt(w,"int32")}var ztt=Y({confusionMatrix_:Btt});var Wtt={__proto__:null,confusionMatrix:ztt};function HA(o,a,i){if(zi(o),a!=null&&a.length!==3)throw new Error("tensor3d() requires shape to have three numbers");var c=uo(o,i);if(c.length!==3&&c.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(c.length===1&&a==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ba(o,a,c,i)}var Pc;function Vtt(o,a){if(a===void 0&&(a=3),a>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var i=!1,c=!1,f=!1,d=!1,g=!1;if(o.data instanceof Uint8Array)i=!0;else if(typeof ImageData!="undefined"&&o instanceof ImageData)c=!0;else if(typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement)f=!0;else if(typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement)d=!0;else if(o.getContext!=null)g=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+("but was "+o.constructor.name));if(f){var v=2;if(f&&o.readyState<v)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}var w=BT(RT,Z.backendName);if(w!=null){var T={pixels:o},N={numChannels:a};return Z.runKernel(RT,T,N)}var E=f?[o.videoWidth,o.videoHeight]:[o.width,o.height],k=E[0],$=E[1],M;g?M=o.getContext("2d").getImageData(0,0,k,$).data:c||i?M=o.data:(d||f)&&(Pc==null&&(Pc=document.createElement("canvas").getContext("2d")),Pc.canvas.width=k,Pc.canvas.height=$,Pc.drawImage(o,0,0,k,$),M=Pc.getImageData(0,0,k,$).data);var G;if(a===4)G=new Int32Array(M);else{var O=k*$;G=new Int32Array(O*a);for(var H=0;H<O;H++)for(var K=0;K<a;++K)G[H*a+K]=M[H*4+K]}var nt=[$,k,a];return HA(G,nt,"int32")}function Utt(o,a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v,w,T,N,E,k,$,M,G,O,H;return jt(this,function(K){switch(K.label){case 0:if(i=W(o,"img","toPixels"),o instanceof ut||(c=i,i=Bt(c,"int32"),c.dispose()),i.rank!==2&&i.rank!==3)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+i.rank+".");if(f=i.shape.slice(0,2),d=f[0],g=f[1],v=i.rank===2?1:i.shape[2],v>4||v===2)throw new Error("toPixels only supports depth of size "+("1, 3 or 4 but got "+v));if(i.dtype!=="float32"&&i.dtype!=="int32")throw new Error("Unsupported type for toPixels: "+i.dtype+". Please use float32 or int32 tensors.");return[4,i.data()];case 1:for(w=K.sent(),T=i.dtype==="float32"?255:1,N=new Uint8ClampedArray(g*d*4),E=0;E<d*g;++E){for(k=[0,0,0,255],$=0;$<v;$++){if(M=w[E*v+$],i.dtype==="float32"){if(M<0||M>1)throw new Error("Tensor values for a float32 Tensor must be in the "+("range [0 - 1] but encountered "+M+"."))}else if(i.dtype==="int32"&&(M<0||M>255))throw new Error("Tensor values for a int32 Tensor must be in the "+("range [0 - 255] but encountered "+M+"."));v===1?(k[0]=M*T,k[1]=M*T,k[2]=M*T):k[$]=M*T}G=E*4,N[G+0]=Math.round(k[0]),N[G+1]=Math.round(k[1]),N[G+2]=Math.round(k[2]),N[G+3]=Math.round(k[3])}return a!=null&&(a.width=g,a.height=d,O=a.getContext("2d"),H=new ImageData(N,g,d),O.putImageData(H,0,0)),i!==o&&i.dispose(),[2,N]}})})}var Gtt=Y({fromPixels_:Vtt}),Htt={__proto__:null,toPixels:Utt,fromPixels:Gtt};function qA(o,a){if(o.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+(" but the rank was "+o.rank+"."));if(a.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+(" but the rank was "+a.rank+"."));if(a.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type,"+(" but the dtype was "+a.dtype+"."));if(a.shape[a.rank-1]>o.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+(a.shape[a.rank-1]+" vs. "+o.rank));if(o.size===0)throw new Error("Requested more than 0 entries, but input is empty."+(" Input shape: "+o.shape+"."));for(var i=a.shape,c=i[i.length-1],f=1,d=0;d<i.length-1;++d)f*=i[d];var g=o.shape,v=i.slice();v.pop();for(var w=1,d=c;d<o.rank;++d)w*=g[d],v.push(g[d]);var T=Nc(o.shape).map(function(N){return N/w}).concat([1]).slice(0,c);return[v,f,w,T]}var qtt={__proto__:null,prepareAndValidate:qA};function ik(o,a,i){var c=a.rank>1?a.shape[a.rank-1]:1,f=a.rank>1?a.rank-1:1,d="Must have updates.shape = indices.shape[:batchDim] + "+("shape[sliceDim:], got updates.shape: "+i.shape)+(", indices.shape: "+a.shape+", shape: "+o)+(", sliceDim: "+c+", and batchDim: "+f+".");if(i.rank<f)throw new Error(d+(" update.rank < "+f+". "));if(o.length<c+(i.rank-f))throw new Error(d+(" Output shape length < "+(c+(i.rank-f))));if(i.rank!==f+o.length-c)throw new Error(d+(" update.rank != "+(f+o.length-c)));for(var g=0;g<f;++g)if(i.shape[g]!==a.shape[g])throw new Error(d+(" updates.shape["+g+"] ("+i.shape[g]+") != indices.shape["+g+"] ("+a.shape[g]+")."));for(var g=0;g<i.rank-f;++g)if(i.shape[g+f]!==o[g+c])throw new Error(d+(" updates.shape["+(g+f)+"] ("+i.shape[g+f]+") != shape["+(g+f)+"] ("+o[g+f]+")"))}function uk(o,a,i){if(a.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+(" but the rank was "+a.rank+"."));if(o.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+(" but the rank was "+o.rank+"."));if(a.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+a.dtype);if(i.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+i);if(i.length===0){if(a.size===0)throw new Error("Indices specified for empty output. indices shape: "+a.shape);if(o.size===0)throw new Error("Updates specified for empty output. updates shape: "+o.shape)}ik(i,a,o)}function jA(o,a,i){for(var c=a.shape.length,f=c>1?a.shape[c-1]:1,d=i.length,g=1,v=f;v<d;++v)g*=i[v];var w=f<1?1:f,T=mn(a.shape)/w,N=Nc(i.slice(0,f)).concat([1]),E=mn(i);return{sliceRank:f,numUpdates:T,sliceSize:g,strides:N,outputSize:E}}var jtt={__proto__:null,validateUpdateShape:ik,validateInput:uk,calculateShapes:jA};function KA(o,a,i){var c=o.shape.length;U(c===a.length,function(){return"Error in slice"+c+"D: Length of begin "+a+" must "+("match the rank of the array ("+c+").")}),U(c===i.length,function(){return"Error in slice"+c+"D: Length of size "+i+" must "+("match the rank of the array ("+c+").")});for(var f=function(g){U(a[g]+i[g]<=o.shape[g],function(){return"Error in slice"+c+"D: begin["+g+"] + size["+g+"] "+("("+(a[g]+i[g])+") would overflow input.shape["+g+"] ("+o.shape[g]+")")})},d=0;d<c;++d)f(d)}function xg(o){for(var a=[],i=0;o>0;)o&1&&a.push(i),o/=2,i++;return a}function XA(o,a,i){for(var c=[],f=0;f<o.length;f++)c[f]=Math.ceil((a[f]-o[f])/i[f]);return c}function YA(o,a,i,c){for(var f=o.slice(),d=f.length;d<c.length;d++)f.push(1);for(var d=0;d<i;d++)d===0?f[a]=1:(f.splice(a,0,1),f.pop());return f}function JA(o,a,i){return i<=o?i:i-(a-1)}function ZA(o,a){for(var i=[],c=0;c<o;c++)i.push(a+c);return i}function s_(o,a,i,c,f,d,g,v,w){var T=o.length,N=new Array(T),E=new Array(T),k=new Array(T);if(a.length&&i>0){var $=a[0],M=i+1;N=QA(g,$,M,c,o),E=t_(v,$,M,f,o),k=YA(d,$,M,o)}else for(var G=0;G<T;G++)N[G]=n_(g,c,d,o,G,w),E[G]=r_(v,f,d,o,G,w),k[G]=e_(d,G,w);return{begin:N,end:E,strides:k}}function QA(o,a,i,c,f){for(var d=f.slice(),g=ZA(i,a),v=0;v<d.length;v++)if(g.indexOf(v)>-1)d[v]=0;else{var w=JA(a,i,v),T=c[w];o&1<<w&&(T=0),d[v]=T}return d}function t_(o,a,i,c,f){for(var d=f.slice(),g=ZA(i,a),v=0;v<d.length;v++)if(g.indexOf(v)>-1)d[v]=Number.MAX_SAFE_INTEGER;else{var w=JA(a,i,v),T=c[w];o&1<<w&&(T=Number.MAX_SAFE_INTEGER),d[v]=T}for(var N=0;N<d.length;N++){var E=f[N];d[N]<0&&(d[N]+=E),d[N]=Ff(0,d[N],f[N])}return d}function e_(o,a,i){var c=o[a];return(i&1<<a||c==null)&&(c=1),c}function n_(o,a,i,c,f,d){var g=a[f],v=i[f]||1;(o&1<<f||d&1<<f||g==null)&&(v>0?g=Number.MIN_SAFE_INTEGER:g=Number.MAX_SAFE_INTEGER);var w=c[f];return g<0&&(g+=w),g=Ff(0,g,w-1),g}function r_(o,a,i,c,f,d){var g=a[f],v=i[f]||1;(o&1<<f||d&1<<f||g==null)&&(v>0?g=Number.MAX_SAFE_INTEGER:g=Number.MIN_SAFE_INTEGER);var w=c[f];return g<0&&(g+=w),v>0?g=Ff(0,g,w):g=Ff(-1,g,w-1),g}function Ktt(o,a,i){for(var c=i.length,f=0;f<i.length;f++)if(i[f]>1){c=f;break}for(var f=c+1;f<i.length;f++)if(a[f]>0||i[f]!==o[f])return!1;return!0}function Xtt(o,a){for(var i=o.length>0?o[o.length-1]:1,c=0;c<o.length-1;c++)i+=o[c]*a[c];return i}function ck(o,a,i){var c,f=o.shape.length;typeof a=="number"?c=[a].concat(new Array(f-1).fill(0)):a.length<f?c=a.concat(new Array(f-a.length).fill(0)):c=a.slice(),c.forEach(function(g){U(g!==-1,function(){return"slice() does not support negative begin indexing."})});var d;return i==null?d=new Array(f).fill(-1):typeof i=="number"?d=[i].concat(new Array(f-1).fill(-1)):i.length<f?d=i.concat(new Array(f-i.length).fill(-1)):d=i,d=d.map(function(g,v){return g>=0?g:(U(g===-1,function(){return"Negative size values should be exactly -1 but got "+(g+" for the slice() size at index "+v+".")}),o.shape[v]-c[v])}),[c,d]}var o_={__proto__:null,assertParamsValid:KA,maskToAxes:xg,computeOutShape:XA,stridesWithElidedDims:YA,getNormalizedAxes:s_,startIndicesWithElidedDims:QA,stopIndicesWithElidedDims:t_,stridesForAxis:e_,startForAxis:n_,stopForAxis:r_,isSliceContinous:Ktt,computeFlatOffset:Xtt,parseSliceParams:ck};var a_=function(){function o(){}return o.prototype.getClassName=function(){return this.constructor.className},o.fromConfig=function(a,i){return new a(i)},o}(),i_=function(){function o(){this.classNameMap={}}return o.getMap=function(){return o.instance==null&&(o.instance=new o),o.instance},o.register=function(a){o.getMap().classNameMap[a.className]=[a,a.fromConfig]},o}();function Ua(o){U(o.className!=null,function(){return"Class being registered does not have the static className property defined."}),U(typeof o.className=="string",function(){return"className is required to be a string, but got type "+typeof o.className}),U(o.className.length>0,function(){return"Class being registered has an empty-string as its className, which is disallowed."}),i_.register(o)}var Ytt={__proto__:null,Serializable:a_,SerializationMap:i_,registerClass:Ua};var Jtt=.001,u_=.1;function Ztt(o,a,i){return i==null&&(i=lk()),hk(o,a,function(c,f){return fk(c,f,i)})}function lk(){return Z.backend.floatPrecision()===32?Jtt:u_}function hk(o,a,i){var c=!0;if((Jn(o)||Jn(a))&&(c=!1),Jn(o)&&Jn(a)&&(c=!0),c){var f=o.constructor.name,d=a.constructor.name;if(f!==d)throw new Error("Arrays are of different type. Actual: "+f+". "+("Expected: "+d))}if(Array.isArray(o)&&Array.isArray(a)){var g=uo(o),v=uo(a);if(!Rs(g,v))throw new Error("Arrays have different shapes. "+("Actual: ["+g+"]. Expected: ["+v+"]"))}var w=Jn(o)?o:Wi(o),T=Jn(a)?a:Wi(a);if(w.length!==T.length)throw new Error("Arrays have different lengths actual: "+w.length+" vs "+("expected: "+T.length+`.
`)+("Actual:   "+w+`.
`)+("Expected: "+T+"."));for(var N=0;N<T.length;++N){var E=w[N],k=T[N];if(!i(E,k))throw new Error("Arrays differ: actual["+N+"] = "+E+", expected["+N+"] = "+k+`.
`+("Actual:   "+w+`.
`)+("Expected: "+T+"."))}}function Qtt(o,a){o().then(function(){return a.fail()},function(){return a()})}function tet(o,a){var i=typeof a=="string"||typeof a=="number"||typeof a=="boolean"?[a]:a;return Oa(o)||Oa(o[0])||Oa(a)||Oa(a[0])?hk(o,i,function(c,f){return c==f}):hk(o,a,function(c,f){return fk(c,f,0)})}function eet(o,a,i){if(i==null&&(i=lk()),!fk(o,a,i))throw new Error("Numbers differ: actual === "+o+", expected === "+a)}function fk(o,a,i){return!isFinite(o)&&!isFinite(a)?!0:!(isNaN(o)||isNaN(a)||Math.abs(o-a)>i)}function net(o,a,i){for(var c=0;c<o.length;c++)if(o[c]<a||o[c]>i)throw new Error("Value out of range:"+o[c]+" low: "+a+", high: "+i)}function ret(o,a){expect(new Float32Array(o)).toEqual(new Float32Array(a))}var set={__proto__:null,TEST_EPSILON_FLOAT16:u_,expectArraysClose:Ztt,testEpsilon:lk,expectPromiseToFail:Qtt,expectArraysEqual:tet,expectNumbersClose:eet,expectValuesInRange:net,expectArrayBuffersEqual:ret};var oet="2.7.0";function aet(){Fe().set("PROD",!0)}function iet(){Fe().set("DEBUG",!0)}function uet(){Fe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Mn(o){Fe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(o+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function cet(){Z.disposeVariables()}function het(){return Z}function fet(){return Z.memory()}function pet(o){return Z.profile(o)}function En(o,a){return Z.tidy(o,a)}function wr(o){var a=XT(o);a.forEach(function(i){return i.dispose()})}function c_(o){return Z.keep(o)}function det(o){return Z.time(o)}function met(o){return Z.setBackend(o)}function get(){return Z.ready()}function vet(){return Z.backendName}function yet(o){Z.removeBackend(o)}function bet(o){return Z.findBackend(o)}function wet(o){return Z.findBackendFactory(o)}function xet(o,a,i){return i===void 0&&(i=1),Z.registerBackend(o,a,i)}function Tet(){return Z.backend}function ket(o,a){Fe().setPlatform(o,a)}function Cet(o,a){var i,c=W(o,"a","add"),f=W(a,"b","add");i=pn(c,f),c=i[0],f=i[1];var d=function(v,w){var T=v.add(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,hg)}var Yt=Y({add_:Cet});function Net(o,a){var i,c=W(o,"a","floorDiv"),f=W(a,"b","floorDiv");i=pn(c,f),c=i[0],f=i[1];var d=function(v,w){var T=v.floorDiv(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,D1)}var pk=Y({floorDiv_:Net});function Iet(o,a){var i,c=W(o,"a","div"),f=W(a,"b","div");if(i=pn(c,f),c=i[0],f=i[1],c.dtype==="int32"&&f.dtype==="int32")return pk(c,f);var d=function(w,T){var N=w.realDivide(c,f);return T([c,f]),N},g={a:c,b:f},v={};return Z.runKernelFunc(d,g,null,k1,v)}var ae=Y({div_:Iet});function Eet(o,a){var i,c=W(o,"a","mul"),f=W(a,"b","mul");i=pn(c,f),c=i[0],f=i[1];var d=function(v,w){var T=v.multiply(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,X1)}var pt=Y({mul_:Eet});function Det(o){var a=W(o,"x","abs"),i={x:a};return Z.runKernelFunc(function(c,f){return f([a]),a.dtype==="complex64"?c.complexAbs(a):c.abs(a)},i,null,Yx)}var _r=Y({abs_:Det});function $et(o){var a=W(o,"x","acos"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.acos(a);return f([a]),d},i,null,Jx)}var l_=Y({acos_:$et});function Aet(o){var a=W(o,"x","acosh"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.acosh(a);return f([a]),d},i,null,Zx)}var h_=Y({acosh_:Aet});function _et(o){U(Array.isArray(o),function(){return"The argument passed to tf.addN() must be a list of tensors"}),U(o.length>=1,function(){return"Must pass at least one tensor to tf.addN(), but got "+(""+o.length)});var a=o.map(function(d,g){return W(d,"tensors"+g,"addN")}),i=a[0];a.forEach(function(d){if(d.dtype!==i.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),a.forEach(function(d){if(!Rs(d.shape,i.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});var c=function(d,g){var v=d.addN(a);return g(a),v},f=a;return Z.runKernelFunc(c,f,null,Qx)}var Fet=Y({addN_:_et});function dk(o,a){for(var i=0;i<o.length;++i)if(o[o.length-i-1]!==a-1-i)return!1;return!0}function f_(o,a,i){for(var c=o.length+a.length,f=[],d=0,g=0,v=0;v<c;v++)i.indexOf(v)===-1?f.push(o[d++]):f.push(a[g++]);return f}function p_(o,a){for(var i=[],c=o.length,f=0;f<c;f++)a.indexOf(f)===-1&&i.push(o[f]);var d=a.map(function(g){return o[g]});return[i,d]}function Jr(o,a){var i=a.map(function(c){return 1});return f_(o,i,a)}function Ret(o,a,i){U(dk(a,i),function(){return o+" supports only inner-most axes for now. "+("Got axes "+a+" and rank-"+i+" input.")})}function Ps(o,a){if(dk(o,a))return null;for(var i=[],c=0;c<a;++c)o.indexOf(c)===-1&&i.push(c);return o.forEach(function(f){return i.push(f)}),i}function Tg(o){return o.map(function(a,i){return[i,a]}).sort(function(a,i){return a[1]-i[1]}).map(function(a){return a[0]})}function lo(o,a){for(var i=[],c=a-o;c<a;++c)i.push(c);return i}function Pet(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","all","bool"),f=function(v){var w=Qe(a,c.shape),T=w,N=Ps(T,c.rank);N!=null&&(c=On(c,N),T=lo(T.length,c.rank));var E=v.all(c,T);if(i){var k=Jr(E.shape,w);return it(E,k)}return E},d={x:c},g={axis:a,keepDims:i};return Z.runKernelFunc(f,d,null,w$,g)}var d_=Y({all_:Pet});function Oet(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","any","bool"),f=function(v){var w=Qe(a,c.shape),T=w,N=Ps(T,c.rank);N!=null&&(c=On(c,N),T=lo(T.length,c.rank));var E=v.any(c,T);if(i){var k=Jr(E.shape,w);return it(E,k)}return E},d={x:c},g={axis:a,keepDims:i};return Z.runKernelFunc(f,d,null,x$,g)}var m_=Y({any_:Oet});function Met(o,a){a===void 0&&(a=0);var i=W(o,"x","argMax"),c=function(g,v){v([i]);var w=Qe(a,i.shape),T=Ps(w,i.rank);return T!=null&&(i=On(i,T),w=lo(w.length,i.rank)),g.argMax(i,w[0])},f={x:i},d={axis:a};return Z.runKernelFunc(c,f,null,t1,d)}var g_=Y({argMax_:Met});function Let(o,a){a===void 0&&(a=0);var i=W(o,"x","argMin"),c=function(g,v){v([i]),a==null&&(a=0);var w=Qe(a,i.shape),T=Ps(w,i.rank);return T!=null&&(i=On(i,T),w=lo(w.length,i.rank)),g.argMin(i,w[0])},f={x:i},d={axis:a};return Z.runKernelFunc(c,f,null,e1,d)}var v_=Y({argMin_:Let});function Bet(o){var a=W(o,"x","asin"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.asin(a);return f([a]),d},i,null,n1)}var y_=Y({asin_:Bet});function zet(o){var a=W(o,"x","asinh"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.asinh(a);return f([a]),d},i,null,r1)}var b_=Y({asinh_:zet});function Wet(o){var a=W(o,"x","atan"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.atan(a);return f([a]),d},i,null,s1)}var w_=Y({atan_:Wet});function Vet(o,a){var i,c=W(o,"a","atan2"),f=W(a,"b","atan2");i=pn(c,f),c=i[0],f=i[1];var d=function(v,w){var T=v.atan2(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,a1)}var x_=Y({atan2_:Vet});function Uet(o){var a=W(o,"x","atanh"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.atanh(a);return f([a]),d},i,null,o1)}var T_=Y({atanh_:Uet});function Get(o,a,i,c,f,d){f===void 0&&(f="NHWC");var g=o[3],v=a.concat([g]),w=Vf(f);return Os(o,v,i,d,c,null,null,w)}function Oc(o,a,i,c,f,d,g){g===void 0&&(g="channelsLast");var v=kg(a),w=v[0],T=v[1],N;if(g==="channelsLast")N=[w,T,o[3],o[3]];else if(g==="channelsFirst")N=[w,T,o[1],o[1]];else throw new Error("Unknown dataFormat "+g);return Os(o,N,i,c,f,d,!1,g)}function Gf(o,a,i,c,f,d,g){g===void 0&&(g="NDHWC");var v=mk(a),w=v[0],T=v[1],N=v[2],E,k;if(g==="NDHWC")k="channelsLast",E=[w,T,N,o[4],o[4]];else if(g==="NCDHW")k="channelsFirst",E=[w,T,N,o[1],o[1]];else throw new Error("Unknown dataFormat "+g);return Uf(o,E,i,c,f,!1,k,d)}function Os(o,a,i,c,f,d,g,v){g===void 0&&(g=!1),v===void 0&&(v="channelsLast");var w=[-1,-1,-1,-1],T=w[0],N=w[1],E=w[2],k=w[3];if(v==="channelsLast")T=o[0],N=o[1],E=o[2],k=o[3];else if(v==="channelsFirst")T=o[0],k=o[1],N=o[2],E=o[3];else throw new Error("Unknown dataFormat "+v);var $=a[0],M=a[1],G=a[3],O=kg(i),H=O[0],K=O[1],nt=kg(c),ct=nt[0],dt=nt[1],Ct=Mc($,ct),St=Mc(M,dt),It=Het(f,N,E,H,K,Ct,St,d,v),Gt=It.padInfo,Et=It.outHeight,Wt=It.outWidth,_t=g?G*k:G,Kt;return v==="channelsFirst"?Kt=[T,_t,Et,Wt]:v==="channelsLast"&&(Kt=[T,Et,Wt,_t]),{batchSize:T,dataFormat:v,inHeight:N,inWidth:E,inChannels:k,outHeight:Et,outWidth:Wt,outChannels:_t,padInfo:Gt,strideHeight:H,strideWidth:K,filterHeight:$,filterWidth:M,effectiveFilterHeight:Ct,effectiveFilterWidth:St,dilationHeight:ct,dilationWidth:dt,inShape:o,outShape:Kt,filterShape:a}}function Uf(o,a,i,c,f,d,g,v){d===void 0&&(d=!1),g===void 0&&(g="channelsLast");var w=[-1,-1,-1,-1,-1],T=w[0],N=w[1],E=w[2],k=w[3],$=w[4];if(g==="channelsLast")T=o[0],N=o[1],E=o[2],k=o[3],$=o[4];else if(g==="channelsFirst")T=o[0],$=o[1],N=o[2],E=o[3],k=o[4];else throw new Error("Unknown dataFormat "+g);var M=a[0],G=a[1],O=a[2],H=a[4],K=mk(i),nt=K[0],ct=K[1],dt=K[2],Ct=mk(c),St=Ct[0],It=Ct[1],Gt=Ct[2],Et=Mc(M,St),Wt=Mc(G,It),_t=Mc(O,Gt),Kt=qet(f,N,E,k,nt,ct,dt,Et,Wt,_t,v),Ne=Kt.padInfo,ce=Kt.outDepth,me=Kt.outHeight,Re=Kt.outWidth,gn=d?H*$:H,en;return g==="channelsFirst"?en=[T,gn,ce,me,Re]:g==="channelsLast"&&(en=[T,ce,me,Re,gn]),{batchSize:T,dataFormat:g,inDepth:N,inHeight:E,inWidth:k,inChannels:$,outDepth:ce,outHeight:me,outWidth:Re,outChannels:gn,padInfo:Ne,strideDepth:nt,strideHeight:ct,strideWidth:dt,filterDepth:M,filterHeight:G,filterWidth:O,effectiveFilterDepth:Et,effectiveFilterHeight:Wt,effectiveFilterWidth:_t,dilationDepth:St,dilationHeight:It,dilationWidth:Gt,inShape:o,outShape:en,filterShape:a}}function jet(o,a,i,c,f){c==null&&(c=gk(o,a,i));var d=o[0],g=o[1],v=Gi((d-a+2*c)/i+1,f);U(fn(v),function(){return"The output # of rows ("+v+") must be an integer. Change the stride and/or zero pad parameters"});var w=Gi((g-a+2*c)/i+1,f);return U(fn(w),function(){return"The output # of columns ("+w+") must be an integer. Change the stride and/or zero pad parameters"}),[v,w]}function Ket(o,a,i,c,f,d){f==null&&(f=gk(o,a,c));var g=o[0],v=o[1],w=o[2],T=Gi((g-a+2*f)/c+1,d);U(fn(T),function(){return"The output # of depths ("+T+") must be an integer. Change the stride and/or zero pad parameters"});var N=Gi((v-a+2*f)/c+1,d);U(fn(N),function(){return"The output # of rows ("+N+") must be an integer. Change the stride and/or zero pad parameters"});var E=Gi((w-a+2*f)/c+1,d);return U(fn(E),function(){return"The output # of columns ("+E+") must be an integer. Change the stride and/or zero pad parameters"}),[T,N,E,i]}function gk(o,a,i,c){c===void 0&&(c=1);var f=Mc(a,c);return Math.floor((o[0]*(i-1)-i+f)/2)}function kg(o){return typeof o=="number"?[o,o,o]:o.length===2?[o[0],o[1],1]:o}function mk(o){return typeof o=="number"?[o,o,o]:o}function Mc(o,a){return a<=1?o:o+(o-1)*(a-1)}function Het(o,a,i,c,f,d,g,v,w){var T,N,E;if(typeof o=="number"){var k=o===0?"VALID":"NUMBER";T={top:o,bottom:o,left:o,right:o,type:k};var $=jet([a,i],d,c,o,v);N=$[0],E=$[1]}else if(o==="same"){N=Math.ceil(a/c),E=Math.ceil(i/f);var M=Math.max(0,(N-1)*c+d-a),G=Math.max(0,(E-1)*f+g-i),O=Math.floor(M/2),H=M-O,K=Math.floor(G/2),nt=G-K;T={top:O,bottom:H,left:K,right:nt,type:"SAME"}}else if(o==="valid")T={top:0,bottom:0,left:0,right:0,type:"VALID"},N=Math.ceil((a-d+1)/c),E=Math.ceil((i-g+1)/f);else if(typeof o=="object"){var ct=w==="channelsLast"?o[1][0]:o[2][0],H=w==="channelsLast"?o[1][1]:o[2][1],K=w==="channelsLast"?o[2][0]:o[3][0],nt=w==="channelsLast"?o[2][1]:o[3][1],k=ct===0&&H===0&&K===0&&nt===0?"VALID":"EXPLICIT";T={top:ct,bottom:H,left:K,right:nt,type:k},N=Gi((a-d+ct+H)/c+1,v),E=Gi((i-g+K+nt)/f+1,v)}else throw Error("Unknown padding parameter: "+o);return{padInfo:T,outHeight:N,outWidth:E}}function qet(o,a,i,c,f,d,g,v,w,T,N){var E,k,$,M;if(typeof o=="number"){var G=o===0?"VALID":"NUMBER";E={top:o,bottom:o,left:o,right:o,front:o,back:o,type:G};var O=Ket([a,i,c,1],v,1,f,o,N);k=O[0],$=O[1],M=O[2]}else if(o==="same"){k=Math.ceil(a/f),$=Math.ceil(i/d),M=Math.ceil(c/g);var H=(k-1)*f+v-a,K=($-1)*d+w-i,nt=(M-1)*g+T-c,ct=Math.floor(H/2),dt=H-ct,Ct=Math.floor(K/2),St=K-Ct,It=Math.floor(nt/2),Gt=nt-It;E={top:Ct,bottom:St,left:It,right:Gt,front:ct,back:dt,type:"SAME"}}else if(o==="valid")E={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},k=Math.ceil((a-v+1)/f),$=Math.ceil((i-w+1)/d),M=Math.ceil((c-T+1)/g);else throw Error("Unknown padding parameter: "+o);return{padInfo:E,outDepth:k,outHeight:$,outWidth:M}}function Gi(o,a){if(!a)return o;switch(a){case"round":return Math.round(o);case"ceil":return Math.ceil(o);case"floor":return Math.floor(o);default:throw new Error("Unknown roundingMode "+a)}}function Ga(o){var a=kg(o),i=a[0],c=a[1],f=a[2];return i===1&&c===1&&f===1}function xr(o,a){return Ga(o)||Ga(a)}function Vf(o){if(o==="NHWC")return"channelsLast";if(o==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+o)}function Xet(o,a,i,c,f){var d=W(o,"x","avgPool","float32"),g=1;U(xr(i,g),function(){return"Error in avgPool: Either strides or dilations must be 1. "+("Got strides "+i+" and dilations '"+g+"'")});var v=d,w=!1;d.rank===3&&(w=!0,v=it(d,[1,d.shape[0],d.shape[1],d.shape[2]])),U(v.rank===4,function(){return"Error in avgPool: x must be rank 4 but got rank "+v.rank+"."}),f!=null&&U(fn(c),function(){return"Error in avgPool: pad must be an integer when using, "+("dimRoundingMode "+f+" but got pad "+c+".")});var T=function($,M){var G=Oc(v.shape,a,i,1,c,f);return M([v]),G.filterWidth===1&&G.filterHeight===1&&Rs(G.inShape,G.outShape)?v.clone():$.avgPool(v,G)},N={x:v},E={filterSize:a,strides:i,pad:c,dimRoundingMode:f},k=Z.runKernelFunc(T,N,null,i1,E);return k=Bt(k,d.dtype),w?it(k,[k.shape[1],k.shape[2],k.shape[3]]):k}var vk=Y({avgPool_:Xet});function Yet(o,a,i,c,f,d,g){d===void 0&&(d="NDHWC"),g==null?g=[1,1,1]:Mn("dilations is deprecated, this field will be gone in v3.0.0.");var v=W(o,"x","avgPool3d","float32"),w=v,T=!1;v.rank===4&&(T=!0,w=it(v,[1,v.shape[0],v.shape[1],v.shape[2],v.shape[3]])),U(w.rank===5,function(){return"Error in avgPool3d: x must be rank 5 but got rank "+w.rank+"."}),U(d==="NDHWC",function(){return"Error in avgPool3d: Only NDHWC is currently supported, "+("but got dataFormat of "+d)}),U(xr(i,g),function(){return"Error in avgPool3d: Either strides or dilations must be 1. "+("Got strides "+i+" and dilations '"+g+"'")}),f!=null&&U(fn(c),function(){return"Error in avgPool3d: pad must be an integer when using, "+("dimRoundingMode "+f+" but got pad "+c+".")});var N=function(M,G){g==null&&(g=[1,1,1]);var O=Gf(w.shape,a,i,g,c,f,d);return G([w]),M.avgPool3d(w,O)},E={x:w},k={filterSize:a,strides:i,pad:c,dimRoundingMode:f,dataFormat:d,dilations:g},$=Z.runKernelFunc(N,E,null,u1,k);return $=Bt($,w.dtype),T?it($,[$.shape[1],$.shape[2],$.shape[3],$.shape[4]]):$}var Jet=Y({avgPool3d_:Yet});function k_(o,a){var i=o[0].length;o.forEach(function(f,d){U(f.length===i,function(){return"Error in concat"+i+"D: rank of tensors["+d+"] must be the same "+("as the rank of the rest ("+i+")")})}),U(a>=0&&a<i,function(){return"Error in concat"+i+"D: axis must be between 0 and "+(i-1)+"."});var c=o[0];o.forEach(function(f,d){for(var g=0;g<i;g++)U(g===a||f[g]===c[g],function(){return"Error in concat"+i+"D: Shape of tensors["+d+"] ("+f+") "+("does not match the shape of the rest ("+c+") ")+("along the non-concatenated axis "+d+".")})})}function S_(o,a){for(var i=o[0].slice(),c=1;c<o.length;c++)i[a]+=o[c][a];return i}function Zet(o,a){a===void 0&&(a=0),U(o.length>=1,function(){return"Pass at least one tensor to concat"});var i=zf(o,"tensors","concat");i[0].dtype==="complex64"&&i.forEach(function(g){if(g.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+g.dtype+". ")});var c=function(g,v){var w=Qe(a,i[0].shape)[0],T=S_(i.map(function(k){return k.shape}),w);if(mn(T)===0)return za([],T);if(i=i.filter(function(k){return k.size>0}),i.length===1)return i[0];var N=i.map(function(k){return k.shape});k_(N,w);var E=g.concat(i,w);return v(i),E},f=i,d={axis:a};return Z.runKernelFunc(c,f,null,d1,d)}var qn=Y({concat_:Zet});function Qet(o){var a=W(o,"x","sigmoid"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.sigmoid(a);return f([d]),d},i,null,vT)}var Hi=Y({sigmoid_:Qet});function tnt(o,a,i){var c=W(o,"x","slice");if(c.rank===0)throw new Error("Slicing scalar is not possible");var f=function(v,w){var T=ck(c,a,i),N=T[0],E=T[1];return KA(c,N,E),w([c]),v.slice(c,N,E)},d={x:c},g={begin:a,size:i};return Z.runKernelFunc(f,d,null,pT,g)}var De=Y({slice_:tnt});function ent(o){var a=W(o,"x","tanh"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.tanh(a);return f([d]),d},i,null,IT)}var Sg=Y({tanh_:ent});function nnt(o,a,i,c,f,d){var g=W(o,"forgetBias","basicLSTMCell"),v=W(a,"lstmKernel","basicLSTMCell"),w=W(i,"lstmBias","basicLSTMCell"),T=W(c,"data","basicLSTMCell"),N=W(f,"c","basicLSTMCell"),E=W(d,"h","basicLSTMCell"),k=qn([T,E],1),$=Ce(k,v),M=Yt($,w),G=M.shape[0],O=M.shape[1]/4,H=[G,O],K=De(M,[0,0],H),nt=De(M,[0,O],H),ct=De(M,[0,O*2],H),dt=De(M,[0,O*3],H),Ct=Yt(pt(Hi(K),Sg(nt)),pt(N,Hi(Yt(g,ct)))),St=pt(Sg(Ct),Hi(dt));return[Ct,St]}var rnt=Y({basicLSTMCell_:nnt});function snt(o,a,i){var c=W(o,"x","batchToSpaceND"),f=a.reduce(function(w,T){return w*T});U(c.rank>=1+a.length,function(){return"input rank is "+c.rank+" but should be > than blockShape.length "+a.length}),U(i.length===a.length,function(){return"crops.length is "+i.length+" but should be equal to blockShape.length  "+a.length}),U(c.shape[0]%f===0,function(){return"input tensor batch is "+c.shape[0]+" but is not divisible by the product of "+("the elements of blockShape "+a.join(" * ")+" === "+f)});var d=function(w){return w.batchToSpaceND(c,a,i)},g={x:c},v={blockShape:a,crops:i};return Z.runKernelFunc(d,g,null,l1,v)}var Cg=Y({batchToSpaceND_:snt});function ont(o){var a;return o.rank===0||o.rank===1?a=it(o,[1,1,1,o.size]):o.rank===2?a=it(o,[1,1,o.shape[0],o.shape[1]]):o.rank===3?a=it(o,[1,o.shape[0],o.shape[1],o.shape[2]]):a=o,a}function ant(o,a,i,c,f,d){d==null&&(d=.001);var g=W(o,"x","batchNorm"),v=W(a,"mean","batchNorm"),w=W(i,"variance","batchNorm"),T;f!=null&&(T=W(f,"scale","batchNorm"));var N;c!=null&&(N=W(c,"offset","batchNorm")),U(v.rank===w.rank,function(){return"Batch normalization gradient requires mean and variance to have equal ranks."}),U(N==null||v.rank===N.rank,function(){return"Batch normalization gradient requires mean and offset to have equal ranks."}),U(T==null||v.rank===T.rank,function(){return"Batch normalization gradient requires mean and scale to have equal ranks."});var E=ont(g),k=function(O,H){return H([E,v,w,T]),O.batchNorm(E,Ng(v),Ng(w),Ng(N),Ng(T),d)},$={x:E,scale:T,offset:N,mean:v,variance:w},M={varianceEpsilon:d},G=Z.runKernelFunc(k,$,null,$1,M);return it(G,g.shape)}function Ng(o){return o==null?null:o.rank===0?it(o,[o.size]):o.rank===1?o:o.rank===2?it(o,[1,1,o.shape[0],o.shape[1]]):o.rank===3?it(o,[1,o.shape[0],o.shape[1],o.shape[2]]):o}var Hf=Y({batchNorm_:ant});function int(o,a,i,c,f,d){var g=W(o,"x","batchNorm"),v=W(a,"mean","batchNorm"),w=W(i,"variance","batchNorm"),T;f!=null&&(T=W(f,"scale","batchNorm"));var N;return c!=null&&(N=W(c,"offset","batchNorm")),U(g.rank===2,function(){return"Error in batchNorm2D: x must be rank 2 but got rank "+(g.rank+".")}),U(v.rank===2||v.rank===1,function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+("got rank "+v.rank+".")}),U(w.rank===2||w.rank===1,function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 "+("but got rank "+w.rank+".")}),T!=null&&U(T.rank===2||T.rank===1,function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 "+("but got rank "+T.rank+".")}),N!=null&&U(N.rank===2||N.rank===1,function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 "+("but got rank "+N.rank+".")}),Hf(g,v,w,N,T,d)}var unt=Y({batchNorm2d_:int});function cnt(o,a,i,c,f,d){var g=W(o,"x","batchNorm"),v=W(a,"mean","batchNorm"),w=W(i,"variance","batchNorm"),T;f!=null&&(T=W(f,"scale","batchNorm"));var N;return c!=null&&(N=W(c,"offset","batchNorm")),U(g.rank===3,function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+(g.rank+".")}),U(v.rank===3||v.rank===1,function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+("got rank "+v.rank+".")}),U(w.rank===3||w.rank===1,function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 "+("but got rank "+w.rank+".")}),T!=null&&U(T.rank===3||T.rank===1,function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 "+("but got rank "+T.rank+".")}),N!=null&&U(N.rank===3||N.rank===1,function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 "+("but got rank "+N.rank+".")}),Hf(g,v,w,N,T,d)}var lnt=Y({batchNorm3d_:cnt});function hnt(o,a,i,c,f,d){var g=W(o,"x","batchNorm"),v=W(a,"mean","batchNorm"),w=W(i,"variance","batchNorm"),T;f!=null&&(T=W(f,"scale","batchNorm"));var N;return c!=null&&(N=W(c,"offset","batchNorm")),U(g.rank===4,function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+(g.rank+".")}),U(v.rank===4||v.rank===1,function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+("got rank "+v.rank+".")}),U(w.rank===4||w.rank===1,function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 "+("but got rank "+w.rank+".")}),T!=null&&U(T.rank===4||T.rank===1,function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 "+("but got rank "+T.rank+".")}),N!=null&&U(N.rank===4||N.rank===1,function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 "+("but got rank "+N.rank+".")}),Hf(g,v,w,N,T,d)}var fnt=Y({batchNorm4d_:hnt});function pnt(o,a){var i=W(o,"broadcastTo","x"),c=i.shape;if(a.some(function(k){return!(k>0)||k%1!==0}))throw new Error("broadcastTo(): Invalid broadcast shape ["+a+"].");if(a.length<i.rank)throw new Error("broadcastTo(): shape.length="+a.length+" < input.rank="+i.rank+".");if(a.length>i.rank){for(var f=i.shape.slice();f.length<a.length;)f.unshift(1);i=it(i,f)}for(var d=i.shape,g=Array.from(a),v=a.length-1;v>=0;v--)if(d[v]===a[v])g[v]=1;else if(i.shape[v]!==1)throw new Error("broadcastTo(): ["+c+"] cannot be broadcast to ["+a+"].");var w=g.map(function(k,$){return k>1?$:-1}).filter(function(k){return k>=0});if(w.length===0)return Ui(i);var T=function(k){return k.tile(i,g)},N={x:i},E={shape:a,inputShape:d};return Z.runKernelFunc(T,N,null,h1,E)}var Ig=Y({broadcastTo_:pnt});function dnt(o){var a=W(o,"x","ceil"),i={x:a};return Z.runKernelFunc(function(c){return c.ceil(a)},i,null,f1)}var C_=Y({ceil_:dnt});function mnt(o,a,i){var c=W(o,"x","clipByValue");U(a<=i,function(){return"Error in clip: min ("+a+") must be "+("less than or equal to max ("+i+").")});var f={x:c},d={clipValueMin:a,clipValueMax:i};return Z.runKernelFunc(function(g,v){var w=g.clip(c,a,i);return v([c]),w},f,null,p1,d)}var N_=Y({clipByValue_:mnt});function gnt(o){return qn(o,0)}var vnt=Y({concat1d_:gnt});function ynt(o,a){return qn(o,a)}var bnt=Y({concat2d_:ynt});function wnt(o,a){return qn(o,a)}var xnt=Y({concat3d_:wnt});function Tnt(o,a){return qn(o,a)}var knt=Y({concat4d_:Tnt});function Snt(o,a,i,c,f,d,g){f===void 0&&(f="NHWC"),d===void 0&&(d=[1,1]);var v=W(o,"x","conv2d"),w=W(a,"filter","conv2d"),T=v,N=!1;v.rank===3&&(N=!0,T=it(v,[1,v.shape[0],v.shape[1],v.shape[2]])),U(T.rank===4,function(){return"Error in conv2d: input must be rank 4, but got rank "+T.rank+"."}),U(w.rank===4,function(){return"Error in conv2d: filter must be rank 4, but got rank "+(w.rank+".")}),g!=null&&U(fn(c),function(){return"Error in conv2d: pad must be an integer when using, "+("dimRoundingMode "+g+" but got pad "+c+".")});var E=f==="NHWC"?T.shape[3]:T.shape[1];U(E===w.shape[2],function(){return"Error in conv2d: depth of input ("+E+") must match "+("input depth for filter "+w.shape[2]+".")}),U(xr(i,d),function(){return"Error in conv2D: Either strides or dilations must be 1. "+("Got strides "+i+" and dilations '"+d+"'")});var k=function(O,H){var K=Vf(f),nt=Os(T.shape,w.shape,i,d,c,g,!1,K),ct=O.conv2d(T,w,nt);return H([T,w]),ct},$={x:T,filter:w},M={strides:i,pad:c,dataFormat:f,dilations:d,dimRoundingMode:g},G=Z.runKernelFunc(k,$,null,m1,M);return N?it(G,[G.shape[1],G.shape[2],G.shape[3]]):G}var Lc=Y({conv2d_:Snt});function Cnt(o,a,i,c,f,d,g){f===void 0&&(f="NWC"),d===void 0&&(d=1);var v=W(o,"x","conv1d"),w=W(a,"filter","conv1d"),T=v,N=!1;v.rank===2&&(N=!0,T=it(v,[1,v.shape[0],v.shape[1]])),U(T.rank===3,function(){return"Error in conv1d: input must be rank 3, but got rank "+T.rank+"."}),U(w.rank===3,function(){return"Error in conv1d: filter must be rank 3, but got rank "+(w.rank+".")}),g!=null&&U(fn(c),function(){return"Error in conv1d: pad must be an integer when using, "+("dimRoundingMode "+g+" but got pad "+c+".")}),U(T.shape[2]===w.shape[1],function(){return"Error in conv1d: depth of input ("+T.shape[2]+") must match "+("input depth for filter "+w.shape[1]+".")}),U(xr(i,d),function(){return"Error in conv1D: Either stride or dilation must be 1. "+("Got stride "+i+" and dilation '"+d+"'")}),U(f==="NWC",function(){return"Error in conv1d: got dataFormat of "+f+" but only NWC is currently supported."});var E=it(w,[1,w.shape[0],w.shape[1],w.shape[2]]),k=it(T,[T.shape[0],1,T.shape[1],T.shape[2]]),$=[1,i],M=[1,d],G="NHWC",O=Lc(k,E,$,c,G,M,g);return N?it(O,[O.shape[2],O.shape[3]]):it(O,[O.shape[0],O.shape[2],O.shape[3]])}var I_=Y({conv1d_:Cnt});function Nnt(o,a,i,c,f,d,g){d===void 0&&(d="NHWC"),U(o.length===a.rank,function(){return"Length of inShape "+("("+o.length+") and rank of dy ("+a.rank+") must match")});var v=o,w=a,T=!1;a.rank===3&&(T=!0,w=it(a,[1,a.shape[0],a.shape[1],a.shape[2]]),v=[1,o[0],o[1],o[2]]),U(v.length===4,function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+(v.length+".")}),U(w.rank===4,function(){return"Error in conv2dDerInput: dy must be rank 4, but got "+("rank "+w.rank)}),U(i.rank===4,function(){return"Error in conv2dDerInput: filter must be rank 4, but got "+("rank "+i.rank)});var N=d==="NHWC"?v[3]:v[1],E=d==="NHWC"?w.shape[3]:w.shape[1];U(N===i.shape[2],function(){return"Error in conv2dDerInput: depth of input ("+N+") must "+("match input depth for filter "+i.shape[2]+".")}),U(E===i.shape[3],function(){return"Error in conv2dDerInput: depth of output ("+E+") must "+("match output depth for filter "+i.shape[3]+".")}),g!=null&&U(fn(f),function(){return"Error in conv2dDerInput: pad must be an integer when using, "+("dimRoundingMode "+g+" but got pad "+f+".")});var k=function(O,H){var K=1,nt=Vf(d),ct=Os(v,i.shape,c,K,f,g,!1,nt),dt=O.conv2dDerInput(w,i,ct);return H([w,i]),dt},$={dy:w,filter:i},M={strides:c,pad:f,dataFormat:d,dimRoundingMode:g,inputShape:v},G=Z.runKernelFunc(k,$,null,g1,M);return T?it(G,[G.shape[1],G.shape[2],G.shape[3]]):G}var yk=Y({conv2DBackpropInput_:Nnt});function Int(o,a,i,c,f,d){var g=W(o,"x","conv2dTranspose"),v=W(a,"filter","conv2dTranspose");return yk(i,g,v,c,f,"NHWC",d)}var E_=Y({conv2dTranspose_:Int});function Ent(o,a,i,c,f,d){f===void 0&&(f="NDHWC"),d===void 0&&(d=[1,1,1]);var g=W(o,"x","conv3d"),v=W(a,"filter","conv3d"),w=g,T=!1;g.rank===4&&(T=!0,w=it(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]])),U(w.rank===5,function(){return"Error in conv3d: input must be rank 5, but got rank "+w.rank+"."}),U(v.rank===5,function(){return"Error in conv3d: filter must be rank 5, but got rank "+(v.rank+".")}),U(w.shape[4]===v.shape[3],function(){return"Error in conv3d: depth of input ("+w.shape[4]+") must match "+("input depth for filter "+v.shape[3]+".")}),U(xr(i,d),function(){return"Error in conv3D: Either strides or dilations must be 1. "+("Got strides "+i+" and dilations '"+d+"'")}),U(f==="NDHWC",function(){return"Error in conv3d: got dataFormat of "+f+" but only NDHWC is currently supported."});var N=function(M,G){var O=Uf(w.shape,v.shape,i,d,c),H=M.conv3d(w,v,O);return G([w,v]),H},E={x:w,filter:v},k={strides:i,pad:c,dataFormat:f,dilations:d},$=Z.runKernelFunc(N,E,null,v1,k);return T?it($,[$.shape[1],$.shape[2],$.shape[3],$.shape[4]]):$}var Dnt=Y({conv3d_:Ent});function $nt(o,a,i,c,f){U(o.length===a.rank,function(){return"Length of inShape "+("("+o.length+") and rank of dy ("+a.rank+") must match")});var d=o,g=a,v=!1;a.rank===4&&(v=!0,g=it(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=[1,o[0],o[1],o[2],o[3]]);var w=d[4],T=g.shape[4];U(d.length===5,function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+(d.length+".")}),U(g.rank===5,function(){return"Error in conv3dDerInput: dy must be rank 5, but got "+("rank "+g.rank)}),U(i.rank===5,function(){return"Error in conv3dDerInput: filter must be rank 5, but got "+("rank "+i.rank)}),U(w===i.shape[3],function(){return"Error in conv3dDerInput: depth of input ("+w+") must "+("match input depth for filter "+i.shape[3]+".")}),U(T===i.shape[4],function(){return"Error in conv3dDerInput: depth of output ("+T+") must "+("match output depth for filter "+i.shape[4]+".")});var N=function(M){var G=1,O=Uf(d,i.shape,c,G,f);return M.conv3dDerInput(g,i,O)},E={dy:g,filter:i},k={pad:f,strides:c,inputShape:d},$=Z.runKernelFunc(N,E,null,I$,k);return v?it($,[$.shape[1],$.shape[2],$.shape[3],$.shape[4]]):$}var D_=Y({conv3DBackpropInput_:$nt});function Ant(o,a,i,c,f){var d=W(o,"x","conv3dTranspose"),g=W(a,"filter","conv3dTranspose");return D_(i,d,g,c,f)}var _nt=Y({conv3dTranspose_:Ant});function Fnt(o){var a=W(o,"x","cos"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.cos(a);return f([a]),d},i,null,y1)}var Eg=Y({cos_:Fnt});function Rnt(o){var a=W(o,"x","cosh"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.cosh(a);return f([a]),d},i,null,b1)}var bk=Y({cosh_:Rnt});function Pnt(o,a,i,c){a===void 0&&(a=0),i===void 0&&(i=!1),c===void 0&&(c=!1);var f=W(o,"x","cumsum"),d=function(w,T){var N=Ps([a],f.rank),E=f;N!=null&&(E=On(f,N));var k=lo(1,f.rank)[0],$=w.cumsum(E,k,i,c);if(T([f]),N!=null){var M=Tg(N);$=On($,M)}return $},g={x:f},v={axis:a,exclusive:i,reverse:c};return Z.runKernelFunc(d,g,null,w1,v)}var wk=Y({cumsum_:Pnt});function Ont(o,a,i){i===void 0&&(i="NHWC");var c=W(o,"x","depthToSpace"),f=i==="NHWC"?c.shape[1]:c.shape[2],d=i==="NHWC"?c.shape[2]:c.shape[3],g=i==="NHWC"?c.shape[3]:c.shape[1];U(f*a>=0,function(){return`Negative dimension size caused by overflow when multiplying
    `+f+" and "+a+`  for depthToSpace with input shape
    `+c.shape}),U(d*a>=0,function(){return`Negative dimension size caused by overflow when multiplying
    `+d+" and "+a+` for depthToSpace with input shape
        `+c.shape}),U(g%(a*a)===0,function(){return"Dimension size must be evenly divisible by "+a*a+" but is "+g+" for depthToSpace with input shape "+c.shape});var v=function(N){return N.depthToSpace(c,a,i)},w={x:c},T={blockSize:a,dataFormat:i};return Z.runKernelFunc(v,w,null,D$,T)}var $_=Y({depthToSpace_:Ont});function Mnt(o,a,i,c,f,d,g){f===void 0&&(f="NHWC"),d===void 0&&(d=[1,1]);var v=W(o,"x","depthwiseConv2d"),w=W(a,"filter","depthwiseConv2d"),T=v,N=!1;v.rank===3&&(N=!0,T=it(v,[1,v.shape[0],v.shape[1],v.shape[2]])),U(T.rank===4,function(){return"Error in depthwiseConv2d: input must be rank 4, but got "+("rank "+T.rank+".")}),U(w.rank===4,function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+(w.rank+".")}),U(T.shape[3]===w.shape[2],function(){return"Error in depthwiseConv2d: number of input channels "+("("+T.shape[3]+") must match the inChannels dimension in ")+("filter "+w.shape[2]+".")}),g!=null&&U(fn(c),function(){return"Error in depthwiseConv2d: pad must be an integer when using, "+("dimRoundingMode "+g+" but got pad "+c+".")});var E=function(G,O){d==null&&(d=[1,1]),U(xr(i,d),function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+("1. Got strides "+i+" and dilations '"+d+"'")});var H=Os(T.shape,w.shape,i,d,c,g,!0),K=G.depthwiseConv2D(T,w,H);return O([T,w]),K},k={x:T,filter:w},$={strides:i,pad:c,dataFormat:f,dilations:d,dimRoundingMode:g},M=Z.runKernelFunc(E,k,null,x1,$);return N?it(M,[M.shape[1],M.shape[2],M.shape[3]]):M}var qf=Y({depthwiseConv2d_:Mnt});function Lnt(o){var a=W(o,"x","diag"),i=function(f){var d=it(a,[a.size]),g=f.diag(d),v=o.shape.concat(o.shape);return it(g,v)},c={x:a};return Z.runKernelFunc(i,c,null,_$)}var Bnt=Y({diag_:Lnt});function znt(o,a,i,c,f,d){f===void 0&&(f=[1,1]),d===void 0&&(d="NHWC");var g=W(o,"x","dilation2d"),v=W(a,"filter","dilation2d");U(g.rank===3||g.rank===4,function(){return"Error in dilation2d: input must be rank 3 or 4, but got rank "+(g.rank+".")}),U(v.rank===3,function(){return"Error in dilation2d: filter must be rank 3, but got rank "+(v.rank+".")}),U(d==="NHWC",function(){return"Error in dilation2d: Only NHWC is currently supported, "+("but got dataFormat of "+d)});var w=g,T=!1;g.rank===3&&(w=it(g,[1,g.shape[0],g.shape[1],g.shape[2]]),T=!0);var N={x:w,filter:v},E={strides:i,pad:c,dilations:f},k=Z.runKernel(T1,N,E);return T?it(k,[k.shape[1],k.shape[2],k.shape[3]]):k}var A_=Y({dilation2d_:znt});function Wnt(o,a){for(var i=o.length,c=[],f=0;f<i;f++){var d=i-1-f,g=o[d]||1,v=a[a.length-1-f]||1;v>1&&g===1&&c.unshift(d)}return c}function Dn(o,a){for(var i=[],c=0;c<a.length;c++){var f=o[o.length-c-1],d=a.length-c-1,g=a[d];(f==null||f===1&&g>1)&&i.unshift(d)}return i}function tn(o,a){for(var i=[],c=Math.max(o.length,a.length),f=0;f<c;f++){var d=o[o.length-f-1];d==null&&(d=1);var g=a[a.length-f-1];if(g==null&&(g=1),d===1)i.unshift(g);else if(g===1)i.unshift(d);else if(d!==g){var v="Operands could not be broadcast together with shapes "+(o+" and "+a+".");throw Error(v)}else i.unshift(d)}return i}function Vnt(o,a){var i,c=W(o,"a","equal"),f=W(a,"b","equal");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(v){return v.equal(c,f)},g={a:c,b:f};return Z.runKernelFunc(d,g,null,O$)}var jf=Y({equal_:Vnt});function Unt(o,a,i){var c=W(a,"a","where"),f=W(i,"b","where"),d=W(o,"condition","where","bool"),g=tn(c.shape,f.shape),v=Ig(c,g),w=Ig(f,g);d.rank===1&&U(d.shape[0]===c.shape[0],function(){return"The first dimension of `a` must match the size of `condition`."}),d.rank!==1&&Ee(d.shape,w.shape,"Error in where: ");var T=function(E,k){var $=E.select(d,v,w);return k([d]),$},N={condition:d,t:v,e:w};return Z.runKernelFunc(T,N,null,hT)}var Ms=Y({where_:Unt});function Gnt(o){var a=W(o,"x","zerosLike"),i={x:a};return Z.runKernelFunc(function(c){return c.zerosLike(a)},i,null,_T)}var ke=Y({zerosLike_:Gnt});function Hnt(o,a){var i,c=W(o,"a","div"),f=W(a,"b","div");i=pn(c,f),c=i[0],f=i[1];var d=ae(c,f),g=ke(d),v=jf(f,g);return Ms(v,g,d)}var __=Y({divNoNan_:Hnt});function qnt(o,a){var i=W(o,"t1","dot"),c=W(a,"t2","dot");U((i.rank===1||i.rank===2)&&(c.rank===1||c.rank===2),function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+(i.rank+" and "+c.rank+".")});var f=i.rank===1?i.size:i.shape[1],d=c.rank===1?c.size:c.shape[0];if(U(f===d,function(){return"Error in dot: inner dimensions of inputs must match, but got "+(f+" and "+d+".")}),i.rank===1&&c.rank===1){var g=it(i,[1,-1]),v=it(c,[-1,1]),w=Ce(g,v);return it(w,[])}else if(i.rank===1&&c.rank===2){var g=it(i,[1,-1]),v=it(c,[c.shape[0],c.shape[1]]),w=Ce(g,v);return it(w,[w.size])}else if(i.rank===2&&c.rank===1){var v=it(c,[-1,1]),w=Ce(i,v);return it(w,[w.size])}else{var v=it(c,[c.shape[0],c.shape[1]]),w=Ce(i,v);return w}}var F_=Y({dot_:qnt});function jnt(o){var a=W(o,"x","elu"),i=function(f,d){var g=f.elu(a);return d([g]),g},c={x:a};return Z.runKernelFunc(i,c,null,S1)}var xk=Y({elu_:jnt});function Knt(o){var a=W(o,"x","erf");U(a.dtype==="int32"||a.dtype==="float32",function(){return"Input dtype must be `int32` or `float32`."}),a.dtype==="int32"&&(a=Bt(a,"float32"));var i={x:a};return Z.runKernelFunc(function(c,f){var d=c.erf(a);return f([a]),d},i,null,C1)}var R_=Y({erf_:Knt});function Xnt(o){var a=W(o,"x","exp"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.exp(a);return f([d]),d},i,null,N1)}var Ls=Y({exp_:Xnt});function Ynt(o,a){a===void 0&&(a=0);var i=null,c=W(o,"x","expandDims",i);U(a<=c.rank,function(){return"Axis must be <= rank of the tensor"});var f=c.shape.slice();return a<0&&(U(-(c.rank+1)<=a,function(){return"Axis must be in the interval ["+-(c.rank+1)+", "+c.rank+"]"}),a=c.rank+a+1),f.splice(a,0,1),it(c,f)}var Bs=Y({expandDims_:Ynt});function Jnt(o){var a=W(o,"x","expm1"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.expm1(a);return f([a]),d},i,null,I1)}var P_=Y({expm1_:Jnt});function Znt(o,a){var i=null,c=W(o,"x","tile",i);U(c.rank===a.length,function(){return"Error in transpose: rank of input "+c.rank+" "+("must match length of reps "+a+".")});var f=function(w,T){var N=w.tile(c,a);return T([c]),N},d=[c],g={x:c},v={reps:a};return Z.runKernelFunc(f,g,null,ET,v,d)}var Bc=Y({tile_:Znt});function Qnt(o,a,i,c){c===void 0&&(c="float32"),a==null&&(a=o);for(var f=co([o,a],c),d=o<=a?o:a,g=0;g<d;++g)f.set(1,g,g);var v=it(f.toTensor(),[o,a]);if(i==null)return v;if(i.length===1)return Bc(Bs(v,0),[i[0],1,1]);if(i.length===2)return Bc(Bs(Bs(v,0),0),[i[0],i[1],1,1]);if(i.length===3)return Bc(Bs(Bs(Bs(v,0),0),0),[i[0],i[1],i[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+("batchShapes, but received "+i.length+"D."))}var O_=Y({eye_:Qnt});function Tk(o,a,i){var c={shape:o,value:a,dtype:i};return Z.runKernelFunc(function(f){return f.fill(o,a,i)},{},null,L$,c)}function trt(o){var a=W(o,"x","floor"),i={x:a};return Z.runKernelFunc(function(c){return c.floor(a)},i,null,E1)}var Dg=Y({floor_:trt});var kk=30;function ert(o){return o<=kk?o:lg(o,Math.floor(Math.sqrt(o)))}function nrt(o,a){var i=!1,c;for(o<=kk?(c=o,i=!0):c=lg(o,Math.floor(Math.sqrt(o)));!i;)c>a||c===o?i=!0:c=lg(o,c+1);return c}function rrt(o,a,i){for(var c=[],f=o.length,d=0;d<f;d++)d!==a?c.push(o[d]):c.push(i);return c}function M_(o,a,i){for(var c=o.shape[i],f=[],d=1,g=1,v=0;v<i;v++)f.push(o.shape[v]),d*=o.shape[v];for(var v=0;v<a.rank;v++)f.push(a.shape[v]);for(var v=i+1;v<o.rank;v++)f.push(o.shape[v]),g*=o.shape[v];return{batchSize:d,sliceSize:g,dimSize:c,outputShape:f}}var srt={__proto__:null,segOpComputeOptimalWindowSize:nrt,computeOutShape:rrt,collectGatherOpShapeInfo:M_};function ort(o,a,i){i===void 0&&(i=0);var c=W(o,"x","gather"),f=W(a,"indices","gather","int32"),d={x:c,indices:f},g={axis:i},v=function(w,T){var N=Qe(i,c.shape)[0],E=M_(c,f,N),k=w.gather(c,it(f,[f.size]),N);return T([c,f]),it(k,E.outputShape)};return Z.runKernelFunc(v,d,null,A1,g)}var $g=Y({gather_:ort});function art(o,a){var i,c=W(o,"a","greater"),f=W(a,"b","greater");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(v){return v.greater(c,f)},g={a:c,b:f};return Z.runKernelFunc(d,g,null,W$)}var Ha=Y({greater_:art});function irt(o,a){var i,c=W(o,"a","greaterEqual"),f=W(a,"b","greaterEqual");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(v,w){var T=v.greaterEqual(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,_1)}var qi=Y({greaterEqual_:irt});function urt(o){var a=W(o,"input","imag"),i=function(f){return f.imag(a)},c={input:a};return Z.runKernelFunc(i,c,null,U$)}var Ag=Y({imag_:urt});function crt(o){var a=W(o,"x","isFinite"),i={x:a};return Z.runKernelFunc(function(c){return c.isFinite(a)},i,null,R1)}var L_=Y({isFinite_:crt});function lrt(o){var a=W(o,"x","isInf"),i={x:a};return Z.runKernelFunc(function(c){return c.isInf(a)},i,null,P1)}var B_=Y({isInf_:lrt});function hrt(o){var a=W(o,"x","isNaN"),i={x:a};return Z.runKernelFunc(function(c){return c.isNaN(a)},i,null,O1)}var z_=Y({isNaN_:hrt});function frt(o,a){var i,c=W(o,"a","maximum"),f=W(a,"b","maximum");i=pn(c,f),c=i[0],f=i[1],c.dtype==="bool"&&(c=Bt(c,"int32"),f=Bt(f,"int32")),tn(c.shape,f.shape);var d=function(v,w){var T=v.maximum(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,V1)}var zc=Y({maximum_:frt});function ne(o,a){if((Jn(o)&&a!=="string"||Array.isArray(o))&&a!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(a==="string"&&Jn(o)&&!(o instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");var i=[],c=[];return Ba(o,i,c,a)}function prt(o,a){a===void 0&&(a=.2);var i=W(o,"x","leakyRelu");return zc(pt(ne(a),i),i)}var W_=Y({leakyRelu_:prt});function drt(o,a){var i,c=W(o,"a","less"),f=W(a,"b","less");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(v){return v.less(c,f)},g={a:c,b:f};return Z.runKernelFunc(d,g,null,G$)}var _g=Y({less_:drt});function mrt(o,a){var i,c=W(o,"a","lessEqual"),f=W(a,"b","lessEqual");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(v,w){var T=v.lessEqual(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,H$)}var ji=Y({lessEqual_:mrt});function grt(o,a,i){if(i<=0)throw new Error("The number of values should be positive.");var c={start:o,stop:a,num:i};return Z.runKernelFunc(function(f){return f.linspace(o,a,i)},{},null,q$,c)}function vrt(o,a,i,c,f){a===void 0&&(a=5),i===void 0&&(i=1),c===void 0&&(c=1),f===void 0&&(f=.5);var d=W(o,"x","localResponseNormalization");U(d.rank===4||d.rank===3,function(){return`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank `+d.rank+"."}),U(fn(a),function(){return"Error in localResponseNormalization: depthRadius must be an "+("integer but got depthRadius "+a+".")});var g=d,v=!1;d.rank===3&&(v=!0,g=it(d,[1,d.shape[0],d.shape[1],d.shape[2]]));var w=function(k,$){var M=k.localResponseNormalization4D(g,a,i,c,f);return $([g,M]),M},T={x:g},N={depthRadius:a,bias:i,alpha:c,beta:f},E=Z.runKernelFunc(w,T,null,z1,N);return v?it(E,[E.shape[1],E.shape[2],E.shape[3]]):E}var V_=Y({localResponseNormalization_:vrt});function yrt(o){var a=W(o,"x","log"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.log(a);return f([a]),d},i,null,M1)}var Ki=Y({log_:yrt});function brt(o){var a=W(o,"x","log1p"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.log1p(a);return f([a]),d},i,null,L1)}var Sk=Y({log1p_:brt});function wrt(o){return U(Ma(o),function(){return"The f passed in grad(f) must be a function"}),function(a,i){var c=W(a,"x","tf.grad",null),f=i!=null?W(i,"dy","tf.grad"):null;return Z.tidy(function(){var d=Z.gradients(function(){return o(c)},[c],f),g=d.value,v=d.grads;return f!=null&&Ee(g.shape,f.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Fg(v),v[0]})}}function xrt(o){return U(Ma(o),function(){return"The f passed in grads(f) must be a function"}),function(a,i){U(Array.isArray(a),function(){return"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"});var c=zf(a,"args","tf.grads",null),f=i!=null?W(i,"dy","tf.grads"):null;return Z.tidy(function(){var d=Z.gradients(function(){return o.apply(void 0,c)},c,f),g=d.value,v=d.grads;return f!=null&&Ee(g.shape,f.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Fg(v),v})}}function Trt(o){return U(Ma(o),function(){return"The f passed in valueAndGrad(f) must be a function"}),function(a,i){U(a instanceof ut,function(){return"The x passed in valueAndGrad(f)(x) must be a tensor"}),U(i==null||i instanceof ut,function(){return"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"});var c=Z.gradients(function(){return o(a)},[a],i),f=c.grads,d=c.value;return Fg(f),{grad:f[0],value:d}}}function krt(o){return U(Ma(o),function(){return"The f passed in valueAndGrads(f) must be a function"}),function(a,i){U(Array.isArray(a)&&a.every(function(f){return f instanceof ut}),function(){return"The args passed in valueAndGrads(f)(args) must be array of tensors"}),U(i==null||i instanceof ut,function(){return"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"});var c=Z.gradients(function(){return o.apply(void 0,a)},a,i);return i!=null&&Ee(c.value.shape,i.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Fg(c.grads),c}}function U_(o,a){U(Ma(o),function(){return"The f passed in variableGrads(f) must be a function"}),U(a==null||Array.isArray(a)&&a.every(function(E){return E instanceof Bf}),function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"});var i=a!=null;if(!i){a=[];for(var c in Z.registeredVariables)a.push(Z.registeredVariables[c])}var f=i?a.filter(function(E){return!E.trainable}):null,d=a.length;a=a.filter(function(E){return E.trainable}),U(a.length>0,function(){return"variableGrads() expects at least one of the input variables to "+("be trainable, but none of the "+d+" variables is ")+"trainable."});var g=!0,v=Z.gradients(o,a,null,g),w=v.value,T=v.grads;U(T.some(function(E){return E!=null}),function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."}),U(w.rank===0,function(){return"The f passed in variableGrads(f) must return a scalar, but it "+("returned a rank-"+w.rank+" tensor")});var N={};return a.forEach(function(E,k){T[k]!=null&&(N[E.name]=T[k])}),f!=null&&f.forEach(function(E){return N[E.name]=null}),{value:w,grads:N}}function ho(o){return Z.customGrad(o)}function Fg(o){var a=o.filter(function(i){return i==null}).length;if(a>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Srt(o){var a=W(o,"x","neg"),i={x:a};return Z.runKernelFunc(function(c){return c.neg(a)},i,null,Y1)}var $n=Y({neg_:Srt});function Crt(o){var a=W(o,"x","softplus"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.softplus(a);return f([a]),d},i,null,yT)}var Ck=Y({softplus_:Crt});function Nrt(o){var a=W(o,"x","logSigmoid"),i=ho(function(c){var f=$n(Ck($n(c))),d=function(g){var v=pt(g,Hi($n(c)));return v};return{value:f,gradFunc:d}});return i(a)}var G_=Y({logSigmoid_:Nrt});function Irt(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","max"),f=function(v,w){var T=Qe(a,c.shape),N=T,E=Ps(N,c.rank),k=c;E!=null&&(k=On(c,E),N=lo(N.length,k.rank));var $=v.max(k,N);E!=null&&k.dispose();var M=$;if(i){var G=Jr(M.shape,Qe(a,c.shape));M=it(M,G),$.dispose()}return w([c,M]),M},d={x:c},g={reductionIndices:a,keepDims:i};return Z.runKernelFunc(f,d,null,W1,g)}var Xi=Y({max_:Irt});function Ert(o,a){var i,c=W(o,"a","sub"),f=W(a,"b","sub");i=pn(c,f),c=i[0],f=i[1];var d=function(v,w){var T=v.subtract(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,CT)}var Qt=Y({sub_:Ert});function Drt(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","sum");c.dtype==="bool"&&(c=Bt(c,"int32"));var f=function(v,w){w([c]);var T=Qe(a,c.shape),N=Ps(T,c.rank),E=T,k=c;N!=null&&(k=On(c,N),E=lo(E.length,c.rank));var $=v.sum(k,E);if(i){var M=Jr($.shape,T);$=it($,M)}return $},d={x:c},g={axis:a,keepDims:i};return Z.runKernelFunc(f,d,null,wT,g)}var ie=Y({sum_:Drt});function $rt(o,a){a===void 0&&(a=-1);var i=W(o,"logits","logSoftmax");if(a===-1&&(a=i.rank-1),a!==i.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+("Logits was rank "+i.rank+" and axis was "+a));var c=function(g,v){var w=!0,T=Xi(o,a,!0),N=Qt(o,T),E=Qt(Bt(N,"float32"),Ki(ie(Ls(N),a,w)));return v([E]),E},f={logits:i},d={axis:a};return Z.runKernelFunc(c,f,null,B1,d)}var H_=Y({logSoftmax_:$rt});function Art(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","logSumExp"),f=Qe(a,c.shape),d=Xi(c,f,!0),g=Qt(c,d),v=Ls(g),w=ie(v,f),T=Ki(w),N=Yt(it(d,T.shape),T);if(i){var E=Jr(N.shape,f);return it(N,E)}return N}var Nk=Y({logSumExp_:Art});function _rt(o,a){var i=W(o,"a","logicalAnd","bool"),c=W(a,"b","logicalAnd","bool");tn(i.shape,c.shape);var f={a:i,b:c};return Z.runKernelFunc(function(d){return d.logicalAnd(i,c)},f,null,j$)}var Yi=Y({logicalAnd_:_rt});function Frt(o){var a=W(o,"x","logicalNot","bool"),i={x:a};return Z.runKernelFunc(function(c){return c.logicalNot(a)},i,null,K$)}var Rg=Y({logicalNot_:Frt});function Rrt(o,a){var i=W(o,"a","logicalOr","bool"),c=W(a,"b","logicalOr","bool");tn(i.shape,c.shape);var f={a:i,b:c};return Z.runKernelFunc(function(d){return d.logicalOr(i,c)},f,null,X$)}var Ik=Y({logicalOr_:Rrt});function Prt(o,a){var i=W(o,"a","logicalXor","bool"),c=W(a,"b","logicalXor","bool");return tn(i.shape,c.shape),Yi(Ik(o,a),Rg(Yi(o,a)))}var q_=Y({logicalXor_:Prt});function Ort(o,a,i,c,f){var d=W(o,"x","maxPool"),g=1,v=d,w=!1;d.rank===3&&(w=!0,v=it(d,[1,d.shape[0],d.shape[1],d.shape[2]])),U(v.rank===4,function(){return"Error in maxPool: input must be rank 4 but got rank "+v.rank+"."}),U(xr(i,g),function(){return"Error in maxPool: Either strides or dilations must be 1. "+("Got strides "+i+" and dilations '"+g+"'")}),f!=null&&U(fn(c),function(){return"Error in maxPool: pad must be an integer when using, "+("dimRoundingMode "+f+" but got pad "+c+".")});var T=function($,M){var G=Oc(v.shape,a,i,1,c,f),O;return G.filterWidth===1&&G.filterHeight===1&&Rs(G.inShape,G.outShape)?O=v.clone():O=$.maxPool(v,G),M([v,O]),O},N={x:v},E={filterSize:a,strides:i,pad:c,dimRoundingMode:f},k=Z.runKernelFunc(T,N,null,U1,E);return w?it(k,[k.shape[1],k.shape[2],k.shape[3]]):k}var Ek=Y({maxPool_:Ort});function Mrt(o,a,i,c,f,d,g){a===void 0&&(a=[1,1,1]),d===void 0&&(d="NDHWC"),g==null?g=[1,1,1]:Mn("dilations is deprecated, this field will be gone in v3.0.0.");var v=W(o,"x","maxPool3d"),w=v,T=!1;v.rank===4&&(T=!0,w=it(v,[1,v.shape[0],v.shape[1],v.shape[2],v.shape[3]])),U(w.rank===5,function(){return"Error in maxPool3d: x must be rank 5 but got rank "+w.rank+"."}),U(d==="NDHWC",function(){return"Error in maxPool3d: Only NDHWC is currently supported, "+("but got dataFormat of "+d)}),U(xr(i,g),function(){return"Error in maxPool3d: Either strides or dilations must be 1. "+("Got strides "+i+" and dilations '"+g+"'")}),f!=null&&U(fn(c),function(){return"Error in maxPool3d: pad must be an integer when using, "+("dimRoundingMode "+f+" but got pad "+c+".")});var N=function(M,G){g==null&&(g=[1,1,1]);var O=Gf(w.shape,a,i,g,c,f,d),H=M.maxPool3d(w,O);return G([w,H]),H},E={x:w},k={filterSize:a,strides:i,pad:c,dimRoundingMode:f,dataFormat:d,dilations:g},$=Z.runKernelFunc(N,E,null,G1,k);return T?it($,[$.shape[1],$.shape[2],$.shape[3],$.shape[4]]):$}var Lrt=Y({maxPool3d_:Mrt});function Brt(o,a,i,c,f){f===void 0&&(f=!1);var d=W(o,"x","maxPoolWithArgmax"),g={x:d},v={filterSize:a,strides:i,pad:c,includeBatchInIndex:f},w=Z.runKernel(Q$,g,v);return{result:w[0],indexes:w[1]}}var zrt=Y({maxPoolWithArgmax_:Brt});function qo(o,a){if(a===void 0&&(a="float32"),a==="complex64"){var i=qo(o,"float32"),c=qo(o,"float32");return La(i,c)}var f=Ec(mn(o),a);return Z.makeTensor(f,o,a)}function Wc(o,a){if(a===void 0&&(a="float32"),a==="complex64"){var i=Wc(o,"float32"),c=qo(o,"float32");return La(i,c)}var f=qx(mn(o),a);return Z.makeTensor(f,o,a)}function Wrt(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","mean"),f=Qe(a,c.shape),d=p_(c.shape,f),g=d[1],v=mn(g),w={x:c},T={axis:a,keepDims:i},N=function(){var k=ne(v),$=k.dtype===c.dtype?c:Bt(c,k.dtype),M=ae($,k);return ie(M,a,i)},E=ho(function(k){var $=Z.runKernelFunc(N,w,null,tA,T),M=function(G){var O=k.shape.slice();f.forEach(function(nt){O[nt]=1});var H=it(G,O),K=ae(pt(H,Wc(k.shape,"float32")),v);return K};return{value:$,gradFunc:M}});return E(c)}var Kf=Y({mean_:Wrt});function Vrt(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","min"),f=function(v,w){var T=Qe(a,c.shape),N=T,E=Ps(N,c.rank),k=c;E!=null&&(k=On(c,E),N=lo(N.length,c.rank));var $=v.min(k,N);E!=null&&k.dispose();var M=$;if(i){var G=Jr(M.shape,T);M=it($,G),$.dispose()}return w([c,M]),M},d={x:c},g={axis:a,keepDims:i};return Z.runKernelFunc(f,d,null,H1,g)}var Pg=Y({min_:Vrt});function Urt(o,a){var i,c=W(o,"a","minimum"),f=W(a,"b","minimum");i=pn(c,f),c=i[0],f=i[1],c.dtype==="bool"&&(c=Bt(c,"int32"),f=Bt(f,"int32")),tn(c.shape,f.shape);var d=function(v,w){var T=v.minimum(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,q1)}var Og=Y({minimum_:Urt});function Grt(o,a,i){U(i==="reflect"||i==="symmetric",function(){return"Invalid mode. Mode must be either reflect or symmetric. "+("Got "+i+".")});var c=W(o,"x","mirrorPad");if(c.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(a.length===c.rank,function(){return"Padding doesn't match input. Must be "+c.rank+". "+("Got "+a.length+".")});for(var f=i==="reflect"?1:0,d=function(T){U(a[T].length===2,function(){return"Invalid number of paddings. Must be length of 2 each."}),U(a[T][0]>=0&&a[T][0]<=c.shape[T]-f&&a[T][1]>=0&&a[T][1]<=c.shape[T]-f,function(){return"Padding in dimension "+T+" cannot be greater than or equal "+("to "+(c.shape[T]-f)+" or less than 0 for input of ")+("shape "+c.shape)})},g=0;g<c.rank;g++)d(g);var v={paddings:a,mode:i},w={x:c};return Z.runKernel(j1,w,v)}var j_=Y({mirrorPad_:Grt});function Hrt(o,a){var i,c=W(o,"a","mod"),f=W(a,"b","mod");i=pn(c,f),c=i[0],f=i[1];var d=function(v,w){var T=v.mod(c,f);return w([c,f]),T},g={a:c,b:f};return Z.runKernelFunc(d,g,null,K1)}var Dk=Y({mod_:Hrt});function qrt(o){var a=W(o,"x","square"),i={},c=[a],f=[];return Z.runKernelFunc(function(d,g){return g([a]),d.square(a)},{x:a},null,"Square",i,c,f)}var Ue=Y({square_:qrt});function jrt(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1),o=W(o,"x","moments");var c=Qe(a,o.shape),f=Kf(o,c,i),d=f.shape;i||(d=Jr(f.shape,c));var g=Ue(Qt(Bt(o,"float32"),it(f,d))),v=Kf(g,c,i);return{mean:f,variance:v}}var Krt=Y({moments_:jrt});function Xrt(o,a,i,c){for(var f=W(a,"data","multiRNNCell"),d=zf(i,"c","multiRNNCell"),g=zf(c,"h","multiRNNCell"),v=f,w=[],T=0;T<o.length;T++){var N=o[T](v,d[T],g[T]);w.push(N[0]),w.push(N[1]),v=N[1]}for(var E=[],k=[],T=0;T<w.length;T+=2)E.push(w[T]),k.push(w[T+1]);return[E,k]}var Yrt=Y({multiRNNCell_:Xrt});function Jrt(o,a,i,c){c===void 0&&(c=!1);var f=W(o,"logits","multinomial"),d=f.size,g=f.rank;if(d<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+(d+"."));if(g>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+g);i=i||Math.random();var v=g===1?it(f,[1,-1]):f,w=Z.runKernelFunc(function(T){return T.multinomial(v,c,a,i)},{logits2D:v});return g===1?it(w,[w.size]):w}var Zrt=Y({multinomial_:Jrt});function Qrt(o,a){var i,c=W(o,"a","notEqual"),f=W(a,"b","notEqual");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(v){return v.notEqual(c,f)},g={a:c,b:f};return Z.runKernelFunc(d,g,null,eA)}var Mg=Y({notEqual_:Qrt});function tst(o){var a=W(o,"input","real"),i=function(f){return f.real(a)},c={input:a};return Z.runKernelFunc(i,c,null,iA)}var Xf=Y({real_:tst});function est(o){var a=W(o,"x","onesLike"),i=function(f,d){if(a.dtype==="complex64"){var g=$k(Xf(a)),v=ke(Ag(a));return La(g,v)}return f.onesLike(a)},c={x:a};return Z.runKernelFunc(i,c,null,J1)}var $k=Y({onesLike_:est});function nst(o,a){var i=W(o,"v1","outerProduct"),c=W(a,"v2","outerProduct");U(i.rank===1&&c.rank===1,function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+(i.rank+" and "+c.rank+".")});var f=it(i,[-1,1]),d=it(c,[1,-1]);return Ce(f,d)}var rst=Y({outerProduct_:nst});function sst(o,a,i){i===void 0&&(i=0);var c=W(o,"x","pad");if(c.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var f=function(v,w){return w([c]),v.pad(c,a,i)},d={paddings:a,constantValue:i},g={x:c};return Z.runKernelFunc(f,g,null,Q1,d)}var Ji=Y({pad_:sst});function ost(o,a,i){return i===void 0&&(i=0),U(a.length===2,function(){return"Invalid number of paddings. Must be length of 2."}),Ji(o,[a],i)}var ast=Y({pad1d_:ost});function ist(o,a,i){return i===void 0&&(i=0),U(a.length===2&&a[0].length===2&&a[1].length===2,function(){return"Invalid number of paddings. Must be length of 2 each."}),Ji(o,a,i)}var ust=Y({pad2d_:ist});function cst(o,a,i){return i===void 0&&(i=0),U(a.length===3&&a[0].length===2&&a[1].length===2&&a[2].length===2,function(){return"Invalid number of paddings. Must be length of 2 each."}),Ji(o,a,i)}var lst=Y({pad3d_:cst});function hst(o,a,i){return i===void 0&&(i=0),U(a.length===4&&a[0].length===2&&a[1].length===2&&a[2].length===2&&a[3].length===2,function(){return"Invalid number of paddings. Must be length of 2 each."}),Ji(o,a,i)}var fst=Y({pad4d_:hst});function pst(o,a,i){var c=W(o,"x","spaceToBatchND");U(c.rank>=1+a.length,function(){return"input rank "+c.rank+" should be > than [blockShape] "+a.length}),U(i.length===a.length,function(){return"paddings.shape[0] "+i.length+" must be equal to [blockShape] "+a.length}),U(c.shape.reduce(function(v,w,T){return T>0&&T<=a.length?v&&(w+i[T-1][0]+i[T-1][1])%a[T-1]===0:v},!0),function(){return"input spatial dimensions "+c.shape.slice(1)+" with paddings "+i.toString()+" must be divisible by blockShapes "+a.toString()});var f=function(v){return v.spaceToBatchND(c,a,i)},d={x:c},g={blockShape:a,paddings:i};return Z.runKernelFunc(f,d,null,xT,g)}var Lg=Y({spaceToBatchND_:pst});function gst(o,a,i,c,f,d){f==null&&(f=[1,1]),d==null&&(d=1),c===0&&(c="valid");var g=W(o,"x","maxPool"),v=g,w=!1;g.rank===3&&(w=!0,v=it(g,[1,g.shape[0],g.shape[1],g.shape[2]])),U(xr(d,f),function(){return"Error in pool: Either strides or dilations must be 1. "+("Got strides "+d+" and dilations '"+f+"'")});var T=Oc(v.shape,a,d,f,c),N=[T.dilationHeight,T.dilationWidth],E;c==="same"?E=mst([T.filterHeight,T.filterWidth],N):E=[[0,0],[0,0]];var k=N[0]===1&&N[1]===1,$=dst([T.inHeight,T.inWidth],N,E),M=$[0],G=$[1],O=k?c:"valid",H=k?v:Lg(v,N,M),K=i==="avg"?function(){return vk(H,a,d,O)}:function(){return Ek(H,a,d,O)},nt=K(),ct=k?nt:Cg(nt,N,G);return w?it(ct,[ct.shape[1],ct.shape[2],ct.shape[3]]):ct}function dst(o,a,i){var c=i.map(function(N){return N[0]}),f=i.map(function(N){return N[1]}),d=o.concat(c,f),g=a.map(function(N,E){return(N-d[E]%N)%N}),v=f.map(function(N,E){return N+g[E]}),w=a.map(function(N,E){return[c[E],v[E]]}),T=a.map(function(N,E){return[0,g[E]]});return[w,T]}function mst(o,a){var i=o.map(function(g,v){return g+(g-1)*(a[v]-1)}),c=i.map(function(g){return g-1}),f=c.map(function(g){return Math.floor(g/2)}),d=c.map(function(g,v){return g-f[v]});return c.map(function(g,v){return[f[v],d[v]]})}var K_=Y({pool_:gst});function vst(o,a){var i,c=W(o,"base","pow"),f=W(a,"exp","pow");i=pn(c,f),c=i[0],f=i[1];var d={a:c,b:f},g=function(v,w){var T=v.pow(c,f);return w([c,f,T]),T};return Z.runKernelFunc(g,d,null,tT)}var jo=Y({pow_:vst});function yst(o,a){var i=W(o,"x","prelu"),c=W(a,"alpha","prelu"),f=function(g,v){var w=g.prelu(i,c);return v([i,c]),w},d={x:i,alpha:c};return Z.runKernelFunc(f,d,null,eT)}var Ak=Y({prelu_:yst});function bst(o,a,i){a===void 0&&(a=null),i===void 0&&(i=!1);var c=W(o,"x","prod");c.dtype==="bool"&&(c=Bt(c,"int32"));var f=function(v){var w=Qe(a,c.shape),T=Ps(w,c.rank),N=w,E=c;T!=null&&(E=On(c,T),N=lo(N.length,c.rank));var k=v.prod(E,N);if(i){var $=Jr(k.shape,w);k=it(k,$)}return k},d={x:c},g={axis:a,keepDims:i};return Z.runKernelFunc(f,d,null,oA,g)}var X_=Y({prod_:bst});function wst(o,a,i){var c=mn(o),f=null;if(i==null||i==="float32")f=new Float32Array(c);else if(i==="int32")f=new Int32Array(c);else if(i==="bool")f=new Uint8Array(c);else throw new Error("Unknown data type "+i);for(var d=0;d<c;d++)f[d]=a();return Z.makeTensor(f,o,i)}var xst=Y({rand_:wst}),Vc=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function Zi(o,a){return a={exports:{}},o(a,a.exports),a.exports}var Tst=Zi(function(o){(function(a,i,c){function f(w){var T=this,N=v();T.next=function(){var E=2091639*T.s0+T.c*23283064365386963e-26;return T.s0=T.s1,T.s1=T.s2,T.s2=E-(T.c=E|0)},T.c=1,T.s0=N(" "),T.s1=N(" "),T.s2=N(" "),T.s0-=N(w),T.s0<0&&(T.s0+=1),T.s1-=N(w),T.s1<0&&(T.s1+=1),T.s2-=N(w),T.s2<0&&(T.s2+=1),N=null}function d(w,T){return T.c=w.c,T.s0=w.s0,T.s1=w.s1,T.s2=w.s2,T}function g(w,T){var N=new f(w),E=T&&T.state,k=N.next;return k.int32=function(){return N.next()*4294967296|0},k.double=function(){return k()+(k()*2097152|0)*11102230246251565e-32},k.quick=k,E&&(typeof E=="object"&&d(E,N),k.state=function(){return d(N,{})}),k}function v(){var w=4022871197,T=function(N){N=N.toString();for(var E=0;E<N.length;E++){w+=N.charCodeAt(E);var k=.02519603282416938*w;w=k>>>0,k-=w,k*=w,w=k>>>0,k-=w,w+=k*4294967296}return(w>>>0)*23283064365386963e-26};return T}i&&i.exports?i.exports=g:c&&c.amd?c(function(){return g}):this.alea=g})(Vc,o,!1)}),kst=Zi(function(o){(function(a,i,c){function f(v){var w=this,T="";w.x=0,w.y=0,w.z=0,w.w=0,w.next=function(){var E=w.x^w.x<<11;return w.x=w.y,w.y=w.z,w.z=w.w,w.w^=w.w>>>19^E^E>>>8},v===(v|0)?w.x=v:T+=v;for(var N=0;N<T.length+64;N++)w.x^=T.charCodeAt(N)|0,w.next()}function d(v,w){return w.x=v.x,w.y=v.y,w.z=v.z,w.w=v.w,w}function g(v,w){var T=new f(v),N=w&&w.state,E=function(){return(T.next()>>>0)/4294967296};return E.double=function(){do var k=T.next()>>>11,$=(T.next()>>>0)/4294967296,M=(k+$)/(1<<21);while(M===0);return M},E.int32=T.next,E.quick=E,N&&(typeof N=="object"&&d(N,T),E.state=function(){return d(T,{})}),E}i&&i.exports?i.exports=g:c&&c.amd?c(function(){return g}):this.xor128=g})(Vc,o,!1)}),Sst=Zi(function(o){(function(a,i,c){function f(v){var w=this,T="";w.next=function(){var E=w.x^w.x>>>2;return w.x=w.y,w.y=w.z,w.z=w.w,w.w=w.v,(w.d=w.d+362437|0)+(w.v=w.v^w.v<<4^(E^E<<1))|0},w.x=0,w.y=0,w.z=0,w.w=0,w.v=0,v===(v|0)?w.x=v:T+=v;for(var N=0;N<T.length+64;N++)w.x^=T.charCodeAt(N)|0,N==T.length&&(w.d=w.x<<10^w.x>>>4),w.next()}function d(v,w){return w.x=v.x,w.y=v.y,w.z=v.z,w.w=v.w,w.v=v.v,w.d=v.d,w}function g(v,w){var T=new f(v),N=w&&w.state,E=function(){return(T.next()>>>0)/4294967296};return E.double=function(){do var k=T.next()>>>11,$=(T.next()>>>0)/4294967296,M=(k+$)/(1<<21);while(M===0);return M},E.int32=T.next,E.quick=E,N&&(typeof N=="object"&&d(N,T),E.state=function(){return d(T,{})}),E}i&&i.exports?i.exports=g:c&&c.amd?c(function(){return g}):this.xorwow=g})(Vc,o,!1)}),Cst=Zi(function(o){(function(a,i,c){function f(v){var w=this;w.next=function(){var N=w.x,E=w.i,k,$;return k=N[E],k^=k>>>7,$=k^k<<24,k=N[E+1&7],$^=k^k>>>10,k=N[E+3&7],$^=k^k>>>3,k=N[E+4&7],$^=k^k<<7,k=N[E+7&7],k=k^k<<13,$^=k^k<<9,N[E]=$,w.i=E+1&7,$};function T(N,E){var k,$,M=[];if(E===(E|0))$=M[0]=E;else for(E=""+E,k=0;k<E.length;++k)M[k&7]=M[k&7]<<15^E.charCodeAt(k)+M[k+1&7]<<13;for(;M.length<8;)M.push(0);for(k=0;k<8&&M[k]===0;++k);for(k==8?$=M[7]=-1:$=M[k],N.x=M,N.i=0,k=256;k>0;--k)N.next()}T(w,v)}function d(v,w){return w.x=v.x.slice(),w.i=v.i,w}function g(v,w){v==null&&(v=+new Date);var T=new f(v),N=w&&w.state,E=function(){return(T.next()>>>0)/4294967296};return E.double=function(){do var k=T.next()>>>11,$=(T.next()>>>0)/4294967296,M=(k+$)/(1<<21);while(M===0);return M},E.int32=T.next,E.quick=E,N&&(N.x&&d(N,T),E.state=function(){return d(T,{})}),E}i&&i.exports?i.exports=g:c&&c.amd?c(function(){return g}):this.xorshift7=g})(Vc,o,!1)}),Nst=Zi(function(o){(function(a,i,c){function f(v){var w=this;w.next=function(){var N=w.w,E=w.X,k=w.i,$,M;return w.w=N=N+1640531527|0,M=E[k+34&127],$=E[k=k+1&127],M^=M<<13,$^=$<<17,M^=M>>>15,$^=$>>>12,M=E[k]=M^$,w.i=k,M+(N^N>>>16)|0};function T(N,E){var k,$,M,G,O,H=[],K=128;for(E===(E|0)?($=E,E=null):(E=E+"\0",$=0,K=Math.max(K,E.length)),M=0,G=-32;G<K;++G)E&&($^=E.charCodeAt((G+32)%E.length)),G===0&&(O=$),$^=$<<10,$^=$>>>15,$^=$<<4,$^=$>>>13,G>=0&&(O=O+1640531527|0,k=H[G&127]^=$+O,M=k==0?M+1:0);for(M>=128&&(H[(E&&E.length||0)&127]=-1),M=127,G=4*128;G>0;--G)$=H[M+34&127],k=H[M=M+1&127],$^=$<<13,k^=k<<17,$^=$>>>15,k^=k>>>12,H[M]=$^k;N.w=O,N.X=H,N.i=M}T(w,v)}function d(v,w){return w.i=v.i,w.w=v.w,w.X=v.X.slice(),w}function g(v,w){v==null&&(v=+new Date);var T=new f(v),N=w&&w.state,E=function(){return(T.next()>>>0)/4294967296};return E.double=function(){do var k=T.next()>>>11,$=(T.next()>>>0)/4294967296,M=(k+$)/(1<<21);while(M===0);return M},E.int32=T.next,E.quick=E,N&&(N.X&&d(N,T),E.state=function(){return d(T,{})}),E}i&&i.exports?i.exports=g:c&&c.amd?c(function(){return g}):this.xor4096=g})(Vc,o,!1)}),Ist=Zi(function(o){(function(a,i,c){function f(v){var w=this,T="";w.next=function(){var E=w.b,k=w.c,$=w.d,M=w.a;return E=E<<25^E>>>7^k,k=k-$|0,$=$<<24^$>>>8^M,M=M-E|0,w.b=E=E<<20^E>>>12^k,w.c=k=k-$|0,w.d=$<<16^k>>>16^M,w.a=M-E|0},w.a=0,w.b=0,w.c=2654435769|0,w.d=1367130551,v===Math.floor(v)?(w.a=v/4294967296|0,w.b=v|0):T+=v;for(var N=0;N<T.length+20;N++)w.b^=T.charCodeAt(N)|0,w.next()}function d(v,w){return w.a=v.a,w.b=v.b,w.c=v.c,w.d=v.d,w}function g(v,w){var T=new f(v),N=w&&w.state,E=function(){return(T.next()>>>0)/4294967296};return E.double=function(){do var k=T.next()>>>11,$=(T.next()>>>0)/4294967296,M=(k+$)/(1<<21);while(M===0);return M},E.int32=T.next,E.quick=E,N&&(typeof N=="object"&&d(N,T),E.state=function(){return d(T,{})}),E}i&&i.exports?i.exports=g:c&&c.amd?c(function(){return g}):this.tychei=g})(Vc,o,!1)}),Qi=Zi(function(o){(function(a,i){var c=this,f=256,d=6,g=52,v="random",w=i.pow(f,d),T=i.pow(2,g),N=T*2,E=f-1,k;function $(ct,dt,Ct){var St=[];dt=dt==!0?{entropy:!0}:dt||{};var It=H(O(dt.entropy?[ct,nt(a)]:ct==null?K():ct,3),St),Gt=new M(St),Et=function(){for(var Wt=Gt.g(d),_t=w,Kt=0;Wt<T;)Wt=(Wt+Kt)*f,_t*=f,Kt=Gt.g(1);for(;Wt>=N;)Wt/=2,_t/=2,Kt>>>=1;return(Wt+Kt)/_t};return Et.int32=function(){return Gt.g(4)|0},Et.quick=function(){return Gt.g(4)/4294967296},Et.double=Et,H(nt(Gt.S),a),(dt.pass||Ct||function(Wt,_t,Kt,Ne){return Ne&&(Ne.S&&G(Ne,Gt),Wt.state=function(){return G(Gt,{})}),Kt?(i[v]=Wt,_t):Wt})(Et,It,"global"in dt?dt.global:this==i,dt.state)}i["seed"+v]=$;function M(ct){var dt,Ct=ct.length,St=this,It=0,Gt=St.i=St.j=0,Et=St.S=[];for(Ct||(ct=[Ct++]);It<f;)Et[It]=It++;for(It=0;It<f;It++)Et[It]=Et[Gt=E&Gt+ct[It%Ct]+(dt=Et[It])],Et[Gt]=dt;(St.g=function(Wt){for(var _t,Kt=0,Ne=St.i,ce=St.j,me=St.S;Wt--;)_t=me[Ne=E&Ne+1],Kt=Kt*f+me[E&(me[Ne]=me[ce=E&ce+_t])+(me[ce]=_t)];return St.i=Ne,St.j=ce,Kt})(f)}function G(ct,dt){return dt.i=ct.i,dt.j=ct.j,dt.S=ct.S.slice(),dt}function O(ct,dt){var Ct=[],St=typeof ct,It;if(dt&&St=="object")for(It in ct)try{Ct.push(O(ct[It],dt-1))}catch(Gt){}return Ct.length?Ct:St=="string"?ct:ct+"\0"}function H(ct,dt){for(var Ct=ct+"",St,It=0;It<Ct.length;)dt[E&It]=E&(St^=dt[E&It]*19)+Ct.charCodeAt(It++);return nt(dt)}function K(){try{var ct;return k&&(ct=k.randomBytes)?ct=ct(f):(ct=new Uint8Array(f),(c.crypto||c.msCrypto).getRandomValues(ct)),nt(ct)}catch(St){var dt=c.navigator,Ct=dt&&dt.plugins;return[+new Date,c,Ct,c.screen,nt(a)]}}function nt(ct){return String.fromCharCode.apply(0,ct)}if(H(i.random(),a),o.exports){o.exports=$;try{k=require("crypto")}catch(ct){}}})([],Math)});Qi.alea=Tst;Qi.xor128=kst;Qi.xorwow=Sst;Qi.xorshift7=Cst;Qi.xor4096=Nst;Qi.tychei=Ist;var Est=Qi,_k=Est.alea;var Fk=function(){function o(a,i,c,f,d){this.mean=a,this.stdDev=i,this.dtype=c,this.nextVal=NaN,this.truncated=f,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);var g=d||Math.random();this.random=_k(g.toString())}return o.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var a=this.nextVal;return this.nextVal=NaN,a}for(var i,c,f=!1;!f;){var d=void 0,g=void 0,v=void 0;do d=2*this.random()-1,g=2*this.random()-1,v=d*d+g*g;while(v>=1||v===0);var w=Math.sqrt(-2*Math.log(v)/v);i=this.mean+this.stdDev*d*w,c=this.mean+this.stdDev*g*w,(!this.truncated||this.isValidTruncated(i))&&(f=!0)}return(!this.truncated||this.isValidTruncated(c))&&(this.nextVal=this.convertValue(c)),this.convertValue(i)},o.prototype.convertValue=function(a){return this.dtype==null||this.dtype==="float32"?a:Math.round(a)},o.prototype.isValidTruncated=function(a){return a<=this.upper&&a>=this.lower},o}(),Dst=function(){function o(a,i,c,f){this.alpha=a,this.beta=1/i,this.dtype=c;var d=f||Math.random();this.randu=_k(d.toString()),this.randn=new Fk(0,1,c,!1,this.randu()),a<1?this.d=a+2/3:this.d=a-1/3,this.c=1/Math.sqrt(9*this.d)}return o.prototype.nextValue=function(){for(var a,i,c,f,d,g;;){do f=this.randn.nextValue(),g=1+this.c*f;while(g<=0);if(g*=g*g,a=f*f,i=1-.331*a*a,c=.5*a+this.d*(1-g+Math.log(g)),d=this.randu(),d<i||Math.log(d)<c)break}return g=1/this.beta*this.d*g,this.alpha<1&&(g*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(g)},o.prototype.convertValue=function(a){return this.dtype==="float32"?a:Math.round(a)},o}(),$st=function(){function o(a,i,c,f){var d=this;if(a===void 0&&(a=0),i===void 0&&(i=1),this.canReturnFloat=function(){return d.dtype==null||d.dtype==="float32"},this.min=a,this.range=i-a,this.dtype=c,f==null&&(f=Math.random()),typeof f=="number"&&(f=f.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+a+" - "+i+" <= 1 and dtype is not float");this.random=_k(f)}return o.prototype.convertValue=function(a){return this.canReturnFloat()?a:Math.round(a)},o.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},o}();function Ast(o,a,i,c,f){if(i===void 0&&(i=1),c===void 0&&(c="float32"),i==null&&(i=1),c==null&&(c="float32"),c!=="float32"&&c!=="int32")throw new Error("Unsupported data type "+c);for(var d=new Dst(a,i,c,f),g=co(o,c),v=0;v<g.values.length;v++)g.values[v]=d.nextValue();return g.toTensor()}var _st=Y({randomGamma_:Ast});function Fst(o,a,i,c,f){if(a===void 0&&(a=0),i===void 0&&(i=1),c!=null&&c==="bool")throw new Error("Unsupported data type "+c);for(var d=new Fk(a,i,c,!1,f),g=co(o,c),v=0;v<g.values.length;v++)g.values[v]=d.nextValue();return g.toTensor()}var Rst=Y({randomNormal_:Fst});function Pst(o,a,i,c,f){a===void 0&&(a=0),i===void 0&&(i=1),c===void 0&&(c="float32");for(var d=co(o,c),g=new $st(a,i,null,f),v=0;v<d.values.length;v++)d.values[v]=g.nextValue();return d.toTensor()}var Y_=Y({randomUniform_:Pst});function Uc(o,a){zi(o);var i=uo(o,a);if(i.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");var c=null;return Ba(o,c,i,a)}function Rk(o,a,i,c){if(i===void 0&&(i=1),c===void 0&&(c="float32"),i===0)throw new Error("Cannot have a step of zero");var f=function(){var g=o===a,v=o<a&&i<0,w=a<o&&i>1;if(g||v||w)return qo([0],c);var T=Math.abs(Math.ceil((a-o)/i)),N=Ec(T,c);a<o&&i===1&&(i=-1),N[0]=o;for(var E=1;E<N.length;E++)N[E]=N[E-1]+i;return Uc(N,c)},d={start:o,stop:a,step:i,dtype:c};return Z.runKernelFunc(f,{},null,aA,d)}function Ost(o){var a=W(o,"x","reciprocal"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.reciprocal(a);return f([a]),d},i,null,nT)}var J_=Y({reciprocal_:Ost});function Mst(o){var a=W(o,"x","relu"),i=function(f,d){return d([a]),a.dtype==="bool"?Bt(a,"int32"):f.relu(a)},c={x:a};return Z.runKernelFunc(i,c,null,rT)}var Yf=Y({relu_:Mst});function Lst(o){var a=W(o,"x","relu6"),i=function(f,d){return d([a]),a.dtype==="bool"?Bt(a,"int32"):f.relu6(a)},c={x:a};return Z.runKernelFunc(i,c,null,iT)}var Pk=Y({relu6_:Lst});function Bst(o,a){var i=W(o,"x","reverse"),c=function(g){var v=Qe(a,i.shape);if(i.rank===0)return Ui(i);var w=g.reverse(i,v);return it(w,i.shape)},f={x:i},d={dims:a};return Z.runKernelFunc(c,f,null,uT,d)}var Ko=Y({reverse_:Bst});function zst(o){var a=W(o,"x","reverse");return U(a.rank===1,function(){return"Error in reverse1D: x must be rank 1 but got rank "+a.rank+"."}),Ko(a,0)}var Wst=Y({reverse1d_:zst});function Vst(o,a){var i=W(o,"x","reverse");return U(i.rank===2,function(){return"Error in reverse2D: x must be rank 2 but got rank "+i.rank+"."}),Ko(i,a)}var Ust=Y({reverse2d_:Vst});function Gst(o,a){var i=W(o,"x","reverse");return U(i.rank===3,function(){return"Error in reverse3D: x must be rank 3 but got rank "+i.rank+"."}),Ko(i,a)}var Hst=Y({reverse3d_:Gst});function qst(o,a){var i=W(o,"x","reverse");return U(i.rank===4,function(){return"Error in reverse4D: x must be rank 4 but got rank "+i.rank+"."}),Ko(i,a)}var jst=Y({reverse4d_:qst});function Kst(o){var a=W(o,"x","round"),i={x:a};return Z.runKernelFunc(function(c){return c.round(a)},i,null,cT)}var Z_=Y({round_:Kst});function Xst(o){var a=W(o,"x","rsqrt"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.rsqrt(a);return f([a]),d},i,null,lT)}var Ok=Y({rsqrt_:Xst});function Yst(o){var a=W(o,"x","selu"),i=function(f,d){var g=f.selu(a);return d([a]),g},c={x:a};return Z.runKernelFunc(i,c,null,fT)}var Q_=Y({selu_:Yst});function Jst(o,a,i,c,f,d,g){d===void 0&&(d=[1,1]),g===void 0&&(g="NHWC");var v=W(o,"x","separableConv2d"),w=W(a,"depthwiseFilter","separableConv2d"),T=W(i,"pointwiseFilter","separableConv2d"),N=v,E=!1;if(v.rank===3&&(E=!0,N=it(v,[1,v.shape[0],v.shape[1],v.shape[2]])),g==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(N.rank===4,function(){return"Error in separableConv2d: input must be rank 4, but got "+("rank "+N.rank+".")}),U(w.rank===4,function(){return"Error in separableConv2d: depthwise filter must be rank 4, but "+("got rank "+w.rank+".")}),U(T.rank===4,function(){return"Error in separableConv2d: pointwise filter must be rank 4, but "+("got rank "+w.rank+".")}),U(T.shape[0]===1,function(){return"Error in separableConv2d: the first dimension of pointwise filter "+(" must be 1, but got "+T.shape[0]+".")}),U(T.shape[1]===1,function(){return"Error in separableConv2d: the second dimension of pointwise "+("filter must be 1, but got "+T.shape[1]+".")});var k=w.shape[2],$=w.shape[3];U(T.shape[2]===k*$,function(){return"Error in separableConv2d: the third dimension of pointwise filter "+("must be "+k*$+", ")+("but got "+T.shape[2]+".")});var M=qf(N,w,c,f,g,d),G=1,O=Lc(M,T,G,"valid",g);return E?it(O,[O.shape[1],O.shape[2],O.shape[3]]):O}var tF=Y({separableConv2d_:Jst});function Zst(o,a){return qt(this,void 0,void 0,function(){var i,c,f,d,g,v,w,T,N,w,E;return jt(this,function(k){switch(k.label){case 0:return i=W(o,"x","setdiff1d"),c=W(a,"y","setdiff1d"),U(i.dtype===c.dtype,function(){return"x and y should have the same dtype, but got x ("+i.dtype+") and y ("+c.dtype+")."}),U(i.rank===1,function(){return"x should be 1D tensor, but got x ("+i.shape+")."}),U(c.rank===1,function(){return"y should be 1D tensor, but got y ("+c.shape+")."}),[4,i.data()];case 1:return f=k.sent(),[4,c.data()];case 2:for(d=k.sent(),g=new Set(d),v=0,w=0;w<f.length;w++)g.has(f[w])||v++;for(T=new gg([v],i.dtype),N=new gg([v],"int32"),w=0,E=0;w<f.length;w++)g.has(f[w])||(T.values[E]=f[w],N.values[E]=w,E++);return[2,[T.toTensor(),N.toTensor()]]}})})}var Qst=Zst;function tot(o){var a=W(o,"x","sign"),i={x:a};return Z.runKernelFunc(function(c){return c.sign(a)},i,null,gT)}var eF=Y({sign_:tot});function eot(o){var a=W(o,"x","sin"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.sin(a);return f([a]),d},i,null,dT)}var Mk=Y({sin_:eot});function not(o){var a=W(o,"x","sinh"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.sinh(a);return f([a]),d},i,null,mT)}var Lk=Y({sinh_:not});function rot(o,a,i){var c=W(o,"x","slice1d");return U(c.rank===1,function(){return"slice1d expects a rank-1 tensor, but got a rank-"+c.rank+" tensor"}),De(c,[a],[i])}var sot=Y({slice1d_:rot});function oot(o,a,i){var c=W(o,"x","slice2d");return U(c.rank===2,function(){return"slice2d expects a rank-2 tensor, but got a rank-"+c.rank+" tensor"}),De(c,a,i)}var aot=Y({slice2d_:oot});function iot(o,a,i){var c=W(o,"x","slice3d");return U(c.rank===3,function(){return"slice3d expects a rank-3 tensor, but got a rank-"+c.rank+" tensor"}),De(c,a,i)}var uot=Y({slice3d_:iot});function cot(o,a,i){var c=W(o,"x","slice4d");return U(c.rank===4,function(){return"slice4d expects a rank-4 tensor, but got a rank-"+c.rank+" tensor"}),De(c,a,i)}var lot=Y({slice4d_:cot});function hot(o,a){a===void 0&&(a=-1);var i=W(o,"logits","softmax","float32");if(a===-1&&(a=i.rank-1),a!==i.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+("Logits was rank "+i.rank+" and dim was "+a));var c={logits:i},f={dim:a};return Z.runKernelFunc(function(d,g){var v=d.softmax(i,a);return g([v]),v},c,null,kT,f)}var nF=Y({softmax_:hot});function fot(o){U(o.dtype==="complex64",function(){return"The dtype for tf.spectral.fft() must be complex64 "+("but got "+o.dtype+".")});var a={input:o};return Z.runKernelFunc(function(i){var c=o.shape[o.shape.length-1],f=o.size/c,d=o.as2D(f,c),g=i.fft(d);return g.reshape(o.shape)},a,null,M$)}var Bg=Y({fft_:fot});function pot(o){U(o.dtype==="complex64",function(){return"The dtype for tf.spectral.ifft() must be complex64 "+("but got "+o.dtype+".")});var a={input:o};return Z.runKernelFunc(function(i){var c=o.shape[o.shape.length-1],f=o.size/c,d=it(o,[f,c]),g=i.ifft(d);return it(g,o.shape)},a,null,V$)}var Jf=Y({ifft_:pot});function dot(o){var a=o.shape[o.shape.length-1],i=o.size/a,c;if(a<=2){var f=it(o,[i,a]);c=Jf(f)}else{var d=[i,2*(a-1)],g=it(Xf(o),[i,a]),v=it(Ag(o),[i,a]),w=Ko(De(g,[0,1],[i,a-2]),1),T=pt(Ko(De(v,[0,1],[i,a-2]),1),ne(-1)),N=qn([g,w],1),E=qn([v,T],1),f=it(La(N,E),[d[0],d[1]]);c=Jf(f)}if(c=Xf(c),o.rank===3&&o.shape[0]!==0){var k=c,$=o.shape[0];c=it(c,[$,c.shape[0]/$,c.shape[1]]),k.dispose()}return c}var Bk=Y({irfft_:dot});function rF(o,a,i){i===void 0&&(i=0);var c=[];if(typeof a=="number")U(o.shape[i]%a===0,function(){return"Number of splits must evenly divide the axis."}),c=new Array(a).fill(o.shape[i]/a);else{var f=a.reduce(function(v,w){return w===-1&&(v+=1),v},0);U(f<=1,function(){return"There should be only one negative value in split array."});var d=a.indexOf(-1);if(d!==-1){var g=a.reduce(function(v,w){return w>0?v+w:v});a[d]=o.shape[i]-g}U(o.shape[i]===a.reduce(function(v,w){return v+w}),function(){return"The sum of sizes must match the size of the axis dimension."}),c=a}return c}function mot(o,a,i){i===void 0&&(i=0);var c=W(o,"x","split"),f=function(v,w){var T=Qe(i,c.shape)[0],N=rF(c,a,T);return v.split(c,N,T)},d={x:c},g={numOrSizeSplits:a,axis:i};return Z.runKernelFunc(f,d,null,TT,g)}var Gc=Y({split_:mot});function got(o,a){U(o.dtype==="float32",function(){return"The dtype for rfft() must be real value but got "+o.dtype});var i=o.shape[o.shape.length-1],c=o.size/i,f;if(a!=null&&a<i){var d=o.shape.map(function(H){return 0}),g=o.shape.map(function(H){return H});g[o.shape.length-1]=a,f=De(o,d,g),i=a}else if(a!=null&&a>i){var v=o.shape.map(function(H){return H});v[o.shape.length-1]=a-i,f=qn([o,qo(v)],o.shape.length-1),i=a}else f=o;var w=ke(f),T=it(La(f,w),[c,i]),N=Bg(T),E=Math.floor(i/2)+1,k=Xf(N),$=Ag(N),M=Gc(k,[E,i-E],k.shape.length-1),G=Gc($,[E,i-E],$.shape.length-1),O=f.shape.slice();return O[f.shape.length-1]=E,it(La(M[0],G[0]),O)}var zg=Y({rfft_:got});function vot(o){var a=W(o,"x","sqrt"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.sqrt(a);return f([a]),d},i,null,bT)}var Tr=Y({sqrt_:vot});function yot(o,a){var i,c=W(o,"a","squaredDifference"),f=W(a,"b","squaredDifference");i=pn(c,f),c=i[0],f=i[1],tn(c.shape,f.shape);var d=function(w,T){var N=w.squaredDifference(c,f);return T([c,f]),N},g={a:c,b:f},v={};return Z.runKernelFunc(d,g,null,ST,v)}var Wg=Y({squaredDifference_:yot});function bot(o,a){var i=W(o,"x","squeeze");return it(i,a$(i.shape,a).newShape)}var Vg=Y({squeeze_:bot});function wot(o,a){a===void 0&&(a=0);var i=zf(o,"tensors","stack");if(U(i.length>=1,function(){return"Pass at least one tensor to tf.stack"}),i.length===1)return Bs(i[0],a);var c=i[0].rank,f=i[0].shape,d=i[0].dtype;U(a<=c,function(){return"Axis must be <= rank of the tensor"}),i.forEach(function(v){Ee(f,v.shape,"All tensors passed to stack must have matching shapes"),U(d===v.dtype,function(){return"All tensors passed to stack must have matching dtypes"})});var g=i.map(function(v){return Bs(v,a)});return qn(g,a)}var tu=Y({stack_:wot});function xot(o,a){a===void 0&&(a=0);var i=W(o,"x","step"),c={x:i},f={alpha:a};return Z.runKernelFunc(function(d){return d.step(i,a)},c,null,FT,f)}var Hc=Y({step_:xot});function Tot(o,a,i,c,f,d,g,v,w){f===void 0&&(f=0),d===void 0&&(d=0),g===void 0&&(g=0),v===void 0&&(v=0),w===void 0&&(w=0);var T=W(o,"x","stridedSlice"),N=function($){c==null&&(c=new Array(a.length));var M=xg(g);if(M.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(g!==0&&v!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(g!==0&&w!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");var G=T.rank-a.length,O=xg(v),H=T.shape.slice();O.forEach(function(Wt){a[Wt]=0,i[Wt]=1,H.splice(Wt,0,1)}),T=it(T,H);var K=s_(T.shape,M,G,a,i,c,f,d,g),nt=K.begin,ct=K.end,dt=K.strides;a=nt,i=ct,c=dt;var Ct=xg(w);Ct.forEach(function(Wt){i[Wt]=a[Wt]+1,c[Wt]=1});var St=XA(a,i,c),It=St.filter(function(Wt,_t){return Ct.indexOf(_t)===-1}),Gt=c.every(function(Wt){return Wt===1});if(Gt)return it(De(T,a,St),It);var Et=$.stridedSlice(T,a,i,c);return it(Et,It)},E={x:T},k={begin:a,end:i,strides:c,beginMask:f,endMask:d,ellipsisMask:g,newAxisMask:v,shrinkAxisMask:w};return Z.runKernelFunc(N,E,null,pA,k)}var sF=Y({stridedSlice_:Tot});function kot(o){var a=W(o,"x","tan"),i={x:a};return Z.runKernelFunc(function(c,f){var d=c.tan(a);return f([a]),d},i,null,NT)}var oF=Y({tan_:kot});function Zf(o,a,i){if(zi(o),a!=null&&a.length!==2)throw new Error("tensor2d() requires shape to have two numbers");var c=uo(o,i);if(c.length!==2&&c.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(c.length===1&&a==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ba(o,a,c,i)}function Sot(o,a,i){if(zi(o),a!=null&&a.length!==4)throw new Error("tensor4d() requires shape to have four numbers");var c=uo(o,i);if(c.length!==4&&c.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(c.length===1&&a==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ba(o,a,c,i)}function Cot(o,a,i){if(zi(o),a!=null&&a.length!==5)throw new Error("tensor5d() requires shape to have five numbers");var c=uo(o,i);if(c.length!==5&&c.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(c.length===1&&a==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ba(o,a,c,i)}function Not(o,a,i){if(zi(o),a!=null&&a.length!==6)throw new Error("tensor6d() requires shape to have six numbers");var c=uo(o,i);if(c.length!==6&&c.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(c.length===1&&a==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return a=a||c,Ba(o,a,c,i)}function Iot(o,a,i){a===void 0&&(a=1),i===void 0&&(i=!0);var c=W(o,"x","topk");if(c.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");var f=c.shape[c.shape.length-1];if(a>f)throw new Error("'k' passed to topk() must be <= the last dimension ("+f+") "+("but got "+a));var d={x:c},g={k:a,sorted:i},v=Z.runKernelFunc(function(N){return N.topk(c,a,i)},d,null,dA,g),w=v[0],T=v[1];return{values:w,indices:T}}var aF=Y({topk_:Iot});function Eot(o,a,i,c,f){if(a===void 0&&(a=0),i===void 0&&(i=1),c!=null&&c==="bool")throw new Error("Unsupported data type $ { dtype }");for(var d=new Fk(a,i,c,!0,f),g=co(o,c),v=0;v<g.values.length;v++)g.values[v]=d.nextValue();return g.toTensor()}var Dot=Y({truncatedNormal_:Eot});function $ot(o,a){a===void 0&&(a=0);var i=W(o,"x","unique",null);U(i.rank>0,function(){return"The input tensor must be at least 1D"});var c={x:i},f={axis:a},d=Z.runKernel(mA,c,f),g=d[0],v=d[1];return{values:g,indices:v}}var iF=Y({unique_:$ot});function Aot(o,a,i){var c=W(o,"x","unsortedSegmentSum"),f=W(a,"segmentIds","unsortedSegmentSum","int32");U(fn(i),function(){return"numSegments must be of dtype int"});var d={x:c,segmentIds:f},g={numSegments:i},v=function(w,T){var N=w.unsortedSegmentSum(c,f,i);return T([f]),N};return Z.runKernelFunc(v,d,null,AT,g)}var zk=Y({unsortedSegmentSum_:Aot});function _ot(o,a){a===void 0&&(a=0);var i=W(o,"x","unstack");U(a>=-i.shape.length&&a<i.shape.length,function(){return"Axis = "+a+" is not in [-"+i.shape.length+", "+i.shape.length+")"}),a<0&&(a+=i.shape.length);var c={value:i},f={axis:a},d=function(g){return g.unstack(i,a)};return Z.runKernelFunc(d,c,null,$T,f)}var Ug=Y({unstack_:_ot});function Fot(o,a,i,c){return a===void 0&&(a=!0),Z.makeVariable(o,a,i,c)}function uF(o,a){for(var i=[],c=0;c<a.length;c++)a[c]&&i.push(c);for(var f=co(o,"int32"),d=co([i.length,o.length],"int32"),c=0;c<i.length;c++){var g=f.indexToLoc(i[c]),v=c*o.length;d.values.set(g,v)}return d.toTensor()}function Rot(o){return qt(this,void 0,void 0,function(){var a,i,c;return jt(this,function(f){switch(f.label){case 0:return a=W(o,"condition","whereAsync","bool"),[4,a.data()];case 1:return i=f.sent(),c=uF(a.shape,i),o!==a&&a.dispose(),[2,c]}})})}var cF=Rot;function Pot(o,a,i){return qt(this,void 0,void 0,function(){var c,f,d,g,v,w,T,N,E,k,$,M,G;return jt(this,function(O){switch(O.label){case 0:for(c=W(o,"tensor","boolMask"),f=W(a,"mask","boolMask","bool"),d=i==null?0:i,g=f.rank,v=c.shape,U(g>0,function(){return"mask cannot be scalar"}),Ee(v.slice(d,d+g),f.shape,"mask's shape must match the first K dimensions of tensor's shape,"),w=1,T=d;T<d+g;T++)w*=v[T];return N=v.slice(0,d).concat([w],v.slice(d+g)),E=it(c,N),k=it(f,[-1]),[4,cF(k)];case 1:return $=O.sent(),M=Vg($,[1]),G=$g(E,M,d),o!==c&&c.dispose(),a!==f&&f.dispose(),M.dispose(),E.dispose(),k.dispose(),$.dispose(),[2,G]}})})}var Oot=Pot;function Mot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","notEqualStrict"),c=W(a,"b","notEqualStrict");return Ee(i.shape,c.shape,"Error in notEqualStrict: "),Mg(i,c)}function Lot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","lessStrict"),c=W(a,"b","lessStrict");return Ee(i.shape,c.shape,"Error in lessStrict: "),_g(i,c)}function Bot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","equalStrict"),c=W(a,"b","equalStrict");return Ee(i.shape,c.shape,"Error in equalStrict: "),jf(i,c)}function zot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","lessEqualStrict"),c=W(a,"b","lessEqualStrict");return Ee(i.shape,c.shape,"Error in lessEqualStrict: "),ji(i,c)}function Wot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","greaterStrict"),c=W(a,"b","greaterStrict");return Ee(i.shape,c.shape,"Error in greaterStrict: "),Ha(i,c)}function Vot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","greaterEqualStrict"),c=W(a,"b","greaterEqualStrict");return Ee(i.shape,c.shape,"Error in greaterEqualStrict: "),qi(i,c)}var lF=Y({equalStrict_:Bot}),hF=Y({greaterEqualStrict_:Vot}),fF=Y({greaterStrict_:Wot}),pF=Y({lessEqualStrict_:zot}),dF=Y({lessStrict_:Lot}),mF=Y({notEqualStrict_:Mot});function Uot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","addStrict"),c=W(a,"b","addStrict");return Ee(i.shape,c.shape,"Error in addStrict: "),Yt(i,c)}function Got(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","subStrict"),c=W(a,"b","subStrict");return Ee(i.shape,c.shape,"Error in subStrict: "),Qt(i,c)}function Hot(o,a){return Mn("strict variants of ops have been deprecated and will be removed in future"),Ee(o.shape,a.shape,"Error in powStrict: "),jo(o,a)}function qot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","mul"),c=W(a,"b","mul");return Ee(i.shape,c.shape,"Error in multiplyStrict: "),pt(i,c)}function jot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","div"),c=W(a,"b","div");return Ee(i.shape,c.shape,"Error in divideStrict: "),ae(i,c)}function Kot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","modStrict"),c=W(a,"b","modStrict");return Ee(i.shape,c.shape,"Error in modStrict: "),Dk(i,c)}function Xot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","minimumStrict"),c=W(a,"b","minimumStrict");return Ee(i.shape,c.shape,"Error in minimumStrict: "),Og(i,c)}function Yot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","maximumStrict"),c=W(a,"b","maximumStrict");return Ee(i.shape,c.shape,"Error in maximumStrict: "),zc(i,c)}function Jot(o,a){Mn("strict variants of ops have been deprecated and will be removed in future");var i=W(o,"a","squaredDifferenceStrict"),c=W(a,"b","squaredDifferenceStrict");return Ee(i.shape,c.shape,"Error in squaredDifferenceStrict: "),Wg(i,c)}var gF=Y({addStrict_:Uot}),vF=Y({divStrict_:jot}),yF=Y({maximumStrict_:Yot}),bF=Y({minimumStrict_:Xot}),wF=Y({modStrict_:Kot}),xF=Y({mulStrict_:qot}),TF=Y({powStrict_:Hot}),kF=Y({squaredDifferenceStrict_:Jot}),SF=Y({subStrict_:Got});function Zot(o,a,i,c){a===void 0&&(a="euclidean"),i===void 0&&(i=null),c===void 0&&(c=!1),o=W(o,"x","norm");var f=CF(o,a,i),d=f.shape;if(c){var g=Qe(i,o.shape);d=Jr(f.shape,g)}return it(f,d)}function CF(o,a,i){if(i===void 0&&(i=null),o.rank===0)return _r(o);if(o.rank!==1&&i===null)return CF(it(o,[-1]),a,i);if(o.rank===1||typeof i=="number"||Array.isArray(i)&&i.length===1){if(a===1)return ie(_r(o),i);if(a===Infinity)return Xi(_r(o),i);if(a===-Infinity)return Pg(_r(o),i);if(a==="euclidean"||a===2)return Tr(ie(jo(_r(o),ne(2,"int32")),i));throw new Error("Error in norm: invalid ord value: "+a)}if(Array.isArray(i)&&i.length===2){if(a===1)return Xi(ie(_r(o),i[0]),i[1]-1);if(a===Infinity)return Xi(ie(_r(o),i[1]),i[0]);if(a===-Infinity)return Pg(ie(_r(o),i[1]),i[0]);if(a==="fro"||a==="euclidean")return Tr(ie(Ue(o),i));throw new Error("Error in norm: invalid ord value: "+a)}throw new Error("Error in norm: invalid axis: "+i)}var Gg=Y({norm_:Zot});function Qot(o,a,i,c,f){f===void 0&&(f=!0);var d=W(o,"v","movingAverage"),g=W(a,"x","movingAverage"),v=W(i,"decay","movingAverage");xA(d,g),U(Rs(d.shape,g.shape),function(){return"Shape mismatch in v and x"});var w=ne(1),T=Qt(w,v),N=pt(Qt(g,d),T);if(f){U(c!=null,function(){return"When using zeroDebias: true, step is required."});var E=W(c,"step","movingAverage");N=ae(N,Qt(w,jo(v,E)))}return Yt(d,N)}var tat=Y({movingAverage_:Qot});function eat(o,a,i){var c=W(o,"indices","scatterND","int32"),f=W(a,"updates","scatterND");uk(f,c,i);var d=function(w){return w.scatterND(c,f,i)},g={indices:c,updates:f},v={shape:i};return Z.runKernelFunc(d,g,null,lA,v)}var nat=Y({scatterND_:eat});function rat(o,a,i,c){if(o.dtype!=="int32")throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+(" but the dtype was "+o.dtype+"."));if(o.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+(" but got shape "+o.shape+"."));var f=o.rank>0?o.shape[0]:1,d=o.rank>1?o.shape[1]:1;if(i.length!==d)throw new Error("outputShape has incorrect number of elements:,"+(" "+i.length+", should be: "+d+"."));var g=a.size;if(!(a.rank===0||a.rank===1&&g===f))throw new Error("sparseValues has incorrect shape "+(a.shape+", should be [] or ["+f+"]"));if(a.dtype!==c.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sat(o,a,i,c){c===void 0&&(c=0);var f=W(o,"sparseIndices","sparseToDense","int32"),d=W(a,"sparseValues","sparseToDense"),g=W(c,"defaultValue","sparseToDense",d.dtype);rat(f,d,i,g);var v={sparseIndices:f,sparseValues:d,defaultValue:g},w={outputShape:i};return Z.runKernelFunc(function(T){return T.sparseToDense(f,d,i,g)},v,null,fA,w)}var oat=Y({sparseToDense_:sat});function aat(o,a){var i=W(a,"indices","gatherND","int32"),c=W(o,"x","gatherND"),f=function(g){return g.gatherND(c,i)},d={params:c,indices:i};return Z.runKernelFunc(f,d,null,z$)}var iat=Y({gatherND_:aat});function uat(o,a){if(a==null)return o.shape.slice();if(Rs(o.shape,a))return a;if(o.shape.length===a.length){for(var i=[],c=0;c<o.shape.length;c++)a[c]==null&&o.shape[c]!=null?i.push(o.shape[c]):i.push(a[c]);return i}return a}function cat(o,a,i,c){var f=W(o,"x","dropout");if(U(f.dtype==="float32",function(){return"x has to be a floating point tensor since it's going to be "+("scaled, but got a "+f.dtype+" tensor instead.")}),U(a>=0&&a<1,function(){return"rate must be a float in the range [0, 1), but got "+a+"."}),a===0)return o instanceof ut?f.clone():f;var d=uat(f,i),g=1-a,v=ae(Dg(Yt(Y_(d,0,1,"float32",c),g)),g);return pt(f,v)}var lat=Y({dropout_:cat});function NF(o){return Math.floor(Math.pow(2,Math.ceil(Math.log(o)/Math.log(2))))}function Wk(o,a,i){for(var c=1-o%2,f=new Float32Array(o),d=0;d<o;++d){var g=2*Math.PI*d/(o+c-1);f[d]=a-i*Math.cos(g)}return Uc(f,"float32")}function hat(o,a,i){return i===void 0&&(i=1),qt(this,void 0,void 0,function(){var c,f,d,g,v,w,T,N,E,k,$,M,G,O,O;return jt(this,function(H){switch(H.label){case 0:return c=W(o,"predictions","inTopK"),f=W(a,"targets","inTopK"),U(c.rank>1,function(){return"inTopK() expects the predictions to be of rank 2 or higher, "+("but got "+c.rank)}),U(c.rank-1===f.rank,function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+(c.rank+" and targets rank "+f.rank)}),Ee(c.shape.slice(0,c.shape.length-1),f.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),d=c.shape[c.shape.length-1],U(i>0&&i<=d,function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last "+("dimension ("+d+"), but got "+i)}),[4,c.data()];case 1:return g=H.sent(),[4,f.data()];case 2:for(v=H.sent(),w=[g.length/d,d],T=w[0],N=w[1],E=ug("bool",T),k=0;k<T;k++){for($=k*N,M=g.subarray($,$+N),G=[],O=0;O<M.length;O++)G.push({value:M[O],index:O});for(G.sort(function(K,nt){return nt.value-K.value}),E[k]=0,O=0;O<i;O++)if(G[O].index===v[k]){E[k]=1;break}}return o!==c&&c.dispose(),a!==f&&f.dispose(),[2,za(E,f.shape,"bool")]}})})}var fat=hat;function pat(o,a,i,c,f,d,g){d===void 0&&(d="NHWC");var v=o;o.rank===3&&(v=it(o,[1,o.shape[0],o.shape[1],o.shape[2]]));var w=a;w.rank===3&&(w=it(a,[1,a.shape[0],a.shape[1],a.shape[2]])),U(v.rank===4,function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+(v.shape+".")}),U(w.rank===4,function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+(w.shape+".")}),U(i.length===4,function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+(i+".")});var T=d==="NHWC"?v.shape[3]:v.shape[1],N=d==="NHWC"?w.shape[3]:w.shape[1];U(T===i[2],function(){return"Error in conv2dDerFilter: depth of input "+T+") must "+("match input depth in filter ("+i[2]+".")}),U(N===i[3],function(){return"Error in conv2dDerFilter: depth of dy ("+N+") must "+("match output depth for filter ("+i[3]+").")}),g!=null&&U(fn(f),function(){return"Error in conv2dDerFilter: pad must be an integer when using, "+("dimRoundingMode "+g+" but got pad "+f+".")});var E=function(M){var G=1,O=Vf(d),H=Os(v.shape,i,c,G,f,g,!1,O);return M.conv2dDerFilter(v,w,H)},k={x:v,dy:w},$={strides:c,pad:f,dataFormat:d,dimRoundingMode:g,filterShape:i};return Z.runKernelFunc(E,k,null,C$,$)}var Vk=Y({conv2DBackpropFilter_:pat});function Hg(o,a,i){if(i==null||i==="linear")return o;if(i==="relu")return pt(o,Hc(a));throw new Error("Cannot compute gradient for fused activation "+i+".")}function qg(o,a){var i=a,c=Dn(o.shape,a.shape);return c.length>0&&(i=ie(i,c)),it(i,o.shape)}function jg(o,a,i){if(a==="linear")return o;if(a==="relu")return Yf(o);if(a==="elu")return xk(o);if(a==="relu6")return Pk(o);if(a==="prelu")return Ak(o,i);throw new Error("Unknown fused activation "+a+".")}var Kg=function(o,a){var i=o>0;return!i||a==="linear"};function dat(o){var a=o.x,i=o.filter,c=o.strides,f=o.pad,d=o.dataFormat,g=d===void 0?"NHWC":d,v=o.dilations,w=v===void 0?[1,1]:v,T=o.dimRoundingMode,N=o.bias,E=o.activation,k=E===void 0?"linear":E,$=o.preluActivationWeights;if(k=k||"linear",Kg(Z.state.gradientDepth,k)===!1){var M=Lc(a,i,c,f,g,w,T);return N!=null&&(M=Yt(M,N)),jg(M,k,$)}var G=W(a,"x","conv2d"),O=W(i,"filter","conv2d"),H=G,K=!1;G.rank===3&&(K=!0,H=it(G,[1,G.shape[0],G.shape[1],G.shape[2]])),U(H.rank===4,function(){return"Error in fused conv2d: input must be rank 4, but got rank "+(H.rank+".")}),U(O.rank===4,function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+(O.rank+".")}),T!=null&&U(fn(f),function(){return"Error in fused conv2d: pad must be an integer when using, "+("dimRoundingMode "+T+" but got pad "+f+".")}),U(H.shape[3]===O.shape[2],function(){return"Error in conv2d: depth of input ("+H.shape[3]+") must match "+("input depth for filter "+O.shape[2]+".")}),U(xr(c,w),function(){return"Error in conv2D: Either strides or dilations must be 1. "+("Got strides "+c+" and dilations '"+w+"'")}),U(g==="NHWC",function(){return"Error in conv2d: got dataFormat of "+g+" but only NHWC is currently supported."});var nt=Os(H.shape,O.shape,c,w,f,T),ct;N!=null&&(ct=W(N,"bias","fused conv2d"),ct=pn(ct,G)[0],tn(nt.outShape,ct.shape));var dt;$!=null&&(dt=W($,"prelu weights","fused conv2d"));var Ct=function(_t,Kt){var Ne=Kt,ce=Ne[0],me=Ne[1],Re=Ne[2],gn=Ne[3],en=Hg(_t,Re,k);U(Ga(w),function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 "+("are not yet supported in gradients. Got dilations '"+w+"'")});var dn=yk(me.shape,en,ce,c,f),Zn=Vk(me,en,ce.shape,c,f),Or=[dn,Zn];if(gn!=null){var Us=qg(gn,en);Or.push(Us)}return Or},St=function(_t){var Kt=_t.fusedConv2d({input:H,filter:O,convInfo:nt,bias:ct,activation:k,preluActivationWeights:dt});return Kt},It={x:H,filter:O,bias:ct,preluActivationWeights:dt},Gt={strides:c,pad:f,dataFormat:g,dilations:w,dimRoundingMode:T,activation:k};if(N==null){var Et=ho(function(_t,Kt,Ne){var ce=Z.runKernelFunc(St,It,null,OT,Gt);return Ne([Kt,_t,ce]),K&&(ce=it(ce,[ce.shape[1],ce.shape[2],ce.shape[3]])),{value:ce,gradFunc:Ct}});return Et(H,O)}else{var Wt=ho(function(_t,Kt,Ne,ce){var me=Z.runKernelFunc(St,It,null,OT,Gt);return ce([Kt,_t,me,Ne]),K&&(me=it(me,[me.shape[1],me.shape[2],me.shape[3]])),{value:me,gradFunc:Ct}});return Wt(H,O,ct)}}var mat=Y({fusedConv2d_:dat});function gat(o,a,i,c,f,d,g){d===void 0&&(d=[1,1]);var v=o;o.rank===3&&(v=it(o,[1,o.shape[0],o.shape[1],o.shape[2]]));var w=a;w.rank===3&&(w=it(a,[1,a.shape[0],a.shape[1],a.shape[2]]));var T=function(k){var $=Os(o.shape,i,c,d,f,g,!0);return k.depthwiseConv2DDerFilter(v,w,$)},N={x:v,dy:w},E={strides:c,pad:f,dimRoundingMode:g,dilations:d,filterShape:i};return Z.runKernelFunc(T,N,null,$$,E)}var IF=Y({depthwiseConv2dNativeBackpropFilter_:gat});function vat(o,a,i,c,f,d,g){d===void 0&&(d=[1,1]);var v=a,w=!1;a.rank===3&&(w=!0,v=it(a,[1,a.shape[0],a.shape[1],a.shape[2]]));var T=function($){var M=Os(o,i.shape,c,d,f,g,!0);return $.depthwiseConv2DDerInput(v,i,M)},N={dy:v,filter:i},E={strides:c,pad:f,dimRoundingMode:g,dilations:d,inputShape:o},k=Z.runKernelFunc(T,N,null,A$,E);return w?it(k,[k.shape[1],k.shape[2],k.shape[3]]):k}var EF=Y({depthwiseConv2dNativeBackpropInput_:vat});function yat(o){var a=o.x,i=o.filter,c=o.strides,f=o.pad,d=o.dataFormat,g=d===void 0?"NHWC":d,v=o.dilations,w=v===void 0?[1,1]:v,T=o.dimRoundingMode,N=o.bias,E=o.activation,k=E===void 0?"linear":E,$=o.preluActivationWeights;if(Kg(Z.state.gradientDepth,k)===!1){var M=qf(a,i,c,f,g,w,T);return N!=null&&(M=Yt(M,N)),jg(M,k,$)}var G=W(a,"x","depthwiseConv2d"),O=W(i,"filter","depthwiseConv2d"),H=G,K=!1;G.rank===3&&(K=!0,H=it(G,[1,G.shape[0],G.shape[1],G.shape[2]])),U(H.rank===4,function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got "+("rank "+H.rank+".")}),U(O.rank===4,function(){return"Error in fused depthwiseConv2d: filter must be rank 4, "+("but got rank "+O.rank+".")}),U(H.shape[3]===O.shape[2],function(){return"Error in fused depthwiseConv2d: number of input channels "+("("+H.shape[3]+") must match the inChannels dimension in ")+("filter "+O.shape[2]+".")}),w==null&&(w=[1,1]),U(xr(c,w),function(){return"Error in fused depthwiseConv2d: Either strides or dilations must "+("be 1. Got strides "+c+" and dilations '"+w+"'")}),T!=null&&U(fn(f),function(){return"Error in fused depthwiseConv2d: pad must be an integer when "+("using dimRoundingMode "+T+" but got pad "+f+".")});var nt=Os(H.shape,O.shape,c,w,f,T,!0),ct;N!=null&&(ct=W(N,"bias","fused conv2d"),ct=pn(ct,G)[0],tn(nt.outShape,ct.shape));var dt;$!=null&&(dt=W($,"prelu weights","fused depthwiseConv2d"));var Ct=function(_t,Kt){U(Ga(w),function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+("'"+w+"'")});var Ne=Kt[0],ce=Kt[1],me=Kt[2],Re=Kt[3],gn=Hg(_t,me,k),en=EF(ce.shape,gn,Ne,c,f,w,T),dn=IF(ce,gn,Ne.shape,c,f,w,T);if(Re!=null){var Zn=qg(ct,gn);return[en,dn,Zn]}return[en,dn]},St=function(_t){var Kt=_t.fusedDepthwiseConv2D({input:H,filter:O,convInfo:nt,bias:ct,activation:k,preluActivationWeights:dt});return Kt},It={x:H,filter:O,bias:ct,preluActivationWeights:dt},Gt={strides:c,pad:f,dataFormat:g,dilations:w,dimRoundingMode:T,activation:k};if(N==null){var Et=ho(function(_t,Kt,Ne){var ce=Z.runKernelFunc(St,It,null,MT,Gt);return Ne([Kt,_t,ce]),K&&(ce=it(ce,[ce.shape[1],ce.shape[2],ce.shape[3]])),{value:ce,gradFunc:Ct}});return Et(H,O)}else{var Wt=ho(function(_t,Kt,Ne,ce){var me=Z.runKernelFunc(St,It,null,MT,Gt);return ce([Kt,_t,me,Ne]),K&&(me=it(me,[me.shape[1],me.shape[2],me.shape[3]])),{value:me,gradFunc:Ct}});return Wt(H,O,ct)}}var bat=Y({fusedDepthwiseConv2d_:yat});function wat(o){var a,i=o.a,c=o.b,f=o.transposeA,d=f===void 0?!1:f,g=o.transposeB,v=g===void 0?!1:g,w=o.bias,T=o.activation,N=T===void 0?"linear":T,E=o.preluActivationWeights;if(Kg(Z.state.gradientDepth,N)===!1){var k=Ce(i,c,d,v);return w!=null&&(k=Yt(k,w)),jg(k,N,E)}var $=W(i,"a","fused matMul"),M=W(c,"b","fused matMul");a=pn($,M),$=a[0],M=a[1];var G=d?$.shape[$.rank-2]:$.shape[$.rank-1],O=v?M.shape[M.rank-1]:M.shape[M.rank-2],H=d?$.shape[$.rank-1]:$.shape[$.rank-2],K=v?M.shape[M.rank-2]:M.shape[M.rank-1],nt=$.shape.slice(0,-2),ct=M.shape.slice(0,-2),dt=mn(nt),Ct=mn(ct);U($.rank>=2&&M.rank>=2&&$.rank===M.rank,function(){return"Error in fused matMul: inputs must have the same rank of at least "+("2, got ranks "+$.rank+" and "+M.rank+".")}),U(Rs(nt,ct),function(){return"Error in fused matMul: outer dimensions ("+nt+") and ("+(ct+") of Tensors with shapes "+$.shape+" and ")+(M.shape+" must match.")}),U(G===O,function(){return"Error in fused matMul: inner shapes ("+G+") and ("+(O+") of Tensors with shapes "+$.shape+" and ")+(M.shape+" and transposeA="+d)+(" and transposeB="+v+" must match.")});var St=$.shape.slice(0,-2).concat([H,K]),It=d?it($,[dt,G,H]):it($,[dt,H,G]),Gt=v?it(M,[Ct,K,O]):it(M,[Ct,O,K]),Et;w!=null&&(Et=W(w,"bias","fused matMul"),Et=pn(Et,$)[0],tn(St,Et.shape));var Wt;E!=null&&(Wt=W(E,"prelu weights","fused matMul"));var _t=function(gn,en){var dn=en[0],Zn=en[1],Or=en[2],Us=en[3],Ln=Hg(it(gn,Or.shape),Or,N),ms,Jt;if(!d&&!v?(ms=Ce(Ln,Zn,!1,!0),Jt=Ce(dn,Ln,!0,!1)):!d&&v?(ms=Ce(Ln,Zn,!1,!1),Jt=Ce(Ln,dn,!0,!1)):d&&!v?(ms=Ce(Zn,Ln,!1,!0),Jt=Ce(dn,Ln,!1,!1)):(ms=Ce(Zn,Ln,!0,!0),Jt=Ce(Ln,dn,!0,!0)),w!=null){var lp=qg(Us,Ln);return[ms,Jt,lp]}else return[ms,Jt]},Kt=function(gn){var en=gn.fusedBatchMatMul({a:It,b:Gt,transposeA:d,transposeB:v,bias:Et,activation:N,preluActivationWeights:Wt});return en},Ne={a:It,b:Gt,bias:Et,preluActivationWeights:Wt},ce={transposeA:d,transposeB:v,activation:N};if(w==null){var me=ho(function(gn,en,dn){var Zn=Z.runKernelFunc(Kt,Ne,null,PT,ce);return dn([gn,en,Zn]),{value:it(Zn,St),gradFunc:_t}});return me(It,Gt)}else{var Re=ho(function(gn,en,dn,Zn){var Or=Z.runKernelFunc(Kt,Ne,null,PT,ce);return Zn([gn,en,Or,dn]),{value:it(Or,St),gradFunc:_t}});return Re(It,Gt,Et)}}var xat=Y({fusedMatMul_:wat});var Tat={__proto__:null,conv2d:mat,depthwiseConv2d:bat,matMul:xat};function kat(o){return Wk(o,.54,.46)}var Sat=Y({hammingWindow_:kat});function Cat(o){return Wk(o,.5,.5)}var DF=Y({hannWindow_:Cat});function Nat(o,a,i,c,f){c===void 0&&(c=!1),f===void 0&&(f=0);for(var d=0,g=[];d+a<=o.size;)g.push(De(o,d,a)),d+=i;if(c)for(;d<o.size;){var v=d+a-o.size,w=qn([De(o,d,a-v),Tk([v],f)]);g.push(w),d+=i}return g.length===0?Zf([],[0,a]):it(qn(g),[g.length,a])}var $F=Y({frame_:Nat});function Iat(o,a,i,c,f){f===void 0&&(f=DF),c==null&&(c=NF(a));for(var d=$F(o,a,i),g=pt(d,f(a)),v=[],w=0;w<d.shape[0];w++)v.push(zg(De(g,[w,0],[1,a]),c));return qn(v)}var Eat=Y({stft_:Iat});function Dat(o,a,i,c,f,d){var g=W(o,"image","cropAndResize"),v=W(a,"boxes","cropAndResize","float32"),w=W(i,"boxInd","cropAndResize","int32");f=f||"bilinear",d=d||0;var T=v.shape[0];U(g.rank===4,function(){return"Error in cropAndResize: image must be rank 4,"+("but got rank "+g.rank+".")}),U(v.rank===2&&v.shape[1]===4,function(){return"Error in cropAndResize: boxes must be have size ["+T+",4] "+("but had shape "+v.shape+".")}),U(w.rank===1&&w.shape[0]===T,function(){return"Error in cropAndResize: boxInd must be have size ["+T+"] "+("but had shape "+v.shape+".")}),U(c.length===2,function(){return"Error in cropAndResize: cropSize must be of length 2, but got "+("length "+c.length+".")}),U(c[0]>=1&&c[1]>=1,function(){return"cropSize must be atleast [1,1], but was "+c}),U(f==="bilinear"||f==="nearest",function(){return"method must be bilinear or nearest, but was "+f});var N=function(M){return M.cropAndResize(g,v,w,c,f,d)},E={image:g,boxes:v,boxInd:w},k={method:f,extrapolationValue:d,cropSize:c},$=Z.runKernelFunc(N,E,null,E$,k);return $}var $at=Y({cropAndResize_:Dat});function Aat(o){var a=W(o,"image","flipLeftRight","float32");U(a.rank===4,function(){return"Error in flipLeftRight: image must be rank 4,"+("but got rank "+a.rank+".")});var i={image:a},c=Z.runKernel(B$,i,{});return c}var _at=Y({flipLeftRight_:Aat});function Fat(o,a,i,c){i===void 0&&(i=0),c===void 0&&(c=.5);var f=W(o,"image","rotateWithOffset","float32");U(f.rank===4,function(){return"Error in rotateWithOffset: image must be rank 4,"+("but got rank "+f.rank+".")});var d={image:f},g={radians:a,fillValue:i,center:c},v=Z.runKernel(gA,d,g);return v}var Rat=Y({rotateWithOffset_:Fat});function qc(o,a,i,c,f,d){c==null&&(c=.5),f==null&&(f=Number.NEGATIVE_INFINITY),d==null&&(d=0);var g=o.shape[0];return i=Math.min(i,g),U(0<=c&&c<=1,function(){return"iouThreshold must be in [0, 1], but was '"+c+"'"}),U(o.rank===2,function(){return"boxes must be a 2D tensor, but was of rank '"+o.rank+"'"}),U(o.shape[1]===4,function(){return"boxes must have 4 columns, but 2nd dimension was "+o.shape[1]}),U(a.rank===1,function(){return"scores must be a 1D tensor"}),U(a.shape[0]===g,function(){return"scores has incompatible shape with boxes. Expected "+g+", "+("but was "+a.shape[0])}),U(0<=d&&d<=1,function(){return"softNmsSigma must be in [0, 1], but was '"+d+"'"}),{maxOutputSize:i,iouThreshold:c,scoreThreshold:f,softNmsSigma:d}}function Pat(o,a,i,c,f){c===void 0&&(c=.5),f===void 0&&(f=Number.NEGATIVE_INFINITY);var d=W(o,"boxes","nonMaxSuppression"),g=W(a,"scores","nonMaxSuppression"),v=qc(d,g,i,c,f);i=v.maxOutputSize,c=v.iouThreshold,f=v.scoreThreshold;var w={maxOutputSize:i,iouThreshold:c,scoreThreshold:f};return Z.runKernelFunc(function(T){return T.nonMaxSuppression(d,g,i,c,f)},{boxes:d,scores:g},null,nA,w)}var Oat=Y({nonMaxSuppression_:Pat});function Lat(o,a,i){var c=Mat(o,a,i),f=c<0?-(c+1):c;o.splice(f,0,a)}function Mat(o,a,i){return zat(o,a,i||Bat)}function Bat(o,a){return o>a?1:o<a?-1:0}function zat(o,a,i){for(var c=0,f=o.length,d=0,g=!1;c<f;){d=c+(f-c>>>1);var v=i(a,o[d]);v>0?c=d+1:(f=d,g=!v)}return g?c:-c-1}function AF(o,a,i,c,f){return Uk(o,a,i,c,f,0).selectedIndices}function _F(o,a,i,c,f,d){return Uk(o,a,i,c,f,0,!1,d,!0)}function FF(o,a,i,c,f,d){return Uk(o,a,i,c,f,d,!0)}function Uk(o,a,i,c,f,d,g,v,w){g===void 0&&(g=!1),v===void 0&&(v=!1),w===void 0&&(w=!1);for(var T=[],N=0;N<a.length;N++)a[N]>f&&T.push({score:a[N],boxIndex:N,suppressBeginIndex:0});T.sort(RF);for(var E=d>0?-.5/d:0,k=[],$=[];k.length<i&&T.length>0;){var M=T.pop(),G=M.score,O=M.boxIndex,H=M.suppressBeginIndex;if(G<f)break;for(var K=!1,nt=k.length-1;nt>=H;--nt){var ct=Wat(o,O,k[nt]);if(ct>=c){K=!0;break}if(M.score=M.score*Vat(c,E,ct),M.score<=f)break}M.suppressBeginIndex=k.length,K||(M.score===G?(k.push(O),$.push(M.score)):M.score>f&&Lat(T,M,RF))}var dt=k.length,Ct=i-dt;v&&Ct>0&&(k.push.apply(k,new Array(Ct).fill(0)),$.push.apply($,new Array(Ct).fill(0)));var St={selectedIndices:Uc(k,"int32")};return g&&(St.selectedScores=Uc($,"float32")),w&&(St.validOutputs=ne(dt,"int32")),St}function Wat(o,a,i){var c=o.subarray(a*4,a*4+4),f=o.subarray(i*4,i*4+4),d=Math.min(c[0],c[2]),g=Math.min(c[1],c[3]),v=Math.max(c[0],c[2]),w=Math.max(c[1],c[3]),T=Math.min(f[0],f[2]),N=Math.min(f[1],f[3]),E=Math.max(f[0],f[2]),k=Math.max(f[1],f[3]),$=(v-d)*(w-g),M=(E-T)*(k-N);if($<=0||M<=0)return 0;var G=Math.max(d,T),O=Math.max(g,N),H=Math.min(v,E),K=Math.min(w,k),nt=Math.max(H-G,0)*Math.max(K-O,0);return nt/($+M-nt)}function Vat(o,a,i){var c=Math.exp(a*i*i);return i<=o?c:0}function RF(o,a){return o.score-a.score||o.score===a.score&&a.boxIndex-o.boxIndex}function Uat(o,a,i,c,f){return c===void 0&&(c=.5),f===void 0&&(f=Number.NEGATIVE_INFINITY),qt(this,void 0,void 0,function(){var d,g,v,w,T,N,E;return jt(this,function(k){switch(k.label){case 0:return d=W(o,"boxes","nonMaxSuppressionAsync"),g=W(a,"scores","nonMaxSuppressionAsync"),v=qc(d,g,i,c,f),i=v.maxOutputSize,c=v.iouThreshold,f=v.scoreThreshold,[4,Promise.all([d.data(),g.data()])];case 1:return w=k.sent(),T=w[0],N=w[1],E=AF(T,N,i,c,f),d!==o&&d.dispose(),g!==a&&g.dispose(),[2,E]}})})}var Gat=Uat;function Hat(o,a,i,c,f,d){c===void 0&&(c=.5),f===void 0&&(f=Number.NEGATIVE_INFINITY),d===void 0&&(d=0);var g=W(o,"boxes","nonMaxSuppression"),v=W(a,"scores","nonMaxSuppression"),w=qc(g,v,i,c,f,d);i=w.maxOutputSize,c=w.iouThreshold,f=w.scoreThreshold,d=w.softNmsSigma;var T={boxes:g,scores:v},N={maxOutputSize:i,iouThreshold:c,scoreThreshold:f,softNmsSigma:d},E=Z.runKernel(sA,T,N);return{selectedIndices:E[0],selectedScores:E[1]}}var qat=Y({nonMaxSuppressionWithScore_:Hat});function jat(o,a,i,c,f,d){return c===void 0&&(c=.5),f===void 0&&(f=Number.NEGATIVE_INFINITY),d===void 0&&(d=0),qt(this,void 0,void 0,function(){var g,v,w,T,N,E,k;return jt(this,function($){switch($.label){case 0:return g=W(o,"boxes","nonMaxSuppressionAsync"),v=W(a,"scores","nonMaxSuppressionAsync"),w=qc(g,v,i,c,f,d),i=w.maxOutputSize,c=w.iouThreshold,f=w.scoreThreshold,d=w.softNmsSigma,[4,Promise.all([g.data(),v.data()])];case 1:return T=$.sent(),N=T[0],E=T[1],k=FF(N,E,i,c,f,d),g!==o&&g.dispose(),v!==a&&v.dispose(),[2,k]}})})}var Kat=jat;function Xat(o,a,i,c,f,d){c===void 0&&(c=.5),f===void 0&&(f=Number.NEGATIVE_INFINITY),d===void 0&&(d=!1);var g=W(o,"boxes","nonMaxSuppression"),v=W(a,"scores","nonMaxSuppression"),w=qc(g,v,i,c,f,null),T=w.maxOutputSize,N=w.iouThreshold,E=w.scoreThreshold,k={boxes:g,scores:v},$={maxOutputSize:T,iouThreshold:N,scoreThreshold:E,padToMaxOutputSize:d},M=Z.runKernel(rA,k,$);return{selectedIndices:M[0],validOutputs:M[1]}}var Yat=Y({nonMaxSuppressionPadded_:Xat});function Jat(o,a,i,c,f,d){return c===void 0&&(c=.5),f===void 0&&(f=Number.NEGATIVE_INFINITY),d===void 0&&(d=!1),qt(this,void 0,void 0,function(){var g,v,w,T,N,E,k,$,M,G;return jt(this,function(O){switch(O.label){case 0:return g=W(o,"boxes","nonMaxSuppressionAsync"),v=W(a,"scores","nonMaxSuppressionAsync"),w=qc(g,v,i,c,f,null),T=w.maxOutputSize,N=w.iouThreshold,E=w.scoreThreshold,[4,Promise.all([g.data(),v.data()])];case 1:return k=O.sent(),$=k[0],M=k[1],G=_F($,M,T,N,E,d),g!==o&&g.dispose(),v!==a&&v.dispose(),[2,G]}})})}var Zat=Jat;function Qat(o,a,i){i===void 0&&(i=!1);var c=W(o,"images","resizeBilinear");U(c.rank===3||c.rank===4,function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got "+("rank "+c.rank+".")}),U(a.length===2,function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+(a+".")});var f=c,d=!1;c.rank===3&&(d=!0,f=it(c,[1,c.shape[0],c.shape[1],c.shape[2]]));var g=a[0],v=a[1],w=function(k,$){return $([f]),k.resizeBilinear(f,g,v,i)},T={images:f},N={alignCorners:i,size:a},E=Z.runKernelFunc(w,T,null,aT,N);return d?it(E,[E.shape[1],E.shape[2],E.shape[3]]):E}var PF=Y({resizeBilinear_:Qat});function tit(o,a,i){i===void 0&&(i=!1);var c=W(o,"images","resizeNearestNeighbor");U(c.rank===3||c.rank===4,function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+("rank "+c.rank+".")}),U(a.length===2,function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+(a+".")}),U(c.dtype==="float32"||c.dtype==="int32",function(){return"`images` must have `int32` or `float32` as dtype"});var f=c,d=!1;c.rank===3&&(d=!0,f=it(c,[1,c.shape[0],c.shape[1],c.shape[2]]));var g=a[0],v=a[1],w={images:f},T={alignCorners:i,size:a},N=function(k,$){return $([f]),k.resizeNearestNeighbor(f,g,v,i)},E=Z.runKernelFunc(N,w,null,oT,T);return d?it(E,[E.shape[1],E.shape[2],E.shape[3]]):E}var OF=Y({resizeNearestNeighbor_:tit});function eit(o,a,i){U(a%1===0,function(){return"bandPart(): numLower must be an integer, got "+a+"."}),U(i%1===0,function(){return"bandPart(): numUpper must be an integer, got "+i+"."});var c=W(o,"a","bandPart");U(c.rank>=2,function(){return"bandPart(): Rank must be at least 2, got "+c.rank+"."});var f=c.shape,d=c.shape.slice(-2),g=d[0],v=d[1];if(!(a<=g))throw new Error("bandPart(): numLower ("+a+")"+(" must not be greater than the number of rows ("+g+")."));if(!(i<=v))throw new Error("bandPart(): numUpper ("+i+")"+(" must not be greater than the number of columns ("+v+")."));a<0&&(a=g),i<0&&(i=v);var w=it(Rk(0,g,1,"int32"),[-1,1]),T=Rk(0,v,1,"int32"),N=Qt(w,T),E=Yi(ji(N,ne(+a,"int32")),qi(N,ne(-i,"int32"))),k=qo([g,v],c.dtype);return it(tu(Ug(it(c,[-1,g,v])).map(function($){return Ms(E,$,k)})),f)}var nit=Y({bandPart_:eit});function rit(o){var a;if(Array.isArray(o)){a=!1,U(o!=null&&o.length>0,function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"});for(var i=o[0].shape[0],c=function(w){U(o[w].shape[0]===i,function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: "+("("+o[w].shape[0]+" vs. "+i+")")})},f=1;f<o.length;++f)c(f)}else a=!0,o=Gc(o,o.shape[0],0).map(function(w){return Vg(w,[0])});U(o.length<=o[0].shape[0],function(){return"Gram-Schmidt: Number of vectors ("+o.length+") exceeds "+("number of dimensions ("+o[0].shape[0]+").")});for(var d=[],g=o,v=function(w){d.push(Z.tidy(function(){var T=g[w];if(w>0)for(var N=0;N<w;++N){var E=pt(ie(pt(d[N],T)),d[N]);T=Qt(T,E)}return ae(T,Gg(T,"euclidean"))}))},f=0;f<o.length;++f)v(f);return a?tu(d,0):d}var sit=Y({gramSchmidt_:rit});function oit(o,a){if(a===void 0&&(a=!1),U(o.rank>=2,function(){return"qr() requires input tensor to have a rank >= 2, but got rank "+o.rank}),o.rank===2)return MF(o,a);var i=o.shape.slice(0,o.shape.length-2).reduce(function(w,T){return w*T}),c=Ug(it(o,[i,o.shape[o.shape.length-2],o.shape[o.shape.length-1]]),0),f=[],d=[];c.forEach(function(w){var T=MF(w,a),N=T[0],E=T[1];f.push(N),d.push(E)});var g=it(tu(f,0),o.shape),v=it(tu(d,0),o.shape);return[g,v]}function MF(o,a){return a===void 0&&(a=!1),Z.tidy(function(){U(o.shape.length===2,function(){return"qr2d() requires a 2D Tensor, but got a "+o.shape.length+"D Tensor."});for(var i=o.shape[0],c=o.shape[1],f=O_(i),d=Ui(o),g=Zf([[1]],[1,1]),v=Ui(g),w=i>=c?c:i,T=function(E){var k,$=d,M=v,G=f;k=Z.tidy(function(){var O=De(d,[E,E],[i-E,1]),H=Gg(O),K=De(d,[E,E],[1,1]),nt=Ms(Ha(K,0),Zf([[-1]]),Zf([[1]])),ct=Qt(K,pt(nt,H)),dt=ae(O,ct);dt.shape[0]===1?v=Ui(g):v=qn([g,De(dt,[1,0],[dt.shape[0]-1,dt.shape[1]])],0);var Ct=$n(ae(Ce(nt,ct),H)),St=De(d,[E,0],[i-E,c]),It=pt(Ct,v),Gt=On(v);if(E===0)d=Qt(St,Ce(It,Ce(Gt,St)));else{var Et=Qt(St,Ce(It,Ce(Gt,St)));d=qn([De(d,[0,0],[E,c]),Et],0)}var Wt=On(It),_t=De(f,[0,E],[i,f.shape[1]-E]);if(E===0)f=Qt(_t,Ce(Ce(_t,v),Wt));else{var Kt=Qt(_t,Ce(Ce(_t,v),Wt));f=qn([De(f,[0,0],[i,E]),Kt],1)}return[v,d,f]}),v=k[0],d=k[1],f=k[2],wr([$,M,G])},N=0;N<w;++N)T(N);return!a&&i>c&&(f=De(f,[0,0],[i,c]),d=De(d,[0,0],[c,c])),[f,d]})}var ait=Y({qr_:oit});(function(o){o[o.NONE=0]="NONE",o[o.MEAN=1]="MEAN",o[o.SUM=2]="SUM",o[o.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(F.Reduction||(F.Reduction={}));function iit(o,a,i){i===void 0&&(i=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var c=W(o,"losses","computeWeightedLoss"),f=null;a!=null&&(f=W(a,"weights","computeWeightedLoss"));var d=f==null?c:pt(c,f);if(i===F.Reduction.NONE)return d;if(i===F.Reduction.SUM)return ie(d);if(i===F.Reduction.MEAN){if(f==null)return Kf(d);var g=c.size/f.size,v=ae(ie(d),ie(f));return g>1?ae(v,ne(g)):v}if(i===F.Reduction.SUM_BY_NONZERO_WEIGHTS){if(f==null)return ae(ie(d),ne(c.size));var w=pt(f,Wc(c.shape)),T=Bt(ie(Mg(w,ne(0))),"float32");return ae(ie(d),T)}throw Error("Unknown reduction: "+i)}var Xo=Y({computeWeightedLoss_:iit});function uit(o,a,i,c){c===void 0&&(c=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var f=W(o,"labels","absoluteDifference"),d=W(a,"predictions","absoluteDifference"),g=null;i!=null&&(g=W(i,"weights","absoluteDifference")),Ee(f.shape,d.shape,"Error in absoluteDifference: ");var v=_r(Qt(f,d));return Xo(v,g,c)}var cit=Y({absoluteDifference_:uit});function lit(o,a,i,c,f){f===void 0&&(f=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var d=W(o,"labels","cosineDistance"),g=W(a,"predictions","cosineDistance"),v=null;c!=null&&(v=W(c,"weights","cosineDistance")),Ee(d.shape,g.shape,"Error in cosineDistance: ");var w=ne(1),T=Qt(w,ie(pt(d,g),i,!0));return Xo(T,v,f)}var hit=Y({cosineDistance_:lit});function fit(o,a,i,c){c===void 0&&(c=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var f=W(o,"labels","hingeLoss"),d=W(a,"predictions","hingeLoss"),g=null;i!=null&&(g=W(i,"weights","hingeLoss")),Ee(f.shape,d.shape,"Error in hingeLoss: ");var v=ne(1);f=Qt(pt(ne(2),f),v);var w=Yf(Qt(v,pt(f,d)));return Xo(w,g,c)}var pit=Y({hingeLoss_:fit});function dit(o,a,i,c,f){c===void 0&&(c=1),f===void 0&&(f=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var d=W(o,"labels","huberLoss"),g=W(a,"predictions","huberLoss"),v=null;i!=null&&(v=W(i,"weights","huberLoss")),Ee(d.shape,g.shape,"Error in huberLoss: ");var w=ne(c),T=_r(Qt(g,d)),N=Og(T,w),E=Qt(T,N),k=Yt(pt(ne(.5),Ue(N)),pt(w,E));return Xo(k,v,f)}var mit=Y({huberLoss_:dit});function git(o,a,i,c,f){c===void 0&&(c=1e-7),f===void 0&&(f=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var d=W(o,"labels","logLoss"),g=W(a,"predictions","logLoss"),v=null;i!=null&&(v=W(i,"weights","logLoss")),Ee(d.shape,g.shape,"Error in logLoss: ");var w=ne(1),T=ne(c),N=$n(pt(d,Ki(Yt(g,T)))),E=pt(Qt(w,d),Ki(Yt(Qt(w,g),T))),k=Qt(N,E);return Xo(k,v,f)}var vit=Y({logLoss_:git});function yit(o,a,i,c){c===void 0&&(c=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var f=W(o,"labels","meanSquaredError"),d=W(a,"predictions","meanSquaredError"),g=null;i!=null&&(g=W(i,"weights","meanSquaredError")),Ee(f.shape,d.shape,"Error in meanSquaredError: ");var v=Wg(f,d);return Xo(v,g,c)}var bit=Y({meanSquaredError_:yit});function wit(o,a){var i=W(o,"labels","sigmoidCrossEntropyWithLogits"),c=W(a,"logits","sigmoidCrossEntropyWithLogits");Ee(i.shape,c.shape,"Error in sigmoidCrossEntropyWithLogits: ");var f=Yf(c),d=pt(c,i),g=Sk(Ls($n(_r(c))));return Yt(Qt(f,d),g)}function xit(o,a,i,c,f){c===void 0&&(c=0),f===void 0&&(f=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var d=W(o,"multiClassLabels","sigmoidCrossEntropy"),g=W(a,"logits","sigmoidCrossEntropy"),v=null;if(i!=null&&(v=W(i,"weights","sigmoidCrossEntropy")),Ee(d.shape,g.shape,"Error in sigmoidCrossEntropy: "),c>0){var w=ne(c),T=ne(1),N=ne(.5);d=Yt(pt(d,Qt(T,w)),pt(N,w))}var E=wit(d,g);return Xo(E,v,f)}var Tit=Y({sigmoidCrossEntropy_:xit});function kit(o,a,i){if(i===void 0&&(i=-1),i===-1&&(i=a.rank-1),i!==a.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+("supported. Labels / logits was rank "+a.rank+" ")+("and dim was "+i));var c=ho(function(f,d,g){var v=!0,w=Nk(d,[i],v),T=Qt(Bt(d,"float32"),w);g([f,T]);var N=$n(pt(T,f)),E=ie(N,[i]),k=function($,M){var G=M[0],O=M[1],H=Jr($.shape,[i]);return[pt(it($,H),Qt(Bt(G,"float32"),Ls(O))),pt(it($,H),Qt(Ls(O),Bt(G,"float32")))]};return{value:E,gradFunc:k}});return c(o,a)}function Sit(o,a,i,c,f){c===void 0&&(c=0),f===void 0&&(f=F.Reduction.SUM_BY_NONZERO_WEIGHTS);var d=W(o,"onehotLabels","softmaxCrossEntropy"),g=W(a,"logits","softmaxCrossEntropy"),v=null;if(i!=null&&(v=W(i,"weights","softmaxCrossEntropy")),Ee(d.shape,g.shape,"Error in softmaxCrossEntropy: "),c>0){var w=ne(c),T=ne(1),N=ne(d.shape[1]);d=Yt(pt(d,Qt(T,w)),ae(w,N))}var E=kit(d,g);return Xo(E,v,f)}var Cit=Y({softmaxCrossEntropy_:Sit});var Nit={fft:Bg,ifft:Jf,rfft:zg,irfft:Bk},Iit={hammingWindow:Sat,hannWindow:DF,frame:$F,stft:Eat},Eit={flipLeftRight:_at,resizeNearestNeighbor:OF,resizeBilinear:PF,rotateWithOffset:Rat,cropAndResize:$at,nonMaxSuppression:Oat,nonMaxSuppressionAsync:Gat,nonMaxSuppressionWithScore:qat,nonMaxSuppressionWithScoreAsync:Kat,nonMaxSuppressionPadded:Yat,nonMaxSuppressionPaddedAsync:Zat},Dit={bandPart:nit,gramSchmidt:sit,qr:ait},$it={absoluteDifference:cit,computeWeightedLoss:Xo,cosineDistance:hit,hingeLoss:pit,huberLoss:mit,logLoss:vit,meanSquaredError:bit,sigmoidCrossEntropy:Tit,softmaxCrossEntropy:Cit};var qa=function(o){Uo(a,o);function a(){return o!==null&&o.apply(this,arguments)||this}return a.prototype.minimize=function(i,c,f){c===void 0&&(c=!1);var d=this.computeGradients(i,f),g=d.value,v=d.grads;if(f!=null){var w=f.map(function(T){return{name:T.name,tensor:v[T.name]}});this.applyGradients(w)}else this.applyGradients(v);return wr(v),c?g:(g.dispose(),null)},Object.defineProperty(a.prototype,"iterations",{get:function(){return this.iterations_==null&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),a.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},a.prototype.computeGradients=function(i,c){return U_(i,c)},a.prototype.dispose=function(){this.iterations_!=null&&wr(this.iterations_)},a.prototype.saveIterations=function(){return qt(this,void 0,void 0,function(){return jt(this,function(i){return this.iterations_==null&&(this.iterations_=0),[2,{name:"iter",tensor:ne(this.iterations_,"int32")}]})})},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){return jt(this,function(i){throw new Error("getWeights() is not implemented for this optimizer yet.")})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){return jt(this,function(c){throw new Error("setWeights() is not implemented for this optimizer class "+(""+this.getClassName()))})})},a.prototype.extractIterations=function(i){return qt(this,void 0,void 0,function(){var c;return jt(this,function(f){switch(f.label){case 0:return c=this,[4,i[0].tensor.data()];case 1:return c.iterations_=f.sent()[0],[2,i.slice(1)]}})})},a}(a_);Object.defineProperty(qa,Symbol.hasInstance,{value:function(o){return o.minimize!=null&&o.computeGradients!=null&&o.applyGradients!=null}});var Gk=function(o){Uo(a,o);function a(i,c,f){f===void 0&&(f=null);var d=o.call(this)||this;return d.learningRate=i,d.rho=c,d.epsilon=f,d.accumulatedGrads=[],d.accumulatedUpdates=[],f==null&&(d.epsilon=Z.backend.epsilon()),d}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);f.forEach(function(d,g){var v=Z.registeredVariables[d],w=!1;c.accumulatedGrads[g]==null&&(c.accumulatedGrads[g]={originalName:d+"/accum_grad",variable:En(function(){return ke(v).variable(w)})}),c.accumulatedUpdates[g]==null&&(c.accumulatedUpdates[g]={originalName:d+"/accum_var",variable:En(function(){return ke(v).variable(w)})});var T=Array.isArray(i)?i[g].tensor:i[d];if(T==null)return;var N=c.accumulatedGrads[g].variable,E=c.accumulatedUpdates[g].variable;En(function(){var k=Yt(pt(N,c.rho),pt(Ue(T),1-c.rho)),$=pt(ae(Tr(Yt(E,c.epsilon)),Tr(Yt(N,c.epsilon))),T),M=Yt(pt(E,c.rho),pt(Ue($),1-c.rho));N.assign(k),E.assign(M);var G=Yt(pt($,-c.learningRate),v);v.assign(G)})}),this.incrementIterations()},a.prototype.dispose=function(){this.accumulatedUpdates!=null&&(wr(this.accumulatedGrads.map(function(i){return i.variable})),wr(this.accumulatedUpdates.map(function(i){return i.variable})))},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){var i;return jt(this,function(c){switch(c.label){case 0:return i=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[c.sent()].concat(i.map(function(f){return{name:f.originalName,tensor:f.variable}}))]}})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){var c,f;return jt(this,function(d){switch(d.label){case 0:return[4,this.extractIterations(i)];case 1:return i=d.sent(),c=i.length/2,f=!1,this.accumulatedGrads=i.slice(0,c).map(function(g){return{originalName:g.name,variable:g.tensor.variable(f)}}),this.accumulatedUpdates=i.slice(c,c*2).map(function(g){return{originalName:g.name,variable:g.tensor.variable(f)}}),[2]}})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},a.fromConfig=function(i,c){return new i(c.learningRate,c.rho,c.epsilon)},a.className="Adadelta",a}(qa);Ua(Gk);var Hk=function(o){Uo(a,o);function a(i,c){c===void 0&&(c=.1);var f=o.call(this)||this;return f.learningRate=i,f.initialAccumulatorValue=c,f.accumulatedGrads=[],f}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);f.forEach(function(d,g){var v=Z.registeredVariables[d];if(c.accumulatedGrads[g]==null){var w=!1;c.accumulatedGrads[g]={originalName:d+"/accumulator",variable:En(function(){return Tk(v.shape,c.initialAccumulatorValue).variable(w)})}}var T=Array.isArray(i)?i[g].tensor:i[d];if(T==null)return;var N=c.accumulatedGrads[g].variable;En(function(){var E=Yt(N,Ue(T));N.assign(E);var k=Yt(pt(ae(T,Tr(Yt(E,Z.backend.epsilon()))),-c.learningRate),v);v.assign(k)})}),this.incrementIterations()},a.prototype.dispose=function(){this.accumulatedGrads!=null&&wr(this.accumulatedGrads.map(function(i){return i.variable}))},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){return jt(this,function(i){switch(i.label){case 0:return[4,this.saveIterations()];case 1:return[2,[i.sent()].concat(this.accumulatedGrads.map(function(c){return{name:c.originalName,tensor:c.variable}}))]}})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){var c;return jt(this,function(f){switch(f.label){case 0:return[4,this.extractIterations(i)];case 1:return i=f.sent(),c=!1,this.accumulatedGrads=i.map(function(d){return{originalName:d.name,variable:d.tensor.variable(c)}}),[2]}})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},a.fromConfig=function(i,c){return new i(c.learningRate,c.initialAccumulatorValue)},a.className="Adagrad",a}(qa);Ua(Hk);var qk=function(o){Uo(a,o);function a(i,c,f,d){d===void 0&&(d=null);var g=o.call(this)||this;return g.learningRate=i,g.beta1=c,g.beta2=f,g.epsilon=d,g.accumulatedFirstMoment=[],g.accumulatedSecondMoment=[],En(function(){g.accBeta1=ne(c).variable(),g.accBeta2=ne(f).variable()}),d==null&&(g.epsilon=Z.backend.epsilon()),g}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);En(function(){var d=Qt(1,c.accBeta1),g=Qt(1,c.accBeta2);f.forEach(function(v,w){var T=Z.registeredVariables[v],N=!1;c.accumulatedFirstMoment[w]==null&&(c.accumulatedFirstMoment[w]={originalName:v+"/m",variable:En(function(){return ke(T).variable(N)})}),c.accumulatedSecondMoment[w]==null&&(c.accumulatedSecondMoment[w]={originalName:v+"/v",variable:En(function(){return ke(T).variable(N)})});var E=Array.isArray(i)?i[w].tensor:i[v];if(E==null)return;var k=c.accumulatedFirstMoment[w].variable,$=c.accumulatedSecondMoment[w].variable,M=Yt(pt(k,c.beta1),pt(E,1-c.beta1)),G=Yt(pt($,c.beta2),pt(Ue(E),1-c.beta2)),O=ae(M,d),H=ae(G,g);k.assign(M),$.assign(G);var K=Yt(pt(ae(O,Yt(Tr(H),c.epsilon)),-c.learningRate),T);T.assign(K)}),c.accBeta1.assign(pt(c.accBeta1,c.beta1)),c.accBeta2.assign(pt(c.accBeta2,c.beta2))}),this.incrementIterations()},a.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&wr(this.accumulatedFirstMoment.map(function(i){return i.variable})),this.accumulatedSecondMoment!=null&&wr(this.accumulatedSecondMoment.map(function(i){return i.variable}))},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){var i;return jt(this,function(c){switch(c.label){case 0:return i=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[c.sent()].concat(i.map(function(f){return{name:f.originalName,tensor:f.variable}}))]}})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){var c,f,d=this;return jt(this,function(g){switch(g.label){case 0:return[4,this.extractIterations(i)];case 1:return i=g.sent(),En(function(){d.accBeta1.assign(jo(d.beta1,d.iterations_+1)),d.accBeta2.assign(jo(d.beta2,d.iterations_+1))}),c=i.length/2,f=!1,this.accumulatedFirstMoment=i.slice(0,c).map(function(v){return{originalName:v.name,variable:v.tensor.variable(f)}}),this.accumulatedSecondMoment=i.slice(c,c*2).map(function(v){return{originalName:v.name,variable:v.tensor.variable(f)}}),[2]}})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},a.fromConfig=function(i,c){return new i(c.learningRate,c.beta1,c.beta2,c.epsilon)},a.className="Adam",a}(qa);Ua(qk);var jk=function(o){Uo(a,o);function a(i,c,f,d,g){d===void 0&&(d=null),g===void 0&&(g=0);var v=o.call(this)||this;return v.learningRate=i,v.beta1=c,v.beta2=f,v.epsilon=d,v.decay=g,v.accumulatedFirstMoment=[],v.accumulatedWeightedInfNorm=[],En(function(){v.iteration=ne(0).variable(),v.accBeta1=ne(c).variable()}),d==null&&(v.epsilon=Z.backend.epsilon()),v}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);En(function(){var d=Qt(1,c.accBeta1),g=ae(-c.learningRate,Yt(pt(c.iteration,c.decay),1));f.forEach(function(v,w){var T=Z.registeredVariables[v],N=!1;c.accumulatedFirstMoment[w]==null&&(c.accumulatedFirstMoment[w]={originalName:v+"/m",variable:ke(T).variable(N)}),c.accumulatedWeightedInfNorm[w]==null&&(c.accumulatedWeightedInfNorm[w]={originalName:v+"/v",variable:ke(T).variable(N)});var E=Array.isArray(i)?i[w].tensor:i[v];if(E==null)return;var k=c.accumulatedFirstMoment[w].variable,$=c.accumulatedWeightedInfNorm[w].variable,M=Yt(pt(k,c.beta1),pt(E,1-c.beta1)),G=pt($,c.beta2),O=_r(E),H=zc(G,O);k.assign(M),$.assign(H);var K=Yt(pt(ae(g,d),ae(M,Yt(H,c.epsilon))),T);T.assign(K)}),c.iteration.assign(Yt(c.iteration,1)),c.accBeta1.assign(pt(c.accBeta1,c.beta1))}),this.incrementIterations()},a.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&wr(this.accumulatedFirstMoment.map(function(i){return i.variable})),this.accumulatedWeightedInfNorm!=null&&wr(this.accumulatedWeightedInfNorm.map(function(i){return i.variable}))},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){return jt(this,function(i){throw new Error("getWeights() is not implemented for Adamax yet.")})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){return jt(this,function(c){throw new Error("setWeights() is not implemented for Adamax yet.")})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},a.fromConfig=function(i,c){return new i(c.learningRate,c.beta1,c.beta2,c.epsilon,c.decay)},a.className="Adamax",a}(qa);Ua(jk);var Xg=function(o){Uo(a,o);function a(i){var c=o.call(this)||this;return c.learningRate=i,c.setLearningRate(i),c}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);f.forEach(function(d,g){var v=Array.isArray(i)?i[g].tensor:i[d];if(v==null)return;var w=Z.registeredVariables[d];En(function(){var T=Yt(pt(c.c,v),w);w.assign(T)})}),this.incrementIterations()},a.prototype.setLearningRate=function(i){this.learningRate=i,this.c!=null&&this.c.dispose(),this.c=c_(ne(-i))},a.prototype.dispose=function(){this.c.dispose()},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){return jt(this,function(i){switch(i.label){case 0:return[4,this.saveIterations()];case 1:return[2,[i.sent()]]}})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){return jt(this,function(c){switch(c.label){case 0:return[4,this.extractIterations(i)];case 1:if(i=c.sent(),i.length!==0)throw new Error("SGD optimizer does not have settable weights.");return[2]}})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate}},a.fromConfig=function(i,c){return new i(c.learningRate)},a.className="SGD",a}(qa);Ua(Xg);var Kk=function(o){Uo(a,o);function a(i,c,f){f===void 0&&(f=!1);var d=o.call(this,i)||this;return d.learningRate=i,d.momentum=c,d.useNesterov=f,d.accumulations=[],d.m=ne(d.momentum),d}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);f.forEach(function(d,g){var v=Z.registeredVariables[d];if(c.accumulations[g]==null){var w=!1;c.accumulations[g]={originalName:d+"/momentum",variable:En(function(){return ke(v).variable(w)})}}var T=c.accumulations[g].variable,N=Array.isArray(i)?i[g].tensor:i[d];if(N==null)return;En(function(){var E,k=Yt(pt(c.m,T),N);c.useNesterov?E=Yt(pt(c.c,Yt(N,pt(k,c.m))),v):E=Yt(pt(c.c,k),v),T.assign(k),v.assign(E)})}),this.incrementIterations()},a.prototype.dispose=function(){this.m.dispose(),this.accumulations!=null&&wr(this.accumulations.map(function(i){return i.variable}))},a.prototype.setMomentum=function(i){this.momentum=i},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){return jt(this,function(i){switch(i.label){case 0:return[4,this.saveIterations()];case 1:return[2,[i.sent()].concat(this.accumulations.map(function(c){return{name:c.originalName,tensor:c.variable}}))]}})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){var c;return jt(this,function(f){switch(f.label){case 0:return[4,this.extractIterations(i)];case 1:return i=f.sent(),c=!1,this.accumulations=i.map(function(d){return{originalName:d.name,variable:d.tensor.variable(c)}}),[2]}})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},a.fromConfig=function(i,c){return new i(c.learningRate,c.momentum,c.useNesterov)},a.className="Momentum",a}(Xg);Ua(Kk);var Xk=function(o){Uo(a,o);function a(i,c,f,d,g){c===void 0&&(c=.9),f===void 0&&(f=0),d===void 0&&(d=null),g===void 0&&(g=!1);var v=o.call(this)||this;if(v.learningRate=i,v.decay=c,v.momentum=f,v.epsilon=d,v.accumulatedMeanSquares=[],v.accumulatedMoments=[],v.accumulatedMeanGrads=[],v.centered=g,d==null&&(v.epsilon=Z.backend.epsilon()),i==null)throw new Error("learningRate for RMSPropOptimizer must be defined.");return v}return a.prototype.applyGradients=function(i){var c=this,f=Array.isArray(i)?i.map(function(d){return d.name}):Object.keys(i);f.forEach(function(d,g){var v=Z.registeredVariables[d],w=!1;c.accumulatedMeanSquares[g]==null&&(c.accumulatedMeanSquares[g]={originalName:d+"/rms",variable:En(function(){return ke(v).variable(w)})}),c.accumulatedMoments[g]==null&&(c.accumulatedMoments[g]={originalName:d+"/momentum",variable:En(function(){return ke(v).variable(w)})}),c.accumulatedMeanGrads[g]==null&&c.centered&&(c.accumulatedMeanGrads[g]={originalName:d+"/mg",variable:En(function(){return ke(v).variable(w)})});var T=Array.isArray(i)?i[g].tensor:i[d];if(T==null)return;var N=c.accumulatedMeanSquares[g].variable,E=c.accumulatedMoments[g].variable;En(function(){var k=Yt(pt(N,c.decay),pt(Ue(T),1-c.decay));if(c.centered){var $=c.accumulatedMeanGrads[g].variable,M=Yt(pt($,c.decay),pt(T,1-c.decay)),G=ae(pt(T,c.learningRate),Tr(Qt(k,Yt(Ue(M),c.epsilon)))),O=Yt(pt(E,c.momentum),G);N.assign(k),$.assign(M),E.assign(O);var H=Qt(v,O);v.assign(H)}else{var K=Yt(pt(N,c.decay),pt(Ue(T),1-c.decay)),O=Yt(pt(E,c.momentum),ae(pt(T,c.learningRate),Tr(Yt(K,c.epsilon))));N.assign(K),E.assign(O);var H=Qt(v,O);v.assign(H)}})}),this.incrementIterations()},a.prototype.dispose=function(){this.accumulatedMeanSquares!=null&&wr(this.accumulatedMeanSquares.map(function(i){return i.variable})),this.accumulatedMeanGrads!=null&&this.centered&&wr(this.accumulatedMeanGrads.map(function(i){return i.variable})),this.accumulatedMoments!=null&&wr(this.accumulatedMoments.map(function(i){return i.variable}))},a.prototype.getWeights=function(){return qt(this,void 0,void 0,function(){var i;return jt(this,function(c){switch(c.label){case 0:return i=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&i.push.apply(i,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[c.sent()].concat(i.map(function(f){return{name:f.originalName,tensor:f.variable}}))]}})})},a.prototype.setWeights=function(i){return qt(this,void 0,void 0,function(){var c,f;return jt(this,function(d){switch(d.label){case 0:return[4,this.extractIterations(i)];case 1:return i=d.sent(),c=this.centered?i.length/3:i.length/2,f=!1,this.accumulatedMeanSquares=i.slice(0,c).map(function(g){return{originalName:g.name,variable:g.tensor.variable(f)}}),this.accumulatedMoments=i.slice(c,c*2).map(function(g){return{originalName:g.name,variable:g.tensor.variable(f)}}),this.centered&&(this.accumulatedMeanGrads=i.slice(c*2,c*3).map(function(g){return{originalName:g.name,variable:g.tensor.variable(f)}})),[2]}})})},a.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},a.fromConfig=function(i,c){return new i(c.learningRate,c.decay,c.momentum,c.epsilon,c.centered)},a.className="RMSProp",a}(qa);Ua(Xk);var eu=function(){function o(){}return o.sgd=function(a){return new Xg(a)},o.momentum=function(a,i,c){return c===void 0&&(c=!1),new Kk(a,i,c)},o.rmsprop=function(a,i,c,f,d){return i===void 0&&(i=.9),c===void 0&&(c=0),f===void 0&&(f=null),d===void 0&&(d=!1),new Xk(a,i,c,f,d)},o.adam=function(a,i,c,f){return a===void 0&&(a=.001),i===void 0&&(i=.9),c===void 0&&(c=.999),f===void 0&&(f=null),new qk(a,i,c,f)},o.adadelta=function(a,i,c){return a===void 0&&(a=.001),i===void 0&&(i=.95),c===void 0&&(c=null),new Gk(a,i,c)},o.adamax=function(a,i,c,f,d){return a===void 0&&(a=.002),i===void 0&&(i=.9),c===void 0&&(c=.999),f===void 0&&(f=null),d===void 0&&(d=0),new jk(a,i,c,f,d)},o.adagrad=function(a,i){return i===void 0&&(i=.1),new Hk(a,i)},o}();var Ait={sgd:eu.sgd,momentum:eu.momentum,adadelta:eu.adadelta,adagrad:eu.adagrad,rmsprop:eu.rmsprop,adamax:eu.adamax,adam:eu.adam};var _it=function(){return typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:function(o){return o()}}();function Fit(){return new Promise(function(o){return _it(function(){return o()})})}function Rit(o,a,i){var c=i*(typeof o=="number"?o:o[0]),f=a*(typeof o=="number"?o:o[1]);return[c,f]}function Pit(o,a,i,c){c===void 0&&(c=!0);var f=[];if(c)f=f.concat(a.slice(0)),f.push(o[0]/i),f=f.concat(o.slice(1));else{f=f.concat(o[0]);for(var d=a.length,g=0;g<d;++g)f=f.concat([o[g+1]/a[g],a[g]]);f=f.concat(o.slice(d+1))}return f}function Oit(o,a,i){i===void 0&&(i=!0);var c=[];if(i){c.push(a);for(var f=a+1;f<o;++f)f<=2*a?(c.push(f),c.push(f-(a+1))):c.push(f)}else{for(var d=[],g=[],f=1;f<o;++f)f>=a*2+1||f%2===1?g.push(f):d.push(f);c.push.apply(c,d),c.push(0),c.push.apply(c,g)}return c}function Mit(o,a,i,c){c===void 0&&(c=!0);var f=[];c?f.push(o[0]/i):f.push(o[0]*i);for(var d=1;d<o.length;++d)d<=a.length?c?f.push(a[d-1]*o[d]):f.push(o[d]/a[d-1]):f.push(o[d]);return f}function Lit(o,a){for(var i=[0],c=0;c<a;++c)i.push(o[c][0]);return i}function Bit(o,a,i){for(var c=o.slice(0,1),f=0;f<i;++f)c.push(o[f+1]-a[f][0]-a[f][1]);return c}var LF=1.7580993408473768,BF=1.0507009873554805;var zit=.3275911,Wit=.254829592,Vit=-.284496736,Uit=1.421413741,Git=-1.453152027,Hit=1.061405429;function qit(){for(var o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];Fe().getBool("IS_TEST")||console.warn.apply(console,o)}function jit(){for(var o=[],a=0;a<arguments.length;a++)o[a]=arguments[a];Fe().getBool("IS_TEST")||console.log.apply(console,o)}function Kit(o,a){if(o.length!==a.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+(o.length+", imag: "+a.length+"."));for(var i=new Float32Array(o.length*2),c=0;c<i.length;c+=2)i[c]=o[c/2],i[c+1]=a[c/2];return i}function Xit(o){for(var a=new Float32Array(o.length/2),i=new Float32Array(o.length/2),c=0;c<o.length;c+=2)a[c/2]=o[c],i[c/2]=o[c+1];return{real:a,imag:i}}function Yit(o){for(var a=Math.ceil(o.length/4),i=new Float32Array(a),c=new Float32Array(a),f=0;f<o.length;f+=4)i[Math.floor(f/4)]=o[f],c[Math.floor(f/4)]=o[f+1];return{real:i,imag:c}}function Jit(o){for(var a=Math.floor(o.length/4),i=new Float32Array(a),c=new Float32Array(a),f=2;f<o.length;f+=4)i[Math.floor(f/4)]=o[f],c[Math.floor(f/4)]=o[f+1];return{real:i,imag:c}}function Zit(o,a){var i=o[a*2],c=o[a*2+1];return{real:i,imag:c}}function Qit(o,a,i,c){o[c*2]=a,o[c*2+1]=i}function tut(o,a){for(var i=new Float32Array(o/2),c=new Float32Array(o/2),f=0;f<Math.ceil(o/2);f++){var d=(a?2:-2)*Math.PI*(f/o);i[f]=Math.cos(d),c[f]=Math.sin(d)}return{real:i,imag:c}}function eut(o,a,i){var c=(i?2:-2)*Math.PI*(o/a),f=Math.cos(c),d=Math.sin(c);return{real:f,imag:d}}function nut(o,a,i){if(a==="complex64"){if(o.dtype==="complex64")return o.clone();var c=qo(o.shape),f=Bt(o,"float32"),d=i.complex(f,c);return c.dispose(),f.dispose(),d}if(!l$(o.dtype,a))return Z.makeTensorFromDataId(o.dataId,o.shape,a);if(o.dtype==="complex64"){var g=i.real(o),d=Bt(g,a);return g.dispose(),d}if(a==="int32")return i.int(o);if(a==="bool"){var v=ne(0,o.dtype),d=i.notEqual(o,v);return v.dispose(),d}else throw new Error("Error in Cast: failed to cast "+o.dtype+" to "+a)}function rut(o,a){return Z.makeTensorFromDataId(o.dataId,a,o.dtype)}function sut(o,a,i){var c=(a-o)/(i-1),f=Ec(i,"float32");f[0]=o;for(var d=1;d<f.length;d++)f[d]=f[d-1]+c;return Uc(f,"float32")}var out={__proto__:null,slice_util:o_,segment_util:srt,castTensor:nut,reshapeTensor:rut,linspaceImpl:sut,upcastType:vg,axesAreInnerMostDims:dk,combineLocations:f_,computeOutAndReduceShapes:p_,expandShapeToKeepDim:Jr,assertAxesAreInnerMostDims:Ret,getAxesPermutation:Ps,getUndoAxesPermutation:Tg,getInnerMostAxes:lo,getBroadcastDims:Wnt,getReductionAxes:Dn,assertAndGetBroadcastShape:tn,assertParamsConsistent:k_,computeOutShape:S_,computeDilation2DInfo:Get,computePool2DInfo:Oc,computePool3DInfo:Gf,computeConv2DInfo:Os,computeConv3DInfo:Uf,computeDefaultPad:gk,tupleValuesAreOne:Ga,eitherStridesOrDilationsAreOne:xr,convertConv2DDataFormat:Vf,getFusedDyActivation:Hg,getFusedBiasGradient:qg,applyActivation:jg,shouldFuse:Kg,PARALLELIZE_THRESHOLD:kk,computeOptimalWindowSize:ert,getImageCenter:Rit,getReshaped:Pit,getPermuted:Oit,getReshapedPermuted:Mit,getSliceBeginCoords:Lit,getSliceSize:Bit,prepareAndValidate:qA,validateUpdateShape:ik,validateInput:uk,calculateShapes:jA,SELU_SCALEALPHA:LF,SELU_SCALE:BF,ERF_P:zit,ERF_A1:Wit,ERF_A2:Vit,ERF_A3:Uit,ERF_A4:Git,ERF_A5:Hit,warn:qit,log:jit,mergeRealAndImagArrays:Kit,splitRealAndImagArrays:Xit,complexWithEvenIndex:Yit,complexWithOddIndex:Jit,getComplexWithIndex:Zit,assignToTypedArray:Qit,exponents:tut,exponent:eut,prepareSplitSize:rF};function aut(o,a,i){var c=new Array(o.rank).fill(0),f=o.shape.slice();return a.map(function(d){var g=f.slice();g[i]=d;var v=De(o,c,g);return c[i]+=d,v})}function iut(o,a){for(var i=new Array(o.rank),c=0;c<i.length;c++)i[c]=o.shape[c]*a[c];for(var f=co(i,o.dtype),c=0;c<f.values.length;++c){for(var d=f.indexToLoc(c),g=new Array(o.rank),v=0;v<g.length;v++)g[v]=d[v]%o.shape[v];var w=o.locToIndex(g);f.values[c]=o.values[w]}return f.toTensor()}function uut(o,a,i,c,f){for(var d=a[a.length-1],g=[o.length/d,d],v=g[0],w=g[1],T=ug(i,v*c),N=ug("int32",v*c),E=0;E<v;E++){for(var k=E*w,$=o.subarray(k,k+w),M=[],G=0;G<$.length;G++)M.push({value:$[G],index:G});M.sort(function(ct,dt){return dt.value-ct.value});for(var O=E*c,H=T.subarray(O,O+c),K=N.subarray(O,O+c),G=0;G<c;G++)H[G]=M[G].value,K[G]=M[G].index}var nt=a.slice();return nt[nt.length-1]=c,[za(T,nt,i),za(N,nt,"int32")]}var cut={__proto__:null,nonMaxSuppressionV3Impl:AF,nonMaxSuppressionV4Impl:_F,nonMaxSuppressionV5Impl:FF,split:aut,tile:iut,topkImpl:uut,whereImpl:uF};var lut={kernelName:Yx,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,Hc(Bt(i,"float32"),-1))}}}};var hut={kernelName:Jx,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){var c=Ue(Bt(i,"float32")),f=Tr(Qt(ne(1),c));return $n(ae(o,f))}}}};var fut={kernelName:Zx,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){var c=Tr(Qt(Ue(Bt(i,"float32")),1));return ae(o,c)}}}};var put={kernelName:hg,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=o,w=Dn(i.shape,f);return w.length>0&&(v=ie(v,w)),it(v,i.shape)},g=function(){var v=o,w=Dn(c.shape,f);return w.length>0&&(v=ie(v,w)),it(v,c.shape)};return{a:d,b:g}}};var dut={kernelName:Qx,saveAllInputs:!0,gradFunc:function(o,a){var i={};return a.forEach(function(c,f){i[f]=function(){return o.clone()}}),i}};var mut={kernelName:t1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ke(i)}}}};var gut={kernelName:e1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ke(i)}}}};var vut={kernelName:n1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,Tr(Qt(ne(1),Ue(Bt(i,"float32")))))}}}};var yut={kernelName:r1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){var c=Tr(Yt(ne(1),Ue(Bt(i,"float32"))));return ae(o,c)}}}};var but={kernelName:a1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=Yt(Ue(i),Ue(c)),w=pt(o,ae(c,v)),T=Dn(i.shape,f);return T.length>0&&(w=ie(w,T)),it(w,i.shape)},g=function(){var v=Yt(Ue(i),Ue(c)),w=$n(pt(o,ae(i,v))),T=Dn(c.shape,f);return T.length>0&&(w=ie(w,T)),it(w,c.shape)};return{a:d,b:g}}};var wut={kernelName:s1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,Yt(Ue(Bt(i,"float32")),1))}}}};var xut={kernelName:o1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,Qt(ne(1),Ue(Bt(i,"float32"))))}}}};function Tut(o,a,i,c,f,d,g){f===void 0&&(f=[1,1,1]);var v=W(o,"dy","avgPool3dBackprop"),w=W(a,"input","avgPool3dBackprop"),T=v,N=w,E=!1;w.rank===4&&(E=!0,T=it(v,[1,v.shape[0],v.shape[1],v.shape[2],v.shape[3]]),N=it(w,[1,w.shape[0],w.shape[1],w.shape[2],w.shape[3]])),U(T.rank===5,function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+(T.rank+".")}),U(N.rank===5,function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+(N.rank+".")}),U(xr(c,f),function(){return"Error in avgPool3dBackprop: Either strides or dilations "+("must be 1. Got strides "+c+" and dilations '"+f+"'")}),g!=null&&U(fn(d),function(){return"Error in maxPool3dBackprop: pad must be an integer when "+("using, dimRoundingMode "+g+" but got pad "+d+".")});var k=function(O){var H=Gf(N.shape,i,c,f,d,g);return O.avgPool3dBackprop(T,N,H)},$={dy:T,input:N},M={filterSize:i,strides:c,dilations:f,pad:d,dimRoundingMode:g},G=Z.runKernelFunc(k,$,null,k$,M);return E?it(G,[G.shape[1],G.shape[2],G.shape[3],G.shape[4]]):G}var kut=Y({avgPool3dBackprop_:Tut});var Sut={kernelName:u1,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i,d=f.filterSize,g=f.strides,v=f.dilations,w=f.pad,T=f.dimRoundingMode,N=v==null?[1,1,1]:v;return{x:function(){return kut(o,c,d,g,N,w,T)}}}};function Cut(o,a,i,c,f){var d=W(o,"dy","avgPoolBackprop"),g=W(a,"input","avgPoolBackprop");U(g.rank===d.rank,function(){return"Rank of input ("+g.rank+") does not match rank of dy ("+d.rank+")"});var v=g,w=d,T=!1;g.rank===3&&(T=!0,v=it(g,[1,g.shape[0],g.shape[1],g.shape[2]]),w=it(d,[1,d.shape[0],d.shape[1],d.shape[2]])),U(w.rank===4,function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+(w.rank+".")}),U(v.rank===4,function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+(v.rank+".")});var N=function(M){var G=Oc(v.shape,i,c,1,f);return M.avgPoolBackprop(w,v,G)},E={dy:w,input:v},k={filterSize:i,strides:c,pad:f},$=Z.runKernelFunc(N,E,null,T$,k);return T?it($,[$.shape[1],$.shape[2],$.shape[3]]):$}var Nut=Y({avgPoolBackprop_:Cut});var Iut={kernelName:i1,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i,d=f.filterSize,g=f.strides,v=f.pad;return{x:function(){return Nut(o,c,d,g,v)}}}};var Eut={kernelName:c1,inputsToSave:["a","b"],gradFunc:function(o,a,i){var c=a[0],f=a[1],d=i,g=d.transposeA,v=d.transposeB;return!g&&!v?{a:function(){return Ce(o,f,!1,!0)},b:function(){return Ce(c,o,!0,!1)}}:!g&&v?{a:function(){return Ce(o,f,!1,!1)},b:function(){return Ce(o,c,!0,!1)}}:g&&!v?{a:function(){return Ce(f,o,!1,!0)},b:function(){return Ce(c,o,!1,!1)}}:{a:function(){return Ce(f,o,!0,!0)},b:function(){return Ce(o,c,!0,!0)}}}};var Dut={kernelName:l1,gradFunc:function(o,a,i){var c=i,f=c.blockShape,d=c.crops;return{x:function(){return Lg(o,f,d)}}}};var $ut={kernelName:h1,gradFunc:function(o,a,i){for(var c=i,f=c.inputShape,d=c.shape,g=Array.from(d),v=f.length-1;v>=0;v--)if(f[v]===d[v])g[v]=1;else if(f[v]!==1)throw new Error("broadcastTo(): ["+f+"] cannot be broadcast to ["+d+"].");for(var w=[],v=0;v<g.length;v++)g[v]>1&&w.push(v);return{x:function(){return ie(o,w,!0)}}}};var Aut={kernelName:fg,gradFunc:function(o){return{x:function(){return o.clone()}}}};var _ut={kernelName:f1,gradFunc:function(o){return{x:function(){return ke(o)}}}};var Fut={kernelName:p1,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i,d=f.clipValueMin,g=f.clipValueMax;return{x:function(){return Ms(Yi(qi(c,d),ji(c,g)),o,ke(o))}}}};var Rut={kernelName:d1,saveAllInputs:!0,gradFunc:function(o,a,i){var c=a.map(function(w){return w.shape}),f=i.axis,d=Qe(f,a[0].shape)[0],g=c.map(function(w){return w[d]}),v=Gc(o,g,d);return v.map(function(w){return function(){return w}})}};var Put={kernelName:m1,inputsToSave:["x","filter"],gradFunc:function(o,a,i){var c=a,f=c[0],d=c[1],g=i,v=g.dilations,w=g.strides,T=g.pad,N=g.dataFormat;return U(Ga(v),function(){return"Error in gradient of conv2D: dilation rates greater than 1 "+("are not yet supported in gradients. Got dilations '"+v+"'")}),{x:function(){return yk(f.shape,o,d,w,T,N)},filter:function(){return Vk(f,o,d.shape,w,T,N)}}}};var Out={kernelName:g1,inputsToSave:["dy","filter"],gradFunc:function(o,a,i){var c=a,f=c[0],d=c[1],g=i,v=g.strides,w=g.pad,T=g.dataFormat,N=g.dimRoundingMode;return{dy:function(){return Lc(o,d,v,w,T,1,N)},filter:function(){return Vk(o,f,d.shape,v,w,T,N)}}}};function Mut(o,a,i,c,f){var d=o;o.rank===4&&(d=it(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]));var g=a;g.rank===4&&(g=it(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),U(d.rank===5,function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+(d.shape+".")}),U(g.rank===5,function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+(g.shape+".")}),U(i.length===5,function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+(i+".")}),U(d.shape[4]===i[3],function(){return"Error in conv3dDerFilter: depth of input "+d.shape[4]+") must "+("match input depth in filter ("+i[3]+".")}),U(g.shape[4]===i[4],function(){return"Error in conv3dDerFilter: depth of dy ("+g.shape[4]+") must "+("match output depth for filter ("+i[4]+").")});var v=function(N){var E=1,k=Uf(d.shape,i,c,E,f);return N.conv3dDerFilter(d,g,k)},w={x:d,dy:g},T={strides:c,pad:f,filterShape:i};return Z.runKernelFunc(v,w,null,N$,T)}var Lut=Y({conv3DBackpropFilter_:Mut});var But={kernelName:v1,inputsToSave:["x","filter"],gradFunc:function(o,a,i){var c=i,f=c.dilations,d=c.strides,g=c.pad;U(Ga(f),function(){return"Error in gradient of conv3D: dilation rates greater than 1 are "+("not yet supported in gradients. Got dilations '"+f+"'")});var v=a[0],w=a[1];return{x:function(){return D_(v.shape,o,w,d,g)},filter:function(){return Lut(v,o,w.shape,d,g)}}}};var zut={kernelName:y1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt($n(Mk(Bt(i,"float32"))),o)}}}};var Wut={kernelName:b1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(Lk(Bt(i,"float32")),o)}}}};var Vut={kernelName:w1,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i,d=f.axis,g=f.exclusive,v=f.reverse;return{x:function(){var w=Ps([d],c.rank),T=wk(o,d,g,!v);return w!=null&&(T=On(T,w)),T}}}};var Uut={kernelName:x1,inputsToSave:["x","filter"],gradFunc:function(o,a,i){var c=i,f=c.dilations,d=c.strides,g=c.pad,v=c.dimRoundingMode,w=f==null?[1,1]:f;U(Ga(w),function(){return"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+("'"+w+"'")});var T=a,N=T[0],E=T[1];return U(N.rank===4,function(){return"Error in gradient of depthwiseConv2dNative: input must be "+("rank 4, but got rank "+N.rank+".")}),U(E.rank===4,function(){return"Error in gradient of depthwiseConv2dNative: filter must be "+("rank 4, but got rank "+E.rank+".")}),U(N.shape[3]===E.shape[2],function(){return"Error in gradient of depthwiseConv2d: number of input "+("channels ("+N.shape[3]+") must match the inChannels dimension ")+("in filter "+E.shape[2]+".")}),U(xr(d,w),function(){return"Error in gradient of depthwiseConv2d: Either strides or "+("dilations must be  1. Got strides "+d+" and dilations ")+("'"+w+"'.")}),v!=null&&U(fn(g),function(){return"Error in depthwiseConv2d: pad must be an integer when using, "+("dimRoundingMode "+v+" but got pad "+g+".")}),{x:function(){return EF(N.shape,o,E,d,g,f,v)},filter:function(){return IF(N,o,E.shape,d,g,f,v)}}}};var Gut={kernelName:T1,inputsToSave:["x","filter"],gradFunc:function(o,a,i){var c=a,f=c[0],d=c[1],g={x:f,filter:d,dy:o},v={x:f,filter:d,dy:o};return{x:function(){return Z.runKernel(F$,g,i)},filter:function(){return Z.runKernel(R$,v,i)}}}};var Hut={kernelName:k1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=ae(o,Bt(c,"float32")),w=Dn(i.shape,f);return w.length>0?it(ie(v,w),i.shape):v},g=function(){var v=pt(o,Bt(i,"float32")),w=Dn(c.shape,f);w.length>0&&(v=it(ie(v,w),c.shape));var T=Ue(c);return $n(ae(v,Bt(T,"float32")))};return{a:d,b:g}}};var qut={kernelName:S1,outputsToSave:[!0],gradFunc:function(o,a){var i=a[0],c=function(d){return d.eluDer(o,i)},f={dy:o,y:i};return{x:function(){return Z.runKernelFunc(c,f,null,P$)}}}};var jut={kernelName:C1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0],c=pt(Ls($n(Ue(i))),2/Math.sqrt(Math.PI));return{x:function(){return pt(o,c)}}}};var Kut={kernelName:N1,outputsToSave:[!0],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,i)}}}};var Xut={kernelName:I1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,Ls(i))}}}};var Yut={kernelName:E1,gradFunc:function(o){return{x:function(){return ke(o)}}}};var Jut={kernelName:D1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=ae(o,Bt(c,"float32")),w=Dn(i.shape,f);return w.length>0?it(ie(v,w),i.shape):v},g=function(){var v=pt(o,Bt(i,"float32")),w=Dn(c.shape,f);w.length>0&&(v=it(ie(v,w),c.shape));var T=Ue(c);return $n(ae(v,Bt(T,"float32")))};return{a:d,b:g}}};var Zut={kernelName:$1,inputsToSave:["x","mean","variance","scale"],gradFunc:function(o,a,i){var c=i.varianceEpsilon,f=a[0],d=a[1],g=a[2],v=a[3],w=v==null?ne(1):v,T=Dn(d.shape,f.shape),N=[];if(d.rank===1){for(var E=0;E<f.shape.length-1;++E)N.push(f.shape[E]);N.push(1)}var k=Qt(f,d),$=pt(o,w),M=Ok(Yt(g,ne(c))),G=pt(pt(pt(M,M),M),ne(-.5)),O=function(){return d.rank===1?it(pt(pt(o,Bc(it(M,[1,1,1,d.shape[0]]),N)),w),f.shape):it(pt(pt(o,M),w),f.shape)},H=function(){var dt=pt(pt(M,ne(-1)),$);return d.rank===1&&(dt=ie(dt,T)),it(dt,d.shape)},K=function(){var dt=pt(pt(G,k),$);return d.rank===1&&(dt=ie(dt,T)),it(dt,d.shape)},nt=function(){var dt=pt(k,M),Ct=pt(o,dt);return d.rank===1&&(Ct=ie(Ct,T)),it(Ct,d.shape)},ct=function(){var dt=o;return d.rank===1&&(dt=ie(dt,T)),it(dt,d.shape)};return{x:O,mean:H,variance:K,scale:nt,offset:ct}}};var Qut={kernelName:A1,inputsToSave:["x","indices"],gradFunc:function(o,a,i){var c=a[0],f=a[1],d=i.axis,g=Qe(d,c.shape)[0],v=function(){var w=c.shape,T=f.size,N=w.slice(0,g),E=N.length,k=w.slice(d,w.length).slice(1),$=k.length,M=zF(0,E),G=zF(E+1,E+1+$),O=WF([N,[T],k]),H=it(o,O),K=it(f,[T]),nt=WF([[E],M,G]),ct=On(H,nt),dt=zk(ct,K,c.shape[g]),Ct=Tg(nt);return dt=On(dt,Ct),dt};return{x:v,indices:function(){return f}}}};function zF(o,a){for(var i=[],c=o;c<a;++c)i.push(c);return i}function WF(o){for(var a=[],i=0;i<o.length;++i)for(var c=0;c<o[i].length;++c)a.push(o[i][c]);return a}var tct={kernelName:_1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1];return{a:function(){return ke(i)},b:function(){return ke(c)}}}};var ect={kernelName:F1,gradFunc:function(o){return{x:function(){return Bt(o,"float32")}}}};var nct={kernelName:R1,gradFunc:function(o){return{x:function(){return ke(o)}}}};var rct={kernelName:P1,gradFunc:function(o){return{x:function(){return ke(o)}}}};var sct={kernelName:O1,gradFunc:function(o){return{x:function(){return ke(o)}}}};var oct={kernelName:L1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,Yt(i,1))}}}};var act={kernelName:M1,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,Bt(i,"float32"))}}}};var ict={kernelName:B1,inputsToSave:[],outputsToSave:[!0],gradFunc:function(o,a,i){var c=a[0],f=i.axis;return{logits:function(){var d=!0,g=Ls(c);return Qt(o,pt(ie(o,f,d),g))}}}};function uct(o,a,i,c,f,d,g){c===void 0&&(c=5),f===void 0&&(f=1),d===void 0&&(d=1),g===void 0&&(g=.5);var v=function(N){return N.LRNGrad(i,o,a,c,f,d,g)},w={x:o,y:a,dy:i},T={depthRadius:c,bias:f,alpha:d,beta:g};return Z.runKernelFunc(v,w,null,Y$,T)}var cct=Y({localResponseNormalizationBackprop_:uct});var lct={kernelName:z1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(o,a,i){var c=a,f=c[0],d=c[1],g=i,v=g.depthRadius,w=g.bias,T=g.alpha,N=g.beta;return{x:function(){return cct(f,d,o,v,w,T,N)}}}};function VF(o,a,i,c){return a.rank<i.rank&&(a=it(a,Jr(a.shape,c))),o.rank<i.rank&&(o=it(o,Jr(o.shape,c))),{x:function(){var f=pt(o,Bt(jf(i,a),o.dtype));return f}}}var UF={kernelName:W1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(o,a,i){var c=i,f=c.reductionIndices,d=a[0],g=a[1],v=Qe(f,d.shape),w=VF(o,g,d,v);return{x:function(){return w.x()}}}};var hct={kernelName:V1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=function(){return pt(o,Bt(qi(i,c),"float32"))},d=function(){return pt(o,Bt(_g(i,c),"float32"))};return{a:f,b:d}}};function fct(o,a,i,c,f,d,g,v){d===void 0&&(d=[1,1,1]);var w=W(o,"dy","maxPool3dBackprop"),T=W(a,"input","maxPool3dBackprop"),N=W(i,"output","maxPool3dBackprop"),E=w,k=T,$=N,M=!1;T.rank===4&&(M=!0,E=it(w,[1,w.shape[0],w.shape[1],w.shape[2],w.shape[3]]),k=it(T,[1,T.shape[0],T.shape[1],T.shape[2],T.shape[3]]),$=it(N,[1,N.shape[0],N.shape[1],N.shape[2],N.shape[3]])),U(E.rank===5,function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+(E.rank+".")}),U(k.rank===5,function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+(k.rank+".")}),U($.rank===5,function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+($.rank+".")}),U(xr(f,d),function(){return"Error in maxPool3dBackprop: Either strides or dilations "+("must be 1. Got strides "+f+" and dilations '"+d+"'")}),v!=null&&U(fn(g),function(){return"Error in maxPool3dBackprop: pad must be an integer when "+("using, dimRoundingMode "+v+" but got pad "+g+".")});var G=function(nt){var ct=Gf(k.shape,c,f,d,g,v);return nt.maxPool3dBackprop(E,k,$,ct)},O={dy:E,input:k,output:$},H={filterSize:c,strides:f,dilations:d,pad:g,dimRoundingMode:v},K=Z.runKernelFunc(G,O,null,Z$,H);return M?it(K,[K.shape[1],K.shape[2],K.shape[3],K.shape[4]]):K}var pct=Y({maxPool3dBackprop_:fct});var dct={kernelName:G1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(o,a,i){var c=a,f=c[0],d=c[1],g=i,v=g.filterSize,w=g.strides,T=g.dilations,N=g.pad,E=g.dimRoundingMode,k=T==null?[1,1,1]:T;return{x:function(){return pct(o,f,d,v,w,k,N,E)}}}};function mct(o,a,i,c,f,d,g){var v=W(o,"dy","maxPoolBackprop"),w=W(a,"input","maxPoolBackprop"),T=W(i,"output","maxPoolBackprop");U(w.rank===v.rank,function(){return"Rank of input ("+w.rank+") does not match rank of dy "+("("+v.rank+")")}),U(v.rank===4,function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+(v.rank+".")}),U(w.rank===4,function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+(w.rank+".")}),g!=null&&U(fn(d),function(){return"Error in maxPoolBackprop: pad must be an integer when using, "+("dimRoundingMode "+g+" but got pad "+d+".")});var N=function($){var M=Oc(w.shape,c,f,1,d,g);return $.maxPoolBackprop(v,w,T,M)},E={dy:v,input:w,output:T},k={filterSize:c,strides:f,pad:d,dimRoundingMode:g};return Z.runKernelFunc(N,E,null,J$,k)}var gct=Y({maxPoolBackprop_:mct});var vct={kernelName:U1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(o,a,i){var c=a,f=c[0],d=c[1],g=i,v=g.filterSize,w=g.strides,T=g.pad;return{x:function(){return gct(o,f,d,v,w,T)}}}};var yct={kernelName:H1,inputsToSave:["x"],outputsToSave:[!0],gradFunc:function(o,a,i){var c=i,f=c.axis,d=a[0],g=a[1],v=Qe(f,d.shape),w=VF(o,g,d,v);return{x:function(){return w.x()}}}};var bct={kernelName:q1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=function(){return pt(o,Bt(ji(i,c),"float32"))},d=function(){return pt(o,Bt(Ha(i,c),"float32"))};return{a:f,b:d}}};var wct={kernelName:j1,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i.paddings,d=f.map(function(g){return g[0]});return{x:function(){return De(o,d,c.shape)}}}};var xct={kernelName:K1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=Dn(i.shape,f);return v.length>0?it(ie(o,v),i.shape):o},g=function(){var v=pt(o,$n(Dg(ae(i,c)))),w=Dn(c.shape,f);return w.length>0?it(ie(v,w),c.shape):v};return{a:d,b:g}}};var Tct={kernelName:X1,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=pt(o,Bt(c,"float32")),w=Dn(i.shape,f);return w.length>0?it(ie(v,w),i.shape):v},g=function(){var v=pt(o,Bt(i,"float32")),w=Dn(c.shape,f);return w.length>0?it(ie(v,w),c.shape):v};return{a:d,b:g}}};var kct={kernelName:Y1,gradFunc:function(o){return{x:function(){return $n(o)}}}};var Sct={kernelName:Z1,inputsToSave:["indices"],gradFunc:function(o,a){var i=a[0];return{indices:function(){return qo(i.shape,"float32")}}}};var Cct={kernelName:J1,gradFunc:function(o){return{x:function(){return ke(o)}}}};var GF={kernelName:Q1,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i.paddings,d=f.map(function(g){return g[0]});return{x:function(){return De(o,d,c.shape)}}}};var Nct={kernelName:tT,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:function(o,a){var i=a[0],c=a[1],f=a[2],d=i,g=c,v=tn(d.shape,g.shape),w=function(){var N=Bt(g,"float32"),E=pt(o,pt(N,jo(d,Qt(N,ne(1))))),k=Dn(d.shape,v);return k.length>0&&(E=ie(E,k)),it(E,d.shape)},T=function(){var N=Ha(d,0),E=Ms(N,Ki(d),ke(d)),k=pt(o,pt(f,E)),$=Dn(g.shape,v);return $.length>0&&(k=ie(k,$)),it(k,g.shape)};return{a:w,b:T}}};var Ict={kernelName:eT,inputsToSave:["x","alpha"],gradFunc:function(o,a){var i=a[0],c=a[1],f=Ha(i,0);return{x:function(){return Ms(f,o,pt(o,c))},alpha:function(){var d=Ms(f,ke(o),pt(o,i)),g=Dn(c.shape,o.shape);return g.length>0&&(d=ie(d,g)),it(d,c.shape)}}}};var Ect={kernelName:nT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,$n(Ue(i)))}}}};var Dct={kernelName:iT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0],c=pt(ji(i,6),Hc(i));return{x:function(){return pt(o,Bt(c,"float32"))}}}};var $ct={kernelName:rT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,Bt(Hc(i),"float32"))}}}};var Act={kernelName:sT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return it(o,i.shape)}}}};var _ct={kernelName:aT,inputsToSave:["images"],gradFunc:function(o,a,i){var c=a[0],f=function(v){var w=i.alignCorners;return v.resizeBilinearBackprop(o,c,w)},d={images:c},g=function(){return Z.runKernelFunc(f,d,null,cA,i)};return{images:g}}};var Fct={kernelName:oT,inputsToSave:["images"],gradFunc:function(o,a,i){var c=a[0],f=function(v){var w=i.alignCorners;return v.resizeNearestNeighborBackprop(o,c,w)},d={images:c},g=function(){return Z.runKernelFunc(f,d,null,uA,i)};return{images:g}}};var Rct={kernelName:uT,gradFunc:function(o,a,i){var c=i.dims,f=Qe(c,o.shape);return{x:function(){return Ko(o,f)}}}};var Pct={kernelName:cT,gradFunc:function(o){return{x:function(){return ke(o)}}}};var Oct={kernelName:lT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return $n(ae(o,pt(jo(i,1.5),2)))}}}};var Mct={kernelName:hT,inputsToSave:["condition"],gradFunc:function(o,a){var i=a[0];return{condition:function(){return Bt(ke(i),"float32")},t:function(){return pt(o,Bt(i,o.dtype))},e:function(){return pt(o,Bt(Rg(i),o.dtype))}}}};var Lct={kernelName:fT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){var c=Ha(i,ne(0)),f=ne(LF),d=ne(BF),g=pt(o,d),v=pt(pt(o,f),Ls(Bt(i,"float32")));return Ms(c,g,v)}}}};var Bct={kernelName:vT,outputsToSave:[!0],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,pt(i,Qt(ne(1),i)))}}}};var zct={kernelName:gT,gradFunc:function(o){return{x:function(){return ke(o)}}}};var Wct={kernelName:dT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(Eg(Bt(i,"float32")),o)}}}};var Vct={kernelName:mT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(bk(Bt(i,"float32")),o)}}}};var Uct={kernelName:pT,inputsToSave:["x"],gradFunc:function(o,a,i){for(var c=a[0],f=i,d=f.begin,g=f.size,v=c.shape,w=ck(c,d,g),T=w[0],N=w[1],E=[],k=0;k<o.rank;k++)E.push([T[k],v[k]-T[k]-N[k]]);return{x:function(){return Ji(o,E)}}}};var Gct={kernelName:kT,outputsToSave:[!0],gradFunc:function(o,a,i){var c=a[0],f=i.dim,d=!0,g=pt(o,c);return{logits:function(){return Qt(g,pt(ie(g,[f],d),c))}}}};var Hct={kernelName:yT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,Hi(i))}}}};var HF={kernelName:xT,gradFunc:function(o,a,i){var c=i,f=c.blockShape,d=c.paddings;return{x:function(){return Cg(o,f,d)}}}};var qF={kernelName:TT,gradFunc:function(o,a,i){var c=i.axis;return{x:function(){return qn(o,c)}}}};var qct={kernelName:bT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,pt(Tr(Bt(i,"float32")),2))}}}};var jct={kernelName:hA,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(o,pt(Bt(i,"float32"),2))}}}};var Kct={kernelName:ST,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=ne(2),d=function(){return pt(o,pt(f,Qt(i,c)))},g=function(){return pt(o,pt(f,Qt(c,i)))};return{a:d,b:g}}};var Xct={kernelName:FT,gradFunc:function(o){return{x:function(){return ke(o)}}}};var Yct={kernelName:CT,inputsToSave:["a","b"],gradFunc:function(o,a){var i=a[0],c=a[1],f=tn(i.shape,c.shape),d=function(){var v=o,w=Dn(i.shape,f);return w.length>0&&(v=ie(v,w)),it(v,i.shape)},g=function(){var v=o,w=Dn(c.shape,f);return w.length>0&&(v=ie(v,w)),it($n(v),c.shape)};return{a:d,b:g}}};var Jct={kernelName:wT,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=c.shape.slice(),d=i.axis,g=Qe(d,c.shape);g.forEach(function(T){f[T]=1});var v=it(o,f),w=pt(v,Wc(c.shape,"float32"));return{x:function(){return w}}}};var Zct={kernelName:NT,inputsToSave:["x"],gradFunc:function(o,a){var i=a[0];return{x:function(){return ae(o,Ue(Eg(i)))}}}};var Qct={kernelName:IT,outputsToSave:[!0],gradFunc:function(o,a){var i=a[0];return{x:function(){return pt(Qt(ne(1),Ue(i)),o)}}}};var tlt={kernelName:ET,inputsToSave:["x"],gradFunc:function(o,a,i){var c=a[0],f=i.reps,d=function(){var g=ke(c);if(c.rank===1)for(var v=0;v<f[0];++v)g=Yt(g,De(o,[v*c.shape[0]],[c.shape[0]]));else if(c.rank===2)for(var v=0;v<f[0];++v)for(var w=0;w<f[1];++w)g=Yt(g,De(o,[v*c.shape[0],w*c.shape[1]],[c.shape[0],c.shape[1]]));else if(c.rank===3)for(var v=0;v<f[0];++v)for(var w=0;w<f[1];++w)for(var T=0;T<f[2];++T)g=Yt(g,De(o,[v*c.shape[0],w*c.shape[1],T*c.shape[2]],[c.shape[0],c.shape[1],c.shape[2]]));else if(c.rank===4)for(var v=0;v<f[0];++v)for(var w=0;w<f[1];++w)for(var T=0;T<f[2];++T)for(var N=0;N<f[3];++N)g=Yt(g,De(o,[v*c.shape[0],w*c.shape[1],T*c.shape[2],N*c.shape[3]],[c.shape[0],c.shape[1],c.shape[2],c.shape[3]]));else throw new Error("Gradient for tile operation is not implemented for rank-"+(c.rank+" tensors yet."));return g};return{x:d}}};var elt={kernelName:DT,gradFunc:function(o,a,i){var c=i,f=c.perm,d=Tg(f);return{x:function(){return On(o,d)}}}};var nlt={kernelName:$T,gradFunc:function(o,a,i){var c=i,f=c.axis;return{value:function(){return tu(o,f)}}}};var slt={kernelName:AT,inputsToSave:["segmentIds"],gradFunc:function(o,a){var i=a[0],c=function(){return rlt(o,i)};return{x:c}}};function rlt(o,a){for(var i=zc(a,ke(a)),c=$g(o,i),f=qi(a,ne(0,"int32")),d=c.rank-f.rank,g=0;g<d;++g)f=Bs(f,g+1);f=Yi(f,Wc(c.shape,"bool"));var v=ke(c);return Ms(f,c,v)}var olt={kernelName:_T,gradFunc:function(o){return{x:function(){return ke(o)}}}};var alt=[lut,hut,fut,put,dut,mut,gut,vut,yut,but,wut,xut,Sut,Iut,Eut,Dut,$ut,Aut,_ut,Fut,Rut,Out,Put,But,zut,Wut,Vut,Uut,Gut,Hut,qut,jut,Kut,Xut,Jut,Yut,Zut,Qut,tct,ect,nct,rct,sct,oct,act,ict,lct,UF,UF,hct,dct,vct,yct,bct,wct,xct,Tct,kct,Sct,Cct,GF,GF,Nct,Ict,Ect,Dct,$ct,Act,_ct,Fct,Rct,Pct,Oct,Mct,Lct,Bct,zct,Wct,Vct,Uct,Gct,Hct,HF,HF,qF,qF,qct,Kct,jct,Xct,Yct,Jct,Zct,Qct,tlt,elt,nlt,slt,olt];for(var Yk=0,jF=alt;Yk<jF.length;Yk++){var ilt=jF[Yk];yA(ilt)}ut.prototype.abs=function(){return this.throwIfDisposed(),_r(this)};ut.prototype.acos=function(){return this.throwIfDisposed(),l_(this)};ut.prototype.acosh=function(){return this.throwIfDisposed(),h_(this)};ut.prototype.addStrict=function(o){return this.throwIfDisposed(),gF(this,o)};ut.prototype.add=function(o){return this.throwIfDisposed(),Yt(this,o)};ut.prototype.all=function(o,a){return this.throwIfDisposed(),d_(this,o,a)};ut.prototype.any=function(o,a){return this.throwIfDisposed(),m_(this,o,a)};ut.prototype.argMax=function(o){return this.throwIfDisposed(),g_(this,o)};ut.prototype.argMin=function(o){return this.throwIfDisposed(),v_(this,o)};ut.prototype.asScalar=function(){return this.throwIfDisposed(),U(this.size===1,function(){return"The array must have only 1 element."}),it(this,[])};ut.prototype.asType=function(o){return this.throwIfDisposed(),Bt(this,o)};ut.prototype.as1D=function(){return this.throwIfDisposed(),it(this,[this.size])};ut.prototype.as2D=function(o,a){return this.throwIfDisposed(),it(this,[o,a])};ut.prototype.as3D=function(o,a,i){return this.throwIfDisposed(),it(this,[o,a,i])};ut.prototype.as4D=function(o,a,i,c){return this.throwIfDisposed(),it(this,[o,a,i,c])};ut.prototype.as5D=function(o,a,i,c,f){return this.throwIfDisposed(),it(this,[o,a,i,c,f])};ut.prototype.asin=function(){return this.throwIfDisposed(),y_(this)};ut.prototype.asinh=function(){return this.throwIfDisposed(),b_(this)};ut.prototype.atan=function(){return this.throwIfDisposed(),w_(this)};ut.prototype.atan2=function(o){return this.throwIfDisposed(),x_(this,o)};ut.prototype.atanh=function(){return this.throwIfDisposed(),T_(this)};ut.prototype.avgPool=function(o,a,i,c){return this.throwIfDisposed(),vk(this,o,a,i,c)};ut.prototype.batchToSpaceND=function(o,a){return this.throwIfDisposed(),Cg(this,o,a)};ut.prototype.batchNorm=function(o,a,i,c,f){return this.throwIfDisposed(),Hf(this,o,a,i,c,f)};ut.prototype.broadcastTo=function(o){return this.throwIfDisposed(),Ig(this,o)};ut.prototype.cast=function(o){return this.throwIfDisposed(),Bt(this,o)};ut.prototype.ceil=function(){return this.throwIfDisposed(),C_(this)};ut.prototype.clipByValue=function(o,a){return this.throwIfDisposed(),N_(this,o,a)};ut.prototype.concat=function(o,a){return this.throwIfDisposed(),o instanceof ut&&(o=[o]),qn([this].concat(o),a)};ut.prototype.conv1d=function(o,a,i,c,f,d){return this.throwIfDisposed(),I_(this,o,a,i,c,f,d)};ut.prototype.conv2dTranspose=function(o,a,i,c,f){return this.throwIfDisposed(),E_(this,o,a,i,c,f)};ut.prototype.conv2d=function(o,a,i,c,f,d){return this.throwIfDisposed(),Lc(this,o,a,i,c,f,d)};ut.prototype.cos=function(){return this.throwIfDisposed(),Eg(this)};ut.prototype.cosh=function(){return this.throwIfDisposed(),bk(this)};ut.prototype.cumsum=function(o,a,i){return this.throwIfDisposed(),wk(this,o,a,i)};ut.prototype.depthToSpace=function(o,a){return this.throwIfDisposed(),$_(this,o,a)};ut.prototype.depthwiseConv2D=function(o,a,i,c,f,d){return Mn("depthwiseConv2D is deprecated, use depthwiseConv2d instead"),this.throwIfDisposed(),qf(this,o,a,i,c,f,d)};ut.prototype.depthwiseConv2d=function(o,a,i,c,f,d){return this.throwIfDisposed(),qf(this,o,a,i,c,f,d)};ut.prototype.dilation2d=function(o,a,i,c,f){return this.throwIfDisposed(),A_(this,o,a,i,c,f)};ut.prototype.divNoNan=function(o){return this.throwIfDisposed(),__(this,o)};ut.prototype.divStrict=function(o){return this.throwIfDisposed(),vF(this,o)};ut.prototype.div=function(o){return this.throwIfDisposed(),ae(this,o)};ut.prototype.dot=function(o){return this.throwIfDisposed(),F_(this,o)};ut.prototype.elu=function(){return this.throwIfDisposed(),xk(this)};ut.prototype.equalStrict=function(o){return this.throwIfDisposed(),lF(this,o)};ut.prototype.equal=function(o){return this.throwIfDisposed(),jf(this,o)};ut.prototype.erf=function(){return this.throwIfDisposed(),R_(this)};ut.prototype.exp=function(){return this.throwIfDisposed(),Ls(this)};ut.prototype.expandDims=function(o){return this.throwIfDisposed(),Bs(this,o)};ut.prototype.expm1=function(){return this.throwIfDisposed(),P_(this)};ut.prototype.fft=function(){return this.throwIfDisposed(),Bg(this)};ut.prototype.flatten=function(){return this.throwIfDisposed(),it(this,[this.size])};ut.prototype.floor=function(){return this.throwIfDisposed(),Dg(this)};ut.prototype.floorDiv=function(o){return this.throwIfDisposed(),pk(this,o)};ut.prototype.gather=function(o,a){return this.throwIfDisposed(),$g(this,o,a)};ut.prototype.greaterEqualStrict=function(o){return this.throwIfDisposed(),hF(this,o)};ut.prototype.greaterEqual=function(o){return this.throwIfDisposed(),qi(this,o)};ut.prototype.greaterStrict=function(o){return this.throwIfDisposed(),fF(this,o)};ut.prototype.greater=function(o){return this.throwIfDisposed(),Ha(this,o)};ut.prototype.ifft=function(){return this.throwIfDisposed(),Jf(this)};ut.prototype.irfft=function(){return this.throwIfDisposed(),Bk(this)};ut.prototype.isFinite=function(){return this.throwIfDisposed(),L_(this)};ut.prototype.isInf=function(){return this.throwIfDisposed(),B_(this)};ut.prototype.isNaN=function(){return this.throwIfDisposed(),z_(this)};ut.prototype.leakyRelu=function(o){return this.throwIfDisposed(),W_(this,o)};ut.prototype.lessEqualStrict=function(o){return this.throwIfDisposed(),pF(this,o)};ut.prototype.lessEqual=function(o){return this.throwIfDisposed(),ji(this,o)};ut.prototype.lessStrict=function(o){return this.throwIfDisposed(),dF(this,o)};ut.prototype.less=function(o){return this.throwIfDisposed(),_g(this,o)};ut.prototype.localResponseNormalization=function(o,a,i,c){return this.throwIfDisposed(),V_(this,o,a,i,c)};ut.prototype.logSigmoid=function(){return this.throwIfDisposed(),G_(this)};ut.prototype.logSoftmax=function(o){return this.throwIfDisposed(),H_(this,o)};ut.prototype.logSumExp=function(o,a){return this.throwIfDisposed(),Nk(this,o,a)};ut.prototype.log=function(){return this.throwIfDisposed(),Ki(this)};ut.prototype.log1p=function(){return this.throwIfDisposed(),Sk(this)};ut.prototype.logicalAnd=function(o){return this.throwIfDisposed(),Yi(this,o)};ut.prototype.logicalNot=function(){return this.throwIfDisposed(),Rg(this)};ut.prototype.logicalOr=function(o){return this.throwIfDisposed(),Ik(this,o)};ut.prototype.logicalXor=function(o){return this.throwIfDisposed(),q_(this,o)};ut.prototype.matMul=function(o,a,i){return this.throwIfDisposed(),Ce(this,o,a,i)};ut.prototype.maxPool=function(o,a,i,c){return this.throwIfDisposed(),Ek(this,o,a,i,c)};ut.prototype.max=function(o,a){return this.throwIfDisposed(),Xi(this,o,a)};ut.prototype.maximumStrict=function(o){return this.throwIfDisposed(),yF(this,o)};ut.prototype.maximum=function(o){return this.throwIfDisposed(),zc(this,o)};ut.prototype.mean=function(o,a){return this.throwIfDisposed(),Kf(this,o,a)};ut.prototype.min=function(o,a){return this.throwIfDisposed(),Pg(this,o,a)};ut.prototype.minimumStrict=function(o){return this.throwIfDisposed(),bF(this,o)};ut.prototype.minimum=function(o){return this.throwIfDisposed(),Og(this,o)};ut.prototype.mirrorPad=function(o,a){return this.throwIfDisposed(),j_(this,o,a)};ut.prototype.modStrict=function(o){return this.throwIfDisposed(),wF(this,o)};ut.prototype.mod=function(o){return this.throwIfDisposed(),Dk(this,o)};ut.prototype.mulStrict=function(o){return this.throwIfDisposed(),xF(this,o)};ut.prototype.mul=function(o){return this.throwIfDisposed(),pt(this,o)};ut.prototype.neg=function(){return this.throwIfDisposed(),$n(this)};ut.prototype.norm=function(o,a,i){return this.throwIfDisposed(),Gg(this,o,a,i)};ut.prototype.notEqualStrict=function(o){return this.throwIfDisposed(),mF(this,o)};ut.prototype.notEqual=function(o){return this.throwIfDisposed(),Mg(this,o)};ut.prototype.oneHot=function(o,a,i){return a===void 0&&(a=1),i===void 0&&(i=0),this.throwIfDisposed(),wg(this,o,a,i)};ut.prototype.onesLike=function(){return this.throwIfDisposed(),$k(this)};ut.prototype.pad=function(o,a){return this.throwIfDisposed(),Ji(this,o,a)};ut.prototype.pool=function(o,a,i,c,f){return this.throwIfDisposed(),K_(this,o,a,i,c,f)};ut.prototype.powStrict=function(o){return this.throwIfDisposed(),TF(this,o)};ut.prototype.pow=function(o){return this.throwIfDisposed(),jo(this,o)};ut.prototype.prelu=function(o){return this.throwIfDisposed(),Ak(this,o)};ut.prototype.prod=function(o,a){return this.throwIfDisposed(),X_(this,o,a)};ut.prototype.reciprocal=function(){return this.throwIfDisposed(),J_(this)};ut.prototype.relu=function(){return this.throwIfDisposed(),Yf(this)};ut.prototype.relu6=function(){return this.throwIfDisposed(),Pk(this)};ut.prototype.reshapeAs=function(o){return this.throwIfDisposed(),it(this,o.shape)};ut.prototype.reshape=function(o){return this.throwIfDisposed(),it(this,o)};ut.prototype.resizeBilinear=function(o,a){return this.throwIfDisposed(),PF(this,o,a)};ut.prototype.resizeNearestNeighbor=function(o,a){return this.throwIfDisposed(),OF(this,o,a)};ut.prototype.reverse=function(o){return this.throwIfDisposed(),Ko(this,o)};ut.prototype.rfft=function(){return this.throwIfDisposed(),zg(this)};ut.prototype.round=function(){return this.throwIfDisposed(),Z_(this)};ut.prototype.rsqrt=function(){return this.throwIfDisposed(),Ok(this)};ut.prototype.selu=function(){return this.throwIfDisposed(),Q_(this)};ut.prototype.separableConv2d=function(o,a,i,c,f,d){return this.throwIfDisposed(),tF(this,o,a,i,c,f,d)};ut.prototype.sigmoid=function(){return this.throwIfDisposed(),Hi(this)};ut.prototype.sign=function(){return this.throwIfDisposed(),eF(this)};ut.prototype.sin=function(){return this.throwIfDisposed(),Mk(this)};ut.prototype.sinh=function(){return this.throwIfDisposed(),Lk(this)};ut.prototype.slice=function(o,a){return this.throwIfDisposed(),De(this,o,a)};ut.prototype.softmax=function(o){return this.throwIfDisposed(),nF(this,o)};ut.prototype.softplus=function(){return this.throwIfDisposed(),Ck(this)};ut.prototype.spaceToBatchND=function(o,a){return this.throwIfDisposed(),Lg(this,o,a)};ut.prototype.split=function(o,a){return this.throwIfDisposed(),Gc(this,o,a)};ut.prototype.sqrt=function(){return this.throwIfDisposed(),Tr(this)};ut.prototype.square=function(){return this.throwIfDisposed(),Ue(this)};ut.prototype.squaredDifference=function(o){return this.throwIfDisposed(),Wg(this,o)};ut.prototype.squaredDifferenceStrict=function(o){return this.throwIfDisposed(),kF(this,o)};ut.prototype.squeeze=function(o){return this.throwIfDisposed(),Vg(this,o)};ut.prototype.stack=function(o,a){this.throwIfDisposed();var i=o instanceof ut?[this,o]:[this].concat(o);return tu(i,a)};ut.prototype.step=function(o){return this.throwIfDisposed(),Hc(this,o)};ut.prototype.stridedSlice=function(o,a,i,c,f,d,g,v){return this.throwIfDisposed(),sF(this,o,a,i,c,f,d,g,v)};ut.prototype.subStrict=function(o){return this.throwIfDisposed(),SF(this,o)};ut.prototype.sub=function(o){return this.throwIfDisposed(),Qt(this,o)};ut.prototype.sum=function(o,a){return this.throwIfDisposed(),ie(this,o,a)};ut.prototype.tan=function(){return this.throwIfDisposed(),oF(this)};ut.prototype.tanh=function(){return this.throwIfDisposed(),Sg(this)};ut.prototype.tile=function(o){return this.throwIfDisposed(),Bc(this,o)};ut.prototype.toBool=function(){return this.throwIfDisposed(),Bt(this,"bool")};ut.prototype.toFloat=function(){return this.throwIfDisposed(),Bt(this,"float32")};ut.prototype.toInt=function(){return this.throwIfDisposed(),Bt(this,"int32")};ut.prototype.topk=function(o,a){return this.throwIfDisposed(),aF(this,o,a)};ut.prototype.transpose=function(o){return this.throwIfDisposed(),On(this,o)};ut.prototype.unique=function(o){return this.throwIfDisposed(),iF(this,o)};ut.prototype.unsortedSegmentSum=function(o,a){return this.throwIfDisposed(),zk(this,o,a)};ut.prototype.unstack=function(o){return this.throwIfDisposed(),Ug(this,o)};ut.prototype.where=function(o,a){return this.throwIfDisposed(),Ms(o,this,a)};ut.prototype.zerosLike=function(){return this.throwIfDisposed(),ke(this)};F.Abs=Yx;F.Acos=Jx;F.Acosh=Zx;F.AdadeltaOptimizer=Gk;F.AdagradOptimizer=Hk;F.AdamOptimizer=qk;F.AdamaxOptimizer=jk;F.Add=hg;F.AddN=Qx;F.All=w$;F.Any=x$;F.ArgMax=t1;F.ArgMin=e1;F.Asin=n1;F.Asinh=r1;F.Atan=s1;F.Atan2=a1;F.Atanh=o1;F.AvgPool=i1;F.AvgPool3D=u1;F.AvgPool3DBackprop=k$;F.AvgPoolBackprop=T$;F.BatchMatMul=c1;F.BatchToSpaceND=l1;F.BroadcastTo=h1;F.Cast=fg;F.Ceil=f1;F.ClipByValue=p1;F.Complex=S$;F.Concat=d1;F.Conv2D=m1;F.Conv2DBackpropFilter=C$;F.Conv2DBackpropInput=g1;F.Conv3D=v1;F.Conv3DBackpropFilterV2=N$;F.Conv3DBackpropInputV2=I$;F.Cos=y1;F.Cosh=b1;F.CropAndResize=E$;F.Cumsum=w1;F.DataStorage=jZ;F.DepthToSpace=D$;F.DepthwiseConv2dNative=x1;F.DepthwiseConv2dNativeBackpropFilter=$$;F.DepthwiseConv2dNativeBackpropInput=A$;F.Diag=_$;F.Dilation2D=T1;F.Dilation2DBackpropFilter=R$;F.Dilation2DBackpropInput=F$;F.Div=k1;F.Elu=S1;F.EluGrad=P$;F.Environment=v$;F.Equal=O$;F.Erf=C1;F.Exp=N1;F.Expm1=I1;F.FFT=M$;F.Fill=L$;F.FlipLeftRight=B$;F.Floor=E1;F.FloorDiv=D1;F.FromPixels=RT;F.FusedBatchNorm=$1;F.FusedConv2D=OT;F.FusedDepthwiseConv2D=MT;F.GatherNd=z$;F.GatherV2=A1;F.Greater=W$;F.GreaterEqual=_1;F.IFFT=V$;F.Identity=F1;F.Imag=U$;F.IsFinite=R1;F.IsInf=P1;F.IsNan=O1;F.KernelBackend=r$;F.LRN=z1;F.LRNBackprop=Y$;F.Less=G$;F.LessEqual=H$;F.LinSpace=q$;F.Log=M1;F.Log1p=L1;F.LogSoftmax=B1;F.LogicalAnd=j$;F.LogicalNot=K$;F.LogicalOr=X$;F.Max=W1;F.MaxPool=U1;F.MaxPool3D=G1;F.MaxPool3DBackprop=Z$;F.MaxPoolBackprop=J$;F.MaxPoolWithArgmax=Q$;F.Maximum=V1;F.Mean=tA;F.Min=H1;F.Minimum=q1;F.MirrorPad=j1;F.Mod=K1;F.MomentumOptimizer=Kk;F.Multiply=X1;F.Negate=Y1;F.NonMaxSuppressionV3=nA;F.NonMaxSuppressionV4=rA;F.NonMaxSuppressionV5=sA;F.NotEqual=eA;F.OP_SCOPE_SUFFIX=EA;F.OneHot=Z1;F.OnesLike=J1;F.Optimizer=qa;F.PadV2=Q1;F.Pool=hQ;F.Pow=tT;F.Prelu=eT;F.Prod=oA;F.RMSPropOptimizer=Xk;F.Range=aA;F.Real=iA;F.Reciprocal=nT;F.Relu=rT;F.Relu6=iT;F.Reshape=sT;F.ResizeBilinear=aT;F.ResizeBilinearGrad=cA;F.ResizeNearestNeighbor=oT;F.ResizeNearestNeighborGrad=uA;F.Reverse=uT;F.RotateWithOffset=gA;F.Round=cT;F.Rsqrt=lT;F.SGDOptimizer=Xg;F.ScatterNd=lA;F.SelectV2=hT;F.Selu=fT;F.Sigmoid=vT;F.Sign=gT;F.Sin=dT;F.Sinh=mT;F.Slice=pT;F.Softmax=kT;F.Softplus=yT;F.SpaceToBatchND=xT;F.SparseToDense=fA;F.SplitV=TT;F.Sqrt=bT;F.Square=hA;F.SquaredDifference=ST;F.Step=FT;F.StridedSlice=pA;F.Sub=CT;F.Sum=wT;F.Tan=NT;F.Tanh=IT;F.Tensor=ut;F.TensorBuffer=gg;F.Tile=ET;F.TopK=dA;F.Transpose=DT;F.Unique=mA;F.Unpack=$T;F.UnsortedSegmentSum=AT;F.Variable=Bf;F.ZerosLike=_T;F._FusedMatMul=PT;F.abs=_r;F.acos=l_;F.acosh=h_;F.add=Yt;F.addN=Fet;F.addStrict=gF;F.all=d_;F.any=m_;F.argMax=g_;F.argMin=v_;F.asin=y_;F.asinh=b_;F.atan=w_;F.atan2=x_;F.atanh=T_;F.avgPool=vk;F.avgPool3d=Jet;F.backend=Tet;F.backend_util=out;F.basicLSTMCell=rnt;F.batchNorm=Hf;F.batchNorm2d=unt;F.batchNorm3d=lnt;F.batchNorm4d=fnt;F.batchToSpaceND=Cg;F.booleanMaskAsync=Oot;F.broadcastTo=Ig;F.browser=Htt;F.buffer=co;F.cast=Bt;F.ceil=C_;F.clipByValue=N_;F.clone=Ui;F.complex=La;F.concat=qn;F.concat1d=vnt;F.concat2d=bnt;F.concat3d=xnt;F.concat4d=knt;F.conv1d=I_;F.conv2d=Lc;F.conv2dTranspose=E_;F.conv3d=Dnt;F.conv3dTranspose=_nt;F.copyRegisteredKernels=dQ;F.cos=Eg;F.cosh=bk;F.cosineWindow=Wk;F.cumsum=wk;F.customGrad=ho;F.deprecationWarn=Mn;F.depthToSpace=$_;F.depthwiseConv2d=qf;F.device_util=LQ;F.diag=Bnt;F.dilation2d=A_;F.disableDeprecationWarnings=uet;F.dispose=wr;F.disposeVariables=cet;F.div=ae;F.divNoNan=__;F.divStrict=vF;F.dot=F_;F.dropout=lat;F.elu=xk;F.enableDebugMode=iet;F.enableProdMode=aet;F.enclosingPowerOfTwo=NF;F.engine=het;F.env=Fe;F.equal=jf;F.equalStrict=lF;F.erf=R_;F.exp=Ls;F.expandDims=Bs;F.expm1=P_;F.eye=O_;F.fft=Bg;F.fill=Tk;F.findBackend=bet;F.findBackendFactory=wet;F.floor=Dg;F.floorDiv=pk;F.fused=Tat;F.gather=$g;F.gatherND=iat;F.gather_util=qtt;F.getBackend=vet;F.getGradient=zT;F.getKernel=BT;F.getKernelsForBackend=pg;F.grad=wrt;F.grads=xrt;F.greater=Ha;F.greaterEqual=qi;F.greaterEqualStrict=hF;F.greaterStrict=fF;F.ifft=Jf;F.imag=Ag;F.image=Eit;F.inTopKAsync=fat;F.io=Rtt;F.irfft=Bk;F.isFinite=L_;F.isInf=B_;F.isNaN=z_;F.keep=c_;F.kernel_impls=cut;F.leakyRelu=W_;F.less=_g;F.lessEqual=ji;F.lessEqualStrict=pF;F.lessStrict=dF;F.linalg=Dit;F.linspace=grt;F.localResponseNormalization=V_;F.log=Ki;F.log1p=Sk;F.logSigmoid=G_;F.logSoftmax=H_;F.logSumExp=Nk;F.logicalAnd=Yi;F.logicalNot=Rg;F.logicalOr=Ik;F.logicalXor=q_;F.losses=$it;F.matMul=Ce;F.math=Wtt;F.max=Xi;F.maxPool=Ek;F.maxPool3d=Lrt;F.maxPoolWithArgmax=zrt;F.maximum=zc;F.maximumStrict=yF;F.mean=Kf;F.memory=fet;F.min=Pg;F.minimum=Og;F.minimumStrict=bF;F.mirrorPad=j_;F.mod=Dk;F.modStrict=wF;F.moments=Krt;F.movingAverage=tat;F.mul=pt;F.mulStrict=xF;F.multiRNNCell=Yrt;F.multinomial=Zrt;F.neg=$n;F.nextFrame=Fit;F.norm=Gg;F.notEqual=Mg;F.notEqualStrict=mF;F.oneHot=wg;F.ones=Wc;F.onesLike=$k;F.op=Y;F.outerProduct=rst;F.pad=Ji;F.pad1d=ast;F.pad2d=ust;F.pad3d=lst;F.pad4d=fst;F.pool=K_;F.pow=jo;F.powStrict=TF;F.prelu=Ak;F.print=LA;F.prod=X_;F.profile=pet;F.rand=xst;F.randomGamma=_st;F.randomNormal=Rst;F.randomUniform=Y_;F.range=Rk;F.ready=get;F.real=Xf;F.reciprocal=J_;F.registerBackend=xet;F.registerGradient=yA;F.registerKernel=vA;F.relu=Yf;F.relu6=Pk;F.removeBackend=yet;F.reshape=it;F.reverse=Ko;F.reverse1d=Wst;F.reverse2d=Ust;F.reverse3d=Hst;F.reverse4d=jst;F.rfft=zg;F.round=Z_;F.rsqrt=Ok;F.scalar=ne;F.scatterND=nat;F.scatter_util=jtt;F.selu=Q_;F.separableConv2d=tF;F.serialization=Ytt;F.setBackend=met;F.setPlatform=ket;F.setdiff1dAsync=Qst;F.sigmoid=Hi;F.sign=eF;F.signal=Iit;F.sin=Mk;F.sinh=Lk;F.slice=De;F.slice1d=sot;F.slice2d=aot;F.slice3d=uot;F.slice4d=lot;F.slice_util=o_;F.softmax=nF;F.softplus=Ck;F.spaceToBatchND=Lg;F.sparseToDense=oat;F.spectral=Nit;F.split=Gc;F.sqrt=Tr;F.square=Ue;F.squaredDifference=Wg;F.squaredDifferenceStrict=kF;F.squeeze=Vg;F.stack=tu;F.step=Hc;F.stridedSlice=sF;F.sub=Qt;F.subStrict=SF;F.sum=ie;F.sumOutType=DQ;F.tan=oF;F.tanh=Sg;F.tensor=za;F.tensor1d=Uc;F.tensor2d=Zf;F.tensor3d=HA;F.tensor4d=Sot;F.tensor5d=Cot;F.tensor6d=Not;F.tensor_util=_Q;F.test_util=set;F.tidy=En;F.tile=Bc;F.time=det;F.topk=aF;F.train=Ait;F.transpose=On;F.truncatedNormal=Dot;F.unique=iF;F.unregisterGradient=pQ;F.unregisterKernel=fQ;F.unsortedSegmentSum=zk;F.unstack=Ug;F.upcastType=vg;F.util=yQ;F.valueAndGrad=Trt;F.valueAndGrads=krt;F.variable=Fot;F.variableGrads=U_;F.version_core=oet;F.where=Ms;F.whereAsync=cF;F.zeros=qo;F.zerosLike=ke});kf(exports,{AgeGenderNet:()=>cv,BoundingBox:()=>Tc,Box:()=>Le,ComposableTask:()=>ds,ComputeAllFaceDescriptorsTask:()=>Qa,ComputeFaceDescriptorsTaskBase:()=>yv,ComputeSingleFaceDescriptorTask:()=>ti,DetectAllFaceLandmarksTask:()=>wv,DetectAllFacesTask:()=>cp,DetectFaceLandmarksTaskBase:()=>bv,DetectFacesTaskBase:()=>Tv,DetectSingleFaceLandmarksTask:()=>xv,DetectSingleFaceTask:()=>kv,Dimensions:()=>or,FACE_EXPRESSION_LABELS:()=>t2,FaceDetection:()=>qe,FaceDetectionNet:()=>wR,FaceExpressionNet:()=>iv,FaceExpressions:()=>Xa,FaceLandmark68Net:()=>nl,FaceLandmark68TinyNet:()=>lv,FaceLandmarkNet:()=>uR,FaceLandmarks:()=>Xr,FaceLandmarks5:()=>QD,FaceLandmarks68:()=>Sc,FaceMatch:()=>Ef,FaceMatcher:()=>Cv,FaceRecognitionNet:()=>sl,Gender:()=>Zo,LabeledBox:()=>Df,LabeledFaceDescriptors:()=>Vo,NetInput:()=>Yo,NeuralNetwork:()=>jn,ObjectDetection:()=>Fa,Point:()=>ue,PredictedBox:()=>t$,Rect:()=>kc,SsdMobilenetv1:()=>au,SsdMobilenetv1Options:()=>hs,TinyFaceDetector:()=>cl,TinyFaceDetectorOptions:()=>vv,TinyYolov2:()=>il,TinyYolov2Options:()=>po,TinyYolov2SizeType:()=>f2,allFaces:()=>Jlt,allFacesSsdMobilenetv1:()=>PR,allFacesTinyYolov2:()=>Ylt,awaitMediaLoaded:()=>Vx,bufferToImage:()=>Ux,computeFaceDescriptor:()=>Olt,createCanvas:()=>Cc,createCanvasFromMedia:()=>_f,createFaceDetectionNet:()=>Dlt,createFaceRecognitionNet:()=>ylt,createSsdMobilenetv1:()=>bR,createTinyFaceDetector:()=>Zlt,createTinyYolov2:()=>_lt,detectAllFaces:()=>Sv,detectFaceLandmarks:()=>FR,detectFaceLandmarksTiny:()=>Plt,detectLandmarks:()=>Klt,detectSingleFace:()=>Xlt,draw:()=>s2,env:()=>_e,euclideanDistance:()=>v2,extendWithAge:()=>dv,extendWithFaceDescriptor:()=>pv,extendWithFaceDetection:()=>Mi,extendWithFaceExpressions:()=>uv,extendWithFaceLandmarks:()=>el,extendWithGender:()=>mv,extractFaceTensors:()=>Kc,extractFaces:()=>jc,fetchImage:()=>ult,fetchJson:()=>Zk,fetchNetWeights:()=>clt,fetchOrThrow:()=>nu,getContext2dOrThrow:()=>br,getMediaDimensions:()=>Bi,imageTensorToCanvas:()=>Gx,imageToSquare:()=>Jk,inverseSigmoid:()=>OZ,iou:()=>Ax,isMediaElement:()=>ig,isMediaLoaded:()=>Af,isWithAge:()=>blt,isWithFaceDetection:()=>oo,isWithFaceExpressions:()=>e2,isWithFaceLandmarks:()=>su,isWithGender:()=>wlt,loadAgeGenderModel:()=>Hlt,loadFaceDetectionModel:()=>qlt,loadFaceExpressionModel:()=>Glt,loadFaceLandmarkModel:()=>Wlt,loadFaceLandmarkTinyModel:()=>Vlt,loadFaceRecognitionModel:()=>Ult,loadSsdMobilenetv1Model:()=>RR,loadTinyFaceDetectorModel:()=>Blt,loadTinyYolov2Model:()=>zlt,loadWeightMap:()=>Qk,locateFaces:()=>jlt,matchDimensions:()=>llt,minBbox:()=>_x,nets:()=>$e,nonMaxSuppression:()=>Fx,normalize:()=>Fs,padToSquare:()=>Rx,predictAgeAndGender:()=>Llt,recognizeFaceExpressions:()=>Mlt,resizeResults:()=>OR,resolveInput:()=>Li,shuffleArray:()=>PZ,sigmoid:()=>If,ssdMobilenetv1:()=>_R,tf:()=>Qlt,tinyFaceDetector:()=>Flt,tinyYolov2:()=>Rlt,toNetInput:()=>He,utils:()=>Ix,validateConfig:()=>l2,version:()=>nht});var Qlt=se(he()),s2={};kf(s2,{AnchorPosition:()=>ao,DrawBox:()=>og,DrawBoxOptions:()=>Wx,DrawFaceLandmarks:()=>r2,DrawFaceLandmarksOptions:()=>n2,DrawTextField:()=>Pa,DrawTextFieldOptions:()=>$f,drawContour:()=>zo,drawDetections:()=>GZ,drawFaceExpressions:()=>hlt,drawFaceLandmarks:()=>flt});function zo(o,a,i=!1){if(o.beginPath(),a.slice(1).forEach(({x:c,y:f},d)=>{let g=a[d];o.moveTo(g.x,g.y),o.lineTo(c,f)}),i){let c=a[a.length-1],f=a[0];if(!c||!f)return;o.moveTo(c.x,c.y),o.lineTo(f.x,f.y)}o.stroke()}var Ix={};kf(Ix,{computeReshapedDimensions:()=>$x,getCenterPoint:()=>Oi,isDimensions:()=>rg,isEven:()=>ng,isFloat:()=>Dx,isTensor:()=>Ri,isTensor1D:()=>RZ,isTensor2D:()=>Ex,isTensor3D:()=>Wo,isTensor4D:()=>Kr,isValidNumber:()=>_s,isValidProbablitiy:()=>xc,range:()=>ro,round:()=>Pi});var ZD=se(he()),or=class{constructor(a,i){if(!_s(a)||!_s(i))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:a,height:i})}`);this._width=a,this._height=i}get width(){return this._width}get height(){return this._height}reverse(){return new or(1/this.width,1/this.height)}};function Ri(o,a){return o instanceof ZD.Tensor&&o.shape.length===a}function RZ(o){return Ri(o,1)}function Ex(o){return Ri(o,2)}function Wo(o){return Ri(o,3)}function Kr(o){return Ri(o,4)}function Dx(o){return o%1!==0}function ng(o){return o%2===0}function Pi(o,a=2){let i=Math.pow(10,a);return Math.floor(o*i)/i}function rg(o){return o&&o.width&&o.height}function $x({width:o,height:a},i){let c=i/Math.max(a,o);return new or(Math.round(o*c),Math.round(a*c))}function Oi(o){return o.reduce((a,i)=>a.add(i),new ue(0,0)).div(new ue(o.length,o.length))}function ro(o,a,i){return Array(o).fill(0).map((c,f)=>a+f*i)}function _s(o){return!!o&&o!==Infinity&&o!==-Infinity&&!isNaN(o)||o===0}function xc(o){return _s(o)&&0<=o&&o<=1}var ue=class{constructor(a,i){this._x=a,this._y=i}get x(){return this._x}get y(){return this._y}add(a){return new ue(this.x+a.x,this.y+a.y)}sub(a){return new ue(this.x-a.x,this.y-a.y)}mul(a){return new ue(this.x*a.x,this.y*a.y)}div(a){return new ue(this.x/a.x,this.y/a.y)}abs(){return new ue(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))}floor(){return new ue(Math.floor(this.x),Math.floor(this.y))}},Le=class{static isRect(a){return!!a&&[a.x,a.y,a.width,a.height].every(_s)}static assertIsValidBox(a,i,c=!1){if(!Le.isRect(a))throw new Error(`${i} - invalid box: ${JSON.stringify(a)}, expected object with properties x, y, width, height`);if(!c&&(a.width<0||a.height<0))throw new Error(`${i} - width (${a.width}) and height (${a.height}) must be positive numbers`)}constructor(a,i=!0){let c=a||{},f=[c.left,c.top,c.right,c.bottom].every(_s),d=[c.x,c.y,c.width,c.height].every(_s);if(!d&&!f)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(c)}`);let[g,v,w,T]=d?[c.x,c.y,c.width,c.height]:[c.left,c.top,c.right-c.left,c.bottom-c.top];Le.assertIsValidBox({x:g,y:v,width:w,height:T},"Box.constructor",i),this._x=g,this._y=v,this._width=w,this._height=T}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new ue(this.left,this.top)}get topRight(){return new ue(this.right,this.top)}get bottomLeft(){return new ue(this.left,this.bottom)}get bottomRight(){return new ue(this.right,this.bottom)}round(){let[a,i,c,f]=[this.x,this.y,this.width,this.height].map(d=>Math.round(d));return new Le({x:a,y:i,width:c,height:f})}floor(){let[a,i,c,f]=[this.x,this.y,this.width,this.height].map(d=>Math.floor(d));return new Le({x:a,y:i,width:c,height:f})}toSquare(){let{x:a,y:i,width:c,height:f}=this,d=Math.abs(c-f);return c<f&&(a-=d/2,c+=d),f<c&&(i-=d/2,f+=d),new Le({x:a,y:i,width:c,height:f})}rescale(a){let i=rg(a)?a.width:a,c=rg(a)?a.height:a;return new Le({x:this.x*i,y:this.y*c,width:this.width*i,height:this.height*c})}pad(a,i){let[c,f,d,g]=[this.x-a/2,this.y-i/2,this.width+a,this.height+i];return new Le({x:c,y:f,width:d,height:g})}clipAtImageBorders(a,i){let{x:c,y:f,right:d,bottom:g}=this,v=Math.max(c,0),w=Math.max(f,0),T=d-v,N=g-w,E=Math.min(T,a-v),k=Math.min(N,i-w);return new Le({x:v,y:w,width:E,height:k}).floor()}shift(a,i){let{width:c,height:f}=this,d=this.x+a,g=this.y+i;return new Le({x:d,y:g,width:c,height:f})}padAtBorders(a,i){let c=this.width+1,f=this.height+1,d=1,g=1,v=c,w=f,T=this.left,N=this.top,E=this.right,k=this.bottom;return E>i&&(v=-E+i+c,E=i),k>a&&(w=-k+a+f,k=a),T<1&&(w=2-T,T=1),N<1&&(w=2-N,N=1),{dy:g,edy:w,dx:d,edx:v,y:N,ey:k,x:T,ex:E,w:c,h:f}}calibrate(a){return new Le({left:this.left+a.left*this.width,top:this.top+a.top*this.height,right:this.right+a.right*this.width,bottom:this.bottom+a.bottom*this.height}).toSquare().round()}},Tc=class extends Le{constructor(a,i,c,f,d=!1){super({left:a,top:i,right:c,bottom:f},d)}};var Fa=class{constructor(a,i,c,f,d){this._imageDims=new or(d.width,d.height),this._score=a,this._classScore=i,this._className=c,this._box=new Le(f).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Le(this._box).rescale(this.imageDims.reverse())}forSize(a,i){return new Fa(this.score,this.classScore,this.className,this.relativeBox,{width:a,height:i})}},qe=class extends Fa{constructor(a,i,c){super(a,a,"",i,c)}forSize(a,i){let{score:c,relativeBox:f,imageDims:d}=super.forSize(a,i);return new qe(c,f,d)}};function Ax(o,a,i=!0){let c=Math.max(0,Math.min(o.right,a.right)-Math.max(o.left,a.left)),f=Math.max(0,Math.min(o.bottom,a.bottom)-Math.max(o.top,a.top)),d=c*f;return i?d/(o.area+a.area-d):d/Math.min(o.area,a.area)}function _x(o){let a=o.map(v=>v.x),i=o.map(v=>v.y),c=a.reduce((v,w)=>w<v?w:v,Infinity),f=i.reduce((v,w)=>w<v?w:v,Infinity),d=a.reduce((v,w)=>v<w?w:v,0),g=i.reduce((v,w)=>v<w?w:v,0);return new Tc(c,f,d,g)}function Fx(o,a,i,c=!0){let f=a.map((g,v)=>({score:g,boxIndex:v})).sort((g,v)=>g.score-v.score).map(g=>g.boxIndex),d=[];for(;f.length>0;){let g=f.pop();d.push(g);let v=f,w=[];for(let T=0;T<v.length;T++){let N=v[T],E=o[g],k=o[N];w.push(Ax(E,k,c))}f=f.filter((T,N)=>w[N]<=i)}return d}var so=se(he());function Fs(o,a){return so.tidy(()=>{let[i,c,f]=a,d=so.fill([...o.shape.slice(0,3),1],i,"float32"),g=so.fill([...o.shape.slice(0,3),1],c,"float32"),v=so.fill([...o.shape.slice(0,3),1],f,"float32"),w=so.concat([d,g,v],3);return so.sub(o,w)})}var Ra=se(he());function Rx(o,a=!1){return Ra.tidy(()=>{let[i,c]=o.shape.slice(1);if(i===c)return o;let f=Math.abs(i-c),d=Math.round(f*(a?.5:1)),g=i>c?2:1,v=k=>{let $=o.shape.slice();return $[g]=k,Ra.fill($,0,"float32")},w=v(d),T=f-w.shape[g],N=a&&T?v(T):null,E=[N,o,w].filter(k=>!!k).map(k=>Ra.cast(k,"float32"));return Ra.concat(E,g)})}function PZ(o){let a=o.slice();for(let i=a.length-1;i>0;i--){let c=Math.floor(Math.random()*(i+1)),f=a[i];a[i]=a[c],a[c]=f}return a}function If(o){return 1/(1+Math.exp(-o))}function OZ(o){return Math.log(o/(1-o))}var kc=class extends Le{constructor(a,i,c,f,d=!1){super({x:a,y:i,width:c,height:f},d)}},MZ=.5,LZ=.43,BZ=.45,Xr=class{constructor(a,i,c=new ue(0,0)){let{width:f,height:d}=i;this._imgDims=new or(f,d),this._shift=c,this._positions=a.map(g=>g.mul(new ue(f,d)).add(c))}get shift(){return new ue(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(a=>a.sub(this._shift).div(new ue(this.imageWidth,this.imageHeight)))}forSize(a,i){return new this.constructor(this.relativePositions,{width:a,height:i})}shiftBy(a,i){return new this.constructor(this.relativePositions,this._imgDims,new ue(a,i))}shiftByPoint(a){return this.shiftBy(a.x,a.y)}align(a,i={}){if(a){let d=a instanceof qe?a.box.floor():new Le(a);return this.shiftBy(d.x,d.y).align(null,i)}let{useDlibAlignment:c,minBoxPadding:f}=Object.assign({},{useDlibAlignment:!1,minBoxPadding:.2},i);return c?this.alignDlib():this.alignMinBbox(f)}alignDlib(){let a=this.getRefPointsForAlignment(),[i,c,f]=a,d=E=>f.sub(E).magnitude(),g=(d(i)+d(c))/2,v=Math.floor(g/BZ),w=Oi(a),T=Math.floor(Math.max(0,w.x-MZ*v)),N=Math.floor(Math.max(0,w.y-LZ*v));return new kc(T,N,Math.min(v,this.imageWidth+T),Math.min(v,this.imageHeight+N))}alignMinBbox(a){let i=_x(this.positions);return i.pad(i.width*a,i.height*a)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}};var QD=class extends Xr{getRefPointsForAlignment(){let a=this.positions;return[a[0],a[1],Oi([a[3],a[4]])]}};var Sc=class extends Xr{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Oi)}};var Ef=class{constructor(a,i){this._label=a,this._distance=i}get label(){return this._label}get distance(){return this._distance}toString(a=!0){return`${this.label}${a?` (${Pi(this.distance)})`:""}`}};var Df=class extends Le{static assertIsValidLabeledBox(a,i){if(Le.assertIsValidBox(a,i),!_s(a.label))throw new Error(`${i} - expected property label (${a.label}) to be a number`)}constructor(a,i){super(a);this._label=i}get label(){return this._label}};var Vo=class{constructor(a,i){if(!(typeof a=="string"))throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(i)||i.some(c=>!(c instanceof Float32Array)))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=a,this._descriptors=i}get label(){return this._label}get descriptors(){return this._descriptors}toJSON(){return{label:this.label,descriptors:this.descriptors.map(a=>Array.from(a))}}static fromJSON(a){let i=a.descriptors.map(c=>new Float32Array(c));return new Vo(a.label,i)}};var t$=class extends Df{static assertIsValidPredictedBox(a,i){if(Df.assertIsValidLabeledBox(a,i),!xc(a.score)||!xc(a.classScore))throw new Error(`${i} - expected properties score (${a.score}) and (${a.classScore}) to be a number between [0, 1]`)}constructor(a,i,c,f){super(a,i);this._score=c,this._classScore=f}get score(){return this._score}get classScore(){return this._classScore}};function oo(o){return o.detection instanceof qe}function Mi(o,a){let i={detection:a};return Object.assign({},o,i)}function Px(){let o=window.fetch||function(){throw new Error("fetch - missing fetch implementation for browser environment")},a=function(){throw new Error("readFile - filesystem not available for browser environment")};return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),fetch:o,readFile:a}}function sg(o){let a="";if(!o)try{o=require("fs")}catch(c){a=c.toString()}let i=o?function(c){return new Promise((f,d)=>{o.readFile(c,function(g,v){return g?d(g):f(v)})})}:function(){throw new Error(`readFile - failed to require fs in nodejs environment with error: ${a}`)};return{readFile:i}}function Ox(){let o=global.Canvas||global.HTMLCanvasElement,a=global.Image||global.HTMLImageElement,i=function(){if(o)return new o;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},c=function(){if(a)return new a;throw new Error("createImageElement - missing Image implementation for nodejs environment")},f=global.fetch||function(){throw new Error("fetch - missing fetch implementation for nodejs environment")},d=sg();return{Canvas:o||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:a||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:i,createImageElement:c,fetch:f,...d}}function Mx(){return typeof window=="object"&&typeof document!="undefined"&&typeof HTMLImageElement!="undefined"&&typeof HTMLCanvasElement!="undefined"&&typeof HTMLVideoElement!="undefined"&&typeof ImageData!="undefined"&&typeof CanvasRenderingContext2D!="undefined"}var Lx=se(n$()),Pn;function VZ(){if(!Pn)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Pn}function Bx(o){Pn=o}function zx(){if(Mx())return Bx(Px());if(Lx.isNodejs())return Bx(Ox())}function UZ(o){if(Pn||zx(),!Pn)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:a=Pn.Canvas,Image:i=Pn.Image}=o;Pn.Canvas=a,Pn.Image=i,Pn.createCanvasElement=o.createCanvasElement||(()=>new a),Pn.createImageElement=o.createImageElement||(()=>new i),Pn.ImageData=o.ImageData||Pn.ImageData,Pn.Video=o.Video||Pn.Video,Pn.fetch=o.fetch||Pn.fetch,Pn.readFile=o.readFile||Pn.readFile}var _e={getEnv:VZ,setEnv:Bx,initialize:zx,createBrowserEnv:Px,createFileSystem:sg,createNodejsEnv:Ox,monkeyPatch:UZ,isBrowser:Mx,isNodejs:Lx.isNodejs};zx();function Li(o){return!_e.isNodejs()&&typeof o=="string"?document.getElementById(o):o}function br(o){let{Canvas:a,CanvasRenderingContext2D:i}=_e.getEnv();if(o instanceof i)return o;let c=Li(o);if(!(c instanceof a))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let f=c.getContext("2d");if(!f)throw new Error("resolveContext2d - canvas 2d context is null");return f}var ao;(function(o){o.TOP_LEFT="TOP_LEFT",o.TOP_RIGHT="TOP_RIGHT",o.BOTTOM_LEFT="BOTTOM_LEFT",o.BOTTOM_RIGHT="BOTTOM_RIGHT"})(ao||(ao={}));var $f=class{constructor(a={}){let{anchorPosition:i,backgroundColor:c,fontColor:f,fontSize:d,fontStyle:g,padding:v}=a;this.anchorPosition=i||ao.TOP_LEFT,this.backgroundColor=c||"rgba(0, 0, 0, 0.5)",this.fontColor=f||"rgba(255, 255, 255, 1)",this.fontSize=d||14,this.fontStyle=g||"Georgia",this.padding=v||4}},Pa=class{constructor(a,i,c={}){this.text=typeof a=="string"?[a]:a instanceof Pa?a.text:a,this.anchor=i,this.options=new $f(c)}measureWidth(a){let{padding:i}=this.options;return this.text.map(c=>a.measureText(c).width).reduce((c,f)=>c<f?f:c,0)+2*i}measureHeight(){let{fontSize:a,padding:i}=this.options;return this.text.length*a+2*i}getUpperLeft(a,i){let{anchorPosition:c}=this.options,f=c===ao.BOTTOM_RIGHT||c===ao.TOP_RIGHT,d=c===ao.BOTTOM_LEFT||c===ao.BOTTOM_RIGHT,g=this.measureWidth(a),v=this.measureHeight(),w=f?this.anchor.x-g:this.anchor.x,T=d?this.anchor.y-v:this.anchor.y;if(i){let{width:N,height:E}=i,k=Math.max(Math.min(w,N-g),0),$=Math.max(Math.min(T,E-v),0);return{x:k,y:$}}return{x:w,y:T}}draw(a){let i=Li(a),c=br(i),{backgroundColor:f,fontColor:d,fontSize:g,fontStyle:v,padding:w}=this.options;c.font=`${g}px ${v}`;let T=this.measureWidth(c),N=this.measureHeight();c.fillStyle=f;let E=this.getUpperLeft(c,i);c.fillRect(E.x,E.y,T,N),c.fillStyle=d,this.text.forEach((k,$)=>{let M=w+E.x,G=w+E.y+($+1)*g;c.fillText(k,M,G)})}},Wx=class{constructor(a={}){let{boxColor:i,lineWidth:c,label:f,drawLabelOptions:d}=a;this.boxColor=i||"rgba(0, 0, 255, 1)",this.lineWidth=c||2,this.label=f;let g={anchorPosition:ao.BOTTOM_LEFT,backgroundColor:this.boxColor};this.drawLabelOptions=new $f(Object.assign({},g,d))}},og=class{constructor(a,i={}){this.box=new Le(a),this.options=new Wx(i)}draw(a){let i=br(a),{boxColor:c,lineWidth:f}=this.options,{x:d,y:g,width:v,height:w}=this.box;i.strokeStyle=c,i.lineWidth=f,i.strokeRect(d,g,v,w);let{label:T}=this.options;T&&new Pa([T],{x:d-f/2,y:g},this.options.drawLabelOptions).draw(a)}};function GZ(o,a){let i=Array.isArray(a)?a:[a];i.forEach(c=>{let f=c instanceof qe?c.score:oo(c)?c.detection.score:void 0,d=c instanceof qe?c.box:oo(c)?c.detection.box:new Le(c),g=f?`${Pi(f)}`:void 0;new og(d,{label:g}).draw(o)})}var tl=se(he());function Af(o){let{Image:a,Video:i}=_e.getEnv();return o instanceof a&&o.complete||o instanceof i&&o.readyState>=3}function Vx(o){return new Promise((a,i)=>{if(o instanceof _e.getEnv().Canvas||Af(o))return a(null);function c(d){if(!d.currentTarget)return;d.currentTarget.removeEventListener("load",c),d.currentTarget.removeEventListener("error",f),a(d)}function f(d){if(!d.currentTarget)return;d.currentTarget.removeEventListener("load",c),d.currentTarget.removeEventListener("error",f),i(d)}o.addEventListener("load",c),o.addEventListener("error",f)})}function Ux(o){return new Promise((a,i)=>{if(!(o instanceof Blob))return i("bufferToImage - expected buf to be of type: Blob");let c=new FileReader;c.onload=()=>{if(typeof c.result!="string")return i("bufferToImage - expected reader.result to be a string, in onload");let f=_e.getEnv().createImageElement();f.onload=()=>a(f),f.onerror=i,f.src=c.result},c.onerror=i,c.readAsDataURL(o)})}function Bi(o){let{Image:a,Video:i}=_e.getEnv();return o instanceof a?new or(o.naturalWidth,o.naturalHeight):o instanceof i?new or(o.videoWidth,o.videoHeight):new or(o.width,o.height)}function Cc({width:o,height:a}){let{createCanvasElement:i}=_e.getEnv(),c=i();return c.width=o,c.height=a,c}function _f(o,a){let{ImageData:i}=_e.getEnv();if(!(o instanceof i)&&!Af(o))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:c,height:f}=a||Bi(o),d=Cc({width:c,height:f});return o instanceof i?br(d).putImageData(o,0,0):br(d).drawImage(o,0,0,c,f),d}var ag=se(he());async function Gx(o,a){let i=a||_e.getEnv().createCanvasElement(),[c,f,d]=o.shape.slice(Kr(o)?1:0),g=ag.tidy(()=>o.as3D(c,f,d).toInt());return await ag.browser.toPixels(g,i),g.dispose(),i}function ig(o){let{Image:a,Canvas:i,Video:c}=_e.getEnv();return o instanceof a||o instanceof i||o instanceof c}var cs=se(KF());function Jk(o,a,i=!1){let{Image:c,Canvas:f}=_e.getEnv();if(!(o instanceof c||o instanceof f))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");let d=Bi(o),g=a/Math.max(d.height,d.width),v=g*d.width,w=g*d.height,T=Cc({width:a,height:a}),N=o instanceof f?o:_f(o),E=Math.abs(v-w)/2,k=i&&v<w?E:0,$=i&&w<v?E:0;return br(T).drawImage(N,k,$,v,w),T}var Yo=class{constructor(a,i=!1){this._imageTensors=[];this._canvases=[];this._treatAsBatchInput=!1;this._inputDimensions=[];if(!Array.isArray(a))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${a}`);this._treatAsBatchInput=i,this._batchSize=a.length,a.forEach((c,f)=>{if(Wo(c)){this._imageTensors[f]=c,this._inputDimensions[f]=c.shape;return}if(Kr(c)){let g=c.shape[0];if(g!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${g} passed, but not supported in input array`);this._imageTensors[f]=c,this._inputDimensions[f]=c.shape.slice(1);return}let d=c instanceof _e.getEnv().Canvas?c:_f(c);this._canvases[f]=d,this._inputDimensions[f]=[d.height,d.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return ro(this.batchSize,0,1).map((a,i)=>this.getReshapedInputDimensions(i))}getInput(a){return this.canvases[a]||this.imageTensors[a]}getInputDimensions(a){return this._inputDimensions[a]}getInputHeight(a){return this._inputDimensions[a][0]}getInputWidth(a){return this._inputDimensions[a][1]}getReshapedInputDimensions(a){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let i=this.getInputWidth(a),c=this.getInputHeight(a);return $x({width:i,height:c},this.inputSize)}toBatchTensor(a,i=!0){return this._inputSize=a,cs.tidy(()=>{let c=ro(this.batchSize,0,1).map(d=>{let g=this.getInput(d);if(g instanceof cs.Tensor){let v=Kr(g)?g:g.expandDims();return v=Rx(v,i),(v.shape[1]!==a||v.shape[2]!==a)&&(v=cs.image.resizeBilinear(v,[a,a])),v.as3D(a,a,3)}if(g instanceof _e.getEnv().Canvas)return cs.browser.fromPixels(Jk(g,a,i));throw new Error(`toBatchTensor - at batchIdx ${d}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${g}`)}),f=cs.stack(c.map(d=>cs.cast(d,"float32"))).as4D(this.batchSize,a,a,3);return f})}};async function He(o){if(o instanceof Yo)return o;let a=Array.isArray(o)?o:[o];if(!a.length)throw new Error("toNetInput - empty array passed as input");let i=f=>Array.isArray(o)?` at input index ${f}:`:"",c=a.map(Li);return c.forEach((f,d)=>{if(!ig(f)&&!Wo(f)&&!Kr(f))throw typeof a[d]=="string"?new Error(`toNetInput -${i(d)} string passed, but could not resolve HTMLElement for element id ${a[d]}`):new Error(`toNetInput -${i(d)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(Kr(f)){let g=f.shape[0];if(g!==1)throw new Error(`toNetInput -${i(d)} tf.Tensor4D with batchSize ${g} passed, but not supported in input array`)}}),await Promise.all(c.map(f=>ig(f)&&Vx(f))),new Yo(c,Array.isArray(o))}async function jc(o,a){let{Canvas:i}=_e.getEnv(),c=o;if(!(o instanceof i)){let g=await He(o);if(g.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let v=g.getInput(0);c=v instanceof i?v:await Gx(v)}let f=br(c),d=a.map(g=>g instanceof qe?g.forSize(c.width,c.height).box.floor():g).map(g=>g.clipAtImageBorders(c.width,c.height));return d.map(({x:g,y:v,width:w,height:T})=>{let N=Cc({width:w,height:T});return br(N).putImageData(f.getImageData(g,v,w,T),0,0),N})}var Yg=se(he());async function Kc(o,a){if(!Wo(o)&&!Kr(o))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Kr(o)&&o.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return Yg.tidy(()=>{let[i,c,f]=o.shape.slice(Kr(o)?1:0),d=a.map(v=>v instanceof qe?v.forSize(c,i).box:v).map(v=>v.clipAtImageBorders(c,i)),g=d.map(({x:v,y:w,width:T,height:N})=>Yg.slice3d(o.as3D(i,c,f),[w,v,0],[N,T,f]));return g})}async function nu(o,a){let i=_e.getEnv().fetch,c=await i(o,a);if(!(c.status<400))throw new Error(`failed to fetch: (${c.status}) ${c.statusText}, from url: ${c.url}`);return c}async function ult(o){let a=await nu(o),i=await a.blob();if(!i.type.startsWith("image/"))throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${i.type}, for url: ${a.url}`);return Ux(i)}async function Zk(o){return(await nu(o)).json()}async function clt(o){return new Float32Array(await(await nu(o)).arrayBuffer())}var XF=se(he());function Jg(o,a){let i=`${a}-weights_manifest.json`;if(!o)return{modelBaseUri:"",manifestUri:i};if(o==="/")return{modelBaseUri:"/",manifestUri:`/${i}`};let c=o.startsWith("http://")?"http://":o.startsWith("https://")?"https://":"";o=o.replace(c,"");let f=o.split("/").filter(v=>v),d=o.endsWith(".json")?f[f.length-1]:i,g=c+(o.endsWith(".json")?f.slice(0,f.length-1):f).join("/");return g=o.startsWith("/")?`/${g}`:g,{modelBaseUri:g,manifestUri:g==="/"?`/${d}`:`${g}/${d}`}}async function Qk(o,a){let{manifestUri:i,modelBaseUri:c}=Jg(o,a),f=await Zk(i);return XF.io.loadWeights(f,c)}function llt(o,a,i=!1){let{width:c,height:f}=i?Bi(a):a;return o.width=c,o.height=f,{width:c,height:f}}var Ka=se(he()),Jo=se(he()),jn=class{constructor(a){this._name=a;this._params=void 0;this._paramMappings=[]}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(a){let{obj:i,objProp:c}=this.traversePropertyPath(a);return i[c]}reassignParamFromPath(a,i){let{obj:c,objProp:f}=this.traversePropertyPath(a);c[f].dispose(),c[f]=i}getParamList(){return this._paramMappings.map(({paramPath:a})=>({path:a,tensor:this.getParamFromPath(a)}))}getTrainableParams(){return this.getParamList().filter(a=>a.tensor instanceof Jo.Variable)}getFrozenParams(){return this.getParamList().filter(a=>!(a.tensor instanceof Jo.Variable))}variable(){this.getFrozenParams().forEach(({path:a,tensor:i})=>{this.reassignParamFromPath(a,i.variable())})}freeze(){this.getTrainableParams().forEach(({path:a,tensor:i})=>{let c=Jo.tensor(i.dataSync());i.dispose(),this.reassignParamFromPath(a,c)})}dispose(a=!0){this.getParamList().forEach(i=>{if(a&&i.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${i.path}`);i.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:a})=>Array.from(a.dataSync())).reduce((a,i)=>a.concat(i)))}async load(a){if(a instanceof Float32Array){this.extractWeights(a);return}await this.loadFromUri(a)}async loadFromUri(a){if(a&&typeof a!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let i=await Qk(a,this.getDefaultModelName());this.loadFromWeightMap(i)}async loadFromDisk(a){if(a&&typeof a!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:i}=_e.getEnv(),{manifestUri:c,modelBaseUri:f}=Jg(a,this.getDefaultModelName()),d=T=>Promise.all(T.map(N=>i(N).then(E=>E.buffer))),g=Jo.io.weightsLoaderFactory(d),v=JSON.parse((await i(c)).toString()),w=await g(v,f);this.loadFromWeightMap(w)}loadFromWeightMap(a){let{paramMappings:i,params:c}=this.extractParamsFromWeigthMap(a);this._paramMappings=i,this._params=c}extractWeights(a){let{paramMappings:i,params:c}=this.extractParams(a);this._paramMappings=i,this._params=c}traversePropertyPath(a){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let i=a.split("/").reduce((d,g)=>{if(!d.nextObj.hasOwnProperty(g))throw new Error(`traversePropertyPath - object does not have property ${g}, for path ${a}`);return{obj:d.nextObj,objProp:g,nextObj:d.nextObj[g]}},{nextObj:this.params}),{obj:c,objProp:f}=i;if(!c||!f||!(c[f]instanceof Jo.Tensor))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${a}`);return{obj:c,objProp:f}}},je=se(he()),Xc=se(he());function kr(o,a,i){return Xc.tidy(()=>{let c=Xc.separableConv2d(o,a.depthwise_filter,a.pointwise_filter,i,"same");return c=Xc.add(c,a.bias),c})}function Zg(o,a,i=!1){return je.tidy(()=>{let c=je.relu(i?je.add(je.conv2d(o,a.conv0.filters,[2,2],"same"),a.conv0.bias):kr(o,a.conv0,[2,2])),f=kr(c,a.conv1,[1,1]),d=je.relu(je.add(c,f)),g=kr(d,a.conv2,[1,1]);return je.relu(je.add(c,je.add(f,g)))})}function Qf(o,a,i=!1,c=!0){return je.tidy(()=>{let f=je.relu(i?je.add(je.conv2d(o,a.conv0.filters,c?[2,2]:[1,1],"same"),a.conv0.bias):kr(o,a.conv0,c?[2,2]:[1,1])),d=kr(f,a.conv1,[1,1]),g=je.relu(je.add(f,d)),v=kr(g,a.conv2,[1,1]),w=je.relu(je.add(f,je.add(d,v))),T=kr(w,a.conv3,[1,1]);return je.relu(je.add(f,je.add(d,je.add(v,T))))})}var ja=se(he());function ru(o,a,i="same",c=!1){return ja.tidy(()=>{let f=ja.add(ja.conv2d(o,a.filters,[1,1],i),a.bias);return c?ja.relu(f):f})}function ar(o,a){Object.keys(o).forEach(i=>{a.some(c=>c.originalPath===i)||o[i].dispose()})}var Qg=se(he());function Yc(o,a){return function(i,c,f,d){let g=Qg.tensor4d(o(i*c*f*f),[f,f,i,c]),v=Qg.tensor1d(o(c));return a.push({paramPath:`${d}/filters`},{paramPath:`${d}/bias`}),{filters:g,bias:v}}}var tv=se(he());function ev(o,a){return function(i,c,f){let d=tv.tensor2d(o(i*c),[i,c]),g=tv.tensor1d(o(c));return a.push({paramPath:`${f}/weights`},{paramPath:`${f}/bias`}),{weights:d,bias:g}}}var tp=se(he()),nv=class{constructor(a,i,c){this.depthwise_filter=a;this.pointwise_filter=i;this.bias=c}};function Jc(o,a){return function(i,c,f){let d=tp.tensor4d(o(3*3*i),[3,3,i,1]),g=tp.tensor4d(o(i*c),[1,1,i,c]),v=tp.tensor1d(o(c));return a.push({paramPath:`${f}/depthwise_filter`},{paramPath:`${f}/pointwise_filter`},{paramPath:`${f}/bias`}),new nv(d,g,v)}}function Zc(o){return function(a){let i=o(`${a}/depthwise_filter`,4),c=o(`${a}/pointwise_filter`,4),f=o(`${a}/bias`,1);return new nv(i,c,f)}}function Fr(o,a){return function(i,c,f){let d=o[i];if(!Ri(d,c))throw new Error(`expected weightMap[${i}] to be a Tensor${c}D, instead have ${d}`);return a.push({originalPath:i,paramPath:f||i}),d}}function ir(o){let a=o;function i(f){let d=a.slice(0,f);return a=a.slice(f),d}function c(){return a}return{extractWeights:i,getRemainingWeights:c}}function rv(o,a){let i=Yc(o,a),c=Jc(o,a);function f(g,v,w,T=!1){let N=T?i(g,v,3,`${w}/conv0`):c(g,v,`${w}/conv0`),E=c(v,v,`${w}/conv1`),k=c(v,v,`${w}/conv2`);return{conv0:N,conv1:E,conv2:k}}function d(g,v,w,T=!1){let{conv0:N,conv1:E,conv2:k}=f(g,v,w,T),$=c(v,v,`${w}/conv3`);return{conv0:N,conv1:E,conv2:k,conv3:$}}return{extractDenseBlock3Params:f,extractDenseBlock4Params:d}}function YF(o){let a=[],{extractWeights:i,getRemainingWeights:c}=ir(o),{extractDenseBlock4Params:f}=rv(i,a),d=f(3,32,"dense0",!0),g=f(32,64,"dense1"),v=f(64,128,"dense2"),w=f(128,256,"dense3");if(c().length!==0)throw new Error(`weights remaing after extract: ${c().length}`);return{paramMappings:a,params:{dense0:d,dense1:g,dense2:v,dense3:w}}}function sv(o){return function(a){let i=o(`${a}/filters`,4),c=o(`${a}/bias`,1);return{filters:i,bias:c}}}function ov(o,a){let i=Fr(o,a),c=sv(i),f=Zc(i);function d(v,w=!1){let T=w?c(`${v}/conv0`):f(`${v}/conv0`),N=f(`${v}/conv1`),E=f(`${v}/conv2`);return{conv0:T,conv1:N,conv2:E}}function g(v,w=!1){let T=w?c(`${v}/conv0`):f(`${v}/conv0`),N=f(`${v}/conv1`),E=f(`${v}/conv2`),k=f(`${v}/conv3`);return{conv0:T,conv1:N,conv2:E,conv3:k}}return{extractDenseBlock3Params:d,extractDenseBlock4Params:g}}function JF(o){let a=[],{extractDenseBlock4Params:i}=ov(o,a),c={dense0:i("dense0",!0),dense1:i("dense1"),dense2:i("dense2"),dense3:i("dense3")};return ar(o,a),{params:c,paramMappings:a}}var ep=class extends jn{constructor(){super("FaceFeatureExtractor")}forwardInput(a){let{params:i}=this;if(!i)throw new Error("FaceFeatureExtractor - load model before inference");return Ka.tidy(()=>{let c=Ka.cast(a.toBatchTensor(112,!0),"float32"),f=[122.782,117.001,104.298],d=Fs(c,f).div(Ka.scalar(255)),g=Qf(d,i.dense0,!0);return g=Qf(g,i.dense1),g=Qf(g,i.dense2),g=Qf(g,i.dense3),g=Ka.avgPool(g,[7,7],[2,2],"valid"),g})}async forward(a){return this.forwardInput(await He(a))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeigthMap(a){return JF(a)}extractParams(a){return YF(a)}},tR=se(he()),Qc=se(he());function np(o,a){return Qc.tidy(()=>Qc.add(Qc.matMul(o,a.weights),a.bias))}function ZF(o,a,i){let c=[],{extractWeights:f,getRemainingWeights:d}=ir(o),g=ev(f,c),v=g(a,i,"fc");if(d().length!==0)throw new Error(`weights remaing after extract: ${d().length}`);return{paramMappings:c,params:{fc:v}}}function QF(o){let a=[],i=Fr(o,a);function c(d){let g=i(`${d}/weights`,2),v=i(`${d}/bias`,1);return{weights:g,bias:v}}let f={fc:c("fc")};return ar(o,a),{params:f,paramMappings:a}}function av(o){let a={},i={};return Object.keys(o).forEach(c=>{let f=c.startsWith("fc")?i:a;f[c]=o[c]}),{featureExtractorMap:a,classifierMap:i}}var rp=class extends jn{constructor(a,i){super(a);this._faceFeatureExtractor=i}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(a){let{params:i}=this;if(!i)throw new Error(`${this._name} - load model before inference`);return tR.tidy(()=>{let c=a instanceof Yo?this.faceFeatureExtractor.forwardInput(a):a;return np(c.as2D(c.shape[0],-1),i.fc)})}dispose(a=!0){this.faceFeatureExtractor.dispose(a),super.dispose(a)}loadClassifierParams(a){let{params:i,paramMappings:c}=this.extractClassifierParams(a);this._params=i,this._paramMappings=c}extractClassifierParams(a){return ZF(a,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeigthMap(a){let{featureExtractorMap:i,classifierMap:c}=av(a);return this.faceFeatureExtractor.loadFromWeightMap(i),QF(c)}extractParams(a){let i=this.getClassifierChannelsIn(),c=this.getClassifierChannelsOut(),f=c*i+c,d=a.slice(0,a.length-f),g=a.slice(a.length-f);return this.faceFeatureExtractor.extractWeights(d),this.extractClassifierParams(g)}},t2=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Xa=class{constructor(a){if(a.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${a.length}`);t2.forEach((i,c)=>{this[i]=a[c]})}asSortedArray(){return t2.map(a=>({expression:a,probability:this[a]})).sort((a,i)=>i.probability-a.probability)}},iv=class extends rp{constructor(a=new ep){super("FaceExpressionNet",a)}forwardInput(a){return tl.tidy(()=>tl.softmax(this.runNet(a)))}async forward(a){return this.forwardInput(await He(a))}async predictExpressions(a){let i=await He(a),c=await this.forwardInput(i),f=await Promise.all(tl.unstack(c).map(async g=>{let v=await g.data();return g.dispose(),v}));c.dispose();let d=f.map(g=>new Xa(g));return i.isBatchInput?d:d[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function e2(o){return o.expressions instanceof Xa}function uv(o,a){let i={expressions:a};return Object.assign({},o,i)}function hlt(o,a,i=.1,c){let f=Array.isArray(a)?a:[a];f.forEach(d=>{let g=d instanceof Xa?d:e2(d)?d.expressions:void 0;if(!g)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let v=g.asSortedArray(),w=v.filter(E=>E.probability>i),T=oo(d)?d.detection.box.bottomLeft:c||new ue(0,0),N=new Pa(w.map(E=>`${E.expression} (${Pi(E.probability)})`),T);N.draw(o)})}function su(o){return oo(o)&&o.landmarks instanceof Xr&&o.unshiftedLandmarks instanceof Xr&&o.alignedRect instanceof qe}function el(o,a){let{box:i}=o.detection,c=a.shiftBy(i.x,i.y),f=c.align(),{imageDims:d}=o.detection,g=new qe(o.detection.score,f.rescale(d.reverse()),d),v={landmarks:c,unshiftedLandmarks:a,alignedRect:g};return Object.assign({},o,v)}var n2=class{constructor(a={}){let{drawLines:i=!0,drawPoints:c=!0,lineWidth:f,lineColor:d,pointSize:g,pointColor:v}=a;this.drawLines=i,this.drawPoints=c,this.lineWidth=f||1,this.pointSize=g||2,this.lineColor=d||"rgba(0, 255, 255, 1)",this.pointColor=v||"rgba(255, 0, 255, 1)"}},r2=class{constructor(a,i={}){this.faceLandmarks=a,this.options=new n2(i)}draw(a){let i=br(a),{drawLines:c,drawPoints:f,lineWidth:d,lineColor:g,pointSize:v,pointColor:w}=this.options;if(c&&this.faceLandmarks instanceof Sc&&(i.strokeStyle=g,i.lineWidth=d,zo(i,this.faceLandmarks.getJawOutline()),zo(i,this.faceLandmarks.getLeftEyeBrow()),zo(i,this.faceLandmarks.getRightEyeBrow()),zo(i,this.faceLandmarks.getNose()),zo(i,this.faceLandmarks.getLeftEye(),!0),zo(i,this.faceLandmarks.getRightEye(),!0),zo(i,this.faceLandmarks.getMouth(),!0)),f){i.strokeStyle=w,i.fillStyle=w;let T=N=>{i.beginPath(),i.arc(N.x,N.y,v,0,2*Math.PI),i.fill()};this.faceLandmarks.positions.forEach(T)}}};function flt(o,a){let i=Array.isArray(a)?a:[a];i.forEach(c=>{let f=c instanceof Xr?c:su(c)?c.landmarks:void 0;if(!f)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new r2(f).draw(o)})}var fo=se(he()),yn=se(he());function plt(o,a){let i=Yc(o,a),c=Jc(o,a);function f(g,v,w){let T=c(g,v,`${w}/separable_conv0`),N=c(v,v,`${w}/separable_conv1`),E=i(g,v,1,`${w}/expansion_conv`);return{separable_conv0:T,separable_conv1:N,expansion_conv:E}}function d(g,v){let w=c(g,g,`${v}/separable_conv0`),T=c(g,g,`${v}/separable_conv1`),N=c(g,g,`${v}/separable_conv2`);return{separable_conv0:w,separable_conv1:T,separable_conv2:N}}return{extractConvParams:i,extractSeparableConvParams:c,extractReductionBlockParams:f,extractMainBlockParams:d}}function eR(o,a){let i=[],{extractWeights:c,getRemainingWeights:f}=ir(o),{extractConvParams:d,extractSeparableConvParams:g,extractReductionBlockParams:v,extractMainBlockParams:w}=plt(c,i),T=d(3,32,3,"entry_flow/conv_in"),N=v(32,64,"entry_flow/reduction_block_0"),E=v(64,128,"entry_flow/reduction_block_1"),k={conv_in:T,reduction_block_0:N,reduction_block_1:E},$={};ro(a,0,1).forEach(H=>{$[`main_block_${H}`]=w(128,`middle_flow/main_block_${H}`)});let M=v(128,256,"exit_flow/reduction_block"),G=g(256,512,"exit_flow/separable_conv"),O={reduction_block:M,separable_conv:G};if(f().length!==0)throw new Error(`weights remaing after extract: ${f().length}`);return{paramMappings:i,params:{entry_flow:k,middle_flow:$,exit_flow:O}}}function dlt(o,a){let i=Fr(o,a),c=sv(i),f=Zc(i);function d(v){let w=f(`${v}/separable_conv0`),T=f(`${v}/separable_conv1`),N=c(`${v}/expansion_conv`);return{separable_conv0:w,separable_conv1:T,expansion_conv:N}}function g(v){let w=f(`${v}/separable_conv0`),T=f(`${v}/separable_conv1`),N=f(`${v}/separable_conv2`);return{separable_conv0:w,separable_conv1:T,separable_conv2:N}}return{extractConvParams:c,extractSeparableConvParams:f,extractReductionBlockParams:d,extractMainBlockParams:g}}function nR(o,a){let i=[],{extractConvParams:c,extractSeparableConvParams:f,extractReductionBlockParams:d,extractMainBlockParams:g}=dlt(o,i),v=c("entry_flow/conv_in"),w=d("entry_flow/reduction_block_0"),T=d("entry_flow/reduction_block_1"),N={conv_in:v,reduction_block_0:w,reduction_block_1:T},E={};ro(a,0,1).forEach(G=>{E[`main_block_${G}`]=g(`middle_flow/main_block_${G}`)});let k=d("exit_flow/reduction_block"),$=f("exit_flow/separable_conv"),M={reduction_block:k,separable_conv:$};return ar(o,i),{params:{entry_flow:N,middle_flow:E,exit_flow:M},paramMappings:i}}function rR(o,a,i){return yn.add(yn.conv2d(o,a.filters,i,"same"),a.bias)}function o2(o,a,i=!0){let c=i?yn.relu(o):o;return c=kr(c,a.separable_conv0,[1,1]),c=kr(yn.relu(c),a.separable_conv1,[1,1]),c=yn.maxPool(c,[3,3],[2,2],"same"),c=yn.add(c,rR(o,a.expansion_conv,[2,2])),c}function mlt(o,a){let i=kr(yn.relu(o),a.separable_conv0,[1,1]);return i=kr(yn.relu(i),a.separable_conv1,[1,1]),i=kr(yn.relu(i),a.separable_conv2,[1,1]),i=yn.add(i,o),i}var a2=class extends jn{constructor(a){super("TinyXception");this._numMainBlocks=a}forwardInput(a){let{params:i}=this;if(!i)throw new Error("TinyXception - load model before inference");return yn.tidy(()=>{let c=yn.cast(a.toBatchTensor(112,!0),"float32"),f=[122.782,117.001,104.298],d=Fs(c,f).div(yn.scalar(256)),g=yn.relu(rR(d,i.entry_flow.conv_in,[2,2]));return g=o2(g,i.entry_flow.reduction_block_0,!1),g=o2(g,i.entry_flow.reduction_block_1),ro(this._numMainBlocks,0,1).forEach(v=>{g=mlt(g,i.middle_flow[`main_block_${v}`])}),g=o2(g,i.exit_flow.reduction_block),g=yn.relu(kr(g,i.exit_flow.separable_conv,[1,1])),g})}async forward(a){return this.forwardInput(await He(a))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeigthMap(a){return nR(a,this._numMainBlocks)}extractParams(a){return eR(a,this._numMainBlocks)}};function sR(o){let a=[],{extractWeights:i,getRemainingWeights:c}=ir(o),f=ev(i,a),d=f(512,1,"fc/age"),g=f(512,2,"fc/gender");if(c().length!==0)throw new Error(`weights remaing after extract: ${c().length}`);return{paramMappings:a,params:{fc:{age:d,gender:g}}}}function oR(o){let a=[],i=Fr(o,a);function c(d){let g=i(`${d}/weights`,2),v=i(`${d}/bias`,1);return{weights:g,bias:v}}let f={fc:{age:c("fc/age"),gender:c("fc/gender")}};return ar(o,a),{params:f,paramMappings:a}}var Zo;(function(o){o.FEMALE="female",o.MALE="male"})(Zo||(Zo={}));var cv=class extends jn{constructor(a=new a2(2)){super("AgeGenderNet");this._faceFeatureExtractor=a}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(a){let{params:i}=this;if(!i)throw new Error(`${this._name} - load model before inference`);return fo.tidy(()=>{let c=a instanceof Yo?this.faceFeatureExtractor.forwardInput(a):a,f=fo.avgPool(c,[7,7],[2,2],"valid").as2D(c.shape[0],-1),d=np(f,i.fc.age).as1D(),g=np(f,i.fc.gender);return{age:d,gender:g}})}forwardInput(a){return fo.tidy(()=>{let{age:i,gender:c}=this.runNet(a);return{age:i,gender:fo.softmax(c)}})}async forward(a){return this.forwardInput(await He(a))}async predictAgeAndGender(a){let i=await He(a),c=await this.forwardInput(i),f=fo.unstack(c.age),d=fo.unstack(c.gender),g=f.map((w,T)=>({ageTensor:w,genderTensor:d[T]})),v=await Promise.all(g.map(async({ageTensor:w,genderTensor:T})=>{let N=(await w.data())[0],E=(await T.data())[0],k=E>.5,$=k?Zo.MALE:Zo.FEMALE,M=k?E:1-E;return w.dispose(),T.dispose(),{age:N,gender:$,genderProbability:M}}));return c.age.dispose(),c.gender.dispose(),i.isBatchInput?v:v[0]}getDefaultModelName(){return"age_gender_model"}dispose(a=!0){this.faceFeatureExtractor.dispose(a),super.dispose(a)}loadClassifierParams(a){let{params:i,paramMappings:c}=this.extractClassifierParams(a);this._params=i,this._paramMappings=c}extractClassifierParams(a){return sR(a)}extractParamsFromWeigthMap(a){let{featureExtractorMap:i,classifierMap:c}=av(a);return this.faceFeatureExtractor.loadFromWeightMap(i),oR(c)}extractParams(a){let i=512*1+1+(512*2+2),c=a.slice(0,a.length-i),f=a.slice(a.length-i);return this.faceFeatureExtractor.extractWeights(c),this.extractClassifierParams(f)}};var Rr=se(he()),sp=class extends rp{postProcess(a,i,c){let f=c.map(({width:g,height:v})=>{let w=i/Math.max(v,g);return{width:g*w,height:v*w}}),d=f.length;return Rr.tidy(()=>{let g=(E,k)=>Rr.stack([Rr.fill([68],E,"float32"),Rr.fill([68],k,"float32")],1).as2D(1,136).as1D(),v=(E,k)=>{let{width:$,height:M}=f[E];return k($,M)?Math.abs($-M)/2:0},w=E=>v(E,(k,$)=>k<$),T=E=>v(E,(k,$)=>$<k),N=a.mul(Rr.fill([d,136],i,"float32")).sub(Rr.stack(Array.from(Array(d),(E,k)=>g(w(k),T(k))))).div(Rr.stack(Array.from(Array(d),(E,k)=>g(f[k].width,f[k].height))));return N})}forwardInput(a){return Rr.tidy(()=>{let i=this.runNet(a);return this.postProcess(i,a.inputSize,a.inputDimensions.map(([c,f])=>({height:c,width:f})))})}async forward(a){return this.forwardInput(await He(a))}async detectLandmarks(a){let i=await He(a),c=Rr.tidy(()=>Rr.unstack(this.forwardInput(i))),f=await Promise.all(c.map(async(d,g)=>{let v=Array.from(await d.data()),w=v.filter((N,E)=>ng(E)),T=v.filter((N,E)=>!ng(E));return new Sc(Array(68).fill(0).map((N,E)=>new ue(w[E],T[E])),{height:i.getInputHeight(g),width:i.getInputWidth(g)})}));return c.forEach(d=>d.dispose()),i.isBatchInput?f:f[0]}getClassifierChannelsOut(){return 136}},nl=class extends sp{constructor(a=new ep){super("FaceLandmark68Net",a)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};var Ya=se(he());function aR(o){let a=[],{extractDenseBlock3Params:i}=ov(o,a),c={dense0:i("dense0",!0),dense1:i("dense1"),dense2:i("dense2")};return ar(o,a),{params:c,paramMappings:a}}function iR(o){let a=[],{extractWeights:i,getRemainingWeights:c}=ir(o),{extractDenseBlock3Params:f}=rv(i,a),d=f(3,32,"dense0",!0),g=f(32,64,"dense1"),v=f(64,128,"dense2");if(c().length!==0)throw new Error(`weights remaing after extract: ${c().length}`);return{paramMappings:a,params:{dense0:d,dense1:g,dense2:v}}}var i2=class extends jn{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(a){let{params:i}=this;if(!i)throw new Error("TinyFaceFeatureExtractor - load model before inference");return Ya.tidy(()=>{let c=Ya.cast(a.toBatchTensor(112,!0),"float32"),f=[122.782,117.001,104.298],d=Fs(c,f).div(Ya.scalar(255)),g=Zg(d,i.dense0,!0);return g=Zg(g,i.dense1),g=Zg(g,i.dense2),g=Ya.avgPool(g,[14,14],[2,2],"valid"),g})}async forward(a){return this.forwardInput(await He(a))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeigthMap(a){return aR(a)}extractParams(a){return iR(a)}},lv=class extends sp{constructor(a=new i2){super("FaceLandmark68TinyNet",a)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}},uR=class extends nl{};var Zr=se(he()),rl=se(he()),hv=se(he());function cR(o,a){return hv.add(hv.mul(o,a.weights),a.biases)}function u2(o,a,i,c,f="same"){let{filters:d,bias:g}=a.conv,v=rl.conv2d(o,d,i,f);return v=rl.add(v,g),v=cR(v,a.scale),c?rl.relu(v):v}function lR(o,a){return u2(o,a,[1,1],!0)}function c2(o,a){return u2(o,a,[1,1],!1)}function fv(o,a){return u2(o,a,[2,2],!0,"valid")}var Pr=se(he());function glt(o,a){function i(v,w,T){let N=o(v),E=N.length/(w*T*T);if(Dx(E))throw new Error(`depth has to be an integer: ${E}, weights.length: ${N.length}, numFilters: ${w}, filterSize: ${T}`);return Pr.tidy(()=>Pr.transpose(Pr.tensor4d(N,[w,E,T,T]),[2,3,1,0]))}function c(v,w,T,N){let E=i(v,w,T),k=Pr.tensor1d(o(w));return a.push({paramPath:`${N}/filters`},{paramPath:`${N}/bias`}),{filters:E,bias:k}}function f(v,w){let T=Pr.tensor1d(o(v)),N=Pr.tensor1d(o(v));return a.push({paramPath:`${w}/weights`},{paramPath:`${w}/biases`}),{weights:T,biases:N}}function d(v,w,T,N){let E=c(v,w,T,`${N}/conv`),k=f(w,`${N}/scale`);return{conv:E,scale:k}}function g(v,w,T,N,E=!1){let k=d((E?.5:1)*v,w,T,`${N}/conv1`),$=d(v,w,T,`${N}/conv2`);return{conv1:k,conv2:$}}return{extractConvLayerParams:d,extractResidualLayerParams:g}}function hR(o){let{extractWeights:a,getRemainingWeights:i}=ir(o),c=[],{extractConvLayerParams:f,extractResidualLayerParams:d}=glt(a,c),g=f(4704,32,7,"conv32_down"),v=d(9216,32,3,"conv32_1"),w=d(9216,32,3,"conv32_2"),T=d(9216,32,3,"conv32_3"),N=d(36864,64,3,"conv64_down",!0),E=d(36864,64,3,"conv64_1"),k=d(36864,64,3,"conv64_2"),$=d(36864,64,3,"conv64_3"),M=d(147456,128,3,"conv128_down",!0),G=d(147456,128,3,"conv128_1"),O=d(147456,128,3,"conv128_2"),H=d(589824,256,3,"conv256_down",!0),K=d(589824,256,3,"conv256_1"),nt=d(589824,256,3,"conv256_2"),ct=d(589824,256,3,"conv256_down_out"),dt=Pr.tidy(()=>Pr.transpose(Pr.tensor2d(a(256*128),[128,256]),[1,0]));if(c.push({paramPath:"fc"}),i().length!==0)throw new Error(`weights remaing after extract: ${i().length}`);let Ct={conv32_down:g,conv32_1:v,conv32_2:w,conv32_3:T,conv64_down:N,conv64_1:E,conv64_2:k,conv64_3:$,conv128_down:M,conv128_1:G,conv128_2:O,conv256_down:H,conv256_1:K,conv256_2:nt,conv256_down_out:ct,fc:dt};return{params:Ct,paramMappings:c}}function vlt(o,a){let i=Fr(o,a);function c(g){let v=i(`${g}/scale/weights`,1),w=i(`${g}/scale/biases`,1);return{weights:v,biases:w}}function f(g){let v=i(`${g}/conv/filters`,4),w=i(`${g}/conv/bias`,1),T=c(g);return{conv:{filters:v,bias:w},scale:T}}function d(g){return{conv1:f(`${g}/conv1`),conv2:f(`${g}/conv2`)}}return{extractConvLayerParams:f,extractResidualLayerParams:d}}function fR(o){let a=[],{extractConvLayerParams:i,extractResidualLayerParams:c}=vlt(o,a),f=i("conv32_down"),d=c("conv32_1"),g=c("conv32_2"),v=c("conv32_3"),w=c("conv64_down"),T=c("conv64_1"),N=c("conv64_2"),E=c("conv64_3"),k=c("conv128_down"),$=c("conv128_1"),M=c("conv128_2"),G=c("conv256_down"),O=c("conv256_1"),H=c("conv256_2"),K=c("conv256_down_out"),nt=o.fc;if(a.push({originalPath:"fc",paramPath:"fc"}),!Ex(nt))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${nt}`);let ct={conv32_down:f,conv32_1:d,conv32_2:g,conv32_3:v,conv64_down:w,conv64_1:T,conv64_2:N,conv64_3:E,conv128_down:k,conv128_1:$,conv128_2:M,conv256_down:G,conv256_1:O,conv256_2:H,conv256_down_out:K,fc:nt};return ar(o,a),{params:ct,paramMappings:a}}var ur=se(he());function zs(o,a){let i=lR(o,a.conv1);return i=c2(i,a.conv2),i=ur.add(i,o),i=ur.relu(i),i}function op(o,a){let i=fv(o,a.conv1);i=c2(i,a.conv2);let c=ur.avgPool(o,2,2,"valid"),f=ur.zeros(c.shape),d=c.shape[3]!==i.shape[3],g=c.shape[1]!==i.shape[1]||c.shape[2]!==i.shape[2];if(g){let v=[...i.shape];v[1]=1;let w=ur.zeros(v);i=ur.concat([i,w],1);let T=[...i.shape];T[2]=1;let N=ur.zeros(T);i=ur.concat([i,N],2)}return c=d?ur.concat([c,f],3):c,i=ur.add(c,i),i=ur.relu(i),i}var sl=class extends jn{constructor(){super("FaceRecognitionNet")}forwardInput(a){let{params:i}=this;if(!i)throw new Error("FaceRecognitionNet - load model before inference");return Zr.tidy(()=>{let c=Zr.cast(a.toBatchTensor(150,!0),"float32"),f=[122.782,117.001,104.298],d=Fs(c,f).div(Zr.scalar(256)),g=fv(d,i.conv32_down);g=Zr.maxPool(g,3,2,"valid"),g=zs(g,i.conv32_1),g=zs(g,i.conv32_2),g=zs(g,i.conv32_3),g=op(g,i.conv64_down),g=zs(g,i.conv64_1),g=zs(g,i.conv64_2),g=zs(g,i.conv64_3),g=op(g,i.conv128_down),g=zs(g,i.conv128_1),g=zs(g,i.conv128_2),g=op(g,i.conv256_down),g=zs(g,i.conv256_1),g=zs(g,i.conv256_2),g=op(g,i.conv256_down_out);let v=g.mean([1,2]),w=Zr.matMul(v,i.fc);return w})}async forward(a){return this.forwardInput(await He(a))}async computeFaceDescriptor(a){let i=await He(a),c=Zr.tidy(()=>Zr.unstack(this.forwardInput(i))),f=await Promise.all(c.map(d=>d.data()));return c.forEach(d=>d.dispose()),i.isBatchInput?f:f[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeigthMap(a){return fR(a)}extractParams(a){return hR(a)}};function ylt(o){let a=new sl;return a.extractWeights(o),a}function pv(o,a){let i={descriptor:a};return Object.assign({},o,i)}function blt(o){return typeof o.age=="number"}function dv(o,a){let i={age:a};return Object.assign({},o,i)}function wlt(o){return(o.gender===Zo.MALE||o.gender===Zo.FEMALE)&&xc(o.genderProbability)}function mv(o,a,i){let c={gender:a,genderProbability:i};return Object.assign({},o,c)}var Vs=se(he()),Ws=se(he());function xlt(o,a){function i(w,T){let N=Ws.tensor4d(o(3*3*w),[3,3,w,1]),E=Ws.tensor1d(o(w)),k=Ws.tensor1d(o(w)),$=Ws.tensor1d(o(w)),M=Ws.tensor1d(o(w));return a.push({paramPath:`${T}/filters`},{paramPath:`${T}/batch_norm_scale`},{paramPath:`${T}/batch_norm_offset`},{paramPath:`${T}/batch_norm_mean`},{paramPath:`${T}/batch_norm_variance`}),{filters:N,batch_norm_scale:E,batch_norm_offset:k,batch_norm_mean:$,batch_norm_variance:M}}function c(w,T,N,E,k){let $=Ws.tensor4d(o(w*T*N*N),[N,N,w,T]),M=Ws.tensor1d(o(T));return a.push({paramPath:`${E}/filters`},{paramPath:`${E}/${k?"batch_norm_offset":"bias"}`}),{filters:$,bias:M}}function f(w,T,N,E){let{filters:k,bias:$}=c(w,T,N,E,!0);return{filters:k,batch_norm_offset:$}}function d(w,T,N){let E=i(w,`${N}/depthwise_conv`),k=f(w,T,1,`${N}/pointwise_conv`);return{depthwise_conv:E,pointwise_conv:k}}function g(){let w=f(3,32,3,"mobilenetv1/conv_0"),T=d(32,64,"mobilenetv1/conv_1"),N=d(64,128,"mobilenetv1/conv_2"),E=d(128,128,"mobilenetv1/conv_3"),k=d(128,256,"mobilenetv1/conv_4"),$=d(256,256,"mobilenetv1/conv_5"),M=d(256,512,"mobilenetv1/conv_6"),G=d(512,512,"mobilenetv1/conv_7"),O=d(512,512,"mobilenetv1/conv_8"),H=d(512,512,"mobilenetv1/conv_9"),K=d(512,512,"mobilenetv1/conv_10"),nt=d(512,512,"mobilenetv1/conv_11"),ct=d(512,1024,"mobilenetv1/conv_12"),dt=d(1024,1024,"mobilenetv1/conv_13");return{conv_0:w,conv_1:T,conv_2:N,conv_3:E,conv_4:k,conv_5:$,conv_6:M,conv_7:G,conv_8:O,conv_9:H,conv_10:K,conv_11:nt,conv_12:ct,conv_13:dt}}function v(){let w=f(1024,256,1,"prediction_layer/conv_0"),T=f(256,512,3,"prediction_layer/conv_1"),N=f(512,128,1,"prediction_layer/conv_2"),E=f(128,256,3,"prediction_layer/conv_3"),k=f(256,128,1,"prediction_layer/conv_4"),$=f(128,256,3,"prediction_layer/conv_5"),M=f(256,64,1,"prediction_layer/conv_6"),G=f(64,128,3,"prediction_layer/conv_7"),O=c(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),H=c(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),K=c(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),nt=c(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),ct=c(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),dt=c(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),Ct=c(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),St=c(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),It=c(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),Gt=c(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),Et=c(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),Wt=c(128,18,1,"prediction_layer/box_predictor_5/class_predictor"),_t={box_encoding_predictor:O,class_predictor:H},Kt={box_encoding_predictor:K,class_predictor:nt},Ne={box_encoding_predictor:ct,class_predictor:dt},ce={box_encoding_predictor:Ct,class_predictor:St},me={box_encoding_predictor:It,class_predictor:Gt},Re={box_encoding_predictor:Et,class_predictor:Wt};return{conv_0:w,conv_1:T,conv_2:N,conv_3:E,conv_4:k,conv_5:$,conv_6:M,conv_7:G,box_predictor_0:_t,box_predictor_1:Kt,box_predictor_2:Ne,box_predictor_3:ce,box_predictor_4:me,box_predictor_5:Re}}return{extractMobilenetV1Params:g,extractPredictionLayerParams:v}}function pR(o){let a=[],{extractWeights:i,getRemainingWeights:c}=ir(o),{extractMobilenetV1Params:f,extractPredictionLayerParams:d}=xlt(i,a),g=f(),v=d(),w=Ws.tensor3d(i(5118*4),[1,5118,4]),T={extra_dim:w};if(a.push({paramPath:"output_layer/extra_dim"}),c().length!==0)throw new Error(`weights remaing after extract: ${c().length}`);return{params:{mobilenetv1:g,prediction_layer:v,output_layer:T},paramMappings:a}}function Tlt(o,a){let i=Fr(o,a);function c(T,N,E){let k=i(`${T}/Conv2d_${N}_pointwise/weights`,4,`${E}/filters`),$=i(`${T}/Conv2d_${N}_pointwise/convolution_bn_offset`,1,`${E}/batch_norm_offset`);return{filters:k,batch_norm_offset:$}}function f(T){let N=`mobilenetv1/conv_${T}`,E=`MobilenetV1/Conv2d_${T}_depthwise`,k=`${N}/depthwise_conv`,$=`${N}/pointwise_conv`,M=i(`${E}/depthwise_weights`,4,`${k}/filters`),G=i(`${E}/BatchNorm/gamma`,1,`${k}/batch_norm_scale`),O=i(`${E}/BatchNorm/beta`,1,`${k}/batch_norm_offset`),H=i(`${E}/BatchNorm/moving_mean`,1,`${k}/batch_norm_mean`),K=i(`${E}/BatchNorm/moving_variance`,1,`${k}/batch_norm_variance`);return{depthwise_conv:{filters:M,batch_norm_scale:G,batch_norm_offset:O,batch_norm_mean:H,batch_norm_variance:K},pointwise_conv:c("MobilenetV1",T,$)}}function d(){return{conv_0:c("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:f(1),conv_2:f(2),conv_3:f(3),conv_4:f(4),conv_5:f(5),conv_6:f(6),conv_7:f(7),conv_8:f(8),conv_9:f(9),conv_10:f(10),conv_11:f(11),conv_12:f(12),conv_13:f(13)}}function g(T,N){let E=i(`${T}/weights`,4,`${N}/filters`),k=i(`${T}/biases`,1,`${N}/bias`);return{filters:E,bias:k}}function v(T){let N=g(`Prediction/BoxPredictor_${T}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${T}/box_encoding_predictor`),E=g(`Prediction/BoxPredictor_${T}/ClassPredictor`,`prediction_layer/box_predictor_${T}/class_predictor`);return{box_encoding_predictor:N,class_predictor:E}}function w(){return{conv_0:c("Prediction",0,"prediction_layer/conv_0"),conv_1:c("Prediction",1,"prediction_layer/conv_1"),conv_2:c("Prediction",2,"prediction_layer/conv_2"),conv_3:c("Prediction",3,"prediction_layer/conv_3"),conv_4:c("Prediction",4,"prediction_layer/conv_4"),conv_5:c("Prediction",5,"prediction_layer/conv_5"),conv_6:c("Prediction",6,"prediction_layer/conv_6"),conv_7:c("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:v(0),box_predictor_1:v(1),box_predictor_2:v(2),box_predictor_3:v(3),box_predictor_4:v(4),box_predictor_5:v(5)}}return{extractMobilenetV1Params:d,extractPredictionLayerParams:w}}function dR(o){let a=[],{extractMobilenetV1Params:i,extractPredictionLayerParams:c}=Tlt(o,a),f=o["Output/extra_dim"];if(a.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Wo(f))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${f}`);let d={mobilenetv1:i(),prediction_layer:c(),output_layer:{extra_dim:f}};return ar(o,a),{params:d,paramMappings:a}}var Qo=se(he()),Ja=se(he());function ls(o,a,i){return Ja.tidy(()=>{let c=Ja.conv2d(o,a.filters,i,"same");return c=Ja.add(c,a.batch_norm_offset),Ja.clipByValue(c,0,6)})}var klt=.0010000000474974513;function Slt(o,a,i){return Qo.tidy(()=>{let c=Qo.depthwiseConv2d(o,a.filters,i,"same");return c=Qo.batchNorm(c,a.batch_norm_mean,a.batch_norm_variance,a.batch_norm_offset,a.batch_norm_scale,klt),Qo.clipByValue(c,0,6)})}function Clt(o){return[2,4,6,12].some(a=>a===o)?[2,2]:[1,1]}function mR(o,a){return Qo.tidy(()=>{let i,c=ls(o,a.conv_0,[2,2]),f=[a.conv_1,a.conv_2,a.conv_3,a.conv_4,a.conv_5,a.conv_6,a.conv_7,a.conv_8,a.conv_9,a.conv_10,a.conv_11,a.conv_12,a.conv_13];if(f.forEach((d,g)=>{let v=g+1,w=Clt(v);c=Slt(c,d.depthwise_conv,w),c=ls(c,d.pointwise_conv,[1,1]),v===11&&(i=c)}),i===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:c,conv11:i}})}function gR(o,a,i,c,f){let d=o.shape[0],g=Math.min(i,d),v=a.map((N,E)=>({score:N,boxIndex:E})).filter(N=>N.score>f).sort((N,E)=>E.score-N.score),w=N=>N<=c?1:0,T=[];return v.forEach(N=>{if(T.length>=g)return;let E=N.score;for(let k=T.length-1;k>=0;--k){let $=Nlt(o,N.boxIndex,T[k]);if($===0)continue;if(N.score*=w($),N.score<=f)break}E===N.score&&T.push(N.boxIndex)}),T}function Nlt(o,a,i){let c=o.arraySync(),f=Math.min(c[a][0],c[a][2]),d=Math.min(c[a][1],c[a][3]),g=Math.max(c[a][0],c[a][2]),v=Math.max(c[a][1],c[a][3]),w=Math.min(c[i][0],c[i][2]),T=Math.min(c[i][1],c[i][3]),N=Math.max(c[i][0],c[i][2]),E=Math.max(c[i][1],c[i][3]),k=(g-f)*(v-d),$=(N-w)*(E-T);if(k<=0||$<=0)return 0;let M=Math.max(f,w),G=Math.max(d,T),O=Math.min(g,N),H=Math.min(v,E),K=Math.max(O-M,0)*Math.max(H-G,0);return K/(k+$-K)}var Ut=se(he());function Ilt(o){let a=Ut.unstack(Ut.transpose(o,[1,0])),i=[Ut.sub(a[2],a[0]),Ut.sub(a[3],a[1])],c=[Ut.add(a[0],Ut.div(i[0],Ut.scalar(2))),Ut.add(a[1],Ut.div(i[1],Ut.scalar(2)))];return{sizes:i,centers:c}}function Elt(o,a){let{sizes:i,centers:c}=Ilt(o),f=Ut.unstack(Ut.transpose(a,[1,0])),d=Ut.div(Ut.mul(Ut.exp(Ut.div(f[2],Ut.scalar(5))),i[0]),Ut.scalar(2)),g=Ut.add(Ut.mul(Ut.div(f[0],Ut.scalar(10)),i[0]),c[0]),v=Ut.div(Ut.mul(Ut.exp(Ut.div(f[3],Ut.scalar(5))),i[1]),Ut.scalar(2)),w=Ut.add(Ut.mul(Ut.div(f[1],Ut.scalar(10)),i[1]),c[1]);return Ut.transpose(Ut.stack([Ut.sub(g,d),Ut.sub(w,v),Ut.add(g,d),Ut.add(w,v)]),[1,0])}function vR(o,a,i){return Ut.tidy(()=>{let c=o.shape[0],f=Elt(Ut.reshape(Ut.tile(i.extra_dim,[c,1,1]),[-1,4]),Ut.reshape(o,[-1,4]));f=Ut.reshape(f,[c,f.shape[0]/c,4]);let d=Ut.sigmoid(Ut.slice(a,[0,0,1],[-1,-1,-1])),g=Ut.slice(d,[0,0,0],[-1,-1,1]);g=Ut.reshape(g,[c,g.shape[1]]);let v=Ut.unstack(f),w=Ut.unstack(g);return{boxes:v,scores:w}})}var ip=se(he()),ap=se(he());function ou(o,a){return ap.tidy(()=>{let i=o.shape[0],c=ap.reshape(ru(o,a.box_encoding_predictor),[i,-1,1,4]),f=ap.reshape(ru(o,a.class_predictor),[i,-1,3]);return{boxPredictionEncoding:c,classPrediction:f}})}function yR(o,a,i){return ip.tidy(()=>{let c=ls(o,i.conv_0,[1,1]),f=ls(c,i.conv_1,[2,2]),d=ls(f,i.conv_2,[1,1]),g=ls(d,i.conv_3,[2,2]),v=ls(g,i.conv_4,[1,1]),w=ls(v,i.conv_5,[2,2]),T=ls(w,i.conv_6,[1,1]),N=ls(T,i.conv_7,[2,2]),E=ou(a,i.box_predictor_0),k=ou(o,i.box_predictor_1),$=ou(f,i.box_predictor_2),M=ou(g,i.box_predictor_3),G=ou(w,i.box_predictor_4),O=ou(N,i.box_predictor_5),H=ip.concat([E.boxPredictionEncoding,k.boxPredictionEncoding,$.boxPredictionEncoding,M.boxPredictionEncoding,G.boxPredictionEncoding,O.boxPredictionEncoding],1),K=ip.concat([E.classPrediction,k.classPrediction,$.classPrediction,M.classPrediction,G.classPrediction,O.classPrediction],1);return{boxPredictions:H,classPredictions:K}})}var hs=class{constructor({minConfidence:a,maxResults:i}={}){this._name="SsdMobilenetv1Options";if(this._minConfidence=a||.5,this._maxResults=i||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},au=class extends jn{constructor(){super("SsdMobilenetv1")}forwardInput(a){let{params:i}=this;if(!i)throw new Error("SsdMobilenetv1 - load model before inference");return Vs.tidy(()=>{let c=Vs.cast(a.toBatchTensor(512,!1),"float32"),f=Vs.sub(Vs.mul(c,Vs.scalar(.007843137718737125)),Vs.scalar(1)),d=mR(f,i.mobilenetv1),{boxPredictions:g,classPredictions:v}=yR(d.out,d.conv11,i.prediction_layer);return vR(g,v,i.output_layer)})}async forward(a){return this.forwardInput(await He(a))}async locateFaces(a,i={}){let{maxResults:c,minConfidence:f}=new hs(i),d=await He(a),{boxes:g,scores:v}=this.forwardInput(d),w=g[0],T=v[0];for(let nt=1;nt<g.length;nt++)g[nt].dispose(),v[nt].dispose();let N=Array.from(await T.data()),E=.5,k=gR(w,N,c,E,f),$=d.getReshapedInputDimensions(0),M=d.inputSize,G=M/$.width,O=M/$.height,H=w.arraySync(),K=k.map(nt=>{let[ct,dt]=[Math.max(0,H[nt][0]),Math.min(1,H[nt][2])].map(It=>It*O),[Ct,St]=[Math.max(0,H[nt][1]),Math.min(1,H[nt][3])].map(It=>It*G);return new qe(N[nt],new kc(Ct,ct,St-Ct,dt-ct),{height:d.getInputHeight(0),width:d.getInputWidth(0)})});return w.dispose(),T.dispose(),K}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeigthMap(a){return dR(a)}extractParams(a){return pR(a)}};function bR(o){let a=new au;return a.extractWeights(o),a}function Dlt(o){return bR(o)}var wR=class extends au{},xR=.4,TR=[new ue(.738768,.874946),new ue(2.42204,2.65704),new ue(4.30971,7.04493),new ue(10.246,4.59428),new ue(12.6868,11.8741)],kR=[new ue(1.603231,2.094468),new ue(6.041143,7.080126),new ue(2.882459,3.518061),new ue(4.266906,5.178857),new ue(9.041765,10.66308)],SR=[117.001,114.697,97.404],CR="tiny_yolov2_model",NR="tiny_yolov2_separable_conv_model",Ke=se(he()),gv=o=>typeof o=="number";function l2(o){if(!o)throw new Error(`invalid config: ${o}`);if(typeof o.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${o.withSeparableConvs}`);if(!gv(o.iouThreshold)||o.iouThreshold<0||o.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${o.iouThreshold}`);if(!Array.isArray(o.classes)||!o.classes.length||!o.classes.every(a=>typeof a=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(o.classes)}`);if(!Array.isArray(o.anchors)||!o.anchors.length||!o.anchors.map(a=>a||{}).every(a=>gv(a.x)&&gv(a.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(o.anchors)}`);if(o.meanRgb&&(!Array.isArray(o.meanRgb)||o.meanRgb.length!==3||!o.meanRgb.every(gv)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(o.meanRgb)}`)}var ps=se(he()),fs=se(he());function ol(o){return fs.tidy(()=>{let a=fs.mul(o,fs.scalar(.10000000149011612));return fs.add(fs.relu(fs.sub(o,a)),a)})}function ta(o,a){return ps.tidy(()=>{let i=ps.pad(o,[[0,0],[1,1],[1,1],[0,0]]);return i=ps.conv2d(i,a.conv.filters,[1,1],"valid"),i=ps.sub(i,a.bn.sub),i=ps.mul(i,a.bn.truediv),i=ps.add(i,a.conv.bias),ol(i)})}var Za=se(he());function ea(o,a){return Za.tidy(()=>{let i=Za.pad(o,[[0,0],[1,1],[1,1],[0,0]]);return i=Za.separableConv2d(i,a.depthwise_filter,a.pointwise_filter,[1,1],"valid"),i=Za.add(i,a.bias),ol(i)})}var h2=se(he());function $lt(o,a){let i=Yc(o,a);function c(g,v){let w=h2.tensor1d(o(g)),T=h2.tensor1d(o(g));return a.push({paramPath:`${v}/sub`},{paramPath:`${v}/truediv`}),{sub:w,truediv:T}}function f(g,v,w){let T=i(g,v,3,`${w}/conv`),N=c(v,`${w}/bn`);return{conv:T,bn:N}}let d=Jc(o,a);return{extractConvParams:i,extractConvWithBatchNormParams:f,extractSeparableConvParams:d}}function IR(o,a,i,c){let{extractWeights:f,getRemainingWeights:d}=ir(o),g=[],{extractConvParams:v,extractConvWithBatchNormParams:w,extractSeparableConvParams:T}=$lt(f,g),N;if(a.withSeparableConvs){let[E,k,$,M,G,O,H,K,nt]=c,ct=a.isFirstLayerConv2d?v(E,k,3,"conv0"):T(E,k,"conv0"),dt=T(k,$,"conv1"),Ct=T($,M,"conv2"),St=T(M,G,"conv3"),It=T(G,O,"conv4"),Gt=T(O,H,"conv5"),Et=K?T(H,K,"conv6"):void 0,Wt=nt?T(K,nt,"conv7"):void 0,_t=v(nt||K||H,5*i,1,"conv8");N={conv0:ct,conv1:dt,conv2:Ct,conv3:St,conv4:It,conv5:Gt,conv6:Et,conv7:Wt,conv8:_t}}else{let[E,k,$,M,G,O,H,K,nt]=c,ct=w(E,k,"conv0"),dt=w(k,$,"conv1"),Ct=w($,M,"conv2"),St=w(M,G,"conv3"),It=w(G,O,"conv4"),Gt=w(O,H,"conv5"),Et=w(H,K,"conv6"),Wt=w(K,nt,"conv7"),_t=v(nt,5*i,1,"conv8");N={conv0:ct,conv1:dt,conv2:Ct,conv3:St,conv4:It,conv5:Gt,conv6:Et,conv7:Wt,conv8:_t}}if(d().length!==0)throw new Error(`weights remaing after extract: ${d().length}`);return{params:N,paramMappings:g}}function Alt(o,a){let i=Fr(o,a);function c(v){let w=i(`${v}/sub`,1),T=i(`${v}/truediv`,1);return{sub:w,truediv:T}}function f(v){let w=i(`${v}/filters`,4),T=i(`${v}/bias`,1);return{filters:w,bias:T}}function d(v){let w=f(`${v}/conv`),T=c(`${v}/bn`);return{conv:w,bn:T}}let g=Zc(i);return{extractConvParams:f,extractConvWithBatchNormParams:d,extractSeparableConvParams:g}}function ER(o,a){let i=[],{extractConvParams:c,extractConvWithBatchNormParams:f,extractSeparableConvParams:d}=Alt(o,i),g;if(a.withSeparableConvs){let v=a.filterSizes&&a.filterSizes.length||9;g={conv0:a.isFirstLayerConv2d?c("conv0"):d("conv0"),conv1:d("conv1"),conv2:d("conv2"),conv3:d("conv3"),conv4:d("conv4"),conv5:d("conv5"),conv6:v>7?d("conv6"):void 0,conv7:v>8?d("conv7"):void 0,conv8:c("conv8")}}else g={conv0:f("conv0"),conv1:f("conv1"),conv2:f("conv2"),conv3:f("conv3"),conv4:f("conv4"),conv5:f("conv5"),conv6:f("conv6"),conv7:f("conv7"),conv8:c("conv8")};return ar(o,i),{params:g,paramMappings:i}}var f2;(function(o){o[o.XS=224]="XS",o[o.SM=320]="SM",o[o.MD=416]="MD",o[o.LG=608]="LG"})(f2||(f2={}));var po=class{constructor({inputSize:a,scoreThreshold:i}={}){this._name="TinyYolov2Options";if(this._inputSize=a||416,this._scoreThreshold=i||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},p2=class extends jn{constructor(a){super("TinyYolov2");l2(a),this._config=a}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(a,i){let c=ta(a,i.conv0);return c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ta(c,i.conv1),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ta(c,i.conv2),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ta(c,i.conv3),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ta(c,i.conv4),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ta(c,i.conv5),c=Ke.maxPool(c,[2,2],[1,1],"same"),c=ta(c,i.conv6),c=ta(c,i.conv7),ru(c,i.conv8,"valid",!1)}runMobilenet(a,i){let c=this.config.isFirstLayerConv2d?ol(ru(a,i.conv0,"valid",!1)):ea(a,i.conv0);return c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ea(c,i.conv1),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ea(c,i.conv2),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ea(c,i.conv3),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ea(c,i.conv4),c=Ke.maxPool(c,[2,2],[2,2],"same"),c=ea(c,i.conv5),c=Ke.maxPool(c,[2,2],[1,1],"same"),c=i.conv6?ea(c,i.conv6):c,c=i.conv7?ea(c,i.conv7):c,ru(c,i.conv8,"valid",!1)}forwardInput(a,i){let{params:c}=this;if(!c)throw new Error("TinyYolov2 - load model before inference");return Ke.tidy(()=>{let f=Ke.cast(a.toBatchTensor(i,!1),"float32");return f=this.config.meanRgb?Fs(f,this.config.meanRgb):f,f=f.div(Ke.scalar(256)),this.config.withSeparableConvs?this.runMobilenet(f,c):this.runTinyYolov2(f,c)})}async forward(a,i){return await this.forwardInput(await He(a),i)}async detect(a,i={}){let{inputSize:c,scoreThreshold:f}=new po(i),d=await He(a),g=await this.forwardInput(d,c),v=Ke.tidy(()=>Ke.unstack(g)[0].expandDims()),w={width:d.getInputWidth(0),height:d.getInputHeight(0)},T=await this.extractBoxes(v,d.getReshapedInputDimensions(0),f);g.dispose(),v.dispose();let N=T.map(O=>O.box),E=T.map(O=>O.score),k=T.map(O=>O.classScore),$=T.map(O=>this.config.classes[O.label]),M=Fx(N.map(O=>O.rescale(c)),E,this.config.iouThreshold,!0),G=M.map(O=>new Fa(E[O],k[O],$[O],N[O],w));return G}getDefaultModelName(){return""}extractParamsFromWeigthMap(a){return ER(a,this.config)}extractParams(a){let i=this.config.filterSizes||p2.DEFAULT_FILTER_SIZES,c=i?i.length:void 0;if(c!==7&&c!==8&&c!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${c} filterSizes in config`);return IR(a,this.config,this.boxEncodingSize,i)}async extractBoxes(a,i,c){let{width:f,height:d}=i,g=Math.max(f,d),v=g/f,w=g/d,T=a.shape[1],N=this.config.anchors.length,[E,k,$]=Ke.tidy(()=>{let H=a.reshape([T,T,N,this.boxEncodingSize]),K=H.slice([0,0,0,0],[T,T,N,4]),nt=H.slice([0,0,0,4],[T,T,N,1]),ct=this.withClassScores?Ke.softmax(H.slice([0,0,0,5],[T,T,N,this.config.classes.length]),3):Ke.scalar(0);return[K,nt,ct]}),M=[],G=await k.array(),O=await E.array();for(let H=0;H<T;H++)for(let K=0;K<T;K++)for(let nt=0;nt<N;nt++){let ct=If(G[H][K][nt][0]);if(!c||ct>c){let dt=(K+If(O[H][K][nt][0]))/T*v,Ct=(H+If(O[H][K][nt][1]))/T*w,St=Math.exp(O[H][K][nt][2])*this.config.anchors[nt].x/T*v,It=Math.exp(O[H][K][nt][3])*this.config.anchors[nt].y/T*w,Gt=dt-St/2,Et=Ct-It/2,Wt={row:H,col:K,anchor:nt},{classScore:_t,label:Kt}=this.withClassScores?await this.extractPredictedClass($,Wt):{classScore:1,label:0};M.push({box:new Tc(Gt,Et,Gt+St,Et+It),score:ct,classScore:ct*_t,label:Kt,...Wt})}}return E.dispose(),k.dispose(),$.dispose(),M}async extractPredictedClass(a,i){let{row:c,col:f,anchor:d}=i,g=await a.array();return Array(this.config.classes.length).fill(0).map((v,w)=>g[c][f][d][w]).map((v,w)=>({classScore:v,label:w})).reduce((v,w)=>v.classScore>w.classScore?v:w)}},al=p2;al.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var il=class extends al{constructor(a=!0){let i=Object.assign({},{withSeparableConvs:a,iouThreshold:xR,classes:["face"]},a?{anchors:kR,meanRgb:SR}:{anchors:TR,withClassScores:!0});super(i)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(a,i){let c=await this.detect(a,i);return c.map(f=>new qe(f.score,f.relativeBox,{width:f.imageWidth,height:f.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?NR:CR}extractParamsFromWeigthMap(a){return super.extractParamsFromWeigthMap(a)}};function _lt(o,a=!0){let i=new il(a);return i.extractWeights(o),i}var vv=class extends po{constructor(){super(...arguments);this._name="TinyFaceDetectorOptions"}},ds=class{async then(a){return a(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}},up=se(he()),d2=se(he());async function iu(o,a,i,c,f=({alignedRect:d})=>d){let d=o.map(w=>su(w)?f(w):w.detection),g=c||(a instanceof d2.Tensor?await Kc(a,d):await jc(a,d)),v=await i(g);return g.forEach(w=>w instanceof d2.Tensor&&w.dispose()),v}async function ul(o,a,i,c,f){return iu([o],a,async d=>i(d[0]),c,f)}var DR=.4,$R=[new ue(1.603231,2.094468),new ue(6.041143,7.080126),new ue(2.882459,3.518061),new ue(4.266906,5.178857),new ue(9.041765,10.66308)],AR=[117.001,114.697,97.404],cl=class extends al{constructor(){let a={withSeparableConvs:!0,iouThreshold:DR,classes:["face"],anchors:$R,meanRgb:AR,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(a)}get anchors(){return this.config.anchors}async locateFaces(a,i){let c=await this.detect(a,i);return c.map(f=>new qe(f.score,f.relativeBox,{width:f.imageWidth,height:f.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeigthMap(a){return super.extractParamsFromWeigthMap(a)}},$e={ssdMobilenetv1:new au,tinyFaceDetector:new cl,tinyYolov2:new il,faceLandmark68Net:new nl,faceLandmark68TinyNet:new lv,faceRecognitionNet:new sl,faceExpressionNet:new iv,ageGenderNet:new cv},_R=(o,a)=>$e.ssdMobilenetv1.locateFaces(o,a),Flt=(o,a)=>$e.tinyFaceDetector.locateFaces(o,a),Rlt=(o,a)=>$e.tinyYolov2.locateFaces(o,a),FR=o=>$e.faceLandmark68Net.detectLandmarks(o),Plt=o=>$e.faceLandmark68TinyNet.detectLandmarks(o),Olt=o=>$e.faceRecognitionNet.computeFaceDescriptor(o),Mlt=o=>$e.faceExpressionNet.predictExpressions(o),Llt=o=>$e.ageGenderNet.predictAgeAndGender(o),RR=o=>$e.ssdMobilenetv1.load(o),Blt=o=>$e.tinyFaceDetector.load(o),zlt=o=>$e.tinyYolov2.load(o),Wlt=o=>$e.faceLandmark68Net.load(o),Vlt=o=>$e.faceLandmark68TinyNet.load(o),Ult=o=>$e.faceRecognitionNet.load(o),Glt=o=>$e.faceExpressionNet.load(o),Hlt=o=>$e.ageGenderNet.load(o),qlt=RR,jlt=_R,Klt=FR,m2=class extends ds{constructor(a,i,c){super();this.parentTask=a;this.input=i;this.extractedFaces=c}},fl=class extends m2{async run(){let a=await this.parentTask,i=await iu(a,this.input,async c=>await Promise.all(c.map(f=>$e.faceExpressionNet.predictExpressions(f))),this.extractedFaces);return a.map((c,f)=>uv(c,i[f]))}withAgeAndGender(){return new ll(this,this.input)}},pl=class extends m2{async run(){let a=await this.parentTask;if(!a)return;let i=await ul(a,this.input,c=>$e.faceExpressionNet.predictExpressions(c),this.extractedFaces);return uv(a,i)}withAgeAndGender(){return new hl(this,this.input)}},lu=class extends fl{withAgeAndGender(){return new uu(this,this.input)}withFaceDescriptors(){return new Qa(this,this.input)}},hu=class extends pl{withAgeAndGender(){return new cu(this,this.input)}withFaceDescriptor(){return new ti(this,this.input)}},g2=class extends ds{constructor(a,i,c){super();this.parentTask=a;this.input=i;this.extractedFaces=c}},ll=class extends g2{async run(){let a=await this.parentTask,i=await iu(a,this.input,async c=>await Promise.all(c.map(f=>$e.ageGenderNet.predictAgeAndGender(f))),this.extractedFaces);return a.map((c,f)=>{let{age:d,gender:g,genderProbability:v}=i[f];return dv(mv(c,g,v),d)})}withFaceExpressions(){return new fl(this,this.input)}},hl=class extends g2{async run(){let a=await this.parentTask;if(!a)return;let{age:i,gender:c,genderProbability:f}=await ul(a,this.input,d=>$e.ageGenderNet.predictAgeAndGender(d),this.extractedFaces);return dv(mv(a,c,f),i)}withFaceExpressions(){return new pl(this,this.input)}},uu=class extends ll{withFaceExpressions(){return new lu(this,this.input)}withFaceDescriptors(){return new Qa(this,this.input)}},cu=class extends hl{withFaceExpressions(){return new hu(this,this.input)}withFaceDescriptor(){return new ti(this,this.input)}},yv=class extends ds{constructor(a,i){super();this.parentTask=a;this.input=i}},Qa=class extends yv{async run(){let a=await this.parentTask,i=await iu(a,this.input,c=>Promise.all(c.map(f=>$e.faceRecognitionNet.computeFaceDescriptor(f))),null,c=>c.landmarks.align(null,{useDlibAlignment:!0}));return i.map((c,f)=>pv(a[f],c))}withFaceExpressions(){return new lu(this,this.input)}withAgeAndGender(){return new uu(this,this.input)}},ti=class extends yv{async run(){let a=await this.parentTask;if(!a)return;let i=await ul(a,this.input,c=>$e.faceRecognitionNet.computeFaceDescriptor(c),null,c=>c.landmarks.align(null,{useDlibAlignment:!0}));return pv(a,i)}withFaceExpressions(){return new hu(this,this.input)}withAgeAndGender(){return new cu(this,this.input)}},bv=class extends ds{constructor(a,i,c){super();this.parentTask=a;this.input=i;this.useTinyLandmarkNet=c}get landmarkNet(){return this.useTinyLandmarkNet?$e.faceLandmark68TinyNet:$e.faceLandmark68Net}},wv=class extends bv{async run(){let a=await this.parentTask,i=a.map(d=>d.detection),c=this.input instanceof up.Tensor?await Kc(this.input,i):await jc(this.input,i),f=await Promise.all(c.map(d=>this.landmarkNet.detectLandmarks(d)));return c.forEach(d=>d instanceof up.Tensor&&d.dispose()),a.map((d,g)=>el(d,f[g]))}withFaceExpressions(){return new lu(this,this.input)}withAgeAndGender(){return new uu(this,this.input)}withFaceDescriptors(){return new Qa(this,this.input)}},xv=class extends bv{async run(){let a=await this.parentTask;if(!a)return;let{detection:i}=a,c=this.input instanceof up.Tensor?await Kc(this.input,[i]):await jc(this.input,[i]),f=await this.landmarkNet.detectLandmarks(c[0]);return c.forEach(d=>d instanceof up.Tensor&&d.dispose()),el(a,f)}withFaceExpressions(){return new hu(this,this.input)}withAgeAndGender(){return new cu(this,this.input)}withFaceDescriptor(){return new ti(this,this.input)}},Tv=class extends ds{constructor(a,i=new hs){super();this.input=a;this.options=i}},cp=class extends Tv{async run(){let{input:a,options:i}=this,c=i instanceof vv?f=>$e.tinyFaceDetector.locateFaces(f,i):i instanceof hs?f=>$e.ssdMobilenetv1.locateFaces(f,i):i instanceof po?f=>$e.tinyYolov2.locateFaces(f,i):null;if(!c)throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options");return c(a)}runAndExtendWithFaceDetections(){return new Promise(async a=>{let i=await this.run();return a(i.map(c=>Mi({},c)))})}withFaceLandmarks(a=!1){return new wv(this.runAndExtendWithFaceDetections(),this.input,a)}withFaceExpressions(){return new fl(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new ll(this.runAndExtendWithFaceDetections(),this.input)}},kv=class extends Tv{async run(){let a=await new cp(this.input,this.options),i=a[0];return a.forEach(c=>{c.score>i.score&&(i=c)}),i}runAndExtendWithFaceDetection(){return new Promise(async a=>{let i=await this.run();return a(i?Mi({},i):void 0)})}withFaceLandmarks(a=!1){return new xv(this.runAndExtendWithFaceDetection(),this.input,a)}withFaceExpressions(){return new pl(this.runAndExtendWithFaceDetection(),this.input)}withAgeAndGender(){return new hl(this.runAndExtendWithFaceDetection(),this.input)}};function Xlt(o,a=new hs){return new kv(o,a)}function Sv(o,a=new hs){return new cp(o,a)}async function PR(o,a){return console.warn("allFacesSsdMobilenetv1 is deprecated and will be removed soon, use the high level api instead"),await Sv(o,new hs(a?{minConfidence:a}:{})).withFaceLandmarks().withFaceDescriptors()}async function Ylt(o,a={}){return console.warn("allFacesTinyYolov2 is deprecated and will be removed soon, use the high level api instead"),await Sv(o,new po(a)).withFaceLandmarks().withFaceDescriptors()}var Jlt=PR;function v2(o,a){if(o.length!==a.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");let i=Array.from(o),c=Array.from(a);return Math.sqrt(i.map((f,d)=>f-c[d]).reduce((f,d)=>f+Math.pow(d,2),0))}var Cv=class{constructor(a,i=.6){this._distanceThreshold=i;let c=Array.isArray(a)?a:[a];if(!c.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");let f=1,d=()=>`person ${f++}`;this._labeledDescriptors=c.map(g=>{if(g instanceof Vo)return g;if(g instanceof Float32Array)return new Vo(d(),[g]);if(g.descriptor&&g.descriptor instanceof Float32Array)return new Vo(d(),[g.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}get labeledDescriptors(){return this._labeledDescriptors}get distanceThreshold(){return this._distanceThreshold}computeMeanDistance(a,i){return i.map(c=>v2(c,a)).reduce((c,f)=>c+f,0)/(i.length||1)}matchDescriptor(a){return this.labeledDescriptors.map(({descriptors:i,label:c})=>new Ef(c,this.computeMeanDistance(a,i))).reduce((i,c)=>i.distance<c.distance?i:c)}findBestMatch(a){let i=this.matchDescriptor(a);return i.distance<this.distanceThreshold?i:new Ef("unknown",i.distance)}toJSON(){return{distanceThreshold:this.distanceThreshold,labeledDescriptors:this.labeledDescriptors.map(a=>a.toJSON())}}static fromJSON(a){let i=a.labeledDescriptors.map(c=>Vo.fromJSON(c));return new Cv(i,a.distanceThreshold)}};function Zlt(o){let a=new cl;return a.extractWeights(o),a}function OR(o,a){let{width:i,height:c}=new or(a.width,a.height);if(i<=0||c<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:i,height:c})}`);if(Array.isArray(o))return o.map(f=>OR(f,{width:i,height:c}));if(su(o)){let f=o.detection.forSize(i,c),d=o.unshiftedLandmarks.forSize(f.box.width,f.box.height);return el(Mi(o,f),d)}return oo(o)?Mi(o,o.detection.forSize(i,c)):o instanceof Xr||o instanceof qe?o.forSize(i,c):o}var MR="0.8.8",tht=typeof process!="undefined",eht=typeof navigator!="undefined"&&typeof navigator.userAgent!="undefined",nht={faceapi:MR,node:tht,browser:eht};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
//# sourceMappingURL=face-api.node.js.map
